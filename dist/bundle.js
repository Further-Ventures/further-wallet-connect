(function () {
    'use strict';

    /******************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise, SuppressedError, Symbol */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __rest(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }

    function __decorate$27(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }

    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    }

    function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
        function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
        var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
        var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
        var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
        var _, done = false;
        for (var i = decorators.length - 1; i >= 0; i--) {
            var context = {};
            for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
            for (var p in contextIn.access) context.access[p] = contextIn.access[p];
            context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
            var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
            if (kind === "accessor") {
                if (result === void 0) continue;
                if (result === null || typeof result !== "object") throw new TypeError("Object expected");
                if (_ = accept(result.get)) descriptor.get = _;
                if (_ = accept(result.set)) descriptor.set = _;
                if (_ = accept(result.init)) initializers.unshift(_);
            }
            else if (_ = accept(result)) {
                if (kind === "field") initializers.unshift(_);
                else descriptor[key] = _;
            }
        }
        if (target) Object.defineProperty(target, contextIn.name, descriptor);
        done = true;
    }
    function __runInitializers(thisArg, initializers, value) {
        var useValue = arguments.length > 2;
        for (var i = 0; i < initializers.length; i++) {
            value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
        }
        return useValue ? value : void 0;
    }
    function __propKey(x) {
        return typeof x === "symbol" ? x : "".concat(x);
    }
    function __setFunctionName(f, name, prefix) {
        if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
        return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
    }
    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    }

    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (g && (g = 0, op[0] && (_ = 0)), _) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    var __createBinding = Object.create ? (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
            desc = { enumerable: true, get: function() { return m[k]; } };
        }
        Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    });

    function __exportStar(m, o) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
    }

    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    /** @deprecated */
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    /** @deprecated */
    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }

    function __spreadArray$1(to, from, pack) {
        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
        return to.concat(ar || Array.prototype.slice.call(from));
    }

    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }

    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
    }

    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }
    }

    function __asyncValues(o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
    }

    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
        return cooked;
    }
    var __setModuleDefault = Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
        o["default"] = v;
    };

    function __importStar(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    }

    function __importDefault$e(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }

    function __classPrivateFieldGet$3(receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    }

    function __classPrivateFieldSet$1(receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    }

    function __classPrivateFieldIn(state, receiver) {
        if (receiver === null || (typeof receiver !== "object" && typeof receiver !== "function")) throw new TypeError("Cannot use 'in' operator on non-object");
        return typeof state === "function" ? receiver === state : state.has(receiver);
    }

    function __addDisposableResource(env, value, async) {
        if (value !== null && value !== void 0) {
            if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
            var dispose;
            if (async) {
                if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
                dispose = value[Symbol.asyncDispose];
            }
            if (dispose === void 0) {
                if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
                dispose = value[Symbol.dispose];
            }
            if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
            env.stack.push({ value: value, dispose: dispose, async: async });
        }
        else if (async) {
            env.stack.push({ async: true });
        }
        return value;
    }

    var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
        var e = new Error(message);
        return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
    };

    function __disposeResources(env) {
        function fail(e) {
            env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
            env.hasError = true;
        }
        function next() {
            while (env.stack.length) {
                var rec = env.stack.pop();
                try {
                    var result = rec.dispose && rec.dispose.call(rec.value);
                    if (rec.async) return Promise.resolve(result).then(next, function(e) { fail(e); return next(); });
                }
                catch (e) {
                    fail(e);
                }
            }
            if (env.hasError) throw env.error;
        }
        return next();
    }

    var tslib_es6 = {
        __extends: __extends,
        __assign: __assign,
        __rest: __rest,
        __decorate: __decorate$27,
        __param: __param,
        __metadata: __metadata,
        __awaiter: __awaiter,
        __generator: __generator,
        __createBinding: __createBinding,
        __exportStar: __exportStar,
        __values: __values,
        __read: __read,
        __spread: __spread,
        __spreadArrays: __spreadArrays,
        __spreadArray: __spreadArray$1,
        __await: __await,
        __asyncGenerator: __asyncGenerator,
        __asyncDelegator: __asyncDelegator,
        __asyncValues: __asyncValues,
        __makeTemplateObject: __makeTemplateObject,
        __importStar: __importStar,
        __importDefault: __importDefault$e,
        __classPrivateFieldGet: __classPrivateFieldGet$3,
        __classPrivateFieldSet: __classPrivateFieldSet$1,
        __classPrivateFieldIn: __classPrivateFieldIn,
        __addDisposableResource: __addDisposableResource,
        __disposeResources: __disposeResources,
    };

    var tslib_es6$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        __addDisposableResource: __addDisposableResource,
        get __assign () { return __assign; },
        __asyncDelegator: __asyncDelegator,
        __asyncGenerator: __asyncGenerator,
        __asyncValues: __asyncValues,
        __await: __await,
        __awaiter: __awaiter,
        __classPrivateFieldGet: __classPrivateFieldGet$3,
        __classPrivateFieldIn: __classPrivateFieldIn,
        __classPrivateFieldSet: __classPrivateFieldSet$1,
        __createBinding: __createBinding,
        __decorate: __decorate$27,
        __disposeResources: __disposeResources,
        __esDecorate: __esDecorate,
        __exportStar: __exportStar,
        __extends: __extends,
        __generator: __generator,
        __importDefault: __importDefault$e,
        __importStar: __importStar,
        __makeTemplateObject: __makeTemplateObject,
        __metadata: __metadata,
        __param: __param,
        __propKey: __propKey,
        __read: __read,
        __rest: __rest,
        __runInitializers: __runInitializers,
        __setFunctionName: __setFunctionName,
        __spread: __spread,
        __spreadArray: __spreadArray$1,
        __spreadArrays: __spreadArrays,
        __values: __values,
        default: tslib_es6
    });

    var domain;

    // This constructor is used to store event handlers. Instantiating this is
    // faster than explicitly calling `Object.create(null)` to get a "clean" empty
    // object (tested with v8 v4.9).
    function EventHandlers() {}
    EventHandlers.prototype = Object.create(null);

    function EventEmitter$1() {
      EventEmitter$1.init.call(this);
    }

    // nodejs oddity
    // require('events') === require('events').EventEmitter
    EventEmitter$1.EventEmitter = EventEmitter$1;

    EventEmitter$1.usingDomains = false;

    EventEmitter$1.prototype.domain = undefined;
    EventEmitter$1.prototype._events = undefined;
    EventEmitter$1.prototype._maxListeners = undefined;

    // By default EventEmitters will print a warning if more than 10 listeners are
    // added to it. This is a useful default which helps finding memory leaks.
    EventEmitter$1.defaultMaxListeners = 10;

    EventEmitter$1.init = function() {
      this.domain = null;
      if (EventEmitter$1.usingDomains) {
        // if there is an active domain, then attach to it.
        if (domain.active ) ;
      }

      if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
        this._events = new EventHandlers();
        this._eventsCount = 0;
      }

      this._maxListeners = this._maxListeners || undefined;
    };

    // Obviously not all Emitters should be limited to 10. This function allows
    // that to be increased. Set to zero for unlimited.
    EventEmitter$1.prototype.setMaxListeners = function setMaxListeners(n) {
      if (typeof n !== 'number' || n < 0 || isNaN(n))
        throw new TypeError('"n" argument must be a positive number');
      this._maxListeners = n;
      return this;
    };

    function $getMaxListeners(that) {
      if (that._maxListeners === undefined)
        return EventEmitter$1.defaultMaxListeners;
      return that._maxListeners;
    }

    EventEmitter$1.prototype.getMaxListeners = function getMaxListeners() {
      return $getMaxListeners(this);
    };

    // These standalone emit* functions are used to optimize calling of event
    // handlers for fast cases because emit() itself often has a variable number of
    // arguments and can be deoptimized because of that. These functions always have
    // the same number of arguments and thus do not get deoptimized, so the code
    // inside them can execute faster.
    function emitNone(handler, isFn, self) {
      if (isFn)
        handler.call(self);
      else {
        var len = handler.length;
        var listeners = arrayClone$3(handler, len);
        for (var i = 0; i < len; ++i)
          listeners[i].call(self);
      }
    }
    function emitOne(handler, isFn, self, arg1) {
      if (isFn)
        handler.call(self, arg1);
      else {
        var len = handler.length;
        var listeners = arrayClone$3(handler, len);
        for (var i = 0; i < len; ++i)
          listeners[i].call(self, arg1);
      }
    }
    function emitTwo(handler, isFn, self, arg1, arg2) {
      if (isFn)
        handler.call(self, arg1, arg2);
      else {
        var len = handler.length;
        var listeners = arrayClone$3(handler, len);
        for (var i = 0; i < len; ++i)
          listeners[i].call(self, arg1, arg2);
      }
    }
    function emitThree(handler, isFn, self, arg1, arg2, arg3) {
      if (isFn)
        handler.call(self, arg1, arg2, arg3);
      else {
        var len = handler.length;
        var listeners = arrayClone$3(handler, len);
        for (var i = 0; i < len; ++i)
          listeners[i].call(self, arg1, arg2, arg3);
      }
    }

    function emitMany(handler, isFn, self, args) {
      if (isFn)
        handler.apply(self, args);
      else {
        var len = handler.length;
        var listeners = arrayClone$3(handler, len);
        for (var i = 0; i < len; ++i)
          listeners[i].apply(self, args);
      }
    }

    EventEmitter$1.prototype.emit = function emit(type) {
      var er, handler, len, args, i, events, domain;
      var doError = (type === 'error');

      events = this._events;
      if (events)
        doError = (doError && events.error == null);
      else if (!doError)
        return false;

      domain = this.domain;

      // If there is no 'error' event listener then throw.
      if (doError) {
        er = arguments[1];
        if (domain) {
          if (!er)
            er = new Error('Uncaught, unspecified "error" event');
          er.domainEmitter = this;
          er.domain = domain;
          er.domainThrown = false;
          domain.emit('error', er);
        } else if (er instanceof Error) {
          throw er; // Unhandled 'error' event
        } else {
          // At least give some kind of context to the user
          var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
          err.context = er;
          throw err;
        }
        return false;
      }

      handler = events[type];

      if (!handler)
        return false;

      var isFn = typeof handler === 'function';
      len = arguments.length;
      switch (len) {
        // fast cases
        case 1:
          emitNone(handler, isFn, this);
          break;
        case 2:
          emitOne(handler, isFn, this, arguments[1]);
          break;
        case 3:
          emitTwo(handler, isFn, this, arguments[1], arguments[2]);
          break;
        case 4:
          emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
          break;
        // slower
        default:
          args = new Array(len - 1);
          for (i = 1; i < len; i++)
            args[i - 1] = arguments[i];
          emitMany(handler, isFn, this, args);
      }

      return true;
    };

    function _addListener(target, type, listener, prepend) {
      var m;
      var events;
      var existing;

      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');

      events = target._events;
      if (!events) {
        events = target._events = new EventHandlers();
        target._eventsCount = 0;
      } else {
        // To avoid recursion in the case that type === "newListener"! Before
        // adding it to the listeners, first emit "newListener".
        if (events.newListener) {
          target.emit('newListener', type,
                      listener.listener ? listener.listener : listener);

          // Re-assign `events` because a newListener handler could have caused the
          // this._events to be assigned to a new object
          events = target._events;
        }
        existing = events[type];
      }

      if (!existing) {
        // Optimize the case of one listener. Don't need the extra array object.
        existing = events[type] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === 'function') {
          // Adding the second element, need to change to array.
          existing = events[type] = prepend ? [listener, existing] :
                                              [existing, listener];
        } else {
          // If we've already got an array, just append.
          if (prepend) {
            existing.unshift(listener);
          } else {
            existing.push(listener);
          }
        }

        // Check for listener leak
        if (!existing.warned) {
          m = $getMaxListeners(target);
          if (m && m > 0 && existing.length > m) {
            existing.warned = true;
            var w = new Error('Possible EventEmitter memory leak detected. ' +
                                existing.length + ' ' + type + ' listeners added. ' +
                                'Use emitter.setMaxListeners() to increase limit');
            w.name = 'MaxListenersExceededWarning';
            w.emitter = target;
            w.type = type;
            w.count = existing.length;
            emitWarning(w);
          }
        }
      }

      return target;
    }
    function emitWarning(e) {
      typeof console.warn === 'function' ? console.warn(e) : console.log(e);
    }
    EventEmitter$1.prototype.addListener = function addListener(type, listener) {
      return _addListener(this, type, listener, false);
    };

    EventEmitter$1.prototype.on = EventEmitter$1.prototype.addListener;

    EventEmitter$1.prototype.prependListener =
        function prependListener(type, listener) {
          return _addListener(this, type, listener, true);
        };

    function _onceWrap(target, type, listener) {
      var fired = false;
      function g() {
        target.removeListener(type, g);
        if (!fired) {
          fired = true;
          listener.apply(target, arguments);
        }
      }
      g.listener = listener;
      return g;
    }

    EventEmitter$1.prototype.once = function once(type, listener) {
      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');
      this.on(type, _onceWrap(this, type, listener));
      return this;
    };

    EventEmitter$1.prototype.prependOnceListener =
        function prependOnceListener(type, listener) {
          if (typeof listener !== 'function')
            throw new TypeError('"listener" argument must be a function');
          this.prependListener(type, _onceWrap(this, type, listener));
          return this;
        };

    // emits a 'removeListener' event iff the listener was removed
    EventEmitter$1.prototype.removeListener =
        function removeListener(type, listener) {
          var list, events, position, i, originalListener;

          if (typeof listener !== 'function')
            throw new TypeError('"listener" argument must be a function');

          events = this._events;
          if (!events)
            return this;

          list = events[type];
          if (!list)
            return this;

          if (list === listener || (list.listener && list.listener === listener)) {
            if (--this._eventsCount === 0)
              this._events = new EventHandlers();
            else {
              delete events[type];
              if (events.removeListener)
                this.emit('removeListener', type, list.listener || listener);
            }
          } else if (typeof list !== 'function') {
            position = -1;

            for (i = list.length; i-- > 0;) {
              if (list[i] === listener ||
                  (list[i].listener && list[i].listener === listener)) {
                originalListener = list[i].listener;
                position = i;
                break;
              }
            }

            if (position < 0)
              return this;

            if (list.length === 1) {
              list[0] = undefined;
              if (--this._eventsCount === 0) {
                this._events = new EventHandlers();
                return this;
              } else {
                delete events[type];
              }
            } else {
              spliceOne(list, position);
            }

            if (events.removeListener)
              this.emit('removeListener', type, originalListener || listener);
          }

          return this;
        };
        
    // Alias for removeListener added in NodeJS 10.0
    // https://nodejs.org/api/events.html#events_emitter_off_eventname_listener
    EventEmitter$1.prototype.off = function(type, listener){
        return this.removeListener(type, listener);
    };

    EventEmitter$1.prototype.removeAllListeners =
        function removeAllListeners(type) {
          var listeners, events;

          events = this._events;
          if (!events)
            return this;

          // not listening for removeListener, no need to emit
          if (!events.removeListener) {
            if (arguments.length === 0) {
              this._events = new EventHandlers();
              this._eventsCount = 0;
            } else if (events[type]) {
              if (--this._eventsCount === 0)
                this._events = new EventHandlers();
              else
                delete events[type];
            }
            return this;
          }

          // emit removeListener for all listeners on all events
          if (arguments.length === 0) {
            var keys = Object.keys(events);
            for (var i = 0, key; i < keys.length; ++i) {
              key = keys[i];
              if (key === 'removeListener') continue;
              this.removeAllListeners(key);
            }
            this.removeAllListeners('removeListener');
            this._events = new EventHandlers();
            this._eventsCount = 0;
            return this;
          }

          listeners = events[type];

          if (typeof listeners === 'function') {
            this.removeListener(type, listeners);
          } else if (listeners) {
            // LIFO order
            do {
              this.removeListener(type, listeners[listeners.length - 1]);
            } while (listeners[0]);
          }

          return this;
        };

    EventEmitter$1.prototype.listeners = function listeners(type) {
      var evlistener;
      var ret;
      var events = this._events;

      if (!events)
        ret = [];
      else {
        evlistener = events[type];
        if (!evlistener)
          ret = [];
        else if (typeof evlistener === 'function')
          ret = [evlistener.listener || evlistener];
        else
          ret = unwrapListeners(evlistener);
      }

      return ret;
    };

    EventEmitter$1.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === 'function') {
        return emitter.listenerCount(type);
      } else {
        return listenerCount.call(emitter, type);
      }
    };

    EventEmitter$1.prototype.listenerCount = listenerCount;
    function listenerCount(type) {
      var events = this._events;

      if (events) {
        var evlistener = events[type];

        if (typeof evlistener === 'function') {
          return 1;
        } else if (evlistener) {
          return evlistener.length;
        }
      }

      return 0;
    }

    EventEmitter$1.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
    };

    // About 1.5x faster than the two-arg version of Array#splice().
    function spliceOne(list, index) {
      for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
        list[i] = list[k];
      list.pop();
    }

    function arrayClone$3(arr, i) {
      var copy = new Array(i);
      while (i--)
        copy[i] = arr[i];
      return copy;
    }

    function unwrapListeners(arr) {
      var ret = new Array(arr.length);
      for (var i = 0; i < ret.length; ++i) {
        ret[i] = arr[i].listener || arr[i];
      }
      return ret;
    }

    var _polyfillNode_events = /*#__PURE__*/Object.freeze({
        __proto__: null,
        EventEmitter: EventEmitter$1,
        default: EventEmitter$1
    });

    var global$1 = (typeof global !== "undefined" ? global :
      typeof self !== "undefined" ? self :
      typeof window !== "undefined" ? window : {});

    // shim for using process in browser
    // based off https://github.com/defunctzombie/node-process/blob/master/browser.js

    function defaultSetTimout() {
        throw new Error('setTimeout has not been defined');
    }
    function defaultClearTimeout () {
        throw new Error('clearTimeout has not been defined');
    }
    var cachedSetTimeout = defaultSetTimout;
    var cachedClearTimeout = defaultClearTimeout;
    if (typeof global$1.setTimeout === 'function') {
        cachedSetTimeout = setTimeout;
    }
    if (typeof global$1.clearTimeout === 'function') {
        cachedClearTimeout = clearTimeout;
    }

    function runTimeout(fun) {
        if (cachedSetTimeout === setTimeout) {
            //normal enviroments in sane situations
            return setTimeout(fun, 0);
        }
        // if setTimeout wasn't available but was latter defined
        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
            cachedSetTimeout = setTimeout;
            return setTimeout(fun, 0);
        }
        try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedSetTimeout(fun, 0);
        } catch(e){
            try {
                // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
                return cachedSetTimeout.call(null, fun, 0);
            } catch(e){
                // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
                return cachedSetTimeout.call(this, fun, 0);
            }
        }


    }
    function runClearTimeout(marker) {
        if (cachedClearTimeout === clearTimeout) {
            //normal enviroments in sane situations
            return clearTimeout(marker);
        }
        // if clearTimeout wasn't available but was latter defined
        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
            cachedClearTimeout = clearTimeout;
            return clearTimeout(marker);
        }
        try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedClearTimeout(marker);
        } catch (e){
            try {
                // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
                return cachedClearTimeout.call(null, marker);
            } catch (e){
                // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
                // Some versions of I.E. have different rules for clearTimeout vs setTimeout
                return cachedClearTimeout.call(this, marker);
            }
        }



    }
    var queue = [];
    var draining = false;
    var currentQueue;
    var queueIndex = -1;

    function cleanUpNextTick() {
        if (!draining || !currentQueue) {
            return;
        }
        draining = false;
        if (currentQueue.length) {
            queue = currentQueue.concat(queue);
        } else {
            queueIndex = -1;
        }
        if (queue.length) {
            drainQueue();
        }
    }

    function drainQueue() {
        if (draining) {
            return;
        }
        var timeout = runTimeout(cleanUpNextTick);
        draining = true;

        var len = queue.length;
        while(len) {
            currentQueue = queue;
            queue = [];
            while (++queueIndex < len) {
                if (currentQueue) {
                    currentQueue[queueIndex].run();
                }
            }
            queueIndex = -1;
            len = queue.length;
        }
        currentQueue = null;
        draining = false;
        runClearTimeout(timeout);
    }
    function nextTick(fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
            for (var i = 1; i < arguments.length; i++) {
                args[i - 1] = arguments[i];
            }
        }
        queue.push(new Item(fun, args));
        if (queue.length === 1 && !draining) {
            runTimeout(drainQueue);
        }
    }
    // v8 likes predictible objects
    function Item(fun, array) {
        this.fun = fun;
        this.array = array;
    }
    Item.prototype.run = function () {
        this.fun.apply(null, this.array);
    };
    var title = 'browser';
    var platform = 'browser';
    var browser$6 = true;
    var env$1 = {};
    var argv = [];
    var version$4 = ''; // empty string to avoid regexp issues
    var versions$1 = {};
    var release = {};
    var config = {};

    function noop$4() {}

    var on$1 = noop$4;
    var addListener = noop$4;
    var once$2 = noop$4;
    var off = noop$4;
    var removeListener = noop$4;
    var removeAllListeners = noop$4;
    var emit = noop$4;

    function binding(name) {
        throw new Error('process.binding is not supported');
    }

    function cwd () { return '/' }
    function chdir (dir) {
        throw new Error('process.chdir is not supported');
    }function umask() { return 0; }

    // from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js
    var performance$1 = global$1.performance || {};
    var performanceNow =
      performance$1.now        ||
      performance$1.mozNow     ||
      performance$1.msNow      ||
      performance$1.oNow       ||
      performance$1.webkitNow  ||
      function(){ return (new Date()).getTime() };

    // generate timestamp or delta
    // see http://nodejs.org/api/process.html#process_process_hrtime
    function hrtime(previousTimestamp){
      var clocktime = performanceNow.call(performance$1)*1e-3;
      var seconds = Math.floor(clocktime);
      var nanoseconds = Math.floor((clocktime%1)*1e9);
      if (previousTimestamp) {
        seconds = seconds - previousTimestamp[0];
        nanoseconds = nanoseconds - previousTimestamp[1];
        if (nanoseconds<0) {
          seconds--;
          nanoseconds += 1e9;
        }
      }
      return [seconds,nanoseconds]
    }

    var startTime = new Date();
    function uptime() {
      var currentTime = new Date();
      var dif = currentTime - startTime;
      return dif / 1000;
    }

    var browser$1$1 = {
      nextTick: nextTick,
      title: title,
      browser: browser$6,
      env: env$1,
      argv: argv,
      version: version$4,
      versions: versions$1,
      on: on$1,
      addListener: addListener,
      once: once$2,
      off: off,
      removeListener: removeListener,
      removeAllListeners: removeAllListeners,
      emit: emit,
      binding: binding,
      cwd: cwd,
      chdir: chdir,
      umask: umask,
      hrtime: hrtime,
      platform: platform,
      release: release,
      config: config,
      uptime: uptime
    };

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function getDefaultExportFromCjs (x) {
    	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
    }

    function getAugmentedNamespace(n) {
      if (n.__esModule) return n;
      var f = n.default;
    	if (typeof f == "function") {
    		var a = function a () {
    			if (this instanceof a) {
            return Reflect.construct(f, arguments, this.constructor);
    			}
    			return f.apply(this, arguments);
    		};
    		a.prototype = f.prototype;
      } else a = {};
      Object.defineProperty(a, '__esModule', {value: true});
    	Object.keys(n).forEach(function (k) {
    		var d = Object.getOwnPropertyDescriptor(n, k);
    		Object.defineProperty(a, k, d.get ? d : {
    			enumerable: true,
    			get: function () {
    				return n[k];
    			}
    		});
    	});
    	return a;
    }

    var chacha20poly1305 = {};

    var chacha = {};

    var binary = {};

    var int = {};

    (function (exports) {
    	// Copyright (C) 2016 Dmitry Chestnykh
    	// MIT License. See LICENSE file for details.
    	Object.defineProperty(exports, "__esModule", { value: true });
    	/**
    	 * Package int provides helper functions for integerss.
    	 */
    	// Shim using 16-bit pieces.
    	function imulShim(a, b) {
    	    var ah = (a >>> 16) & 0xffff, al = a & 0xffff;
    	    var bh = (b >>> 16) & 0xffff, bl = b & 0xffff;
    	    return ((al * bl) + (((ah * bl + al * bh) << 16) >>> 0) | 0);
    	}
    	/** 32-bit integer multiplication.  */
    	// Use system Math.imul if available, otherwise use our shim.
    	exports.mul = Math.imul || imulShim;
    	/** 32-bit integer addition.  */
    	function add(a, b) {
    	    return (a + b) | 0;
    	}
    	exports.add = add;
    	/**  32-bit integer subtraction.  */
    	function sub(a, b) {
    	    return (a - b) | 0;
    	}
    	exports.sub = sub;
    	/** 32-bit integer left rotation */
    	function rotl(x, n) {
    	    return x << n | x >>> (32 - n);
    	}
    	exports.rotl = rotl;
    	/** 32-bit integer left rotation */
    	function rotr(x, n) {
    	    return x << (32 - n) | x >>> n;
    	}
    	exports.rotr = rotr;
    	function isIntegerShim(n) {
    	    return typeof n === "number" && isFinite(n) && Math.floor(n) === n;
    	}
    	/**
    	 * Returns true if the argument is an integer number.
    	 *
    	 * In ES2015, Number.isInteger.
    	 */
    	exports.isInteger = Number.isInteger || isIntegerShim;
    	/**
    	 *  Math.pow(2, 53) - 1
    	 *
    	 *  In ES2015 Number.MAX_SAFE_INTEGER.
    	 */
    	exports.MAX_SAFE_INTEGER = 9007199254740991;
    	/**
    	 * Returns true if the argument is a safe integer number
    	 * (-MIN_SAFE_INTEGER < number <= MAX_SAFE_INTEGER)
    	 *
    	 * In ES2015, Number.isSafeInteger.
    	 */
    	exports.isSafeInteger = function (n) {
    	    return exports.isInteger(n) && (n >= -exports.MAX_SAFE_INTEGER && n <= exports.MAX_SAFE_INTEGER);
    	};
    	
    } (int));

    // Copyright (C) 2016 Dmitry Chestnykh
    // MIT License. See LICENSE file for details.
    Object.defineProperty(binary, "__esModule", { value: true });
    /**
     * Package binary provides functions for encoding and decoding numbers in byte arrays.
     */
    var int_1 = int;
    // TODO(dchest): add asserts for correct value ranges and array offsets.
    /**
     * Reads 2 bytes from array starting at offset as big-endian
     * signed 16-bit integer and returns it.
     */
    function readInt16BE(array, offset) {
        if (offset === void 0) { offset = 0; }
        return (((array[offset + 0] << 8) | array[offset + 1]) << 16) >> 16;
    }
    binary.readInt16BE = readInt16BE;
    /**
     * Reads 2 bytes from array starting at offset as big-endian
     * unsigned 16-bit integer and returns it.
     */
    function readUint16BE(array, offset) {
        if (offset === void 0) { offset = 0; }
        return ((array[offset + 0] << 8) | array[offset + 1]) >>> 0;
    }
    binary.readUint16BE = readUint16BE;
    /**
     * Reads 2 bytes from array starting at offset as little-endian
     * signed 16-bit integer and returns it.
     */
    function readInt16LE(array, offset) {
        if (offset === void 0) { offset = 0; }
        return (((array[offset + 1] << 8) | array[offset]) << 16) >> 16;
    }
    binary.readInt16LE = readInt16LE;
    /**
     * Reads 2 bytes from array starting at offset as little-endian
     * unsigned 16-bit integer and returns it.
     */
    function readUint16LE(array, offset) {
        if (offset === void 0) { offset = 0; }
        return ((array[offset + 1] << 8) | array[offset]) >>> 0;
    }
    binary.readUint16LE = readUint16LE;
    /**
     * Writes 2-byte big-endian representation of 16-bit unsigned
     * value to byte array starting at offset.
     *
     * If byte array is not given, creates a new 2-byte one.
     *
     * Returns the output byte array.
     */
    function writeUint16BE(value, out, offset) {
        if (out === void 0) { out = new Uint8Array(2); }
        if (offset === void 0) { offset = 0; }
        out[offset + 0] = value >>> 8;
        out[offset + 1] = value >>> 0;
        return out;
    }
    binary.writeUint16BE = writeUint16BE;
    binary.writeInt16BE = writeUint16BE;
    /**
     * Writes 2-byte little-endian representation of 16-bit unsigned
     * value to array starting at offset.
     *
     * If byte array is not given, creates a new 2-byte one.
     *
     * Returns the output byte array.
     */
    function writeUint16LE(value, out, offset) {
        if (out === void 0) { out = new Uint8Array(2); }
        if (offset === void 0) { offset = 0; }
        out[offset + 0] = value >>> 0;
        out[offset + 1] = value >>> 8;
        return out;
    }
    binary.writeUint16LE = writeUint16LE;
    binary.writeInt16LE = writeUint16LE;
    /**
     * Reads 4 bytes from array starting at offset as big-endian
     * signed 32-bit integer and returns it.
     */
    function readInt32BE(array, offset) {
        if (offset === void 0) { offset = 0; }
        return (array[offset] << 24) |
            (array[offset + 1] << 16) |
            (array[offset + 2] << 8) |
            array[offset + 3];
    }
    binary.readInt32BE = readInt32BE;
    /**
     * Reads 4 bytes from array starting at offset as big-endian
     * unsigned 32-bit integer and returns it.
     */
    function readUint32BE(array, offset) {
        if (offset === void 0) { offset = 0; }
        return ((array[offset] << 24) |
            (array[offset + 1] << 16) |
            (array[offset + 2] << 8) |
            array[offset + 3]) >>> 0;
    }
    binary.readUint32BE = readUint32BE;
    /**
     * Reads 4 bytes from array starting at offset as little-endian
     * signed 32-bit integer and returns it.
     */
    function readInt32LE(array, offset) {
        if (offset === void 0) { offset = 0; }
        return (array[offset + 3] << 24) |
            (array[offset + 2] << 16) |
            (array[offset + 1] << 8) |
            array[offset];
    }
    binary.readInt32LE = readInt32LE;
    /**
     * Reads 4 bytes from array starting at offset as little-endian
     * unsigned 32-bit integer and returns it.
     */
    function readUint32LE(array, offset) {
        if (offset === void 0) { offset = 0; }
        return ((array[offset + 3] << 24) |
            (array[offset + 2] << 16) |
            (array[offset + 1] << 8) |
            array[offset]) >>> 0;
    }
    binary.readUint32LE = readUint32LE;
    /**
     * Writes 4-byte big-endian representation of 32-bit unsigned
     * value to byte array starting at offset.
     *
     * If byte array is not given, creates a new 4-byte one.
     *
     * Returns the output byte array.
     */
    function writeUint32BE(value, out, offset) {
        if (out === void 0) { out = new Uint8Array(4); }
        if (offset === void 0) { offset = 0; }
        out[offset + 0] = value >>> 24;
        out[offset + 1] = value >>> 16;
        out[offset + 2] = value >>> 8;
        out[offset + 3] = value >>> 0;
        return out;
    }
    binary.writeUint32BE = writeUint32BE;
    binary.writeInt32BE = writeUint32BE;
    /**
     * Writes 4-byte little-endian representation of 32-bit unsigned
     * value to array starting at offset.
     *
     * If byte array is not given, creates a new 4-byte one.
     *
     * Returns the output byte array.
     */
    function writeUint32LE(value, out, offset) {
        if (out === void 0) { out = new Uint8Array(4); }
        if (offset === void 0) { offset = 0; }
        out[offset + 0] = value >>> 0;
        out[offset + 1] = value >>> 8;
        out[offset + 2] = value >>> 16;
        out[offset + 3] = value >>> 24;
        return out;
    }
    binary.writeUint32LE = writeUint32LE;
    binary.writeInt32LE = writeUint32LE;
    /**
     * Reads 8 bytes from array starting at offset as big-endian
     * signed 64-bit integer and returns it.
     *
     * IMPORTANT: due to JavaScript limitation, supports exact
     * numbers in range -9007199254740991 to 9007199254740991.
     * If the number stored in the byte array is outside this range,
     * the result is not exact.
     */
    function readInt64BE(array, offset) {
        if (offset === void 0) { offset = 0; }
        var hi = readInt32BE(array, offset);
        var lo = readInt32BE(array, offset + 4);
        return hi * 0x100000000 + lo - ((lo >> 31) * 0x100000000);
    }
    binary.readInt64BE = readInt64BE;
    /**
     * Reads 8 bytes from array starting at offset as big-endian
     * unsigned 64-bit integer and returns it.
     *
     * IMPORTANT: due to JavaScript limitation, supports values up to 2^53-1.
     */
    function readUint64BE(array, offset) {
        if (offset === void 0) { offset = 0; }
        var hi = readUint32BE(array, offset);
        var lo = readUint32BE(array, offset + 4);
        return hi * 0x100000000 + lo;
    }
    binary.readUint64BE = readUint64BE;
    /**
     * Reads 8 bytes from array starting at offset as little-endian
     * signed 64-bit integer and returns it.
     *
     * IMPORTANT: due to JavaScript limitation, supports exact
     * numbers in range -9007199254740991 to 9007199254740991.
     * If the number stored in the byte array is outside this range,
     * the result is not exact.
     */
    function readInt64LE(array, offset) {
        if (offset === void 0) { offset = 0; }
        var lo = readInt32LE(array, offset);
        var hi = readInt32LE(array, offset + 4);
        return hi * 0x100000000 + lo - ((lo >> 31) * 0x100000000);
    }
    binary.readInt64LE = readInt64LE;
    /**
     * Reads 8 bytes from array starting at offset as little-endian
     * unsigned 64-bit integer and returns it.
     *
     * IMPORTANT: due to JavaScript limitation, supports values up to 2^53-1.
     */
    function readUint64LE(array, offset) {
        if (offset === void 0) { offset = 0; }
        var lo = readUint32LE(array, offset);
        var hi = readUint32LE(array, offset + 4);
        return hi * 0x100000000 + lo;
    }
    binary.readUint64LE = readUint64LE;
    /**
     * Writes 8-byte big-endian representation of 64-bit unsigned
     * value to byte array starting at offset.
     *
     * Due to JavaScript limitation, supports values up to 2^53-1.
     *
     * If byte array is not given, creates a new 8-byte one.
     *
     * Returns the output byte array.
     */
    function writeUint64BE(value, out, offset) {
        if (out === void 0) { out = new Uint8Array(8); }
        if (offset === void 0) { offset = 0; }
        writeUint32BE(value / 0x100000000 >>> 0, out, offset);
        writeUint32BE(value >>> 0, out, offset + 4);
        return out;
    }
    binary.writeUint64BE = writeUint64BE;
    binary.writeInt64BE = writeUint64BE;
    /**
     * Writes 8-byte little-endian representation of 64-bit unsigned
     * value to byte array starting at offset.
     *
     * Due to JavaScript limitation, supports values up to 2^53-1.
     *
     * If byte array is not given, creates a new 8-byte one.
     *
     * Returns the output byte array.
     */
    function writeUint64LE(value, out, offset) {
        if (out === void 0) { out = new Uint8Array(8); }
        if (offset === void 0) { offset = 0; }
        writeUint32LE(value >>> 0, out, offset);
        writeUint32LE(value / 0x100000000 >>> 0, out, offset + 4);
        return out;
    }
    binary.writeUint64LE = writeUint64LE;
    binary.writeInt64LE = writeUint64LE;
    /**
     * Reads bytes from array starting at offset as big-endian
     * unsigned bitLen-bit integer and returns it.
     *
     * Supports bit lengths divisible by 8, up to 48.
     */
    function readUintBE(bitLength, array, offset) {
        if (offset === void 0) { offset = 0; }
        // TODO(dchest): implement support for bitLengths non-divisible by 8
        if (bitLength % 8 !== 0) {
            throw new Error("readUintBE supports only bitLengths divisible by 8");
        }
        if (bitLength / 8 > array.length - offset) {
            throw new Error("readUintBE: array is too short for the given bitLength");
        }
        var result = 0;
        var mul = 1;
        for (var i = bitLength / 8 + offset - 1; i >= offset; i--) {
            result += array[i] * mul;
            mul *= 256;
        }
        return result;
    }
    binary.readUintBE = readUintBE;
    /**
     * Reads bytes from array starting at offset as little-endian
     * unsigned bitLen-bit integer and returns it.
     *
     * Supports bit lengths divisible by 8, up to 48.
     */
    function readUintLE(bitLength, array, offset) {
        if (offset === void 0) { offset = 0; }
        // TODO(dchest): implement support for bitLengths non-divisible by 8
        if (bitLength % 8 !== 0) {
            throw new Error("readUintLE supports only bitLengths divisible by 8");
        }
        if (bitLength / 8 > array.length - offset) {
            throw new Error("readUintLE: array is too short for the given bitLength");
        }
        var result = 0;
        var mul = 1;
        for (var i = offset; i < offset + bitLength / 8; i++) {
            result += array[i] * mul;
            mul *= 256;
        }
        return result;
    }
    binary.readUintLE = readUintLE;
    /**
     * Writes a big-endian representation of bitLen-bit unsigned
     * value to array starting at offset.
     *
     * Supports bit lengths divisible by 8, up to 48.
     *
     * If byte array is not given, creates a new one.
     *
     * Returns the output byte array.
     */
    function writeUintBE(bitLength, value, out, offset) {
        if (out === void 0) { out = new Uint8Array(bitLength / 8); }
        if (offset === void 0) { offset = 0; }
        // TODO(dchest): implement support for bitLengths non-divisible by 8
        if (bitLength % 8 !== 0) {
            throw new Error("writeUintBE supports only bitLengths divisible by 8");
        }
        if (!int_1.isSafeInteger(value)) {
            throw new Error("writeUintBE value must be an integer");
        }
        var div = 1;
        for (var i = bitLength / 8 + offset - 1; i >= offset; i--) {
            out[i] = (value / div) & 0xff;
            div *= 256;
        }
        return out;
    }
    binary.writeUintBE = writeUintBE;
    /**
     * Writes a little-endian representation of bitLen-bit unsigned
     * value to array starting at offset.
     *
     * Supports bit lengths divisible by 8, up to 48.
     *
     * If byte array is not given, creates a new one.
     *
     * Returns the output byte array.
     */
    function writeUintLE(bitLength, value, out, offset) {
        if (out === void 0) { out = new Uint8Array(bitLength / 8); }
        if (offset === void 0) { offset = 0; }
        // TODO(dchest): implement support for bitLengths non-divisible by 8
        if (bitLength % 8 !== 0) {
            throw new Error("writeUintLE supports only bitLengths divisible by 8");
        }
        if (!int_1.isSafeInteger(value)) {
            throw new Error("writeUintLE value must be an integer");
        }
        var div = 1;
        for (var i = offset; i < offset + bitLength / 8; i++) {
            out[i] = (value / div) & 0xff;
            div *= 256;
        }
        return out;
    }
    binary.writeUintLE = writeUintLE;
    /**
     * Reads 4 bytes from array starting at offset as big-endian
     * 32-bit floating-point number and returns it.
     */
    function readFloat32BE(array, offset) {
        if (offset === void 0) { offset = 0; }
        var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
        return view.getFloat32(offset);
    }
    binary.readFloat32BE = readFloat32BE;
    /**
     * Reads 4 bytes from array starting at offset as little-endian
     * 32-bit floating-point number and returns it.
     */
    function readFloat32LE(array, offset) {
        if (offset === void 0) { offset = 0; }
        var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
        return view.getFloat32(offset, true);
    }
    binary.readFloat32LE = readFloat32LE;
    /**
     * Reads 8 bytes from array starting at offset as big-endian
     * 64-bit floating-point number ("double") and returns it.
     */
    function readFloat64BE(array, offset) {
        if (offset === void 0) { offset = 0; }
        var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
        return view.getFloat64(offset);
    }
    binary.readFloat64BE = readFloat64BE;
    /**
     * Reads 8 bytes from array starting at offset as little-endian
     * 64-bit floating-point number ("double") and returns it.
     */
    function readFloat64LE(array, offset) {
        if (offset === void 0) { offset = 0; }
        var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
        return view.getFloat64(offset, true);
    }
    binary.readFloat64LE = readFloat64LE;
    /**
     * Writes 4-byte big-endian floating-point representation of value
     * to byte array starting at offset.
     *
     * If byte array is not given, creates a new 4-byte one.
     *
     * Returns the output byte array.
     */
    function writeFloat32BE(value, out, offset) {
        if (out === void 0) { out = new Uint8Array(4); }
        if (offset === void 0) { offset = 0; }
        var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
        view.setFloat32(offset, value);
        return out;
    }
    binary.writeFloat32BE = writeFloat32BE;
    /**
     * Writes 4-byte little-endian floating-point representation of value
     * to byte array starting at offset.
     *
     * If byte array is not given, creates a new 4-byte one.
     *
     * Returns the output byte array.
     */
    function writeFloat32LE(value, out, offset) {
        if (out === void 0) { out = new Uint8Array(4); }
        if (offset === void 0) { offset = 0; }
        var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
        view.setFloat32(offset, value, true);
        return out;
    }
    binary.writeFloat32LE = writeFloat32LE;
    /**
     * Writes 8-byte big-endian floating-point representation of value
     * to byte array starting at offset.
     *
     * If byte array is not given, creates a new 8-byte one.
     *
     * Returns the output byte array.
     */
    function writeFloat64BE(value, out, offset) {
        if (out === void 0) { out = new Uint8Array(8); }
        if (offset === void 0) { offset = 0; }
        var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
        view.setFloat64(offset, value);
        return out;
    }
    binary.writeFloat64BE = writeFloat64BE;
    /**
     * Writes 8-byte little-endian floating-point representation of value
     * to byte array starting at offset.
     *
     * If byte array is not given, creates a new 8-byte one.
     *
     * Returns the output byte array.
     */
    function writeFloat64LE(value, out, offset) {
        if (out === void 0) { out = new Uint8Array(8); }
        if (offset === void 0) { offset = 0; }
        var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
        view.setFloat64(offset, value, true);
        return out;
    }
    binary.writeFloat64LE = writeFloat64LE;

    var wipe$1 = {};

    // Copyright (C) 2016 Dmitry Chestnykh
    // MIT License. See LICENSE file for details.
    Object.defineProperty(wipe$1, "__esModule", { value: true });
    /**
     * Sets all values in the given array to zero and returns it.
     *
     * The fact that it sets bytes to zero can be relied on.
     *
     * There is no guarantee that this function makes data disappear from memory,
     * as runtime implementation can, for example, have copying garbage collector
     * that will make copies of sensitive data before we wipe it. Or that an
     * operating system will write our data to swap or sleep image. Another thing
     * is that an optimizing compiler can remove calls to this function or make it
     * no-op. There's nothing we can do with it, so we just do our best and hope
     * that everything will be okay and good will triumph over evil.
     */
    function wipe(array) {
        // Right now it's similar to array.fill(0). If it turns
        // out that runtimes optimize this call away, maybe
        // we can try something else.
        for (var i = 0; i < array.length; i++) {
            array[i] = 0;
        }
        return array;
    }
    wipe$1.wipe = wipe;

    // Copyright (C) 2016 Dmitry Chestnykh
    // MIT License. See LICENSE file for details.
    Object.defineProperty(chacha, "__esModule", { value: true });
    /**
     * Package chacha implements ChaCha stream cipher.
     */
    var binary_1 = binary;
    var wipe_1$3 = wipe$1;
    // Number of ChaCha rounds (ChaCha20).
    var ROUNDS = 20;
    // Applies the ChaCha core function to 16-byte input,
    // 32-byte key key, and puts the result into 64-byte array out.
    function core(out, input, key) {
        var j0 = 0x61707865; // "expa"  -- ChaCha's "sigma" constant
        var j1 = 0x3320646E; // "nd 3"     for 32-byte keys
        var j2 = 0x79622D32; // "2-by"
        var j3 = 0x6B206574; // "te k"
        var j4 = (key[3] << 24) | (key[2] << 16) | (key[1] << 8) | key[0];
        var j5 = (key[7] << 24) | (key[6] << 16) | (key[5] << 8) | key[4];
        var j6 = (key[11] << 24) | (key[10] << 16) | (key[9] << 8) | key[8];
        var j7 = (key[15] << 24) | (key[14] << 16) | (key[13] << 8) | key[12];
        var j8 = (key[19] << 24) | (key[18] << 16) | (key[17] << 8) | key[16];
        var j9 = (key[23] << 24) | (key[22] << 16) | (key[21] << 8) | key[20];
        var j10 = (key[27] << 24) | (key[26] << 16) | (key[25] << 8) | key[24];
        var j11 = (key[31] << 24) | (key[30] << 16) | (key[29] << 8) | key[28];
        var j12 = (input[3] << 24) | (input[2] << 16) | (input[1] << 8) | input[0];
        var j13 = (input[7] << 24) | (input[6] << 16) | (input[5] << 8) | input[4];
        var j14 = (input[11] << 24) | (input[10] << 16) | (input[9] << 8) | input[8];
        var j15 = (input[15] << 24) | (input[14] << 16) | (input[13] << 8) | input[12];
        var x0 = j0;
        var x1 = j1;
        var x2 = j2;
        var x3 = j3;
        var x4 = j4;
        var x5 = j5;
        var x6 = j6;
        var x7 = j7;
        var x8 = j8;
        var x9 = j9;
        var x10 = j10;
        var x11 = j11;
        var x12 = j12;
        var x13 = j13;
        var x14 = j14;
        var x15 = j15;
        for (var i = 0; i < ROUNDS; i += 2) {
            x0 = x0 + x4 | 0;
            x12 ^= x0;
            x12 = x12 >>> (32 - 16) | x12 << 16;
            x8 = x8 + x12 | 0;
            x4 ^= x8;
            x4 = x4 >>> (32 - 12) | x4 << 12;
            x1 = x1 + x5 | 0;
            x13 ^= x1;
            x13 = x13 >>> (32 - 16) | x13 << 16;
            x9 = x9 + x13 | 0;
            x5 ^= x9;
            x5 = x5 >>> (32 - 12) | x5 << 12;
            x2 = x2 + x6 | 0;
            x14 ^= x2;
            x14 = x14 >>> (32 - 16) | x14 << 16;
            x10 = x10 + x14 | 0;
            x6 ^= x10;
            x6 = x6 >>> (32 - 12) | x6 << 12;
            x3 = x3 + x7 | 0;
            x15 ^= x3;
            x15 = x15 >>> (32 - 16) | x15 << 16;
            x11 = x11 + x15 | 0;
            x7 ^= x11;
            x7 = x7 >>> (32 - 12) | x7 << 12;
            x2 = x2 + x6 | 0;
            x14 ^= x2;
            x14 = x14 >>> (32 - 8) | x14 << 8;
            x10 = x10 + x14 | 0;
            x6 ^= x10;
            x6 = x6 >>> (32 - 7) | x6 << 7;
            x3 = x3 + x7 | 0;
            x15 ^= x3;
            x15 = x15 >>> (32 - 8) | x15 << 8;
            x11 = x11 + x15 | 0;
            x7 ^= x11;
            x7 = x7 >>> (32 - 7) | x7 << 7;
            x1 = x1 + x5 | 0;
            x13 ^= x1;
            x13 = x13 >>> (32 - 8) | x13 << 8;
            x9 = x9 + x13 | 0;
            x5 ^= x9;
            x5 = x5 >>> (32 - 7) | x5 << 7;
            x0 = x0 + x4 | 0;
            x12 ^= x0;
            x12 = x12 >>> (32 - 8) | x12 << 8;
            x8 = x8 + x12 | 0;
            x4 ^= x8;
            x4 = x4 >>> (32 - 7) | x4 << 7;
            x0 = x0 + x5 | 0;
            x15 ^= x0;
            x15 = x15 >>> (32 - 16) | x15 << 16;
            x10 = x10 + x15 | 0;
            x5 ^= x10;
            x5 = x5 >>> (32 - 12) | x5 << 12;
            x1 = x1 + x6 | 0;
            x12 ^= x1;
            x12 = x12 >>> (32 - 16) | x12 << 16;
            x11 = x11 + x12 | 0;
            x6 ^= x11;
            x6 = x6 >>> (32 - 12) | x6 << 12;
            x2 = x2 + x7 | 0;
            x13 ^= x2;
            x13 = x13 >>> (32 - 16) | x13 << 16;
            x8 = x8 + x13 | 0;
            x7 ^= x8;
            x7 = x7 >>> (32 - 12) | x7 << 12;
            x3 = x3 + x4 | 0;
            x14 ^= x3;
            x14 = x14 >>> (32 - 16) | x14 << 16;
            x9 = x9 + x14 | 0;
            x4 ^= x9;
            x4 = x4 >>> (32 - 12) | x4 << 12;
            x2 = x2 + x7 | 0;
            x13 ^= x2;
            x13 = x13 >>> (32 - 8) | x13 << 8;
            x8 = x8 + x13 | 0;
            x7 ^= x8;
            x7 = x7 >>> (32 - 7) | x7 << 7;
            x3 = x3 + x4 | 0;
            x14 ^= x3;
            x14 = x14 >>> (32 - 8) | x14 << 8;
            x9 = x9 + x14 | 0;
            x4 ^= x9;
            x4 = x4 >>> (32 - 7) | x4 << 7;
            x1 = x1 + x6 | 0;
            x12 ^= x1;
            x12 = x12 >>> (32 - 8) | x12 << 8;
            x11 = x11 + x12 | 0;
            x6 ^= x11;
            x6 = x6 >>> (32 - 7) | x6 << 7;
            x0 = x0 + x5 | 0;
            x15 ^= x0;
            x15 = x15 >>> (32 - 8) | x15 << 8;
            x10 = x10 + x15 | 0;
            x5 ^= x10;
            x5 = x5 >>> (32 - 7) | x5 << 7;
        }
        binary_1.writeUint32LE(x0 + j0 | 0, out, 0);
        binary_1.writeUint32LE(x1 + j1 | 0, out, 4);
        binary_1.writeUint32LE(x2 + j2 | 0, out, 8);
        binary_1.writeUint32LE(x3 + j3 | 0, out, 12);
        binary_1.writeUint32LE(x4 + j4 | 0, out, 16);
        binary_1.writeUint32LE(x5 + j5 | 0, out, 20);
        binary_1.writeUint32LE(x6 + j6 | 0, out, 24);
        binary_1.writeUint32LE(x7 + j7 | 0, out, 28);
        binary_1.writeUint32LE(x8 + j8 | 0, out, 32);
        binary_1.writeUint32LE(x9 + j9 | 0, out, 36);
        binary_1.writeUint32LE(x10 + j10 | 0, out, 40);
        binary_1.writeUint32LE(x11 + j11 | 0, out, 44);
        binary_1.writeUint32LE(x12 + j12 | 0, out, 48);
        binary_1.writeUint32LE(x13 + j13 | 0, out, 52);
        binary_1.writeUint32LE(x14 + j14 | 0, out, 56);
        binary_1.writeUint32LE(x15 + j15 | 0, out, 60);
    }
    /**
     * Encrypt src with ChaCha20 stream generated for the given 32-byte key and
     * 8-byte (as in original implementation) or 12-byte (as in RFC7539) nonce and
     * write the result into dst and return it.
     *
     * dst and src may be the same, but otherwise must not overlap.
     *
     * If nonce is 12 bytes, users should not encrypt more than 256 GiB with the
     * same key and nonce, otherwise the stream will repeat. The function will
     * throw error if counter overflows to prevent this.
     *
     * If nonce is 8 bytes, the output is practically unlimited (2^70 bytes, which
     * is more than a million petabytes). However, it is not recommended to
     * generate 8-byte nonces randomly, as the chance of collision is high.
     *
     * Never use the same key and nonce to encrypt more than one message.
     *
     * If nonceInplaceCounterLength is not 0, the nonce is assumed to be a 16-byte
     * array with stream counter in first nonceInplaceCounterLength bytes and nonce
     * in the last remaining bytes. The counter will be incremented inplace for
     * each ChaCha block. This is useful if you need to encrypt one stream of data
     * in chunks.
     */
    function streamXOR(key, nonce, src, dst, nonceInplaceCounterLength) {
        if (nonceInplaceCounterLength === void 0) { nonceInplaceCounterLength = 0; }
        // We only support 256-bit keys.
        if (key.length !== 32) {
            throw new Error("ChaCha: key size must be 32 bytes");
        }
        if (dst.length < src.length) {
            throw new Error("ChaCha: destination is shorter than source");
        }
        var nc;
        var counterLength;
        if (nonceInplaceCounterLength === 0) {
            if (nonce.length !== 8 && nonce.length !== 12) {
                throw new Error("ChaCha nonce must be 8 or 12 bytes");
            }
            nc = new Uint8Array(16);
            // First counterLength bytes of nc are counter, starting with zero.
            counterLength = nc.length - nonce.length;
            // Last bytes of nc after counterLength are nonce, set them.
            nc.set(nonce, counterLength);
        }
        else {
            if (nonce.length !== 16) {
                throw new Error("ChaCha nonce with counter must be 16 bytes");
            }
            // This will update passed nonce with counter inplace.
            nc = nonce;
            counterLength = nonceInplaceCounterLength;
        }
        // Allocate temporary space for ChaCha block.
        var block = new Uint8Array(64);
        for (var i = 0; i < src.length; i += 64) {
            // Generate a block.
            core(block, nc, key);
            // XOR block bytes with src into dst.
            for (var j = i; j < i + 64 && j < src.length; j++) {
                dst[j] = src[j] ^ block[j - i];
            }
            // Increment counter.
            incrementCounter(nc, 0, counterLength);
        }
        // Cleanup temporary space.
        wipe_1$3.wipe(block);
        if (nonceInplaceCounterLength === 0) {
            // Cleanup counter.
            wipe_1$3.wipe(nc);
        }
        return dst;
    }
    chacha.streamXOR = streamXOR;
    /**
     * Generate ChaCha20 stream for the given 32-byte key and 8-byte or 12-byte
     * nonce and write it into dst and return it.
     *
     * Never use the same key and nonce to generate more than one stream.
     *
     * If nonceInplaceCounterLength is not 0, it behaves the same with respect to
     * the nonce as described in the streamXOR documentation.
     *
     * stream is like streamXOR with all-zero src.
     */
    function stream(key, nonce, dst, nonceInplaceCounterLength) {
        if (nonceInplaceCounterLength === void 0) { nonceInplaceCounterLength = 0; }
        wipe_1$3.wipe(dst);
        return streamXOR(key, nonce, dst, dst, nonceInplaceCounterLength);
    }
    chacha.stream = stream;
    function incrementCounter(counter, pos, len) {
        var carry = 1;
        while (len--) {
            carry = carry + (counter[pos] & 0xff) | 0;
            counter[pos] = carry & 0xff;
            carry >>>= 8;
            pos++;
        }
        if (carry > 0) {
            throw new Error("ChaCha: counter overflow");
        }
    }

    var poly1305 = {};

    var constantTime = {};

    // Copyright (C) 2016 Dmitry Chestnykh
    // MIT License. See LICENSE file for details.
    Object.defineProperty(constantTime, "__esModule", { value: true });
    /**
     * Package constant-time provides functions for performing algorithmically constant-time operations.
     */
    /**
     * NOTE! Due to the inability to guarantee real constant time evaluation of
     * anything in JavaScript VM, this is module is the best effort.
     */
    /**
     * Returns resultIfOne if subject is 1, or resultIfZero if subject is 0.
     *
     * Supports only 32-bit integers, so resultIfOne or resultIfZero are not
     * integers, they'll be converted to them with bitwise operations.
     */
    function select(subject, resultIfOne, resultIfZero) {
        return (~(subject - 1) & resultIfOne) | ((subject - 1) & resultIfZero);
    }
    constantTime.select = select;
    /**
     * Returns 1 if a <= b, or 0 if not.
     * Arguments must be positive 32-bit integers less than or equal to 2^31 - 1.
     */
    function lessOrEqual(a, b) {
        return (((a | 0) - (b | 0) - 1) >>> 31) & 1;
    }
    constantTime.lessOrEqual = lessOrEqual;
    /**
     * Returns 1 if a and b are of equal length and their contents
     * are equal, or 0 otherwise.
     *
     * Note that unlike in equal(), zero-length inputs are considered
     * the same, so this function will return 1.
     */
    function compare$c(a, b) {
        if (a.length !== b.length) {
            return 0;
        }
        var result = 0;
        for (var i = 0; i < a.length; i++) {
            result |= a[i] ^ b[i];
        }
        return (1 & ((result - 1) >>> 8));
    }
    constantTime.compare = compare$c;
    /**
     * Returns true if a and b are of equal non-zero length,
     * and their contents are equal, or false otherwise.
     *
     * Note that unlike in compare() zero-length inputs are considered
     * _not_ equal, so this function will return false.
     */
    function equal(a, b) {
        if (a.length === 0 || b.length === 0) {
            return false;
        }
        return compare$c(a, b) !== 0;
    }
    constantTime.equal = equal;

    (function (exports) {
    	// Copyright (C) 2016 Dmitry Chestnykh
    	// MIT License. See LICENSE file for details.
    	Object.defineProperty(exports, "__esModule", { value: true });
    	/**
    	 * Package poly1305 implements Poly1305 one-time message authentication algorithm.
    	 */
    	var constant_time_1 = constantTime;
    	var wipe_1 = wipe$1;
    	exports.DIGEST_LENGTH = 16;
    	// Port of Andrew Moon's Poly1305-donna-16. Public domain.
    	// https://github.com/floodyberry/poly1305-donna
    	/**
    	 * Poly1305 computes 16-byte authenticator of message using
    	 * a one-time 32-byte key.
    	 *
    	 * Important: key should be used for only one message,
    	 * it should never repeat.
    	 */
    	var Poly1305 = /** @class */ (function () {
    	    function Poly1305(key) {
    	        this.digestLength = exports.DIGEST_LENGTH;
    	        this._buffer = new Uint8Array(16);
    	        this._r = new Uint16Array(10);
    	        this._h = new Uint16Array(10);
    	        this._pad = new Uint16Array(8);
    	        this._leftover = 0;
    	        this._fin = 0;
    	        this._finished = false;
    	        var t0 = key[0] | key[1] << 8;
    	        this._r[0] = (t0) & 0x1fff;
    	        var t1 = key[2] | key[3] << 8;
    	        this._r[1] = ((t0 >>> 13) | (t1 << 3)) & 0x1fff;
    	        var t2 = key[4] | key[5] << 8;
    	        this._r[2] = ((t1 >>> 10) | (t2 << 6)) & 0x1f03;
    	        var t3 = key[6] | key[7] << 8;
    	        this._r[3] = ((t2 >>> 7) | (t3 << 9)) & 0x1fff;
    	        var t4 = key[8] | key[9] << 8;
    	        this._r[4] = ((t3 >>> 4) | (t4 << 12)) & 0x00ff;
    	        this._r[5] = ((t4 >>> 1)) & 0x1ffe;
    	        var t5 = key[10] | key[11] << 8;
    	        this._r[6] = ((t4 >>> 14) | (t5 << 2)) & 0x1fff;
    	        var t6 = key[12] | key[13] << 8;
    	        this._r[7] = ((t5 >>> 11) | (t6 << 5)) & 0x1f81;
    	        var t7 = key[14] | key[15] << 8;
    	        this._r[8] = ((t6 >>> 8) | (t7 << 8)) & 0x1fff;
    	        this._r[9] = ((t7 >>> 5)) & 0x007f;
    	        this._pad[0] = key[16] | key[17] << 8;
    	        this._pad[1] = key[18] | key[19] << 8;
    	        this._pad[2] = key[20] | key[21] << 8;
    	        this._pad[3] = key[22] | key[23] << 8;
    	        this._pad[4] = key[24] | key[25] << 8;
    	        this._pad[5] = key[26] | key[27] << 8;
    	        this._pad[6] = key[28] | key[29] << 8;
    	        this._pad[7] = key[30] | key[31] << 8;
    	    }
    	    Poly1305.prototype._blocks = function (m, mpos, bytes) {
    	        var hibit = this._fin ? 0 : 1 << 11;
    	        var h0 = this._h[0], h1 = this._h[1], h2 = this._h[2], h3 = this._h[3], h4 = this._h[4], h5 = this._h[5], h6 = this._h[6], h7 = this._h[7], h8 = this._h[8], h9 = this._h[9];
    	        var r0 = this._r[0], r1 = this._r[1], r2 = this._r[2], r3 = this._r[3], r4 = this._r[4], r5 = this._r[5], r6 = this._r[6], r7 = this._r[7], r8 = this._r[8], r9 = this._r[9];
    	        while (bytes >= 16) {
    	            var t0 = m[mpos + 0] | m[mpos + 1] << 8;
    	            h0 += (t0) & 0x1fff;
    	            var t1 = m[mpos + 2] | m[mpos + 3] << 8;
    	            h1 += ((t0 >>> 13) | (t1 << 3)) & 0x1fff;
    	            var t2 = m[mpos + 4] | m[mpos + 5] << 8;
    	            h2 += ((t1 >>> 10) | (t2 << 6)) & 0x1fff;
    	            var t3 = m[mpos + 6] | m[mpos + 7] << 8;
    	            h3 += ((t2 >>> 7) | (t3 << 9)) & 0x1fff;
    	            var t4 = m[mpos + 8] | m[mpos + 9] << 8;
    	            h4 += ((t3 >>> 4) | (t4 << 12)) & 0x1fff;
    	            h5 += ((t4 >>> 1)) & 0x1fff;
    	            var t5 = m[mpos + 10] | m[mpos + 11] << 8;
    	            h6 += ((t4 >>> 14) | (t5 << 2)) & 0x1fff;
    	            var t6 = m[mpos + 12] | m[mpos + 13] << 8;
    	            h7 += ((t5 >>> 11) | (t6 << 5)) & 0x1fff;
    	            var t7 = m[mpos + 14] | m[mpos + 15] << 8;
    	            h8 += ((t6 >>> 8) | (t7 << 8)) & 0x1fff;
    	            h9 += ((t7 >>> 5)) | hibit;
    	            var c = 0;
    	            var d0 = c;
    	            d0 += h0 * r0;
    	            d0 += h1 * (5 * r9);
    	            d0 += h2 * (5 * r8);
    	            d0 += h3 * (5 * r7);
    	            d0 += h4 * (5 * r6);
    	            c = (d0 >>> 13);
    	            d0 &= 0x1fff;
    	            d0 += h5 * (5 * r5);
    	            d0 += h6 * (5 * r4);
    	            d0 += h7 * (5 * r3);
    	            d0 += h8 * (5 * r2);
    	            d0 += h9 * (5 * r1);
    	            c += (d0 >>> 13);
    	            d0 &= 0x1fff;
    	            var d1 = c;
    	            d1 += h0 * r1;
    	            d1 += h1 * r0;
    	            d1 += h2 * (5 * r9);
    	            d1 += h3 * (5 * r8);
    	            d1 += h4 * (5 * r7);
    	            c = (d1 >>> 13);
    	            d1 &= 0x1fff;
    	            d1 += h5 * (5 * r6);
    	            d1 += h6 * (5 * r5);
    	            d1 += h7 * (5 * r4);
    	            d1 += h8 * (5 * r3);
    	            d1 += h9 * (5 * r2);
    	            c += (d1 >>> 13);
    	            d1 &= 0x1fff;
    	            var d2 = c;
    	            d2 += h0 * r2;
    	            d2 += h1 * r1;
    	            d2 += h2 * r0;
    	            d2 += h3 * (5 * r9);
    	            d2 += h4 * (5 * r8);
    	            c = (d2 >>> 13);
    	            d2 &= 0x1fff;
    	            d2 += h5 * (5 * r7);
    	            d2 += h6 * (5 * r6);
    	            d2 += h7 * (5 * r5);
    	            d2 += h8 * (5 * r4);
    	            d2 += h9 * (5 * r3);
    	            c += (d2 >>> 13);
    	            d2 &= 0x1fff;
    	            var d3 = c;
    	            d3 += h0 * r3;
    	            d3 += h1 * r2;
    	            d3 += h2 * r1;
    	            d3 += h3 * r0;
    	            d3 += h4 * (5 * r9);
    	            c = (d3 >>> 13);
    	            d3 &= 0x1fff;
    	            d3 += h5 * (5 * r8);
    	            d3 += h6 * (5 * r7);
    	            d3 += h7 * (5 * r6);
    	            d3 += h8 * (5 * r5);
    	            d3 += h9 * (5 * r4);
    	            c += (d3 >>> 13);
    	            d3 &= 0x1fff;
    	            var d4 = c;
    	            d4 += h0 * r4;
    	            d4 += h1 * r3;
    	            d4 += h2 * r2;
    	            d4 += h3 * r1;
    	            d4 += h4 * r0;
    	            c = (d4 >>> 13);
    	            d4 &= 0x1fff;
    	            d4 += h5 * (5 * r9);
    	            d4 += h6 * (5 * r8);
    	            d4 += h7 * (5 * r7);
    	            d4 += h8 * (5 * r6);
    	            d4 += h9 * (5 * r5);
    	            c += (d4 >>> 13);
    	            d4 &= 0x1fff;
    	            var d5 = c;
    	            d5 += h0 * r5;
    	            d5 += h1 * r4;
    	            d5 += h2 * r3;
    	            d5 += h3 * r2;
    	            d5 += h4 * r1;
    	            c = (d5 >>> 13);
    	            d5 &= 0x1fff;
    	            d5 += h5 * r0;
    	            d5 += h6 * (5 * r9);
    	            d5 += h7 * (5 * r8);
    	            d5 += h8 * (5 * r7);
    	            d5 += h9 * (5 * r6);
    	            c += (d5 >>> 13);
    	            d5 &= 0x1fff;
    	            var d6 = c;
    	            d6 += h0 * r6;
    	            d6 += h1 * r5;
    	            d6 += h2 * r4;
    	            d6 += h3 * r3;
    	            d6 += h4 * r2;
    	            c = (d6 >>> 13);
    	            d6 &= 0x1fff;
    	            d6 += h5 * r1;
    	            d6 += h6 * r0;
    	            d6 += h7 * (5 * r9);
    	            d6 += h8 * (5 * r8);
    	            d6 += h9 * (5 * r7);
    	            c += (d6 >>> 13);
    	            d6 &= 0x1fff;
    	            var d7 = c;
    	            d7 += h0 * r7;
    	            d7 += h1 * r6;
    	            d7 += h2 * r5;
    	            d7 += h3 * r4;
    	            d7 += h4 * r3;
    	            c = (d7 >>> 13);
    	            d7 &= 0x1fff;
    	            d7 += h5 * r2;
    	            d7 += h6 * r1;
    	            d7 += h7 * r0;
    	            d7 += h8 * (5 * r9);
    	            d7 += h9 * (5 * r8);
    	            c += (d7 >>> 13);
    	            d7 &= 0x1fff;
    	            var d8 = c;
    	            d8 += h0 * r8;
    	            d8 += h1 * r7;
    	            d8 += h2 * r6;
    	            d8 += h3 * r5;
    	            d8 += h4 * r4;
    	            c = (d8 >>> 13);
    	            d8 &= 0x1fff;
    	            d8 += h5 * r3;
    	            d8 += h6 * r2;
    	            d8 += h7 * r1;
    	            d8 += h8 * r0;
    	            d8 += h9 * (5 * r9);
    	            c += (d8 >>> 13);
    	            d8 &= 0x1fff;
    	            var d9 = c;
    	            d9 += h0 * r9;
    	            d9 += h1 * r8;
    	            d9 += h2 * r7;
    	            d9 += h3 * r6;
    	            d9 += h4 * r5;
    	            c = (d9 >>> 13);
    	            d9 &= 0x1fff;
    	            d9 += h5 * r4;
    	            d9 += h6 * r3;
    	            d9 += h7 * r2;
    	            d9 += h8 * r1;
    	            d9 += h9 * r0;
    	            c += (d9 >>> 13);
    	            d9 &= 0x1fff;
    	            c = (((c << 2) + c)) | 0;
    	            c = (c + d0) | 0;
    	            d0 = c & 0x1fff;
    	            c = (c >>> 13);
    	            d1 += c;
    	            h0 = d0;
    	            h1 = d1;
    	            h2 = d2;
    	            h3 = d3;
    	            h4 = d4;
    	            h5 = d5;
    	            h6 = d6;
    	            h7 = d7;
    	            h8 = d8;
    	            h9 = d9;
    	            mpos += 16;
    	            bytes -= 16;
    	        }
    	        this._h[0] = h0;
    	        this._h[1] = h1;
    	        this._h[2] = h2;
    	        this._h[3] = h3;
    	        this._h[4] = h4;
    	        this._h[5] = h5;
    	        this._h[6] = h6;
    	        this._h[7] = h7;
    	        this._h[8] = h8;
    	        this._h[9] = h9;
    	    };
    	    Poly1305.prototype.finish = function (mac, macpos) {
    	        if (macpos === void 0) { macpos = 0; }
    	        var g = new Uint16Array(10);
    	        var c;
    	        var mask;
    	        var f;
    	        var i;
    	        if (this._leftover) {
    	            i = this._leftover;
    	            this._buffer[i++] = 1;
    	            for (; i < 16; i++) {
    	                this._buffer[i] = 0;
    	            }
    	            this._fin = 1;
    	            this._blocks(this._buffer, 0, 16);
    	        }
    	        c = this._h[1] >>> 13;
    	        this._h[1] &= 0x1fff;
    	        for (i = 2; i < 10; i++) {
    	            this._h[i] += c;
    	            c = this._h[i] >>> 13;
    	            this._h[i] &= 0x1fff;
    	        }
    	        this._h[0] += (c * 5);
    	        c = this._h[0] >>> 13;
    	        this._h[0] &= 0x1fff;
    	        this._h[1] += c;
    	        c = this._h[1] >>> 13;
    	        this._h[1] &= 0x1fff;
    	        this._h[2] += c;
    	        g[0] = this._h[0] + 5;
    	        c = g[0] >>> 13;
    	        g[0] &= 0x1fff;
    	        for (i = 1; i < 10; i++) {
    	            g[i] = this._h[i] + c;
    	            c = g[i] >>> 13;
    	            g[i] &= 0x1fff;
    	        }
    	        g[9] -= (1 << 13);
    	        mask = (c ^ 1) - 1;
    	        for (i = 0; i < 10; i++) {
    	            g[i] &= mask;
    	        }
    	        mask = ~mask;
    	        for (i = 0; i < 10; i++) {
    	            this._h[i] = (this._h[i] & mask) | g[i];
    	        }
    	        this._h[0] = ((this._h[0]) | (this._h[1] << 13)) & 0xffff;
    	        this._h[1] = ((this._h[1] >>> 3) | (this._h[2] << 10)) & 0xffff;
    	        this._h[2] = ((this._h[2] >>> 6) | (this._h[3] << 7)) & 0xffff;
    	        this._h[3] = ((this._h[3] >>> 9) | (this._h[4] << 4)) & 0xffff;
    	        this._h[4] = ((this._h[4] >>> 12) | (this._h[5] << 1) | (this._h[6] << 14)) & 0xffff;
    	        this._h[5] = ((this._h[6] >>> 2) | (this._h[7] << 11)) & 0xffff;
    	        this._h[6] = ((this._h[7] >>> 5) | (this._h[8] << 8)) & 0xffff;
    	        this._h[7] = ((this._h[8] >>> 8) | (this._h[9] << 5)) & 0xffff;
    	        f = this._h[0] + this._pad[0];
    	        this._h[0] = f & 0xffff;
    	        for (i = 1; i < 8; i++) {
    	            f = (((this._h[i] + this._pad[i]) | 0) + (f >>> 16)) | 0;
    	            this._h[i] = f & 0xffff;
    	        }
    	        mac[macpos + 0] = this._h[0] >>> 0;
    	        mac[macpos + 1] = this._h[0] >>> 8;
    	        mac[macpos + 2] = this._h[1] >>> 0;
    	        mac[macpos + 3] = this._h[1] >>> 8;
    	        mac[macpos + 4] = this._h[2] >>> 0;
    	        mac[macpos + 5] = this._h[2] >>> 8;
    	        mac[macpos + 6] = this._h[3] >>> 0;
    	        mac[macpos + 7] = this._h[3] >>> 8;
    	        mac[macpos + 8] = this._h[4] >>> 0;
    	        mac[macpos + 9] = this._h[4] >>> 8;
    	        mac[macpos + 10] = this._h[5] >>> 0;
    	        mac[macpos + 11] = this._h[5] >>> 8;
    	        mac[macpos + 12] = this._h[6] >>> 0;
    	        mac[macpos + 13] = this._h[6] >>> 8;
    	        mac[macpos + 14] = this._h[7] >>> 0;
    	        mac[macpos + 15] = this._h[7] >>> 8;
    	        this._finished = true;
    	        return this;
    	    };
    	    Poly1305.prototype.update = function (m) {
    	        var mpos = 0;
    	        var bytes = m.length;
    	        var want;
    	        if (this._leftover) {
    	            want = (16 - this._leftover);
    	            if (want > bytes) {
    	                want = bytes;
    	            }
    	            for (var i = 0; i < want; i++) {
    	                this._buffer[this._leftover + i] = m[mpos + i];
    	            }
    	            bytes -= want;
    	            mpos += want;
    	            this._leftover += want;
    	            if (this._leftover < 16) {
    	                return this;
    	            }
    	            this._blocks(this._buffer, 0, 16);
    	            this._leftover = 0;
    	        }
    	        if (bytes >= 16) {
    	            want = bytes - (bytes % 16);
    	            this._blocks(m, mpos, want);
    	            mpos += want;
    	            bytes -= want;
    	        }
    	        if (bytes) {
    	            for (var i = 0; i < bytes; i++) {
    	                this._buffer[this._leftover + i] = m[mpos + i];
    	            }
    	            this._leftover += bytes;
    	        }
    	        return this;
    	    };
    	    Poly1305.prototype.digest = function () {
    	        // TODO(dchest): it behaves differently than other hashes/HMAC,
    	        // because it throws when finished — others just return saved result.
    	        if (this._finished) {
    	            throw new Error("Poly1305 was finished");
    	        }
    	        var mac = new Uint8Array(16);
    	        this.finish(mac);
    	        return mac;
    	    };
    	    Poly1305.prototype.clean = function () {
    	        wipe_1.wipe(this._buffer);
    	        wipe_1.wipe(this._r);
    	        wipe_1.wipe(this._h);
    	        wipe_1.wipe(this._pad);
    	        this._leftover = 0;
    	        this._fin = 0;
    	        this._finished = true; // mark as finished even if not
    	        return this;
    	    };
    	    return Poly1305;
    	}());
    	exports.Poly1305 = Poly1305;
    	/**
    	 * Returns 16-byte authenticator of data using a one-time 32-byte key.
    	 *
    	 * Important: key should be used for only one message, it should never repeat.
    	 */
    	function oneTimeAuth(key, data) {
    	    var h = new Poly1305(key);
    	    h.update(data);
    	    var digest = h.digest();
    	    h.clean();
    	    return digest;
    	}
    	exports.oneTimeAuth = oneTimeAuth;
    	/**
    	 * Returns true if two authenticators are 16-byte long and equal.
    	 * Uses contant-time comparison to avoid leaking timing information.
    	 */
    	function equal(a, b) {
    	    if (a.length !== exports.DIGEST_LENGTH || b.length !== exports.DIGEST_LENGTH) {
    	        return false;
    	    }
    	    return constant_time_1.equal(a, b);
    	}
    	exports.equal = equal;
    	
    } (poly1305));

    (function (exports) {
    	// Copyright (C) 2016 Dmitry Chestnykh
    	// MIT License. See LICENSE file for details.
    	Object.defineProperty(exports, "__esModule", { value: true });
    	var chacha_1 = chacha;
    	var poly1305_1 = poly1305;
    	var wipe_1 = wipe$1;
    	var binary_1 = binary;
    	var constant_time_1 = constantTime;
    	exports.KEY_LENGTH = 32;
    	exports.NONCE_LENGTH = 12;
    	exports.TAG_LENGTH = 16;
    	var ZEROS = new Uint8Array(16);
    	/**
    	 * ChaCha20-Poly1305 Authenticated Encryption with Associated Data.
    	 *
    	 * Defined in RFC7539.
    	 */
    	var ChaCha20Poly1305 = /** @class */ (function () {
    	    /**
    	     * Creates a new instance with the given 32-byte key.
    	     */
    	    function ChaCha20Poly1305(key) {
    	        this.nonceLength = exports.NONCE_LENGTH;
    	        this.tagLength = exports.TAG_LENGTH;
    	        if (key.length !== exports.KEY_LENGTH) {
    	            throw new Error("ChaCha20Poly1305 needs 32-byte key");
    	        }
    	        // Copy key.
    	        this._key = new Uint8Array(key);
    	    }
    	    /**
    	     * Encrypts and authenticates plaintext, authenticates associated data,
    	     * and returns sealed ciphertext, which includes authentication tag.
    	     *
    	     * RFC7539 specifies 12 bytes for nonce. It may be this 12-byte nonce
    	     * ("IV"), or full 16-byte counter (called "32-bit fixed-common part")
    	     * and nonce.
    	     *
    	     * If dst is given (it must be the size of plaintext + the size of tag
    	     * length) the result will be put into it. Dst and plaintext must not
    	     * overlap.
    	     */
    	    ChaCha20Poly1305.prototype.seal = function (nonce, plaintext, associatedData, dst) {
    	        if (nonce.length > 16) {
    	            throw new Error("ChaCha20Poly1305: incorrect nonce length");
    	        }
    	        // Allocate space for counter, and set nonce as last bytes of it.
    	        var counter = new Uint8Array(16);
    	        counter.set(nonce, counter.length - nonce.length);
    	        // Generate authentication key by taking first 32-bytes of stream.
    	        // We pass full counter, which has 12-byte nonce and 4-byte block counter,
    	        // and it will get incremented after generating the block, which is
    	        // exactly what we need: we only use the first 32 bytes of 64-byte
    	        // ChaCha block and discard the next 32 bytes.
    	        var authKey = new Uint8Array(32);
    	        chacha_1.stream(this._key, counter, authKey, 4);
    	        // Allocate space for sealed ciphertext.
    	        var resultLength = plaintext.length + this.tagLength;
    	        var result;
    	        if (dst) {
    	            if (dst.length !== resultLength) {
    	                throw new Error("ChaCha20Poly1305: incorrect destination length");
    	            }
    	            result = dst;
    	        }
    	        else {
    	            result = new Uint8Array(resultLength);
    	        }
    	        // Encrypt plaintext.
    	        chacha_1.streamXOR(this._key, counter, plaintext, result, 4);
    	        // Authenticate.
    	        // XXX: can "simplify" here: pass full result (which is already padded
    	        // due to zeroes prepared for tag), and ciphertext length instead of
    	        // subarray of result.
    	        this._authenticate(result.subarray(result.length - this.tagLength, result.length), authKey, result.subarray(0, result.length - this.tagLength), associatedData);
    	        // Cleanup.
    	        wipe_1.wipe(counter);
    	        return result;
    	    };
    	    /**
    	     * Authenticates sealed ciphertext (which includes authentication tag) and
    	     * associated data, decrypts ciphertext and returns decrypted plaintext.
    	     *
    	     * RFC7539 specifies 12 bytes for nonce. It may be this 12-byte nonce
    	     * ("IV"), or full 16-byte counter (called "32-bit fixed-common part")
    	     * and nonce.
    	     *
    	     * If authentication fails, it returns null.
    	     *
    	     * If dst is given (it must be of ciphertext length minus tag length),
    	     * the result will be put into it. Dst and plaintext must not overlap.
    	     */
    	    ChaCha20Poly1305.prototype.open = function (nonce, sealed, associatedData, dst) {
    	        if (nonce.length > 16) {
    	            throw new Error("ChaCha20Poly1305: incorrect nonce length");
    	        }
    	        // Sealed ciphertext should at least contain tag.
    	        if (sealed.length < this.tagLength) {
    	            // TODO(dchest): should we throw here instead?
    	            return null;
    	        }
    	        // Allocate space for counter, and set nonce as last bytes of it.
    	        var counter = new Uint8Array(16);
    	        counter.set(nonce, counter.length - nonce.length);
    	        // Generate authentication key by taking first 32-bytes of stream.
    	        var authKey = new Uint8Array(32);
    	        chacha_1.stream(this._key, counter, authKey, 4);
    	        // Authenticate.
    	        // XXX: can simplify and avoid allocation: since authenticate()
    	        // already allocates tag (from Poly1305.digest(), it can return)
    	        // it instead of copying to calculatedTag. But then in seal()
    	        // we'll need to copy it.
    	        var calculatedTag = new Uint8Array(this.tagLength);
    	        this._authenticate(calculatedTag, authKey, sealed.subarray(0, sealed.length - this.tagLength), associatedData);
    	        // Constant-time compare tags and return null if they differ.
    	        if (!constant_time_1.equal(calculatedTag, sealed.subarray(sealed.length - this.tagLength, sealed.length))) {
    	            return null;
    	        }
    	        // Allocate space for decrypted plaintext.
    	        var resultLength = sealed.length - this.tagLength;
    	        var result;
    	        if (dst) {
    	            if (dst.length !== resultLength) {
    	                throw new Error("ChaCha20Poly1305: incorrect destination length");
    	            }
    	            result = dst;
    	        }
    	        else {
    	            result = new Uint8Array(resultLength);
    	        }
    	        // Decrypt.
    	        chacha_1.streamXOR(this._key, counter, sealed.subarray(0, sealed.length - this.tagLength), result, 4);
    	        // Cleanup.
    	        wipe_1.wipe(counter);
    	        return result;
    	    };
    	    ChaCha20Poly1305.prototype.clean = function () {
    	        wipe_1.wipe(this._key);
    	        return this;
    	    };
    	    ChaCha20Poly1305.prototype._authenticate = function (tagOut, authKey, ciphertext, associatedData) {
    	        // Initialize Poly1305 with authKey.
    	        var h = new poly1305_1.Poly1305(authKey);
    	        // Authenticate padded associated data.
    	        if (associatedData) {
    	            h.update(associatedData);
    	            if (associatedData.length % 16 > 0) {
    	                h.update(ZEROS.subarray(associatedData.length % 16));
    	            }
    	        }
    	        // Authenticate padded ciphertext.
    	        h.update(ciphertext);
    	        if (ciphertext.length % 16 > 0) {
    	            h.update(ZEROS.subarray(ciphertext.length % 16));
    	        }
    	        // Authenticate length of associated data.
    	        // XXX: can avoid allocation here?
    	        var length = new Uint8Array(8);
    	        if (associatedData) {
    	            binary_1.writeUint64LE(associatedData.length, length);
    	        }
    	        h.update(length);
    	        // Authenticate length of ciphertext.
    	        binary_1.writeUint64LE(ciphertext.length, length);
    	        h.update(length);
    	        // Get tag and copy it into tagOut.
    	        var tag = h.digest();
    	        for (var i = 0; i < tag.length; i++) {
    	            tagOut[i] = tag[i];
    	        }
    	        // Cleanup.
    	        h.clean();
    	        wipe_1.wipe(tag);
    	        wipe_1.wipe(length);
    	    };
    	    return ChaCha20Poly1305;
    	}());
    	exports.ChaCha20Poly1305 = ChaCha20Poly1305;
    	
    } (chacha20poly1305));

    var hkdf = {};

    var hmac$1 = {};

    var hash$2 = {};

    // Copyright (C) 2016 Dmitry Chestnykh
    // MIT License. See LICENSE file for details.
    Object.defineProperty(hash$2, "__esModule", { value: true });
    function isSerializableHash(h) {
        return (typeof h.saveState !== "undefined" &&
            typeof h.restoreState !== "undefined" &&
            typeof h.cleanSavedState !== "undefined");
    }
    hash$2.isSerializableHash = isSerializableHash;

    // Copyright (C) 2016 Dmitry Chestnykh
    // MIT License. See LICENSE file for details.
    Object.defineProperty(hmac$1, "__esModule", { value: true });
    /**
     * Package hmac implements HMAC algorithm.
     */
    var hash_1 = hash$2;
    var constant_time_1 = constantTime;
    var wipe_1$2 = wipe$1;
    /**
     *  HMAC implements hash-based message authentication algorithm.
     */
    var HMAC = /** @class */ (function () {
        /**
         * Constructs a new HMAC with the given Hash and secret key.
         */
        function HMAC(hash, key) {
            this._finished = false; // true if HMAC was finalized
            // Initialize inner and outer hashes.
            this._inner = new hash();
            this._outer = new hash();
            // Set block and digest sizes for this HMAC
            // instance to values from the hash.
            this.blockSize = this._outer.blockSize;
            this.digestLength = this._outer.digestLength;
            // Pad temporary stores a key (or its hash) padded with zeroes.
            var pad = new Uint8Array(this.blockSize);
            if (key.length > this.blockSize) {
                // If key is bigger than hash block size, it must be
                // hashed and this hash is used as a key instead.
                this._inner.update(key).finish(pad).clean();
            }
            else {
                // Otherwise, copy the key into pad.
                pad.set(key);
            }
            // Now two different keys are derived from padded key
            // by xoring a different byte value to each.
            // To make inner hash key, xor byte 0x36 into pad.
            for (var i = 0; i < pad.length; i++) {
                pad[i] ^= 0x36;
            }
            // Update inner hash with the result.
            this._inner.update(pad);
            // To make outer hash key, xor byte 0x5c into pad.
            // But since we already xored 0x36 there, we must
            // first undo this by xoring it again.
            for (var i = 0; i < pad.length; i++) {
                pad[i] ^= 0x36 ^ 0x5c;
            }
            // Update outer hash with the result.
            this._outer.update(pad);
            // Save states of both hashes, so that we can quickly restore
            // them later in reset() without the need to remember the actual
            // key and perform this initialization again.
            if (hash_1.isSerializableHash(this._inner) && hash_1.isSerializableHash(this._outer)) {
                this._innerKeyedState = this._inner.saveState();
                this._outerKeyedState = this._outer.saveState();
            }
            // Clean pad.
            wipe_1$2.wipe(pad);
        }
        /**
         * Returns HMAC state to the state initialized with key
         * to make it possible to run HMAC over the other data with the same
         * key without creating a new instance.
         */
        HMAC.prototype.reset = function () {
            if (!hash_1.isSerializableHash(this._inner) || !hash_1.isSerializableHash(this._outer)) {
                throw new Error("hmac: can't reset() because hash doesn't implement restoreState()");
            }
            // Restore keyed states of inner and outer hashes.
            this._inner.restoreState(this._innerKeyedState);
            this._outer.restoreState(this._outerKeyedState);
            this._finished = false;
            return this;
        };
        /**
         * Cleans HMAC state.
         */
        HMAC.prototype.clean = function () {
            if (hash_1.isSerializableHash(this._inner)) {
                this._inner.cleanSavedState(this._innerKeyedState);
            }
            if (hash_1.isSerializableHash(this._outer)) {
                this._outer.cleanSavedState(this._outerKeyedState);
            }
            this._inner.clean();
            this._outer.clean();
        };
        /**
         * Updates state with provided data.
         */
        HMAC.prototype.update = function (data) {
            this._inner.update(data);
            return this;
        };
        /**
         * Finalizes HMAC and puts the result in out.
         */
        HMAC.prototype.finish = function (out) {
            if (this._finished) {
                // If HMAC was finalized, outer hash is also finalized,
                // so it produces the same digest it produced when it
                // was finalized.
                this._outer.finish(out);
                return this;
            }
            // Finalize inner hash and store the result temporarily.
            this._inner.finish(out);
            // Update outer hash with digest of inner hash and and finalize it.
            this._outer.update(out.subarray(0, this.digestLength)).finish(out);
            this._finished = true;
            return this;
        };
        /**
         * Returns the computed message authentication code.
         */
        HMAC.prototype.digest = function () {
            var out = new Uint8Array(this.digestLength);
            this.finish(out);
            return out;
        };
        /**
         * Saves HMAC state.
         * This function is needed for PBKDF2 optimization.
         */
        HMAC.prototype.saveState = function () {
            if (!hash_1.isSerializableHash(this._inner)) {
                throw new Error("hmac: can't saveState() because hash doesn't implement it");
            }
            return this._inner.saveState();
        };
        HMAC.prototype.restoreState = function (savedState) {
            if (!hash_1.isSerializableHash(this._inner) || !hash_1.isSerializableHash(this._outer)) {
                throw new Error("hmac: can't restoreState() because hash doesn't implement it");
            }
            this._inner.restoreState(savedState);
            this._outer.restoreState(this._outerKeyedState);
            this._finished = false;
            return this;
        };
        HMAC.prototype.cleanSavedState = function (savedState) {
            if (!hash_1.isSerializableHash(this._inner)) {
                throw new Error("hmac: can't cleanSavedState() because hash doesn't implement it");
            }
            this._inner.cleanSavedState(savedState);
        };
        return HMAC;
    }());
    hmac$1.HMAC = HMAC;
    /**
     * Returns HMAC using the given hash constructor for the key over data.
     */
    function hmac(hash, key, data) {
        var h = new HMAC(hash, key);
        h.update(data);
        var digest = h.digest();
        h.clean();
        return digest;
    }
    hmac$1.hmac = hmac;
    /**
     * Returns true if two HMAC digests are equal.
     * Uses constant-time comparison to avoid leaking timing information.
     *
     * Example:
     *
     *    const receivedDigest = ...
     *    const realDigest = hmac(SHA256, key, data);
     *    if (!equal(receivedDigest, realDigest)) {
     *        throw new Error("Authentication error");
     *    }
     */
    hmac$1.equal = constant_time_1.equal;

    // Copyright (C) 2016 Dmitry Chestnykh
    // MIT License. See LICENSE file for details.
    Object.defineProperty(hkdf, "__esModule", { value: true });
    var hmac_1 = hmac$1;
    var wipe_1$1 = wipe$1;
    /**
     * HMAC-based Extract-and-Expand Key Derivation Function.
     *
     * Implements HKDF from RFC5869.
     *
     * Expands the given master key with salt and info into
     * a limited stream of key material.
     */
    var HKDF = /** @class */ (function () {
        /**
         * Create a new HKDF instance for the given hash function
         * with the master key, optional salt, and info.
         *
         * - Master key is a high-entropy secret key (not a password).
         * - Salt is a non-secret random value.
         * - Info is application- and/or context-specific information.
         */
        function HKDF(hash, key, salt, info) {
            if (salt === void 0) { salt = new Uint8Array(0); }
            this._counter = new Uint8Array(1); // starts with zero
            this._hash = hash;
            this._info = info;
            // HKDF-Extract uses salt as HMAC key, and key as data.
            var okm = hmac_1.hmac(this._hash, salt, key);
            // Initialize HMAC for expanding with extracted key.
            this._hmac = new hmac_1.HMAC(hash, okm);
            // Allocate buffer.
            this._buffer = new Uint8Array(this._hmac.digestLength);
            this._bufpos = this._buffer.length;
        }
        // Fill buffer with new block of HKDF-Extract output.
        HKDF.prototype._fillBuffer = function () {
            // Increment counter.
            this._counter[0]++;
            var ctr = this._counter[0];
            // Check if counter overflowed.
            if (ctr === 0) {
                throw new Error("hkdf: cannot expand more");
            }
            // Prepare HMAC instance for new data with old key.
            this._hmac.reset();
            // Hash in previous output if it was generated
            // (i.e. counter is greater than 1).
            if (ctr > 1) {
                this._hmac.update(this._buffer);
            }
            // Hash in info if it exists.
            if (this._info) {
                this._hmac.update(this._info);
            }
            // Hash in the counter.
            this._hmac.update(this._counter);
            // Output result to buffer and clean HMAC instance.
            this._hmac.finish(this._buffer);
            // Reset buffer position.
            this._bufpos = 0;
        };
        /**
         * Expand returns next key material of the given length.
         *
         * It throws if expansion limit is reached (which is
         * 254 digests of the underlying HMAC function).
         */
        HKDF.prototype.expand = function (length) {
            var out = new Uint8Array(length);
            for (var i = 0; i < out.length; i++) {
                if (this._bufpos === this._buffer.length) {
                    this._fillBuffer();
                }
                out[i] = this._buffer[this._bufpos++];
            }
            return out;
        };
        HKDF.prototype.clean = function () {
            this._hmac.clean();
            wipe_1$1.wipe(this._buffer);
            wipe_1$1.wipe(this._counter);
            this._bufpos = 0;
        };
        return HKDF;
    }());
    var HKDF_1 = hkdf.HKDF = HKDF;

    var random = {};

    var system = {};

    var browser$5 = {};

    // Copyright (C) 2016 Dmitry Chestnykh
    // MIT License. See LICENSE file for details.
    Object.defineProperty(browser$5, "__esModule", { value: true });
    browser$5.BrowserRandomSource = void 0;
    const QUOTA = 65536;
    class BrowserRandomSource {
        constructor() {
            this.isAvailable = false;
            this.isInstantiated = false;
            const browserCrypto = typeof self !== 'undefined'
                ? (self.crypto || self.msCrypto) // IE11 has msCrypto
                : null;
            if (browserCrypto && browserCrypto.getRandomValues !== undefined) {
                this._crypto = browserCrypto;
                this.isAvailable = true;
                this.isInstantiated = true;
            }
        }
        randomBytes(length) {
            if (!this.isAvailable || !this._crypto) {
                throw new Error("Browser random byte generator is not available.");
            }
            const out = new Uint8Array(length);
            for (let i = 0; i < out.length; i += QUOTA) {
                this._crypto.getRandomValues(out.subarray(i, i + Math.min(out.length - i, QUOTA)));
            }
            return out;
        }
    }
    browser$5.BrowserRandomSource = BrowserRandomSource;

    function commonjsRequire(path) {
    	throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
    }

    var node = {};

    var _polyfillNode_crypto = {};

    var _polyfillNode_crypto$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        default: _polyfillNode_crypto
    });

    var require$$1$3 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_crypto$1);

    // Copyright (C) 2016 Dmitry Chestnykh
    // MIT License. See LICENSE file for details.
    Object.defineProperty(node, "__esModule", { value: true });
    node.NodeRandomSource = void 0;
    const wipe_1 = wipe$1;
    class NodeRandomSource {
        constructor() {
            this.isAvailable = false;
            this.isInstantiated = false;
            if (typeof commonjsRequire !== "undefined") {
                const nodeCrypto = require$$1$3;
                if (nodeCrypto && nodeCrypto.randomBytes) {
                    this._crypto = nodeCrypto;
                    this.isAvailable = true;
                    this.isInstantiated = true;
                }
            }
        }
        randomBytes(length) {
            if (!this.isAvailable || !this._crypto) {
                throw new Error("Node.js random byte generator is not available.");
            }
            // Get random bytes (result is Buffer).
            let buffer = this._crypto.randomBytes(length);
            // Make sure we got the length that we requested.
            if (buffer.length !== length) {
                throw new Error("NodeRandomSource: got fewer bytes than requested");
            }
            // Allocate output array.
            const out = new Uint8Array(length);
            // Copy bytes from buffer to output.
            for (let i = 0; i < out.length; i++) {
                out[i] = buffer[i];
            }
            // Cleanup.
            (0, wipe_1.wipe)(buffer);
            return out;
        }
    }
    node.NodeRandomSource = NodeRandomSource;

    // Copyright (C) 2016 Dmitry Chestnykh
    // MIT License. See LICENSE file for details.
    Object.defineProperty(system, "__esModule", { value: true });
    system.SystemRandomSource = void 0;
    const browser_1 = browser$5;
    const node_1 = node;
    class SystemRandomSource {
        constructor() {
            this.isAvailable = false;
            this.name = "";
            // Try browser.
            this._source = new browser_1.BrowserRandomSource();
            if (this._source.isAvailable) {
                this.isAvailable = true;
                this.name = "Browser";
                return;
            }
            // If no browser source, try Node.
            this._source = new node_1.NodeRandomSource();
            if (this._source.isAvailable) {
                this.isAvailable = true;
                this.name = "Node";
                return;
            }
            // No sources, we're out of options.
        }
        randomBytes(length) {
            if (!this.isAvailable) {
                throw new Error("System random byte generator is not available.");
            }
            return this._source.randomBytes(length);
        }
    }
    system.SystemRandomSource = SystemRandomSource;

    (function (exports) {
    	// Copyright (C) 2016 Dmitry Chestnykh
    	// MIT License. See LICENSE file for details.
    	Object.defineProperty(exports, "__esModule", { value: true });
    	exports.randomStringForEntropy = exports.randomString = exports.randomUint32 = exports.randomBytes = exports.defaultRandomSource = void 0;
    	const system_1 = system;
    	const binary_1 = binary;
    	const wipe_1 = wipe$1;
    	exports.defaultRandomSource = new system_1.SystemRandomSource();
    	function randomBytes(length, prng = exports.defaultRandomSource) {
    	    return prng.randomBytes(length);
    	}
    	exports.randomBytes = randomBytes;
    	/**
    	 * Returns a uniformly random unsigned 32-bit integer.
    	 */
    	function randomUint32(prng = exports.defaultRandomSource) {
    	    // Generate 4-byte random buffer.
    	    const buf = randomBytes(4, prng);
    	    // Convert bytes from buffer into a 32-bit integer.
    	    // It's not important which byte order to use, since
    	    // the result is random.
    	    const result = (0, binary_1.readUint32LE)(buf);
    	    // Clean the buffer.
    	    (0, wipe_1.wipe)(buf);
    	    return result;
    	}
    	exports.randomUint32 = randomUint32;
    	/** 62 alphanumeric characters for default charset of randomString() */
    	const ALPHANUMERIC = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
    	/**
    	 * Returns a uniform random string of the given length
    	 * with characters from the given charset.
    	 *
    	 * Charset must not have more than 256 characters.
    	 *
    	 * Default charset generates case-sensitive alphanumeric
    	 * strings (0-9, A-Z, a-z).
    	 */
    	function randomString(length, charset = ALPHANUMERIC, prng = exports.defaultRandomSource) {
    	    if (charset.length < 2) {
    	        throw new Error("randomString charset is too short");
    	    }
    	    if (charset.length > 256) {
    	        throw new Error("randomString charset is too long");
    	    }
    	    let out = '';
    	    const charsLen = charset.length;
    	    const maxByte = 256 - (256 % charsLen);
    	    while (length > 0) {
    	        const buf = randomBytes(Math.ceil(length * 256 / maxByte), prng);
    	        for (let i = 0; i < buf.length && length > 0; i++) {
    	            const randomByte = buf[i];
    	            if (randomByte < maxByte) {
    	                out += charset.charAt(randomByte % charsLen);
    	                length--;
    	            }
    	        }
    	        (0, wipe_1.wipe)(buf);
    	    }
    	    return out;
    	}
    	exports.randomString = randomString;
    	/**
    	 * Returns uniform random string containing at least the given
    	 * number of bits of entropy.
    	 *
    	 * For example, randomStringForEntropy(128) will return a 22-character
    	 * alphanumeric string, while randomStringForEntropy(128, "0123456789")
    	 * will return a 39-character numeric string, both will contain at
    	 * least 128 bits of entropy.
    	 *
    	 * Default charset generates case-sensitive alphanumeric
    	 * strings (0-9, A-Z, a-z).
    	 */
    	function randomStringForEntropy(bits, charset = ALPHANUMERIC, prng = exports.defaultRandomSource) {
    	    const length = Math.ceil(bits / (Math.log(charset.length) / Math.LN2));
    	    return randomString(length, charset, prng);
    	}
    	exports.randomStringForEntropy = randomStringForEntropy;
    	
    } (random));

    var sha256$1 = {};

    (function (exports) {
    	// Copyright (C) 2016 Dmitry Chestnykh
    	// MIT License. See LICENSE file for details.
    	Object.defineProperty(exports, "__esModule", { value: true });
    	var binary_1 = binary;
    	var wipe_1 = wipe$1;
    	exports.DIGEST_LENGTH = 32;
    	exports.BLOCK_SIZE = 64;
    	/**
    	 * SHA2-256 cryptographic hash algorithm.
    	 */
    	var SHA256 = /** @class */ (function () {
    	    function SHA256() {
    	        /** Length of hash output */
    	        this.digestLength = exports.DIGEST_LENGTH;
    	        /** Block size */
    	        this.blockSize = exports.BLOCK_SIZE;
    	        // Note: Int32Array is used instead of Uint32Array for performance reasons.
    	        this._state = new Int32Array(8); // hash state
    	        this._temp = new Int32Array(64); // temporary state
    	        this._buffer = new Uint8Array(128); // buffer for data to hash
    	        this._bufferLength = 0; // number of bytes in buffer
    	        this._bytesHashed = 0; // number of total bytes hashed
    	        this._finished = false; // indicates whether the hash was finalized
    	        this.reset();
    	    }
    	    SHA256.prototype._initState = function () {
    	        this._state[0] = 0x6a09e667;
    	        this._state[1] = 0xbb67ae85;
    	        this._state[2] = 0x3c6ef372;
    	        this._state[3] = 0xa54ff53a;
    	        this._state[4] = 0x510e527f;
    	        this._state[5] = 0x9b05688c;
    	        this._state[6] = 0x1f83d9ab;
    	        this._state[7] = 0x5be0cd19;
    	    };
    	    /**
    	     * Resets hash state making it possible
    	     * to re-use this instance to hash other data.
    	     */
    	    SHA256.prototype.reset = function () {
    	        this._initState();
    	        this._bufferLength = 0;
    	        this._bytesHashed = 0;
    	        this._finished = false;
    	        return this;
    	    };
    	    /**
    	     * Cleans internal buffers and resets hash state.
    	     */
    	    SHA256.prototype.clean = function () {
    	        wipe_1.wipe(this._buffer);
    	        wipe_1.wipe(this._temp);
    	        this.reset();
    	    };
    	    /**
    	     * Updates hash state with the given data.
    	     *
    	     * Throws error when trying to update already finalized hash:
    	     * instance must be reset to update it again.
    	     */
    	    SHA256.prototype.update = function (data, dataLength) {
    	        if (dataLength === void 0) { dataLength = data.length; }
    	        if (this._finished) {
    	            throw new Error("SHA256: can't update because hash was finished.");
    	        }
    	        var dataPos = 0;
    	        this._bytesHashed += dataLength;
    	        if (this._bufferLength > 0) {
    	            while (this._bufferLength < this.blockSize && dataLength > 0) {
    	                this._buffer[this._bufferLength++] = data[dataPos++];
    	                dataLength--;
    	            }
    	            if (this._bufferLength === this.blockSize) {
    	                hashBlocks(this._temp, this._state, this._buffer, 0, this.blockSize);
    	                this._bufferLength = 0;
    	            }
    	        }
    	        if (dataLength >= this.blockSize) {
    	            dataPos = hashBlocks(this._temp, this._state, data, dataPos, dataLength);
    	            dataLength %= this.blockSize;
    	        }
    	        while (dataLength > 0) {
    	            this._buffer[this._bufferLength++] = data[dataPos++];
    	            dataLength--;
    	        }
    	        return this;
    	    };
    	    /**
    	     * Finalizes hash state and puts hash into out.
    	     * If hash was already finalized, puts the same value.
    	     */
    	    SHA256.prototype.finish = function (out) {
    	        if (!this._finished) {
    	            var bytesHashed = this._bytesHashed;
    	            var left = this._bufferLength;
    	            var bitLenHi = (bytesHashed / 0x20000000) | 0;
    	            var bitLenLo = bytesHashed << 3;
    	            var padLength = (bytesHashed % 64 < 56) ? 64 : 128;
    	            this._buffer[left] = 0x80;
    	            for (var i = left + 1; i < padLength - 8; i++) {
    	                this._buffer[i] = 0;
    	            }
    	            binary_1.writeUint32BE(bitLenHi, this._buffer, padLength - 8);
    	            binary_1.writeUint32BE(bitLenLo, this._buffer, padLength - 4);
    	            hashBlocks(this._temp, this._state, this._buffer, 0, padLength);
    	            this._finished = true;
    	        }
    	        for (var i = 0; i < this.digestLength / 4; i++) {
    	            binary_1.writeUint32BE(this._state[i], out, i * 4);
    	        }
    	        return this;
    	    };
    	    /**
    	     * Returns the final hash digest.
    	     */
    	    SHA256.prototype.digest = function () {
    	        var out = new Uint8Array(this.digestLength);
    	        this.finish(out);
    	        return out;
    	    };
    	    /**
    	     * Function useful for HMAC/PBKDF2 optimization.
    	     * Returns hash state to be used with restoreState().
    	     * Only chain value is saved, not buffers or other
    	     * state variables.
    	     */
    	    SHA256.prototype.saveState = function () {
    	        if (this._finished) {
    	            throw new Error("SHA256: cannot save finished state");
    	        }
    	        return {
    	            state: new Int32Array(this._state),
    	            buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : undefined,
    	            bufferLength: this._bufferLength,
    	            bytesHashed: this._bytesHashed
    	        };
    	    };
    	    /**
    	     * Function useful for HMAC/PBKDF2 optimization.
    	     * Restores state saved by saveState() and sets bytesHashed
    	     * to the given value.
    	     */
    	    SHA256.prototype.restoreState = function (savedState) {
    	        this._state.set(savedState.state);
    	        this._bufferLength = savedState.bufferLength;
    	        if (savedState.buffer) {
    	            this._buffer.set(savedState.buffer);
    	        }
    	        this._bytesHashed = savedState.bytesHashed;
    	        this._finished = false;
    	        return this;
    	    };
    	    /**
    	     * Cleans state returned by saveState().
    	     */
    	    SHA256.prototype.cleanSavedState = function (savedState) {
    	        wipe_1.wipe(savedState.state);
    	        if (savedState.buffer) {
    	            wipe_1.wipe(savedState.buffer);
    	        }
    	        savedState.bufferLength = 0;
    	        savedState.bytesHashed = 0;
    	    };
    	    return SHA256;
    	}());
    	exports.SHA256 = SHA256;
    	// Constants
    	var K = new Int32Array([
    	    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b,
    	    0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01,
    	    0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7,
    	    0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
    	    0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152,
    	    0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147,
    	    0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc,
    	    0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
    	    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819,
    	    0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08,
    	    0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f,
    	    0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
    	    0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
    	]);
    	function hashBlocks(w, v, p, pos, len) {
    	    while (len >= 64) {
    	        var a = v[0];
    	        var b = v[1];
    	        var c = v[2];
    	        var d = v[3];
    	        var e = v[4];
    	        var f = v[5];
    	        var g = v[6];
    	        var h = v[7];
    	        for (var i = 0; i < 16; i++) {
    	            var j = pos + i * 4;
    	            w[i] = binary_1.readUint32BE(p, j);
    	        }
    	        for (var i = 16; i < 64; i++) {
    	            var u = w[i - 2];
    	            var t1 = (u >>> 17 | u << (32 - 17)) ^ (u >>> 19 | u << (32 - 19)) ^ (u >>> 10);
    	            u = w[i - 15];
    	            var t2 = (u >>> 7 | u << (32 - 7)) ^ (u >>> 18 | u << (32 - 18)) ^ (u >>> 3);
    	            w[i] = (t1 + w[i - 7] | 0) + (t2 + w[i - 16] | 0);
    	        }
    	        for (var i = 0; i < 64; i++) {
    	            var t1 = (((((e >>> 6 | e << (32 - 6)) ^ (e >>> 11 | e << (32 - 11)) ^
    	                (e >>> 25 | e << (32 - 25))) + ((e & f) ^ (~e & g))) | 0) +
    	                ((h + ((K[i] + w[i]) | 0)) | 0)) | 0;
    	            var t2 = (((a >>> 2 | a << (32 - 2)) ^ (a >>> 13 | a << (32 - 13)) ^
    	                (a >>> 22 | a << (32 - 22))) + ((a & b) ^ (a & c) ^ (b & c))) | 0;
    	            h = g;
    	            g = f;
    	            f = e;
    	            e = (d + t1) | 0;
    	            d = c;
    	            c = b;
    	            b = a;
    	            a = (t1 + t2) | 0;
    	        }
    	        v[0] += a;
    	        v[1] += b;
    	        v[2] += c;
    	        v[3] += d;
    	        v[4] += e;
    	        v[5] += f;
    	        v[6] += g;
    	        v[7] += h;
    	        pos += 64;
    	        len -= 64;
    	    }
    	    return pos;
    	}
    	function hash(data) {
    	    var h = new SHA256();
    	    h.update(data);
    	    var digest = h.digest();
    	    h.clean();
    	    return digest;
    	}
    	exports.hash = hash;
    	
    } (sha256$1));

    var x25519 = {};

    (function (exports) {
    	// Copyright (C) 2016 Dmitry Chestnykh
    	// MIT License. See LICENSE file for details.
    	Object.defineProperty(exports, "__esModule", { value: true });
    	exports.sharedKey = exports.generateKeyPair = exports.generateKeyPairFromSeed = exports.scalarMultBase = exports.scalarMult = exports.SHARED_KEY_LENGTH = exports.SECRET_KEY_LENGTH = exports.PUBLIC_KEY_LENGTH = void 0;
    	/**
    	 * Package x25519 implements X25519 key agreement.
    	 */
    	const random_1 = random;
    	const wipe_1 = wipe$1;
    	exports.PUBLIC_KEY_LENGTH = 32;
    	exports.SECRET_KEY_LENGTH = 32;
    	exports.SHARED_KEY_LENGTH = 32;
    	// Returns new zero-filled 16-element GF (Float64Array).
    	// If passed an array of numbers, prefills the returned
    	// array with them.
    	//
    	// We use Float64Array, because we need 48-bit numbers
    	// for this implementation.
    	function gf(init) {
    	    const r = new Float64Array(16);
    	    if (init) {
    	        for (let i = 0; i < init.length; i++) {
    	            r[i] = init[i];
    	        }
    	    }
    	    return r;
    	}
    	// Base point.
    	const _9 = new Uint8Array(32);
    	_9[0] = 9;
    	const _121665 = gf([0xdb41, 1]);
    	function car25519(o) {
    	    let c = 1;
    	    for (let i = 0; i < 16; i++) {
    	        let v = o[i] + c + 65535;
    	        c = Math.floor(v / 65536);
    	        o[i] = v - c * 65536;
    	    }
    	    o[0] += c - 1 + 37 * (c - 1);
    	}
    	function sel25519(p, q, b) {
    	    const c = ~(b - 1);
    	    for (let i = 0; i < 16; i++) {
    	        const t = c & (p[i] ^ q[i]);
    	        p[i] ^= t;
    	        q[i] ^= t;
    	    }
    	}
    	function pack25519(o, n) {
    	    const m = gf();
    	    const t = gf();
    	    for (let i = 0; i < 16; i++) {
    	        t[i] = n[i];
    	    }
    	    car25519(t);
    	    car25519(t);
    	    car25519(t);
    	    for (let j = 0; j < 2; j++) {
    	        m[0] = t[0] - 0xffed;
    	        for (let i = 1; i < 15; i++) {
    	            m[i] = t[i] - 0xffff - ((m[i - 1] >> 16) & 1);
    	            m[i - 1] &= 0xffff;
    	        }
    	        m[15] = t[15] - 0x7fff - ((m[14] >> 16) & 1);
    	        const b = (m[15] >> 16) & 1;
    	        m[14] &= 0xffff;
    	        sel25519(t, m, 1 - b);
    	    }
    	    for (let i = 0; i < 16; i++) {
    	        o[2 * i] = t[i] & 0xff;
    	        o[2 * i + 1] = t[i] >> 8;
    	    }
    	}
    	function unpack25519(o, n) {
    	    for (let i = 0; i < 16; i++) {
    	        o[i] = n[2 * i] + (n[2 * i + 1] << 8);
    	    }
    	    o[15] &= 0x7fff;
    	}
    	function add(o, a, b) {
    	    for (let i = 0; i < 16; i++) {
    	        o[i] = a[i] + b[i];
    	    }
    	}
    	function sub(o, a, b) {
    	    for (let i = 0; i < 16; i++) {
    	        o[i] = a[i] - b[i];
    	    }
    	}
    	function mul(o, a, b) {
    	    let v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
    	    v = a[0];
    	    t0 += v * b0;
    	    t1 += v * b1;
    	    t2 += v * b2;
    	    t3 += v * b3;
    	    t4 += v * b4;
    	    t5 += v * b5;
    	    t6 += v * b6;
    	    t7 += v * b7;
    	    t8 += v * b8;
    	    t9 += v * b9;
    	    t10 += v * b10;
    	    t11 += v * b11;
    	    t12 += v * b12;
    	    t13 += v * b13;
    	    t14 += v * b14;
    	    t15 += v * b15;
    	    v = a[1];
    	    t1 += v * b0;
    	    t2 += v * b1;
    	    t3 += v * b2;
    	    t4 += v * b3;
    	    t5 += v * b4;
    	    t6 += v * b5;
    	    t7 += v * b6;
    	    t8 += v * b7;
    	    t9 += v * b8;
    	    t10 += v * b9;
    	    t11 += v * b10;
    	    t12 += v * b11;
    	    t13 += v * b12;
    	    t14 += v * b13;
    	    t15 += v * b14;
    	    t16 += v * b15;
    	    v = a[2];
    	    t2 += v * b0;
    	    t3 += v * b1;
    	    t4 += v * b2;
    	    t5 += v * b3;
    	    t6 += v * b4;
    	    t7 += v * b5;
    	    t8 += v * b6;
    	    t9 += v * b7;
    	    t10 += v * b8;
    	    t11 += v * b9;
    	    t12 += v * b10;
    	    t13 += v * b11;
    	    t14 += v * b12;
    	    t15 += v * b13;
    	    t16 += v * b14;
    	    t17 += v * b15;
    	    v = a[3];
    	    t3 += v * b0;
    	    t4 += v * b1;
    	    t5 += v * b2;
    	    t6 += v * b3;
    	    t7 += v * b4;
    	    t8 += v * b5;
    	    t9 += v * b6;
    	    t10 += v * b7;
    	    t11 += v * b8;
    	    t12 += v * b9;
    	    t13 += v * b10;
    	    t14 += v * b11;
    	    t15 += v * b12;
    	    t16 += v * b13;
    	    t17 += v * b14;
    	    t18 += v * b15;
    	    v = a[4];
    	    t4 += v * b0;
    	    t5 += v * b1;
    	    t6 += v * b2;
    	    t7 += v * b3;
    	    t8 += v * b4;
    	    t9 += v * b5;
    	    t10 += v * b6;
    	    t11 += v * b7;
    	    t12 += v * b8;
    	    t13 += v * b9;
    	    t14 += v * b10;
    	    t15 += v * b11;
    	    t16 += v * b12;
    	    t17 += v * b13;
    	    t18 += v * b14;
    	    t19 += v * b15;
    	    v = a[5];
    	    t5 += v * b0;
    	    t6 += v * b1;
    	    t7 += v * b2;
    	    t8 += v * b3;
    	    t9 += v * b4;
    	    t10 += v * b5;
    	    t11 += v * b6;
    	    t12 += v * b7;
    	    t13 += v * b8;
    	    t14 += v * b9;
    	    t15 += v * b10;
    	    t16 += v * b11;
    	    t17 += v * b12;
    	    t18 += v * b13;
    	    t19 += v * b14;
    	    t20 += v * b15;
    	    v = a[6];
    	    t6 += v * b0;
    	    t7 += v * b1;
    	    t8 += v * b2;
    	    t9 += v * b3;
    	    t10 += v * b4;
    	    t11 += v * b5;
    	    t12 += v * b6;
    	    t13 += v * b7;
    	    t14 += v * b8;
    	    t15 += v * b9;
    	    t16 += v * b10;
    	    t17 += v * b11;
    	    t18 += v * b12;
    	    t19 += v * b13;
    	    t20 += v * b14;
    	    t21 += v * b15;
    	    v = a[7];
    	    t7 += v * b0;
    	    t8 += v * b1;
    	    t9 += v * b2;
    	    t10 += v * b3;
    	    t11 += v * b4;
    	    t12 += v * b5;
    	    t13 += v * b6;
    	    t14 += v * b7;
    	    t15 += v * b8;
    	    t16 += v * b9;
    	    t17 += v * b10;
    	    t18 += v * b11;
    	    t19 += v * b12;
    	    t20 += v * b13;
    	    t21 += v * b14;
    	    t22 += v * b15;
    	    v = a[8];
    	    t8 += v * b0;
    	    t9 += v * b1;
    	    t10 += v * b2;
    	    t11 += v * b3;
    	    t12 += v * b4;
    	    t13 += v * b5;
    	    t14 += v * b6;
    	    t15 += v * b7;
    	    t16 += v * b8;
    	    t17 += v * b9;
    	    t18 += v * b10;
    	    t19 += v * b11;
    	    t20 += v * b12;
    	    t21 += v * b13;
    	    t22 += v * b14;
    	    t23 += v * b15;
    	    v = a[9];
    	    t9 += v * b0;
    	    t10 += v * b1;
    	    t11 += v * b2;
    	    t12 += v * b3;
    	    t13 += v * b4;
    	    t14 += v * b5;
    	    t15 += v * b6;
    	    t16 += v * b7;
    	    t17 += v * b8;
    	    t18 += v * b9;
    	    t19 += v * b10;
    	    t20 += v * b11;
    	    t21 += v * b12;
    	    t22 += v * b13;
    	    t23 += v * b14;
    	    t24 += v * b15;
    	    v = a[10];
    	    t10 += v * b0;
    	    t11 += v * b1;
    	    t12 += v * b2;
    	    t13 += v * b3;
    	    t14 += v * b4;
    	    t15 += v * b5;
    	    t16 += v * b6;
    	    t17 += v * b7;
    	    t18 += v * b8;
    	    t19 += v * b9;
    	    t20 += v * b10;
    	    t21 += v * b11;
    	    t22 += v * b12;
    	    t23 += v * b13;
    	    t24 += v * b14;
    	    t25 += v * b15;
    	    v = a[11];
    	    t11 += v * b0;
    	    t12 += v * b1;
    	    t13 += v * b2;
    	    t14 += v * b3;
    	    t15 += v * b4;
    	    t16 += v * b5;
    	    t17 += v * b6;
    	    t18 += v * b7;
    	    t19 += v * b8;
    	    t20 += v * b9;
    	    t21 += v * b10;
    	    t22 += v * b11;
    	    t23 += v * b12;
    	    t24 += v * b13;
    	    t25 += v * b14;
    	    t26 += v * b15;
    	    v = a[12];
    	    t12 += v * b0;
    	    t13 += v * b1;
    	    t14 += v * b2;
    	    t15 += v * b3;
    	    t16 += v * b4;
    	    t17 += v * b5;
    	    t18 += v * b6;
    	    t19 += v * b7;
    	    t20 += v * b8;
    	    t21 += v * b9;
    	    t22 += v * b10;
    	    t23 += v * b11;
    	    t24 += v * b12;
    	    t25 += v * b13;
    	    t26 += v * b14;
    	    t27 += v * b15;
    	    v = a[13];
    	    t13 += v * b0;
    	    t14 += v * b1;
    	    t15 += v * b2;
    	    t16 += v * b3;
    	    t17 += v * b4;
    	    t18 += v * b5;
    	    t19 += v * b6;
    	    t20 += v * b7;
    	    t21 += v * b8;
    	    t22 += v * b9;
    	    t23 += v * b10;
    	    t24 += v * b11;
    	    t25 += v * b12;
    	    t26 += v * b13;
    	    t27 += v * b14;
    	    t28 += v * b15;
    	    v = a[14];
    	    t14 += v * b0;
    	    t15 += v * b1;
    	    t16 += v * b2;
    	    t17 += v * b3;
    	    t18 += v * b4;
    	    t19 += v * b5;
    	    t20 += v * b6;
    	    t21 += v * b7;
    	    t22 += v * b8;
    	    t23 += v * b9;
    	    t24 += v * b10;
    	    t25 += v * b11;
    	    t26 += v * b12;
    	    t27 += v * b13;
    	    t28 += v * b14;
    	    t29 += v * b15;
    	    v = a[15];
    	    t15 += v * b0;
    	    t16 += v * b1;
    	    t17 += v * b2;
    	    t18 += v * b3;
    	    t19 += v * b4;
    	    t20 += v * b5;
    	    t21 += v * b6;
    	    t22 += v * b7;
    	    t23 += v * b8;
    	    t24 += v * b9;
    	    t25 += v * b10;
    	    t26 += v * b11;
    	    t27 += v * b12;
    	    t28 += v * b13;
    	    t29 += v * b14;
    	    t30 += v * b15;
    	    t0 += 38 * t16;
    	    t1 += 38 * t17;
    	    t2 += 38 * t18;
    	    t3 += 38 * t19;
    	    t4 += 38 * t20;
    	    t5 += 38 * t21;
    	    t6 += 38 * t22;
    	    t7 += 38 * t23;
    	    t8 += 38 * t24;
    	    t9 += 38 * t25;
    	    t10 += 38 * t26;
    	    t11 += 38 * t27;
    	    t12 += 38 * t28;
    	    t13 += 38 * t29;
    	    t14 += 38 * t30;
    	    // t15 left as is
    	    // first car
    	    c = 1;
    	    v = t0 + c + 65535;
    	    c = Math.floor(v / 65536);
    	    t0 = v - c * 65536;
    	    v = t1 + c + 65535;
    	    c = Math.floor(v / 65536);
    	    t1 = v - c * 65536;
    	    v = t2 + c + 65535;
    	    c = Math.floor(v / 65536);
    	    t2 = v - c * 65536;
    	    v = t3 + c + 65535;
    	    c = Math.floor(v / 65536);
    	    t3 = v - c * 65536;
    	    v = t4 + c + 65535;
    	    c = Math.floor(v / 65536);
    	    t4 = v - c * 65536;
    	    v = t5 + c + 65535;
    	    c = Math.floor(v / 65536);
    	    t5 = v - c * 65536;
    	    v = t6 + c + 65535;
    	    c = Math.floor(v / 65536);
    	    t6 = v - c * 65536;
    	    v = t7 + c + 65535;
    	    c = Math.floor(v / 65536);
    	    t7 = v - c * 65536;
    	    v = t8 + c + 65535;
    	    c = Math.floor(v / 65536);
    	    t8 = v - c * 65536;
    	    v = t9 + c + 65535;
    	    c = Math.floor(v / 65536);
    	    t9 = v - c * 65536;
    	    v = t10 + c + 65535;
    	    c = Math.floor(v / 65536);
    	    t10 = v - c * 65536;
    	    v = t11 + c + 65535;
    	    c = Math.floor(v / 65536);
    	    t11 = v - c * 65536;
    	    v = t12 + c + 65535;
    	    c = Math.floor(v / 65536);
    	    t12 = v - c * 65536;
    	    v = t13 + c + 65535;
    	    c = Math.floor(v / 65536);
    	    t13 = v - c * 65536;
    	    v = t14 + c + 65535;
    	    c = Math.floor(v / 65536);
    	    t14 = v - c * 65536;
    	    v = t15 + c + 65535;
    	    c = Math.floor(v / 65536);
    	    t15 = v - c * 65536;
    	    t0 += c - 1 + 37 * (c - 1);
    	    // second car
    	    c = 1;
    	    v = t0 + c + 65535;
    	    c = Math.floor(v / 65536);
    	    t0 = v - c * 65536;
    	    v = t1 + c + 65535;
    	    c = Math.floor(v / 65536);
    	    t1 = v - c * 65536;
    	    v = t2 + c + 65535;
    	    c = Math.floor(v / 65536);
    	    t2 = v - c * 65536;
    	    v = t3 + c + 65535;
    	    c = Math.floor(v / 65536);
    	    t3 = v - c * 65536;
    	    v = t4 + c + 65535;
    	    c = Math.floor(v / 65536);
    	    t4 = v - c * 65536;
    	    v = t5 + c + 65535;
    	    c = Math.floor(v / 65536);
    	    t5 = v - c * 65536;
    	    v = t6 + c + 65535;
    	    c = Math.floor(v / 65536);
    	    t6 = v - c * 65536;
    	    v = t7 + c + 65535;
    	    c = Math.floor(v / 65536);
    	    t7 = v - c * 65536;
    	    v = t8 + c + 65535;
    	    c = Math.floor(v / 65536);
    	    t8 = v - c * 65536;
    	    v = t9 + c + 65535;
    	    c = Math.floor(v / 65536);
    	    t9 = v - c * 65536;
    	    v = t10 + c + 65535;
    	    c = Math.floor(v / 65536);
    	    t10 = v - c * 65536;
    	    v = t11 + c + 65535;
    	    c = Math.floor(v / 65536);
    	    t11 = v - c * 65536;
    	    v = t12 + c + 65535;
    	    c = Math.floor(v / 65536);
    	    t12 = v - c * 65536;
    	    v = t13 + c + 65535;
    	    c = Math.floor(v / 65536);
    	    t13 = v - c * 65536;
    	    v = t14 + c + 65535;
    	    c = Math.floor(v / 65536);
    	    t14 = v - c * 65536;
    	    v = t15 + c + 65535;
    	    c = Math.floor(v / 65536);
    	    t15 = v - c * 65536;
    	    t0 += c - 1 + 37 * (c - 1);
    	    o[0] = t0;
    	    o[1] = t1;
    	    o[2] = t2;
    	    o[3] = t3;
    	    o[4] = t4;
    	    o[5] = t5;
    	    o[6] = t6;
    	    o[7] = t7;
    	    o[8] = t8;
    	    o[9] = t9;
    	    o[10] = t10;
    	    o[11] = t11;
    	    o[12] = t12;
    	    o[13] = t13;
    	    o[14] = t14;
    	    o[15] = t15;
    	}
    	function square(o, a) {
    	    mul(o, a, a);
    	}
    	function inv25519(o, inp) {
    	    const c = gf();
    	    for (let i = 0; i < 16; i++) {
    	        c[i] = inp[i];
    	    }
    	    for (let i = 253; i >= 0; i--) {
    	        square(c, c);
    	        if (i !== 2 && i !== 4) {
    	            mul(c, c, inp);
    	        }
    	    }
    	    for (let i = 0; i < 16; i++) {
    	        o[i] = c[i];
    	    }
    	}
    	function scalarMult(n, p) {
    	    const z = new Uint8Array(32);
    	    const x = new Float64Array(80);
    	    const a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf();
    	    for (let i = 0; i < 31; i++) {
    	        z[i] = n[i];
    	    }
    	    z[31] = (n[31] & 127) | 64;
    	    z[0] &= 248;
    	    unpack25519(x, p);
    	    for (let i = 0; i < 16; i++) {
    	        b[i] = x[i];
    	    }
    	    a[0] = d[0] = 1;
    	    for (let i = 254; i >= 0; --i) {
    	        const r = (z[i >>> 3] >>> (i & 7)) & 1;
    	        sel25519(a, b, r);
    	        sel25519(c, d, r);
    	        add(e, a, c);
    	        sub(a, a, c);
    	        add(c, b, d);
    	        sub(b, b, d);
    	        square(d, e);
    	        square(f, a);
    	        mul(a, c, a);
    	        mul(c, b, e);
    	        add(e, a, c);
    	        sub(a, a, c);
    	        square(b, a);
    	        sub(c, d, f);
    	        mul(a, c, _121665);
    	        add(a, a, d);
    	        mul(c, c, a);
    	        mul(a, d, f);
    	        mul(d, b, x);
    	        square(b, e);
    	        sel25519(a, b, r);
    	        sel25519(c, d, r);
    	    }
    	    for (let i = 0; i < 16; i++) {
    	        x[i + 16] = a[i];
    	        x[i + 32] = c[i];
    	        x[i + 48] = b[i];
    	        x[i + 64] = d[i];
    	    }
    	    const x32 = x.subarray(32);
    	    const x16 = x.subarray(16);
    	    inv25519(x32, x32);
    	    mul(x16, x16, x32);
    	    const q = new Uint8Array(32);
    	    pack25519(q, x16);
    	    return q;
    	}
    	exports.scalarMult = scalarMult;
    	function scalarMultBase(n) {
    	    return scalarMult(n, _9);
    	}
    	exports.scalarMultBase = scalarMultBase;
    	function generateKeyPairFromSeed(seed) {
    	    if (seed.length !== exports.SECRET_KEY_LENGTH) {
    	        throw new Error(`x25519: seed must be ${exports.SECRET_KEY_LENGTH} bytes`);
    	    }
    	    const secretKey = new Uint8Array(seed);
    	    const publicKey = scalarMultBase(secretKey);
    	    return {
    	        publicKey,
    	        secretKey
    	    };
    	}
    	exports.generateKeyPairFromSeed = generateKeyPairFromSeed;
    	function generateKeyPair(prng) {
    	    const seed = (0, random_1.randomBytes)(32, prng);
    	    const result = generateKeyPairFromSeed(seed);
    	    (0, wipe_1.wipe)(seed);
    	    return result;
    	}
    	exports.generateKeyPair = generateKeyPair;
    	/**
    	 * Returns a shared key between our secret key and a peer's public key.
    	 *
    	 * Throws an error if the given keys are of wrong length.
    	 *
    	 * If rejectZero is true throws if the calculated shared key is all-zero.
    	 * From RFC 7748:
    	 *
    	 * > Protocol designers using Diffie-Hellman over the curves defined in
    	 * > this document must not assume "contributory behavior".  Specially,
    	 * > contributory behavior means that both parties' private keys
    	 * > contribute to the resulting shared key.  Since curve25519 and
    	 * > curve448 have cofactors of 8 and 4 (respectively), an input point of
    	 * > small order will eliminate any contribution from the other party's
    	 * > private key.  This situation can be detected by checking for the all-
    	 * > zero output, which implementations MAY do, as specified in Section 6.
    	 * > However, a large number of existing implementations do not do this.
    	 *
    	 * IMPORTANT: the returned key is a raw result of scalar multiplication.
    	 * To use it as a key material, hash it with a cryptographic hash function.
    	 */
    	function sharedKey(mySecretKey, theirPublicKey, rejectZero = false) {
    	    if (mySecretKey.length !== exports.PUBLIC_KEY_LENGTH) {
    	        throw new Error("X25519: incorrect secret key length");
    	    }
    	    if (theirPublicKey.length !== exports.PUBLIC_KEY_LENGTH) {
    	        throw new Error("X25519: incorrect public key length");
    	    }
    	    const result = scalarMult(mySecretKey, theirPublicKey);
    	    if (rejectZero) {
    	        let zeros = 0;
    	        for (let i = 0; i < result.length; i++) {
    	            zeros |= result[i];
    	        }
    	        if (zeros === 0) {
    	            throw new Error("X25519: invalid shared key");
    	        }
    	    }
    	    return result;
    	}
    	exports.sharedKey = sharedKey;
    	
    } (x25519));

    function asUint8Array(buf) {
      if (globalThis.Buffer != null) {
        return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
      }
      return buf;
    }

    function allocUnsafe$1(size = 0) {
      if (globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null) {
        return asUint8Array(globalThis.Buffer.allocUnsafe(size));
      }
      return new Uint8Array(size);
    }

    function concat$1(arrays, length) {
      if (!length) {
        length = arrays.reduce((acc, curr) => acc + curr.length, 0);
      }
      const output = allocUnsafe$1(length);
      let offset = 0;
      for (const arr of arrays) {
        output.set(arr, offset);
        offset += arr.length;
      }
      return asUint8Array(output);
    }

    function base(ALPHABET, name) {
      if (ALPHABET.length >= 255) {
        throw new TypeError('Alphabet too long');
      }
      var BASE_MAP = new Uint8Array(256);
      for (var j = 0; j < BASE_MAP.length; j++) {
        BASE_MAP[j] = 255;
      }
      for (var i = 0; i < ALPHABET.length; i++) {
        var x = ALPHABET.charAt(i);
        var xc = x.charCodeAt(0);
        if (BASE_MAP[xc] !== 255) {
          throw new TypeError(x + ' is ambiguous');
        }
        BASE_MAP[xc] = i;
      }
      var BASE = ALPHABET.length;
      var LEADER = ALPHABET.charAt(0);
      var FACTOR = Math.log(BASE) / Math.log(256);
      var iFACTOR = Math.log(256) / Math.log(BASE);
      function encode(source) {
        if (source instanceof Uint8Array);
        else if (ArrayBuffer.isView(source)) {
          source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
        } else if (Array.isArray(source)) {
          source = Uint8Array.from(source);
        }
        if (!(source instanceof Uint8Array)) {
          throw new TypeError('Expected Uint8Array');
        }
        if (source.length === 0) {
          return '';
        }
        var zeroes = 0;
        var length = 0;
        var pbegin = 0;
        var pend = source.length;
        while (pbegin !== pend && source[pbegin] === 0) {
          pbegin++;
          zeroes++;
        }
        var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
        var b58 = new Uint8Array(size);
        while (pbegin !== pend) {
          var carry = source[pbegin];
          var i = 0;
          for (var it1 = size - 1; (carry !== 0 || i < length) && it1 !== -1; it1--, i++) {
            carry += 256 * b58[it1] >>> 0;
            b58[it1] = carry % BASE >>> 0;
            carry = carry / BASE >>> 0;
          }
          if (carry !== 0) {
            throw new Error('Non-zero carry');
          }
          length = i;
          pbegin++;
        }
        var it2 = size - length;
        while (it2 !== size && b58[it2] === 0) {
          it2++;
        }
        var str = LEADER.repeat(zeroes);
        for (; it2 < size; ++it2) {
          str += ALPHABET.charAt(b58[it2]);
        }
        return str;
      }
      function decodeUnsafe(source) {
        if (typeof source !== 'string') {
          throw new TypeError('Expected String');
        }
        if (source.length === 0) {
          return new Uint8Array();
        }
        var psz = 0;
        if (source[psz] === ' ') {
          return;
        }
        var zeroes = 0;
        var length = 0;
        while (source[psz] === LEADER) {
          zeroes++;
          psz++;
        }
        var size = (source.length - psz) * FACTOR + 1 >>> 0;
        var b256 = new Uint8Array(size);
        while (source[psz]) {
          var carry = BASE_MAP[source.charCodeAt(psz)];
          if (carry === 255) {
            return;
          }
          var i = 0;
          for (var it3 = size - 1; (carry !== 0 || i < length) && it3 !== -1; it3--, i++) {
            carry += BASE * b256[it3] >>> 0;
            b256[it3] = carry % 256 >>> 0;
            carry = carry / 256 >>> 0;
          }
          if (carry !== 0) {
            throw new Error('Non-zero carry');
          }
          length = i;
          psz++;
        }
        if (source[psz] === ' ') {
          return;
        }
        var it4 = size - length;
        while (it4 !== size && b256[it4] === 0) {
          it4++;
        }
        var vch = new Uint8Array(zeroes + (size - it4));
        var j = zeroes;
        while (it4 !== size) {
          vch[j++] = b256[it4++];
        }
        return vch;
      }
      function decode(string) {
        var buffer = decodeUnsafe(string);
        if (buffer) {
          return buffer;
        }
        throw new Error(`Non-${ name } character`);
      }
      return {
        encode: encode,
        decodeUnsafe: decodeUnsafe,
        decode: decode
      };
    }
    var src = base;
    var _brrp__multiformats_scope_baseX = src;

    const coerce$4 = o => {
      if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array')
        return o;
      if (o instanceof ArrayBuffer)
        return new Uint8Array(o);
      if (ArrayBuffer.isView(o)) {
        return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
      }
      throw new Error('Unknown type, must be binary type');
    };
    const fromString$2 = str => new TextEncoder().encode(str);
    const toString$2 = b => new TextDecoder().decode(b);

    class Encoder {
      constructor(name, prefix, baseEncode) {
        this.name = name;
        this.prefix = prefix;
        this.baseEncode = baseEncode;
      }
      encode(bytes) {
        if (bytes instanceof Uint8Array) {
          return `${ this.prefix }${ this.baseEncode(bytes) }`;
        } else {
          throw Error('Unknown type, must be binary type');
        }
      }
    }
    class Decoder {
      constructor(name, prefix, baseDecode) {
        this.name = name;
        this.prefix = prefix;
        if (prefix.codePointAt(0) === undefined) {
          throw new Error('Invalid prefix character');
        }
        this.prefixCodePoint = prefix.codePointAt(0);
        this.baseDecode = baseDecode;
      }
      decode(text) {
        if (typeof text === 'string') {
          if (text.codePointAt(0) !== this.prefixCodePoint) {
            throw Error(`Unable to decode multibase string ${ JSON.stringify(text) }, ${ this.name } decoder only supports inputs prefixed with ${ this.prefix }`);
          }
          return this.baseDecode(text.slice(this.prefix.length));
        } else {
          throw Error('Can only multibase decode strings');
        }
      }
      or(decoder) {
        return or$3(this, decoder);
      }
    }
    class ComposedDecoder {
      constructor(decoders) {
        this.decoders = decoders;
      }
      or(decoder) {
        return or$3(this, decoder);
      }
      decode(input) {
        const prefix = input[0];
        const decoder = this.decoders[prefix];
        if (decoder) {
          return decoder.decode(input);
        } else {
          throw RangeError(`Unable to decode multibase string ${ JSON.stringify(input) }, only inputs prefixed with ${ Object.keys(this.decoders) } are supported`);
        }
      }
    }
    const or$3 = (left, right) => new ComposedDecoder({
      ...left.decoders || { [left.prefix]: left },
      ...right.decoders || { [right.prefix]: right }
    });
    class Codec {
      constructor(name, prefix, baseEncode, baseDecode) {
        this.name = name;
        this.prefix = prefix;
        this.baseEncode = baseEncode;
        this.baseDecode = baseDecode;
        this.encoder = new Encoder(name, prefix, baseEncode);
        this.decoder = new Decoder(name, prefix, baseDecode);
      }
      encode(input) {
        return this.encoder.encode(input);
      }
      decode(input) {
        return this.decoder.decode(input);
      }
    }
    const from$1 = ({name, prefix, encode, decode}) => new Codec(name, prefix, encode, decode);
    const baseX = ({prefix, name, alphabet}) => {
      const {encode, decode} = _brrp__multiformats_scope_baseX(alphabet, name);
      return from$1({
        prefix,
        name,
        encode,
        decode: text => coerce$4(decode(text))
      });
    };
    const decode$2 = (string, alphabet, bitsPerChar, name) => {
      const codes = {};
      for (let i = 0; i < alphabet.length; ++i) {
        codes[alphabet[i]] = i;
      }
      let end = string.length;
      while (string[end - 1] === '=') {
        --end;
      }
      const out = new Uint8Array(end * bitsPerChar / 8 | 0);
      let bits = 0;
      let buffer = 0;
      let written = 0;
      for (let i = 0; i < end; ++i) {
        const value = codes[string[i]];
        if (value === undefined) {
          throw new SyntaxError(`Non-${ name } character`);
        }
        buffer = buffer << bitsPerChar | value;
        bits += bitsPerChar;
        if (bits >= 8) {
          bits -= 8;
          out[written++] = 255 & buffer >> bits;
        }
      }
      if (bits >= bitsPerChar || 255 & buffer << 8 - bits) {
        throw new SyntaxError('Unexpected end of data');
      }
      return out;
    };
    const encode$1 = (data, alphabet, bitsPerChar) => {
      const pad = alphabet[alphabet.length - 1] === '=';
      const mask = (1 << bitsPerChar) - 1;
      let out = '';
      let bits = 0;
      let buffer = 0;
      for (let i = 0; i < data.length; ++i) {
        buffer = buffer << 8 | data[i];
        bits += 8;
        while (bits > bitsPerChar) {
          bits -= bitsPerChar;
          out += alphabet[mask & buffer >> bits];
        }
      }
      if (bits) {
        out += alphabet[mask & buffer << bitsPerChar - bits];
      }
      if (pad) {
        while (out.length * bitsPerChar & 7) {
          out += '=';
        }
      }
      return out;
    };
    const rfc4648 = ({name, prefix, bitsPerChar, alphabet}) => {
      return from$1({
        prefix,
        name,
        encode(input) {
          return encode$1(input, alphabet, bitsPerChar);
        },
        decode(input) {
          return decode$2(input, alphabet, bitsPerChar, name);
        }
      });
    };

    const identity = from$1({
      prefix: '\0',
      name: 'identity',
      encode: buf => toString$2(buf),
      decode: str => fromString$2(str)
    });

    var identityBase = /*#__PURE__*/Object.freeze({
        __proto__: null,
        identity: identity
    });

    const base2 = rfc4648({
      prefix: '0',
      name: 'base2',
      alphabet: '01',
      bitsPerChar: 1
    });

    var base2$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        base2: base2
    });

    const base8 = rfc4648({
      prefix: '7',
      name: 'base8',
      alphabet: '01234567',
      bitsPerChar: 3
    });

    var base8$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        base8: base8
    });

    const base10 = baseX({
      prefix: '9',
      name: 'base10',
      alphabet: '0123456789'
    });

    var base10$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        base10: base10
    });

    const base16 = rfc4648({
      prefix: 'f',
      name: 'base16',
      alphabet: '0123456789abcdef',
      bitsPerChar: 4
    });
    const base16upper = rfc4648({
      prefix: 'F',
      name: 'base16upper',
      alphabet: '0123456789ABCDEF',
      bitsPerChar: 4
    });

    var base16$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        base16: base16,
        base16upper: base16upper
    });

    const base32 = rfc4648({
      prefix: 'b',
      name: 'base32',
      alphabet: 'abcdefghijklmnopqrstuvwxyz234567',
      bitsPerChar: 5
    });
    const base32upper = rfc4648({
      prefix: 'B',
      name: 'base32upper',
      alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',
      bitsPerChar: 5
    });
    const base32pad = rfc4648({
      prefix: 'c',
      name: 'base32pad',
      alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',
      bitsPerChar: 5
    });
    const base32padupper = rfc4648({
      prefix: 'C',
      name: 'base32padupper',
      alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',
      bitsPerChar: 5
    });
    const base32hex = rfc4648({
      prefix: 'v',
      name: 'base32hex',
      alphabet: '0123456789abcdefghijklmnopqrstuv',
      bitsPerChar: 5
    });
    const base32hexupper = rfc4648({
      prefix: 'V',
      name: 'base32hexupper',
      alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',
      bitsPerChar: 5
    });
    const base32hexpad = rfc4648({
      prefix: 't',
      name: 'base32hexpad',
      alphabet: '0123456789abcdefghijklmnopqrstuv=',
      bitsPerChar: 5
    });
    const base32hexpadupper = rfc4648({
      prefix: 'T',
      name: 'base32hexpadupper',
      alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',
      bitsPerChar: 5
    });
    const base32z = rfc4648({
      prefix: 'h',
      name: 'base32z',
      alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',
      bitsPerChar: 5
    });

    var base32$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        base32: base32,
        base32hex: base32hex,
        base32hexpad: base32hexpad,
        base32hexpadupper: base32hexpadupper,
        base32hexupper: base32hexupper,
        base32pad: base32pad,
        base32padupper: base32padupper,
        base32upper: base32upper,
        base32z: base32z
    });

    const base36 = baseX({
      prefix: 'k',
      name: 'base36',
      alphabet: '0123456789abcdefghijklmnopqrstuvwxyz'
    });
    const base36upper = baseX({
      prefix: 'K',
      name: 'base36upper',
      alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'
    });

    var base36$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        base36: base36,
        base36upper: base36upper
    });

    const base58btc = baseX({
      name: 'base58btc',
      prefix: 'z',
      alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'
    });
    const base58flickr = baseX({
      name: 'base58flickr',
      prefix: 'Z',
      alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'
    });

    var base58 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        base58btc: base58btc,
        base58flickr: base58flickr
    });

    const base64$2 = rfc4648({
      prefix: 'm',
      name: 'base64',
      alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
      bitsPerChar: 6
    });
    const base64pad = rfc4648({
      prefix: 'M',
      name: 'base64pad',
      alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',
      bitsPerChar: 6
    });
    const base64url = rfc4648({
      prefix: 'u',
      name: 'base64url',
      alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',
      bitsPerChar: 6
    });
    const base64urlpad = rfc4648({
      prefix: 'U',
      name: 'base64urlpad',
      alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=',
      bitsPerChar: 6
    });

    var base64$3 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        base64: base64$2,
        base64pad: base64pad,
        base64url: base64url,
        base64urlpad: base64urlpad
    });

    const alphabet = Array.from('\uD83D\uDE80\uD83E\uDE90\u2604\uD83D\uDEF0\uD83C\uDF0C\uD83C\uDF11\uD83C\uDF12\uD83C\uDF13\uD83C\uDF14\uD83C\uDF15\uD83C\uDF16\uD83C\uDF17\uD83C\uDF18\uD83C\uDF0D\uD83C\uDF0F\uD83C\uDF0E\uD83D\uDC09\u2600\uD83D\uDCBB\uD83D\uDDA5\uD83D\uDCBE\uD83D\uDCBF\uD83D\uDE02\u2764\uD83D\uDE0D\uD83E\uDD23\uD83D\uDE0A\uD83D\uDE4F\uD83D\uDC95\uD83D\uDE2D\uD83D\uDE18\uD83D\uDC4D\uD83D\uDE05\uD83D\uDC4F\uD83D\uDE01\uD83D\uDD25\uD83E\uDD70\uD83D\uDC94\uD83D\uDC96\uD83D\uDC99\uD83D\uDE22\uD83E\uDD14\uD83D\uDE06\uD83D\uDE44\uD83D\uDCAA\uD83D\uDE09\u263A\uD83D\uDC4C\uD83E\uDD17\uD83D\uDC9C\uD83D\uDE14\uD83D\uDE0E\uD83D\uDE07\uD83C\uDF39\uD83E\uDD26\uD83C\uDF89\uD83D\uDC9E\u270C\u2728\uD83E\uDD37\uD83D\uDE31\uD83D\uDE0C\uD83C\uDF38\uD83D\uDE4C\uD83D\uDE0B\uD83D\uDC97\uD83D\uDC9A\uD83D\uDE0F\uD83D\uDC9B\uD83D\uDE42\uD83D\uDC93\uD83E\uDD29\uD83D\uDE04\uD83D\uDE00\uD83D\uDDA4\uD83D\uDE03\uD83D\uDCAF\uD83D\uDE48\uD83D\uDC47\uD83C\uDFB6\uD83D\uDE12\uD83E\uDD2D\u2763\uD83D\uDE1C\uD83D\uDC8B\uD83D\uDC40\uD83D\uDE2A\uD83D\uDE11\uD83D\uDCA5\uD83D\uDE4B\uD83D\uDE1E\uD83D\uDE29\uD83D\uDE21\uD83E\uDD2A\uD83D\uDC4A\uD83E\uDD73\uD83D\uDE25\uD83E\uDD24\uD83D\uDC49\uD83D\uDC83\uD83D\uDE33\u270B\uD83D\uDE1A\uD83D\uDE1D\uD83D\uDE34\uD83C\uDF1F\uD83D\uDE2C\uD83D\uDE43\uD83C\uDF40\uD83C\uDF37\uD83D\uDE3B\uD83D\uDE13\u2B50\u2705\uD83E\uDD7A\uD83C\uDF08\uD83D\uDE08\uD83E\uDD18\uD83D\uDCA6\u2714\uD83D\uDE23\uD83C\uDFC3\uD83D\uDC90\u2639\uD83C\uDF8A\uD83D\uDC98\uD83D\uDE20\u261D\uD83D\uDE15\uD83C\uDF3A\uD83C\uDF82\uD83C\uDF3B\uD83D\uDE10\uD83D\uDD95\uD83D\uDC9D\uD83D\uDE4A\uD83D\uDE39\uD83D\uDDE3\uD83D\uDCAB\uD83D\uDC80\uD83D\uDC51\uD83C\uDFB5\uD83E\uDD1E\uD83D\uDE1B\uD83D\uDD34\uD83D\uDE24\uD83C\uDF3C\uD83D\uDE2B\u26BD\uD83E\uDD19\u2615\uD83C\uDFC6\uD83E\uDD2B\uD83D\uDC48\uD83D\uDE2E\uD83D\uDE46\uD83C\uDF7B\uD83C\uDF43\uD83D\uDC36\uD83D\uDC81\uD83D\uDE32\uD83C\uDF3F\uD83E\uDDE1\uD83C\uDF81\u26A1\uD83C\uDF1E\uD83C\uDF88\u274C\u270A\uD83D\uDC4B\uD83D\uDE30\uD83E\uDD28\uD83D\uDE36\uD83E\uDD1D\uD83D\uDEB6\uD83D\uDCB0\uD83C\uDF53\uD83D\uDCA2\uD83E\uDD1F\uD83D\uDE41\uD83D\uDEA8\uD83D\uDCA8\uD83E\uDD2C\u2708\uD83C\uDF80\uD83C\uDF7A\uD83E\uDD13\uD83D\uDE19\uD83D\uDC9F\uD83C\uDF31\uD83D\uDE16\uD83D\uDC76\uD83E\uDD74\u25B6\u27A1\u2753\uD83D\uDC8E\uD83D\uDCB8\u2B07\uD83D\uDE28\uD83C\uDF1A\uD83E\uDD8B\uD83D\uDE37\uD83D\uDD7A\u26A0\uD83D\uDE45\uD83D\uDE1F\uD83D\uDE35\uD83D\uDC4E\uD83E\uDD32\uD83E\uDD20\uD83E\uDD27\uD83D\uDCCC\uD83D\uDD35\uD83D\uDC85\uD83E\uDDD0\uD83D\uDC3E\uD83C\uDF52\uD83D\uDE17\uD83E\uDD11\uD83C\uDF0A\uD83E\uDD2F\uD83D\uDC37\u260E\uD83D\uDCA7\uD83D\uDE2F\uD83D\uDC86\uD83D\uDC46\uD83C\uDFA4\uD83D\uDE47\uD83C\uDF51\u2744\uD83C\uDF34\uD83D\uDCA3\uD83D\uDC38\uD83D\uDC8C\uD83D\uDCCD\uD83E\uDD40\uD83E\uDD22\uD83D\uDC45\uD83D\uDCA1\uD83D\uDCA9\uD83D\uDC50\uD83D\uDCF8\uD83D\uDC7B\uD83E\uDD10\uD83E\uDD2E\uD83C\uDFBC\uD83E\uDD75\uD83D\uDEA9\uD83C\uDF4E\uD83C\uDF4A\uD83D\uDC7C\uD83D\uDC8D\uD83D\uDCE3\uD83E\uDD42');
    const alphabetBytesToChars = alphabet.reduce((p, c, i) => {
      p[i] = c;
      return p;
    }, []);
    const alphabetCharsToBytes = alphabet.reduce((p, c, i) => {
      p[c.codePointAt(0)] = i;
      return p;
    }, []);
    function encode(data) {
      return data.reduce((p, c) => {
        p += alphabetBytesToChars[c];
        return p;
      }, '');
    }
    function decode$1(str) {
      const byts = [];
      for (const char of str) {
        const byt = alphabetCharsToBytes[char.codePointAt(0)];
        if (byt === undefined) {
          throw new Error(`Non-base256emoji character: ${ char }`);
        }
        byts.push(byt);
      }
      return new Uint8Array(byts);
    }
    const base256emoji = from$1({
      prefix: '\uD83D\uDE80',
      name: 'base256emoji',
      encode,
      decode: decode$1
    });

    var base256emoji$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        base256emoji: base256emoji
    });

    new TextEncoder();
    new TextDecoder();

    const bases = {
      ...identityBase,
      ...base2$1,
      ...base8$1,
      ...base10$1,
      ...base16$1,
      ...base32$1,
      ...base36$1,
      ...base58,
      ...base64$3,
      ...base256emoji$1
    };

    function createCodec(name, prefix, encode, decode) {
      return {
        name,
        prefix,
        encoder: {
          name,
          prefix,
          encode
        },
        decoder: { decode }
      };
    }
    const string$1 = createCodec('utf8', 'u', buf => {
      const decoder = new TextDecoder('utf8');
      return 'u' + decoder.decode(buf);
    }, str => {
      const encoder = new TextEncoder();
      return encoder.encode(str.substring(1));
    });
    const ascii = createCodec('ascii', 'a', buf => {
      let string = 'a';
      for (let i = 0; i < buf.length; i++) {
        string += String.fromCharCode(buf[i]);
      }
      return string;
    }, str => {
      str = str.substring(1);
      const buf = allocUnsafe$1(str.length);
      for (let i = 0; i < str.length; i++) {
        buf[i] = str.charCodeAt(i);
      }
      return buf;
    });
    const BASES = {
      utf8: string$1,
      'utf-8': string$1,
      hex: bases.base16,
      latin1: ascii,
      ascii: ascii,
      binary: ascii,
      ...bases
    };

    function fromString$1(string, encoding = 'utf8') {
      const base = BASES[encoding];
      if (!base) {
        throw new Error(`Unsupported encoding "${ encoding }"`);
      }
      if ((encoding === 'utf8' || encoding === 'utf-8') && globalThis.Buffer != null && globalThis.Buffer.from != null) {
        return asUint8Array(globalThis.Buffer.from(string, 'utf-8'));
      }
      return base.decoder.decode(`${ base.prefix }${ string }`);
    }

    function toString$1(array, encoding = 'utf8') {
      const base = BASES[encoding];
      if (!base) {
        throw new Error(`Unsupported encoding "${ encoding }"`);
      }
      if ((encoding === 'utf8' || encoding === 'utf-8') && globalThis.Buffer != null && globalThis.Buffer.from != null) {
        return globalThis.Buffer.from(array.buffer, array.byteOffset, array.byteLength).toString('utf8');
      }
      return base.encoder.encode(array).substring(1);
    }

    var __spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
        return to.concat(ar || Array.prototype.slice.call(from));
    };
    var BrowserInfo = /** @class */ (function () {
        function BrowserInfo(name, version, os) {
            this.name = name;
            this.version = version;
            this.os = os;
            this.type = 'browser';
        }
        return BrowserInfo;
    }());
    var NodeInfo = /** @class */ (function () {
        function NodeInfo(version) {
            this.version = version;
            this.type = 'node';
            this.name = 'node';
            this.os = browser$1$1.platform;
        }
        return NodeInfo;
    }());
    var SearchBotDeviceInfo = /** @class */ (function () {
        function SearchBotDeviceInfo(name, version, os, bot) {
            this.name = name;
            this.version = version;
            this.os = os;
            this.bot = bot;
            this.type = 'bot-device';
        }
        return SearchBotDeviceInfo;
    }());
    var BotInfo = /** @class */ (function () {
        function BotInfo() {
            this.type = 'bot';
            this.bot = true; // NOTE: deprecated test name instead
            this.name = 'bot';
            this.version = null;
            this.os = null;
        }
        return BotInfo;
    }());
    var ReactNativeInfo = /** @class */ (function () {
        function ReactNativeInfo() {
            this.type = 'react-native';
            this.name = 'react-native';
            this.version = null;
            this.os = null;
        }
        return ReactNativeInfo;
    }());
    // tslint:disable-next-line:max-line-length
    var SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;
    var SEARCHBOT_OS_REGEX = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/;
    var REQUIRED_VERSION_PARTS = 3;
    var userAgentRules = [
        ['aol', /AOLShield\/([0-9\._]+)/],
        ['edge', /Edge\/([0-9\._]+)/],
        ['edge-ios', /EdgiOS\/([0-9\._]+)/],
        ['yandexbrowser', /YaBrowser\/([0-9\._]+)/],
        ['kakaotalk', /KAKAOTALK\s([0-9\.]+)/],
        ['samsung', /SamsungBrowser\/([0-9\.]+)/],
        ['silk', /\bSilk\/([0-9._-]+)\b/],
        ['miui', /MiuiBrowser\/([0-9\.]+)$/],
        ['beaker', /BeakerBrowser\/([0-9\.]+)/],
        ['edge-chromium', /EdgA?\/([0-9\.]+)/],
        [
            'chromium-webview',
            /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/,
        ],
        ['chrome', /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
        ['phantomjs', /PhantomJS\/([0-9\.]+)(:?\s|$)/],
        ['crios', /CriOS\/([0-9\.]+)(:?\s|$)/],
        ['firefox', /Firefox\/([0-9\.]+)(?:\s|$)/],
        ['fxios', /FxiOS\/([0-9\.]+)/],
        ['opera-mini', /Opera Mini.*Version\/([0-9\.]+)/],
        ['opera', /Opera\/([0-9\.]+)(?:\s|$)/],
        ['opera', /OPR\/([0-9\.]+)(:?\s|$)/],
        ['pie', /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],
        ['pie', /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],
        ['netfront', /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],
        ['ie', /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
        ['ie', /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
        ['ie', /MSIE\s(7\.0)/],
        ['bb10', /BB10;\sTouch.*Version\/([0-9\.]+)/],
        ['android', /Android\s([0-9\.]+)/],
        ['ios', /Version\/([0-9\._]+).*Mobile.*Safari.*/],
        ['safari', /Version\/([0-9\._]+).*Safari/],
        ['facebook', /FB[AS]V\/([0-9\.]+)/],
        ['instagram', /Instagram\s([0-9\.]+)/],
        ['ios-webview', /AppleWebKit\/([0-9\.]+).*Mobile/],
        ['ios-webview', /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
        ['curl', /^curl\/([0-9\.]+)$/],
        ['searchbot', SEARCHBOX_UA_REGEX],
    ];
    var operatingSystemRules = [
        ['iOS', /iP(hone|od|ad)/],
        ['Android OS', /Android/],
        ['BlackBerry OS', /BlackBerry|BB10/],
        ['Windows Mobile', /IEMobile/],
        ['Amazon OS', /Kindle/],
        ['Windows 3.11', /Win16/],
        ['Windows 95', /(Windows 95)|(Win95)|(Windows_95)/],
        ['Windows 98', /(Windows 98)|(Win98)/],
        ['Windows 2000', /(Windows NT 5.0)|(Windows 2000)/],
        ['Windows XP', /(Windows NT 5.1)|(Windows XP)/],
        ['Windows Server 2003', /(Windows NT 5.2)/],
        ['Windows Vista', /(Windows NT 6.0)/],
        ['Windows 7', /(Windows NT 6.1)/],
        ['Windows 8', /(Windows NT 6.2)/],
        ['Windows 8.1', /(Windows NT 6.3)/],
        ['Windows 10', /(Windows NT 10.0)/],
        ['Windows ME', /Windows ME/],
        ['Windows CE', /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],
        ['Open BSD', /OpenBSD/],
        ['Sun OS', /SunOS/],
        ['Chrome OS', /CrOS/],
        ['Linux', /(Linux)|(X11)/],
        ['Mac OS', /(Mac_PowerPC)|(Macintosh)/],
        ['QNX', /QNX/],
        ['BeOS', /BeOS/],
        ['OS/2', /OS\/2/],
    ];
    function detect(userAgent) {
        if (!!userAgent) {
            return parseUserAgent(userAgent);
        }
        if (typeof document === 'undefined' &&
            typeof navigator !== 'undefined' &&
            navigator.product === 'ReactNative') {
            return new ReactNativeInfo();
        }
        if (typeof navigator !== 'undefined') {
            return parseUserAgent(navigator.userAgent);
        }
        return getNodeVersion();
    }
    function matchUserAgent(ua) {
        // opted for using reduce here rather than Array#first with a regex.test call
        // this is primarily because using the reduce we only perform the regex
        // execution once rather than once for the test and for the exec again below
        // probably something that needs to be benchmarked though
        return (ua !== '' &&
            userAgentRules.reduce(function (matched, _a) {
                var browser = _a[0], regex = _a[1];
                if (matched) {
                    return matched;
                }
                var uaMatch = regex.exec(ua);
                return !!uaMatch && [browser, uaMatch];
            }, false));
    }
    function parseUserAgent(ua) {
        var matchedRule = matchUserAgent(ua);
        if (!matchedRule) {
            return null;
        }
        var name = matchedRule[0], match = matchedRule[1];
        if (name === 'searchbot') {
            return new BotInfo();
        }
        // Do not use RegExp for split operation as some browser do not support it (See: http://blog.stevenlevithan.com/archives/cross-browser-split)
        var versionParts = match[1] && match[1].split('.').join('_').split('_').slice(0, 3);
        if (versionParts) {
            if (versionParts.length < REQUIRED_VERSION_PARTS) {
                versionParts = __spreadArray(__spreadArray([], versionParts, true), createVersionParts(REQUIRED_VERSION_PARTS - versionParts.length), true);
            }
        }
        else {
            versionParts = [];
        }
        var version = versionParts.join('.');
        var os = detectOS(ua);
        var searchBotMatch = SEARCHBOT_OS_REGEX.exec(ua);
        if (searchBotMatch && searchBotMatch[1]) {
            return new SearchBotDeviceInfo(name, version, os, searchBotMatch[1]);
        }
        return new BrowserInfo(name, version, os);
    }
    function detectOS(ua) {
        for (var ii = 0, count = operatingSystemRules.length; ii < count; ii++) {
            var _a = operatingSystemRules[ii], os = _a[0], regex = _a[1];
            var match = regex.exec(ua);
            if (match) {
                return os;
            }
        }
        return null;
    }
    function getNodeVersion() {
        var isNode = typeof browser$1$1 !== 'undefined' && browser$1$1.version;
        return isNode ? new NodeInfo(browser$1$1.version.slice(1)) : null;
    }
    function createVersionParts(count) {
        var output = [];
        for (var ii = 0; ii < count; ii++) {
            output.push('0');
        }
        return output;
    }

    var cjs$7 = {};

    var require$$0$4 = /*@__PURE__*/getAugmentedNamespace(tslib_es6$1);

    var utils$5 = {};

    var delay = {};

    var hasRequiredDelay;

    function requireDelay () {
    	if (hasRequiredDelay) return delay;
    	hasRequiredDelay = 1;
    	Object.defineProperty(delay, "__esModule", { value: true });
    	delay.delay = void 0;
    	function delay$1(timeout) {
    	    return new Promise(resolve => {
    	        setTimeout(() => {
    	            resolve(true);
    	        }, timeout);
    	    });
    	}
    	delay.delay = delay$1;
    	
    	return delay;
    }

    var convert = {};

    var constants$6 = {};

    var misc$1 = {};

    var hasRequiredMisc;

    function requireMisc () {
    	if (hasRequiredMisc) return misc$1;
    	hasRequiredMisc = 1;
    	Object.defineProperty(misc$1, "__esModule", { value: true });
    	misc$1.ONE_THOUSAND = misc$1.ONE_HUNDRED = void 0;
    	misc$1.ONE_HUNDRED = 100;
    	misc$1.ONE_THOUSAND = 1000;
    	
    	return misc$1;
    }

    var time$2 = {};

    var hasRequiredTime;

    function requireTime () {
    	if (hasRequiredTime) return time$2;
    	hasRequiredTime = 1;
    	(function (exports) {
    		Object.defineProperty(exports, "__esModule", { value: true });
    		exports.ONE_YEAR = exports.FOUR_WEEKS = exports.THREE_WEEKS = exports.TWO_WEEKS = exports.ONE_WEEK = exports.THIRTY_DAYS = exports.SEVEN_DAYS = exports.FIVE_DAYS = exports.THREE_DAYS = exports.ONE_DAY = exports.TWENTY_FOUR_HOURS = exports.TWELVE_HOURS = exports.SIX_HOURS = exports.THREE_HOURS = exports.ONE_HOUR = exports.SIXTY_MINUTES = exports.THIRTY_MINUTES = exports.TEN_MINUTES = exports.FIVE_MINUTES = exports.ONE_MINUTE = exports.SIXTY_SECONDS = exports.THIRTY_SECONDS = exports.TEN_SECONDS = exports.FIVE_SECONDS = exports.ONE_SECOND = void 0;
    		exports.ONE_SECOND = 1;
    		exports.FIVE_SECONDS = 5;
    		exports.TEN_SECONDS = 10;
    		exports.THIRTY_SECONDS = 30;
    		exports.SIXTY_SECONDS = 60;
    		exports.ONE_MINUTE = exports.SIXTY_SECONDS;
    		exports.FIVE_MINUTES = exports.ONE_MINUTE * 5;
    		exports.TEN_MINUTES = exports.ONE_MINUTE * 10;
    		exports.THIRTY_MINUTES = exports.ONE_MINUTE * 30;
    		exports.SIXTY_MINUTES = exports.ONE_MINUTE * 60;
    		exports.ONE_HOUR = exports.SIXTY_MINUTES;
    		exports.THREE_HOURS = exports.ONE_HOUR * 3;
    		exports.SIX_HOURS = exports.ONE_HOUR * 6;
    		exports.TWELVE_HOURS = exports.ONE_HOUR * 12;
    		exports.TWENTY_FOUR_HOURS = exports.ONE_HOUR * 24;
    		exports.ONE_DAY = exports.TWENTY_FOUR_HOURS;
    		exports.THREE_DAYS = exports.ONE_DAY * 3;
    		exports.FIVE_DAYS = exports.ONE_DAY * 5;
    		exports.SEVEN_DAYS = exports.ONE_DAY * 7;
    		exports.THIRTY_DAYS = exports.ONE_DAY * 30;
    		exports.ONE_WEEK = exports.SEVEN_DAYS;
    		exports.TWO_WEEKS = exports.ONE_WEEK * 2;
    		exports.THREE_WEEKS = exports.ONE_WEEK * 3;
    		exports.FOUR_WEEKS = exports.ONE_WEEK * 4;
    		exports.ONE_YEAR = exports.ONE_DAY * 365;
    		
    	} (time$2));
    	return time$2;
    }

    var hasRequiredConstants$2;

    function requireConstants$2 () {
    	if (hasRequiredConstants$2) return constants$6;
    	hasRequiredConstants$2 = 1;
    	(function (exports) {
    		Object.defineProperty(exports, "__esModule", { value: true });
    		const tslib_1 = require$$0$4;
    		tslib_1.__exportStar(requireMisc(), exports);
    		tslib_1.__exportStar(requireTime(), exports);
    		
    	} (constants$6));
    	return constants$6;
    }

    var hasRequiredConvert;

    function requireConvert () {
    	if (hasRequiredConvert) return convert;
    	hasRequiredConvert = 1;
    	Object.defineProperty(convert, "__esModule", { value: true });
    	convert.fromMiliseconds = convert.toMiliseconds = void 0;
    	const constants_1 = requireConstants$2();
    	function toMiliseconds(seconds) {
    	    return seconds * constants_1.ONE_THOUSAND;
    	}
    	convert.toMiliseconds = toMiliseconds;
    	function fromMiliseconds(miliseconds) {
    	    return Math.floor(miliseconds / constants_1.ONE_THOUSAND);
    	}
    	convert.fromMiliseconds = fromMiliseconds;
    	
    	return convert;
    }

    var hasRequiredUtils$1;

    function requireUtils$1 () {
    	if (hasRequiredUtils$1) return utils$5;
    	hasRequiredUtils$1 = 1;
    	(function (exports) {
    		Object.defineProperty(exports, "__esModule", { value: true });
    		const tslib_1 = require$$0$4;
    		tslib_1.__exportStar(requireDelay(), exports);
    		tslib_1.__exportStar(requireConvert(), exports);
    		
    	} (utils$5));
    	return utils$5;
    }

    var watch$2 = {};

    var hasRequiredWatch$1;

    function requireWatch$1 () {
    	if (hasRequiredWatch$1) return watch$2;
    	hasRequiredWatch$1 = 1;
    	Object.defineProperty(watch$2, "__esModule", { value: true });
    	watch$2.Watch = void 0;
    	class Watch {
    	    constructor() {
    	        this.timestamps = new Map();
    	    }
    	    start(label) {
    	        if (this.timestamps.has(label)) {
    	            throw new Error(`Watch already started for label: ${label}`);
    	        }
    	        this.timestamps.set(label, { started: Date.now() });
    	    }
    	    stop(label) {
    	        const timestamp = this.get(label);
    	        if (typeof timestamp.elapsed !== "undefined") {
    	            throw new Error(`Watch already stopped for label: ${label}`);
    	        }
    	        const elapsed = Date.now() - timestamp.started;
    	        this.timestamps.set(label, { started: timestamp.started, elapsed });
    	    }
    	    get(label) {
    	        const timestamp = this.timestamps.get(label);
    	        if (typeof timestamp === "undefined") {
    	            throw new Error(`No timestamp found for label: ${label}`);
    	        }
    	        return timestamp;
    	    }
    	    elapsed(label) {
    	        const timestamp = this.get(label);
    	        const elapsed = timestamp.elapsed || Date.now() - timestamp.started;
    	        return elapsed;
    	    }
    	}
    	watch$2.Watch = Watch;
    	watch$2.default = Watch;
    	
    	return watch$2;
    }

    var types$1 = {};

    var watch$1 = {};

    var hasRequiredWatch;

    function requireWatch () {
    	if (hasRequiredWatch) return watch$1;
    	hasRequiredWatch = 1;
    	Object.defineProperty(watch$1, "__esModule", { value: true });
    	watch$1.IWatch = void 0;
    	class IWatch {
    	}
    	watch$1.IWatch = IWatch;
    	
    	return watch$1;
    }

    var hasRequiredTypes$1;

    function requireTypes$1 () {
    	if (hasRequiredTypes$1) return types$1;
    	hasRequiredTypes$1 = 1;
    	(function (exports) {
    		Object.defineProperty(exports, "__esModule", { value: true });
    		const tslib_1 = require$$0$4;
    		tslib_1.__exportStar(requireWatch(), exports);
    		
    	} (types$1));
    	return types$1;
    }

    (function (exports) {
    	Object.defineProperty(exports, "__esModule", { value: true });
    	const tslib_1 = require$$0$4;
    	tslib_1.__exportStar(requireUtils$1(), exports);
    	tslib_1.__exportStar(requireWatch$1(), exports);
    	tslib_1.__exportStar(requireTypes$1(), exports);
    	tslib_1.__exportStar(requireConstants$2(), exports);
    	
    } (cjs$7));

    var cjs$6 = {};

    Object.defineProperty(cjs$6, "__esModule", { value: true });
    cjs$6.getLocalStorage = cjs$6.getLocalStorageOrThrow = cjs$6.getCrypto = cjs$6.getCryptoOrThrow = getLocation_1 = cjs$6.getLocation = cjs$6.getLocationOrThrow = getNavigator_1 = cjs$6.getNavigator = cjs$6.getNavigatorOrThrow = getDocument_1 = cjs$6.getDocument = cjs$6.getDocumentOrThrow = cjs$6.getFromWindowOrThrow = cjs$6.getFromWindow = void 0;
    function getFromWindow(name) {
        let res = undefined;
        if (typeof window !== "undefined" && typeof window[name] !== "undefined") {
            res = window[name];
        }
        return res;
    }
    cjs$6.getFromWindow = getFromWindow;
    function getFromWindowOrThrow(name) {
        const res = getFromWindow(name);
        if (!res) {
            throw new Error(`${name} is not defined in Window`);
        }
        return res;
    }
    cjs$6.getFromWindowOrThrow = getFromWindowOrThrow;
    function getDocumentOrThrow() {
        return getFromWindowOrThrow("document");
    }
    cjs$6.getDocumentOrThrow = getDocumentOrThrow;
    function getDocument() {
        return getFromWindow("document");
    }
    var getDocument_1 = cjs$6.getDocument = getDocument;
    function getNavigatorOrThrow() {
        return getFromWindowOrThrow("navigator");
    }
    cjs$6.getNavigatorOrThrow = getNavigatorOrThrow;
    function getNavigator() {
        return getFromWindow("navigator");
    }
    var getNavigator_1 = cjs$6.getNavigator = getNavigator;
    function getLocationOrThrow() {
        return getFromWindowOrThrow("location");
    }
    cjs$6.getLocationOrThrow = getLocationOrThrow;
    function getLocation$1() {
        return getFromWindow("location");
    }
    var getLocation_1 = cjs$6.getLocation = getLocation$1;
    function getCryptoOrThrow() {
        return getFromWindowOrThrow("crypto");
    }
    cjs$6.getCryptoOrThrow = getCryptoOrThrow;
    function getCrypto() {
        return getFromWindow("crypto");
    }
    cjs$6.getCrypto = getCrypto;
    function getLocalStorageOrThrow() {
        return getFromWindowOrThrow("localStorage");
    }
    cjs$6.getLocalStorageOrThrow = getLocalStorageOrThrow;
    function getLocalStorage() {
        return getFromWindow("localStorage");
    }
    cjs$6.getLocalStorage = getLocalStorage;

    var cjs$5 = {};

    Object.defineProperty(cjs$5, "__esModule", { value: true });
    var getWindowMetadata_1 = cjs$5.getWindowMetadata = void 0;
    const window_getters_1 = cjs$6;
    function getWindowMetadata() {
        let doc;
        let loc;
        try {
            doc = window_getters_1.getDocumentOrThrow();
            loc = window_getters_1.getLocationOrThrow();
        }
        catch (e) {
            return null;
        }
        function getIcons() {
            const links = doc.getElementsByTagName("link");
            const icons = [];
            for (let i = 0; i < links.length; i++) {
                const link = links[i];
                const rel = link.getAttribute("rel");
                if (rel) {
                    if (rel.toLowerCase().indexOf("icon") > -1) {
                        const href = link.getAttribute("href");
                        if (href) {
                            if (href.toLowerCase().indexOf("https:") === -1 &&
                                href.toLowerCase().indexOf("http:") === -1 &&
                                href.indexOf("//") !== 0) {
                                let absoluteHref = loc.protocol + "//" + loc.host;
                                if (href.indexOf("/") === 0) {
                                    absoluteHref += href;
                                }
                                else {
                                    const path = loc.pathname.split("/");
                                    path.pop();
                                    const finalPath = path.join("/");
                                    absoluteHref += finalPath + "/" + href;
                                }
                                icons.push(absoluteHref);
                            }
                            else if (href.indexOf("//") === 0) {
                                const absoluteUrl = loc.protocol + href;
                                icons.push(absoluteUrl);
                            }
                            else {
                                icons.push(href);
                            }
                        }
                    }
                }
            }
            return icons;
        }
        function getWindowMetadataOfAny(...args) {
            const metaTags = doc.getElementsByTagName("meta");
            for (let i = 0; i < metaTags.length; i++) {
                const tag = metaTags[i];
                const attributes = ["itemprop", "property", "name"]
                    .map((target) => tag.getAttribute(target))
                    .filter((attr) => {
                    if (attr) {
                        return args.includes(attr);
                    }
                    return false;
                });
                if (attributes.length && attributes) {
                    const content = tag.getAttribute("content");
                    if (content) {
                        return content;
                    }
                }
            }
            return "";
        }
        function getName() {
            let name = getWindowMetadataOfAny("name", "og:site_name", "og:title", "twitter:title");
            if (!name) {
                name = doc.title;
            }
            return name;
        }
        function getDescription() {
            const description = getWindowMetadataOfAny("description", "og:description", "twitter:description", "keywords");
            return description;
        }
        const name = getName();
        const description = getDescription();
        const url = loc.origin;
        const icons = getIcons();
        const meta = {
            description,
            url,
            icons,
            name,
        };
        return meta;
    }
    getWindowMetadata_1 = cjs$5.getWindowMetadata = getWindowMetadata;

    var queryString = {};

    var strictUriEncode = str => encodeURIComponent(str).replace(/[!'()*]/g, x => `%${x.charCodeAt(0).toString(16).toUpperCase()}`);

    var token = '%[a-f0-9]{2}';
    var singleMatcher = new RegExp('(' + token + ')|([^%]+?)', 'gi');
    var multiMatcher = new RegExp('(' + token + ')+', 'gi');

    function decodeComponents(components, split) {
    	try {
    		// Try to decode the entire string first
    		return [decodeURIComponent(components.join(''))];
    	} catch (err) {
    		// Do nothing
    	}

    	if (components.length === 1) {
    		return components;
    	}

    	split = split || 1;

    	// Split the array in 2 parts
    	var left = components.slice(0, split);
    	var right = components.slice(split);

    	return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
    }

    function decode(input) {
    	try {
    		return decodeURIComponent(input);
    	} catch (err) {
    		var tokens = input.match(singleMatcher) || [];

    		for (var i = 1; i < tokens.length; i++) {
    			input = decodeComponents(tokens, i).join('');

    			tokens = input.match(singleMatcher) || [];
    		}

    		return input;
    	}
    }

    function customDecodeURIComponent(input) {
    	// Keep track of all the replacements and prefill the map with the `BOM`
    	var replaceMap = {
    		'%FE%FF': '\uFFFD\uFFFD',
    		'%FF%FE': '\uFFFD\uFFFD'
    	};

    	var match = multiMatcher.exec(input);
    	while (match) {
    		try {
    			// Decode as big chunks as possible
    			replaceMap[match[0]] = decodeURIComponent(match[0]);
    		} catch (err) {
    			var result = decode(match[0]);

    			if (result !== match[0]) {
    				replaceMap[match[0]] = result;
    			}
    		}

    		match = multiMatcher.exec(input);
    	}

    	// Add `%C2` at the end of the map to make sure it does not replace the combinator before everything else
    	replaceMap['%C2'] = '\uFFFD';

    	var entries = Object.keys(replaceMap);

    	for (var i = 0; i < entries.length; i++) {
    		// Replace all decoded components
    		var key = entries[i];
    		input = input.replace(new RegExp(key, 'g'), replaceMap[key]);
    	}

    	return input;
    }

    var decodeUriComponent = function (encodedURI) {
    	if (typeof encodedURI !== 'string') {
    		throw new TypeError('Expected `encodedURI` to be of type `string`, got `' + typeof encodedURI + '`');
    	}

    	try {
    		encodedURI = encodedURI.replace(/\+/g, ' ');

    		// Try the built in decoder first
    		return decodeURIComponent(encodedURI);
    	} catch (err) {
    		// Fallback to a more advanced decoder
    		return customDecodeURIComponent(encodedURI);
    	}
    };

    var splitOnFirst = (string, separator) => {
    	if (!(typeof string === 'string' && typeof separator === 'string')) {
    		throw new TypeError('Expected the arguments to be of type `string`');
    	}

    	if (separator === '') {
    		return [string];
    	}

    	const separatorIndex = string.indexOf(separator);

    	if (separatorIndex === -1) {
    		return [string];
    	}

    	return [
    		string.slice(0, separatorIndex),
    		string.slice(separatorIndex + separator.length)
    	];
    };

    var filterObj = function (obj, predicate) {
    	var ret = {};
    	var keys = Object.keys(obj);
    	var isArr = Array.isArray(predicate);

    	for (var i = 0; i < keys.length; i++) {
    		var key = keys[i];
    		var val = obj[key];

    		if (isArr ? predicate.indexOf(key) !== -1 : predicate(key, val, obj)) {
    			ret[key] = val;
    		}
    	}

    	return ret;
    };

    (function (exports) {
    	const strictUriEncode$1 = strictUriEncode;
    	const decodeComponent = decodeUriComponent;
    	const splitOnFirst$1 = splitOnFirst;
    	const filterObject = filterObj;

    	const isNullOrUndefined = value => value === null || value === undefined;

    	const encodeFragmentIdentifier = Symbol('encodeFragmentIdentifier');

    	function encoderForArrayFormat(options) {
    		switch (options.arrayFormat) {
    			case 'index':
    				return key => (result, value) => {
    					const index = result.length;

    					if (
    						value === undefined ||
    						(options.skipNull && value === null) ||
    						(options.skipEmptyString && value === '')
    					) {
    						return result;
    					}

    					if (value === null) {
    						return [...result, [encode(key, options), '[', index, ']'].join('')];
    					}

    					return [
    						...result,
    						[encode(key, options), '[', encode(index, options), ']=', encode(value, options)].join('')
    					];
    				};

    			case 'bracket':
    				return key => (result, value) => {
    					if (
    						value === undefined ||
    						(options.skipNull && value === null) ||
    						(options.skipEmptyString && value === '')
    					) {
    						return result;
    					}

    					if (value === null) {
    						return [...result, [encode(key, options), '[]'].join('')];
    					}

    					return [...result, [encode(key, options), '[]=', encode(value, options)].join('')];
    				};

    			case 'colon-list-separator':
    				return key => (result, value) => {
    					if (
    						value === undefined ||
    						(options.skipNull && value === null) ||
    						(options.skipEmptyString && value === '')
    					) {
    						return result;
    					}

    					if (value === null) {
    						return [...result, [encode(key, options), ':list='].join('')];
    					}

    					return [...result, [encode(key, options), ':list=', encode(value, options)].join('')];
    				};

    			case 'comma':
    			case 'separator':
    			case 'bracket-separator': {
    				const keyValueSep = options.arrayFormat === 'bracket-separator' ?
    					'[]=' :
    					'=';

    				return key => (result, value) => {
    					if (
    						value === undefined ||
    						(options.skipNull && value === null) ||
    						(options.skipEmptyString && value === '')
    					) {
    						return result;
    					}

    					// Translate null to an empty string so that it doesn't serialize as 'null'
    					value = value === null ? '' : value;

    					if (result.length === 0) {
    						return [[encode(key, options), keyValueSep, encode(value, options)].join('')];
    					}

    					return [[result, encode(value, options)].join(options.arrayFormatSeparator)];
    				};
    			}

    			default:
    				return key => (result, value) => {
    					if (
    						value === undefined ||
    						(options.skipNull && value === null) ||
    						(options.skipEmptyString && value === '')
    					) {
    						return result;
    					}

    					if (value === null) {
    						return [...result, encode(key, options)];
    					}

    					return [...result, [encode(key, options), '=', encode(value, options)].join('')];
    				};
    		}
    	}

    	function parserForArrayFormat(options) {
    		let result;

    		switch (options.arrayFormat) {
    			case 'index':
    				return (key, value, accumulator) => {
    					result = /\[(\d*)\]$/.exec(key);

    					key = key.replace(/\[\d*\]$/, '');

    					if (!result) {
    						accumulator[key] = value;
    						return;
    					}

    					if (accumulator[key] === undefined) {
    						accumulator[key] = {};
    					}

    					accumulator[key][result[1]] = value;
    				};

    			case 'bracket':
    				return (key, value, accumulator) => {
    					result = /(\[\])$/.exec(key);
    					key = key.replace(/\[\]$/, '');

    					if (!result) {
    						accumulator[key] = value;
    						return;
    					}

    					if (accumulator[key] === undefined) {
    						accumulator[key] = [value];
    						return;
    					}

    					accumulator[key] = [].concat(accumulator[key], value);
    				};

    			case 'colon-list-separator':
    				return (key, value, accumulator) => {
    					result = /(:list)$/.exec(key);
    					key = key.replace(/:list$/, '');

    					if (!result) {
    						accumulator[key] = value;
    						return;
    					}

    					if (accumulator[key] === undefined) {
    						accumulator[key] = [value];
    						return;
    					}

    					accumulator[key] = [].concat(accumulator[key], value);
    				};

    			case 'comma':
    			case 'separator':
    				return (key, value, accumulator) => {
    					const isArray = typeof value === 'string' && value.includes(options.arrayFormatSeparator);
    					const isEncodedArray = (typeof value === 'string' && !isArray && decode(value, options).includes(options.arrayFormatSeparator));
    					value = isEncodedArray ? decode(value, options) : value;
    					const newValue = isArray || isEncodedArray ? value.split(options.arrayFormatSeparator).map(item => decode(item, options)) : value === null ? value : decode(value, options);
    					accumulator[key] = newValue;
    				};

    			case 'bracket-separator':
    				return (key, value, accumulator) => {
    					const isArray = /(\[\])$/.test(key);
    					key = key.replace(/\[\]$/, '');

    					if (!isArray) {
    						accumulator[key] = value ? decode(value, options) : value;
    						return;
    					}

    					const arrayValue = value === null ?
    						[] :
    						value.split(options.arrayFormatSeparator).map(item => decode(item, options));

    					if (accumulator[key] === undefined) {
    						accumulator[key] = arrayValue;
    						return;
    					}

    					accumulator[key] = [].concat(accumulator[key], arrayValue);
    				};

    			default:
    				return (key, value, accumulator) => {
    					if (accumulator[key] === undefined) {
    						accumulator[key] = value;
    						return;
    					}

    					accumulator[key] = [].concat(accumulator[key], value);
    				};
    		}
    	}

    	function validateArrayFormatSeparator(value) {
    		if (typeof value !== 'string' || value.length !== 1) {
    			throw new TypeError('arrayFormatSeparator must be single character string');
    		}
    	}

    	function encode(value, options) {
    		if (options.encode) {
    			return options.strict ? strictUriEncode$1(value) : encodeURIComponent(value);
    		}

    		return value;
    	}

    	function decode(value, options) {
    		if (options.decode) {
    			return decodeComponent(value);
    		}

    		return value;
    	}

    	function keysSorter(input) {
    		if (Array.isArray(input)) {
    			return input.sort();
    		}

    		if (typeof input === 'object') {
    			return keysSorter(Object.keys(input))
    				.sort((a, b) => Number(a) - Number(b))
    				.map(key => input[key]);
    		}

    		return input;
    	}

    	function removeHash(input) {
    		const hashStart = input.indexOf('#');
    		if (hashStart !== -1) {
    			input = input.slice(0, hashStart);
    		}

    		return input;
    	}

    	function getHash(url) {
    		let hash = '';
    		const hashStart = url.indexOf('#');
    		if (hashStart !== -1) {
    			hash = url.slice(hashStart);
    		}

    		return hash;
    	}

    	function extract(input) {
    		input = removeHash(input);
    		const queryStart = input.indexOf('?');
    		if (queryStart === -1) {
    			return '';
    		}

    		return input.slice(queryStart + 1);
    	}

    	function parseValue(value, options) {
    		if (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === 'string' && value.trim() !== '')) {
    			value = Number(value);
    		} else if (options.parseBooleans && value !== null && (value.toLowerCase() === 'true' || value.toLowerCase() === 'false')) {
    			value = value.toLowerCase() === 'true';
    		}

    		return value;
    	}

    	function parse(query, options) {
    		options = Object.assign({
    			decode: true,
    			sort: true,
    			arrayFormat: 'none',
    			arrayFormatSeparator: ',',
    			parseNumbers: false,
    			parseBooleans: false
    		}, options);

    		validateArrayFormatSeparator(options.arrayFormatSeparator);

    		const formatter = parserForArrayFormat(options);

    		// Create an object with no prototype
    		const ret = Object.create(null);

    		if (typeof query !== 'string') {
    			return ret;
    		}

    		query = query.trim().replace(/^[?#&]/, '');

    		if (!query) {
    			return ret;
    		}

    		for (const param of query.split('&')) {
    			if (param === '') {
    				continue;
    			}

    			let [key, value] = splitOnFirst$1(options.decode ? param.replace(/\+/g, ' ') : param, '=');

    			// Missing `=` should be `null`:
    			// http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters
    			value = value === undefined ? null : ['comma', 'separator', 'bracket-separator'].includes(options.arrayFormat) ? value : decode(value, options);
    			formatter(decode(key, options), value, ret);
    		}

    		for (const key of Object.keys(ret)) {
    			const value = ret[key];
    			if (typeof value === 'object' && value !== null) {
    				for (const k of Object.keys(value)) {
    					value[k] = parseValue(value[k], options);
    				}
    			} else {
    				ret[key] = parseValue(value, options);
    			}
    		}

    		if (options.sort === false) {
    			return ret;
    		}

    		return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key) => {
    			const value = ret[key];
    			if (Boolean(value) && typeof value === 'object' && !Array.isArray(value)) {
    				// Sort object keys, not values
    				result[key] = keysSorter(value);
    			} else {
    				result[key] = value;
    			}

    			return result;
    		}, Object.create(null));
    	}

    	exports.extract = extract;
    	exports.parse = parse;

    	exports.stringify = (object, options) => {
    		if (!object) {
    			return '';
    		}

    		options = Object.assign({
    			encode: true,
    			strict: true,
    			arrayFormat: 'none',
    			arrayFormatSeparator: ','
    		}, options);

    		validateArrayFormatSeparator(options.arrayFormatSeparator);

    		const shouldFilter = key => (
    			(options.skipNull && isNullOrUndefined(object[key])) ||
    			(options.skipEmptyString && object[key] === '')
    		);

    		const formatter = encoderForArrayFormat(options);

    		const objectCopy = {};

    		for (const key of Object.keys(object)) {
    			if (!shouldFilter(key)) {
    				objectCopy[key] = object[key];
    			}
    		}

    		const keys = Object.keys(objectCopy);

    		if (options.sort !== false) {
    			keys.sort(options.sort);
    		}

    		return keys.map(key => {
    			const value = object[key];

    			if (value === undefined) {
    				return '';
    			}

    			if (value === null) {
    				return encode(key, options);
    			}

    			if (Array.isArray(value)) {
    				if (value.length === 0 && options.arrayFormat === 'bracket-separator') {
    					return encode(key, options) + '[]';
    				}

    				return value
    					.reduce(formatter(key), [])
    					.join('&');
    			}

    			return encode(key, options) + '=' + encode(value, options);
    		}).filter(x => x.length > 0).join('&');
    	};

    	exports.parseUrl = (url, options) => {
    		options = Object.assign({
    			decode: true
    		}, options);

    		const [url_, hash] = splitOnFirst$1(url, '#');

    		return Object.assign(
    			{
    				url: url_.split('?')[0] || '',
    				query: parse(extract(url), options)
    			},
    			options && options.parseFragmentIdentifier && hash ? {fragmentIdentifier: decode(hash, options)} : {}
    		);
    	};

    	exports.stringifyUrl = (object, options) => {
    		options = Object.assign({
    			encode: true,
    			strict: true,
    			[encodeFragmentIdentifier]: true
    		}, options);

    		const url = removeHash(object.url).split('?')[0] || '';
    		const queryFromUrl = exports.extract(object.url);
    		const parsedQueryFromUrl = exports.parse(queryFromUrl, {sort: false});

    		const query = Object.assign(parsedQueryFromUrl, object.query);
    		let queryString = exports.stringify(query, options);
    		if (queryString) {
    			queryString = `?${queryString}`;
    		}

    		let hash = getHash(object.url);
    		if (object.fragmentIdentifier) {
    			hash = `#${options[encodeFragmentIdentifier] ? encode(object.fragmentIdentifier, options) : object.fragmentIdentifier}`;
    		}

    		return `${url}${queryString}${hash}`;
    	};

    	exports.pick = (input, filter, options) => {
    		options = Object.assign({
    			parseFragmentIdentifier: true,
    			[encodeFragmentIdentifier]: false
    		}, options);

    		const {url, query, fragmentIdentifier} = exports.parseUrl(input, options);
    		return exports.stringifyUrl({
    			url,
    			query: filterObject(query, filter),
    			fragmentIdentifier
    		}, options);
    	};

    	exports.exclude = (input, filter, options) => {
    		const exclusionFilter = Array.isArray(filter) ? key => !filter.includes(key) : (key, value) => !filter(key, value);

    		return exports.pick(input, exclusionFilter, options);
    	}; 
    } (queryString));

    const RELAY_JSONRPC = {
        waku: {
            publish: "waku_publish",
            batchPublish: "waku_batchPublish",
            subscribe: "waku_subscribe",
            batchSubscribe: "waku_batchSubscribe",
            subscription: "waku_subscription",
            unsubscribe: "waku_unsubscribe",
            batchUnsubscribe: "waku_batchUnsubscribe",
        },
        irn: {
            publish: "irn_publish",
            batchPublish: "irn_batchPublish",
            subscribe: "irn_subscribe",
            batchSubscribe: "irn_batchSubscribe",
            subscription: "irn_subscription",
            unsubscribe: "irn_unsubscribe",
            batchUnsubscribe: "irn_batchUnsubscribe",
        },
        iridium: {
            publish: "iridium_publish",
            batchPublish: "iridium_batchPublish",
            subscribe: "iridium_subscribe",
            batchSubscribe: "iridium_batchSubscribe",
            subscription: "iridium_subscription",
            unsubscribe: "iridium_unsubscribe",
            batchUnsubscribe: "iridium_batchUnsubscribe",
        },
    };

    const K$7=":";function ve$1(e){const[n,t]=e.split(K$7);return {namespace:n,reference:t}}function Un(e,n=[]){const t=[];return Object.keys(e).forEach(r=>{if(n.length&&!n.includes(r))return;const o=e[r];t.push(...o.accounts);}),t}function L$9(e,n){return e.includes(":")?[e]:n.chains||[]}const J$2="base10",p$c="base16",F$6="base64pad",H$7="utf8",Q$5=0,_$a=1,Dn=0,Te$1=1,Z$7=12,X$2=32;function kn(){const e=x25519.generateKeyPair();return {privateKey:toString$1(e.secretKey,p$c),publicKey:toString$1(e.publicKey,p$c)}}function Vn$1(){const e=random.randomBytes(X$2);return toString$1(e,p$c)}function Mn(e,n){const t=x25519.sharedKey(fromString$1(e,p$c),fromString$1(n,p$c),!0),r=new HKDF_1(sha256$1.SHA256,t).expand(X$2);return toString$1(r,p$c)}function Kn(e){const n=sha256$1.hash(fromString$1(e,p$c));return toString$1(n,p$c)}function Ln(e){const n=sha256$1.hash(fromString$1(e,H$7));return toString$1(n,p$c)}function Pe$1(e){return fromString$1(`${e}`,J$2)}function j$9(e){return Number(toString$1(e,J$2))}function xn(e){const n=Pe$1(typeof e.type<"u"?e.type:Q$5);if(j$9(n)===_$a&&typeof e.senderPublicKey>"u")throw new Error("Missing sender public key for type 1 envelope");const t=typeof e.senderPublicKey<"u"?fromString$1(e.senderPublicKey,p$c):void 0,r=typeof e.iv<"u"?fromString$1(e.iv,p$c):random.randomBytes(Z$7),o=new chacha20poly1305.ChaCha20Poly1305(fromString$1(e.symKey,p$c)).seal(r,fromString$1(e.message,H$7));return Re$1({type:n,sealed:o,iv:r,senderPublicKey:t})}function Fn(e){const n=new chacha20poly1305.ChaCha20Poly1305(fromString$1(e.symKey,p$c)),{sealed:t,iv:r}=ee$2(e.encoded),o=n.open(r,t);if(o===null)throw new Error("Failed to decrypt");return toString$1(o,H$7)}function Re$1(e){if(j$9(e.type)===_$a){if(typeof e.senderPublicKey>"u")throw new Error("Missing sender public key for type 1 envelope");return toString$1(concat$1([e.type,e.senderPublicKey,e.iv,e.sealed]),F$6)}return toString$1(concat$1([e.type,e.iv,e.sealed]),F$6)}function ee$2(e){const n=fromString$1(e,F$6),t=n.slice(Dn,Te$1),r=Te$1;if(j$9(t)===_$a){const d=r+X$2,l=d+Z$7,c=n.slice(r,d),u=n.slice(d,l),a=n.slice(l);return {type:t,sealed:a,iv:u,senderPublicKey:c}}const o=r+Z$7,s=n.slice(r,o),i=n.slice(o);return {type:t,sealed:i,iv:s}}function Hn(e,n){const t=ee$2(e);return Ae$1({type:j$9(t.type),senderPublicKey:typeof t.senderPublicKey<"u"?toString$1(t.senderPublicKey,p$c):void 0,receiverPublicKey:n?.receiverPublicKey})}function Ae$1(e){const n=e?.type||Q$5;if(n===_$a){if(typeof e?.senderPublicKey>"u")throw new Error("missing sender public key");if(typeof e?.receiverPublicKey>"u")throw new Error("missing receiver public key")}return {type:n,senderPublicKey:e?.senderPublicKey,receiverPublicKey:e?.receiverPublicKey}}function qn(e){return e.type===_$a&&typeof e.senderPublicKey=="string"&&typeof e.receiverPublicKey=="string"}var Bn=Object.defineProperty,Ue$2=Object.getOwnPropertySymbols,Gn=Object.prototype.hasOwnProperty,Wn=Object.prototype.propertyIsEnumerable,_e$1=(e,n,t)=>n in e?Bn(e,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[n]=t,$e$2=(e,n)=>{for(var t in n||(n={}))Gn.call(n,t)&&_e$1(e,t,n[t]);if(Ue$2)for(var t of Ue$2(n))Wn.call(n,t)&&_e$1(e,t,n[t]);return e};const Ce$1="ReactNative",m$8={reactNative:"react-native",node:"node",browser:"browser",unknown:"unknown"},De$2="js";function te$3(){return typeof browser$1$1<"u"&&typeof browser$1$1.versions<"u"&&typeof browser$1$1.versions.node<"u"}function $$8(){return !getDocument_1()&&!!getNavigator_1()&&navigator.product===Ce$1}function D$9(){return !te$3()&&!!getNavigator_1()&&!!getDocument_1()}function R$7(){return $$8()?m$8.reactNative:te$3()?m$8.node:D$9()?m$8.browser:m$8.unknown}function Jn(){var e;try{return $$8()&&typeof global$1<"u"&&typeof(global$1==null?void 0:global$1.Application)<"u"?(e=global$1.Application)==null?void 0:e.applicationId:void 0}catch{return}}function ke$2(e,n){let t=queryString.parse(e);return t=$e$2($e$2({},t),n),e=queryString.stringify(t),e}function Qn(){return getWindowMetadata_1()||{name:"",description:"",url:"",icons:[""]}}function Ve$2(){if(R$7()===m$8.reactNative&&typeof global$1<"u"&&typeof(global$1==null?void 0:global$1.Platform)<"u"){const{OS:t,Version:r}=global$1.Platform;return [t,r].join("-")}const e=detect();if(e===null)return "unknown";const n=e.os?e.os.replace(" ","").toLowerCase():"unknown";return e.type==="browser"?[n,e.name,e.version].join("-"):[n,e.version].join("-")}function Me$2(){var e;const n=R$7();return n===m$8.browser?[n,((e=getLocation_1())==null?void 0:e.host)||"unknown"].join(":"):n}function Ke$2(e,n,t){const r=Ve$2(),o=Me$2();return [[e,n].join("-"),[De$2,t].join("-"),r,o].join("/")}function Xn({protocol:e,version:n,relayUrl:t,sdkVersion:r,auth:o,projectId:s,useOnCloseEvent:i,bundleId:d}){const l=t.split("?"),c=Ke$2(e,n,r),u={auth:o,ua:c,projectId:s,useOnCloseEvent:i||void 0,origin:d||void 0},a=ke$2(l[1]||"",u);return l[0]+"?"+a}function O$5(e,n){return e.filter(t=>n.includes(t)).length===e.length}function rt$2(e){return Object.fromEntries(e.entries())}function ot$2(e){return new Map(Object.entries(e))}function at$2(e=cjs$7.FIVE_MINUTES,n){const t=cjs$7.toMiliseconds(e||cjs$7.FIVE_MINUTES);let r,o,s;return {resolve:i=>{s&&r&&(clearTimeout(s),r(i));},reject:i=>{s&&o&&(clearTimeout(s),o(i));},done:()=>new Promise((i,d)=>{s=setTimeout(()=>{d(new Error(n));},t),r=i,o=d;})}}function ut$2(e,n,t){return new Promise(async(r,o)=>{const s=setTimeout(()=>o(new Error(t)),n);try{const i=await e;r(i);}catch(i){o(i);}clearTimeout(s);})}function re$4(e,n){if(typeof n=="string"&&n.startsWith(`${e}:`))return n;if(e.toLowerCase()==="topic"){if(typeof n!="string")throw new Error('Value must be "string" for expirer target type: topic');return `topic:${n}`}else if(e.toLowerCase()==="id"){if(typeof n!="number")throw new Error('Value must be "number" for expirer target type: id');return `id:${n}`}throw new Error(`Unknown expirer target type: ${e}`)}function lt$6(e){return re$4("topic",e)}function dt$2(e){return re$4("id",e)}function ft$5(e){const[n,t]=e.split(":"),r={id:void 0,topic:void 0};if(n==="topic"&&typeof t=="string")r.topic=t;else if(n==="id"&&Number.isInteger(Number(t)))r.id=Number(t);else throw new Error(`Invalid target, expected id:number or topic:string, got ${n}:${t}`);return r}function pt$2(e,n){return cjs$7.fromMiliseconds((n||Date.now())+cjs$7.toMiliseconds(e))}function mt$2(e){return Date.now()>=cjs$7.toMiliseconds(e)}function yt$2(e,n){return `${e}${n?`:${n}`:""}`}function S$d(e=[],n=[]){return [...new Set([...e,...n])]}async function gt$7({id:e,topic:n,wcDeepLink:t}){try{if(!t)return;const r=typeof t=="string"?JSON.parse(t):t;let o=r?.href;if(typeof o!="string")return;o.endsWith("/")&&(o=o.slice(0,-1));const s=`${o}/wc?requestId=${e}&sessionTopic=${n}`,i=R$7();i===m$8.browser?s.startsWith("https://")?window.open(s,"_blank","noreferrer noopener"):window.open(s,"_self","noreferrer noopener"):i===m$8.reactNative&&typeof(global$1==null?void 0:global$1.Linking)<"u"&&await global$1.Linking.openURL(s);}catch(r){console.error(r);}}async function ht$2(e,n){try{return await e.getItem(n)||(D$9()?localStorage.getItem(n):void 0)}catch(t){console.error(t);}}const He$2="irn";function vt$2(e){return e?.relay||{protocol:He$2}}function Et$2(e){const n=RELAY_JSONRPC[e];if(typeof n>"u")throw new Error(`Relay Protocol not supported: ${e}`);return n}var bt$2=Object.defineProperty,Nt$2=Object.defineProperties,Ot$2=Object.getOwnPropertyDescriptors,qe$2=Object.getOwnPropertySymbols,St$2=Object.prototype.hasOwnProperty,wt$2=Object.prototype.propertyIsEnumerable,Be$2=(e,n,t)=>n in e?bt$2(e,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[n]=t,It$2=(e,n)=>{for(var t in n||(n={}))St$2.call(n,t)&&Be$2(e,t,n[t]);if(qe$2)for(var t of qe$2(n))wt$2.call(n,t)&&Be$2(e,t,n[t]);return e},Tt$2=(e,n)=>Nt$2(e,Ot$2(n));function Ge$2(e,n="-"){const t={},r="relay"+n;return Object.keys(e).forEach(o=>{if(o.startsWith(r)){const s=o.replace(r,""),i=e[o];t[s]=i;}}),t}function Pt$2(e){e=e.includes("wc://")?e.replace("wc://",""):e,e=e.includes("wc:")?e.replace("wc:",""):e;const n=e.indexOf(":"),t=e.indexOf("?")!==-1?e.indexOf("?"):void 0,r=e.substring(0,n),o=e.substring(n+1,t).split("@"),s=typeof t<"u"?e.substring(t):"",i=queryString.parse(s);return {protocol:r,topic:We$2(o[0]),version:parseInt(o[1],10),symKey:i.symKey,relay:Ge$2(i),expiryTimestamp:i.expiryTimestamp?parseInt(i.expiryTimestamp,10):void 0}}function We$2(e){return e.startsWith("//")?e.substring(2):e}function ze$1(e,n="-"){const t="relay",r={};return Object.keys(e).forEach(o=>{const s=t+n+o;e[o]&&(r[s]=e[o]);}),r}function Rt$2(e){return `${e.protocol}:${e.topic}@${e.version}?`+queryString.stringify(Tt$2(It$2({symKey:e.symKey},ze$1(e.relay)),{expiryTimestamp:e.expiryTimestamp}))}function A$7(e){const n=[];return e.forEach(t=>{const[r,o]=t.split(":");n.push(`${r}:${o}`);}),n}function Qe$2(e){const n=[];return Object.values(e).forEach(t=>{n.push(...A$7(t.accounts));}),n}function Ze$1(e,n){const t=[];return Object.values(e).forEach(r=>{A$7(r.accounts).includes(n)&&t.push(...r.methods);}),t}function Xe$1(e,n){const t=[];return Object.values(e).forEach(r=>{A$7(r.accounts).includes(n)&&t.push(...r.events);}),t}function oe$3(e){return e.includes(":")}function en(e){return oe$3(e)?e.split(":")[0]:e}const nn={INVALID_METHOD:{message:"Invalid method.",code:1001},INVALID_EVENT:{message:"Invalid event.",code:1002},INVALID_UPDATE_REQUEST:{message:"Invalid update request.",code:1003},INVALID_EXTEND_REQUEST:{message:"Invalid extend request.",code:1004},INVALID_SESSION_SETTLE_REQUEST:{message:"Invalid session settle request.",code:1005},UNAUTHORIZED_METHOD:{message:"Unauthorized method.",code:3001},UNAUTHORIZED_EVENT:{message:"Unauthorized event.",code:3002},UNAUTHORIZED_UPDATE_REQUEST:{message:"Unauthorized update request.",code:3003},UNAUTHORIZED_EXTEND_REQUEST:{message:"Unauthorized extend request.",code:3004},USER_REJECTED:{message:"User rejected.",code:5e3},USER_REJECTED_CHAINS:{message:"User rejected chains.",code:5001},USER_REJECTED_METHODS:{message:"User rejected methods.",code:5002},USER_REJECTED_EVENTS:{message:"User rejected events.",code:5003},UNSUPPORTED_CHAINS:{message:"Unsupported chains.",code:5100},UNSUPPORTED_METHODS:{message:"Unsupported methods.",code:5101},UNSUPPORTED_EVENTS:{message:"Unsupported events.",code:5102},UNSUPPORTED_ACCOUNTS:{message:"Unsupported accounts.",code:5103},UNSUPPORTED_NAMESPACE_KEY:{message:"Unsupported namespace key.",code:5104},USER_DISCONNECTED:{message:"User disconnected.",code:6e3},SESSION_SETTLEMENT_FAILED:{message:"Session settlement failed.",code:7e3},WC_METHOD_UNSUPPORTED:{message:"Unsupported wc_ method.",code:10001}},tn={NOT_INITIALIZED:{message:"Not initialized.",code:1},NO_MATCHING_KEY:{message:"No matching key.",code:2},RESTORE_WILL_OVERRIDE:{message:"Restore will override.",code:3},RESUBSCRIBED:{message:"Resubscribed.",code:4},MISSING_OR_INVALID:{message:"Missing or invalid.",code:5},EXPIRED:{message:"Expired.",code:6},UNKNOWN_TYPE:{message:"Unknown type.",code:7},MISMATCHED_TOPIC:{message:"Mismatched topic.",code:8},NON_CONFORMING_NAMESPACES:{message:"Non conforming namespaces.",code:9}};function N$8(e,n){const{message:t,code:r}=tn[e];return {message:n?`${t} ${n}`:t,code:r}}function U$3(e,n){const{message:t,code:r}=nn[e];return {message:n?`${t} ${n}`:t,code:r}}function k$8(e,n){return Array.isArray(e)?typeof n<"u"&&e.length?e.every(n):!0:!1}function B$6(e){return Object.getPrototypeOf(e)===Object.prototype&&Object.keys(e).length}function w$a(e){return typeof e>"u"}function g$b(e,n){return n&&w$a(e)?!0:typeof e=="string"&&!!e.trim().length}function G$4(e,n){return n&&w$a(e)?!0:typeof e=="number"&&!isNaN(e)}function Mt$2(e,n){const{requiredNamespaces:t}=n,r=Object.keys(e.namespaces),o=Object.keys(t);let s=!0;return O$5(o,r)?(r.forEach(i=>{const{accounts:d,methods:l,events:c}=e.namespaces[i],u=A$7(d),a=t[i];(!O$5(L$9(i,a),u)||!O$5(a.methods,l)||!O$5(a.events,c))&&(s=!1);}),s):!1}function V$7(e){return g$b(e,!1)&&e.includes(":")?e.split(":").length===2:!1}function rn(e){if(g$b(e,!1)&&e.includes(":")){const n=e.split(":");if(n.length===3){const t=n[0]+":"+n[1];return !!n[2]&&V$7(t)}}return !1}function Kt$2(e){if(g$b(e,!1))try{return typeof new URL(e)<"u"}catch{return !1}return !1}function Lt$2(e){var n;return (n=e?.proposer)==null?void 0:n.publicKey}function xt$2(e){return e?.topic}function Ft$2(e,n){let t=null;return g$b(e?.publicKey,!1)||(t=N$8("MISSING_OR_INVALID",`${n} controller public key should be a string`)),t}function ie$1(e){let n=!0;return k$8(e)?e.length&&(n=e.every(t=>g$b(t,!1))):n=!1,n}function on(e,n,t){let r=null;return k$8(n)&&n.length?n.forEach(o=>{r||V$7(o)||(r=U$3("UNSUPPORTED_CHAINS",`${t}, chain ${o} should be a string and conform to "namespace:chainId" format`));}):V$7(e)||(r=U$3("UNSUPPORTED_CHAINS",`${t}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`)),r}function sn(e,n,t){let r=null;return Object.entries(e).forEach(([o,s])=>{if(r)return;const i=on(o,L$9(o,s),`${n} ${t}`);i&&(r=i);}),r}function cn(e,n){let t=null;return k$8(e)?e.forEach(r=>{t||rn(r)||(t=U$3("UNSUPPORTED_ACCOUNTS",`${n}, account ${r} should be a string and conform to "namespace:chainId:address" format`));}):t=U$3("UNSUPPORTED_ACCOUNTS",`${n}, accounts should be an array of strings conforming to "namespace:chainId:address" format`),t}function an(e,n){let t=null;return Object.values(e).forEach(r=>{if(t)return;const o=cn(r?.accounts,`${n} namespace`);o&&(t=o);}),t}function un(e,n){let t=null;return ie$1(e?.methods)?ie$1(e?.events)||(t=U$3("UNSUPPORTED_EVENTS",`${n}, events should be an array of strings or empty array for no events`)):t=U$3("UNSUPPORTED_METHODS",`${n}, methods should be an array of strings or empty array for no methods`),t}function ce$3(e,n){let t=null;return Object.values(e).forEach(r=>{if(t)return;const o=un(r,`${n}, namespace`);o&&(t=o);}),t}function Ht$2(e,n,t){let r=null;if(e&&B$6(e)){const o=ce$3(e,n);o&&(r=o);const s=sn(e,n,t);s&&(r=s);}else r=N$8("MISSING_OR_INVALID",`${n}, ${t} should be an object with data`);return r}function ln(e,n){let t=null;if(e&&B$6(e)){const r=ce$3(e,n);r&&(t=r);const o=an(e,n);o&&(t=o);}else t=N$8("MISSING_OR_INVALID",`${n}, namespaces should be an object with data`);return t}function dn(e){return g$b(e.protocol,!0)}function qt$2(e,n){let t=!1;return n&&!e?t=!0:e&&k$8(e)&&e.length&&e.forEach(r=>{t=dn(r);}),t}function Bt$2(e){return typeof e=="number"}function Gt$2(e){return typeof e<"u"&&typeof e!==null}function Wt$1(e){return !(!e||typeof e!="object"||!e.code||!G$4(e.code,!1)||!e.message||!g$b(e.message,!1))}function zt$2(e){return !(w$a(e)||!g$b(e.method,!1))}function Yt$2(e){return !(w$a(e)||w$a(e.result)&&w$a(e.error)||!G$4(e.id,!1)||!g$b(e.jsonrpc,!1))}function Jt$2(e){return !(w$a(e)||!g$b(e.name,!1))}function Qt$1(e,n){return !(!V$7(n)||!Qe$2(e).includes(n))}function Zt$1(e,n,t){return g$b(t,!1)?Ze$1(e,n).includes(t):!1}function Xt$1(e,n,t){return g$b(t,!1)?Xe$1(e,n).includes(t):!1}function fn(e,n,t){let r=null;const o=er$2(e),s=nr$2(n),i=Object.keys(o),d=Object.keys(s),l=pn(Object.keys(e)),c=pn(Object.keys(n)),u=l.filter(a=>!c.includes(a));return u.length&&(r=N$8("NON_CONFORMING_NAMESPACES",`${t} namespaces keys don't satisfy requiredNamespaces.
      Required: ${u.toString()}
      Received: ${Object.keys(n).toString()}`)),O$5(i,d)||(r=N$8("NON_CONFORMING_NAMESPACES",`${t} namespaces chains don't satisfy required namespaces.
      Required: ${i.toString()}
      Approved: ${d.toString()}`)),Object.keys(n).forEach(a=>{if(!a.includes(":")||r)return;const b=A$7(n[a].accounts);b.includes(a)||(r=N$8("NON_CONFORMING_NAMESPACES",`${t} namespaces accounts don't satisfy namespace accounts for ${a}
        Required: ${a}
        Approved: ${b.toString()}`));}),i.forEach(a=>{r||(O$5(o[a].methods,s[a].methods)?O$5(o[a].events,s[a].events)||(r=N$8("NON_CONFORMING_NAMESPACES",`${t} namespaces events don't satisfy namespace events for ${a}`)):r=N$8("NON_CONFORMING_NAMESPACES",`${t} namespaces methods don't satisfy namespace methods for ${a}`));}),r}function er$2(e){const n={};return Object.keys(e).forEach(t=>{var r;t.includes(":")?n[t]=e[t]:(r=e[t].chains)==null||r.forEach(o=>{n[o]={methods:e[t].methods,events:e[t].events};});}),n}function pn(e){return [...new Set(e.map(n=>n.includes(":")?n.split(":")[0]:n))]}function nr$2(e){const n={};return Object.keys(e).forEach(t=>{if(t.includes(":"))n[t]=e[t];else {const r=A$7(e[t].accounts);r?.forEach(o=>{n[o]={accounts:e[t].accounts.filter(s=>s.includes(`${o}:`)),methods:e[t].methods,events:e[t].events};});}}),n}function tr$2(e,n){return G$4(e,!1)&&e<=n.max&&e>=n.min}function rr$2(){const e=R$7();return new Promise(n=>{switch(e){case m$8.browser:n(mn());break;case m$8.reactNative:n(yn());break;case m$8.node:n(gn());break;default:n(!0);}})}function mn(){return D$9()&&navigator?.onLine}async function yn(){if($$8()&&typeof global$1<"u"&&global$1!=null&&global$1.NetInfo){const e=await(global$1==null?void 0:global$1.NetInfo.fetch());return e?.isConnected}return !0}function gn(){return !0}function or$2(e){switch(R$7()){case m$8.browser:hn(e);break;case m$8.reactNative:vn(e);break;}}function hn(e){!$$8()&&D$9()&&(window.addEventListener("online",()=>e(!0)),window.addEventListener("offline",()=>e(!1)));}function vn(e){$$8()&&typeof global$1<"u"&&global$1!=null&&global$1.NetInfo&&global$1?.NetInfo.addEventListener(n=>e(n?.isConnected));}const ae$2={};let sr$2 = class sr{static get(n){return ae$2[n]}static set(n,t){ae$2[n]=t;}static delete(n){delete ae$2[n];}};

    const suspectProtoRx = /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/;
    const suspectConstructorRx = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/;
    const JsonSigRx = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;
    function jsonParseTransform(key, value) {
      if (key === "__proto__" || key === "constructor" && value && typeof value === "object" && "prototype" in value) {
        warnKeyDropped(key);
        return;
      }
      return value;
    }
    function warnKeyDropped(key) {
      console.warn(`[destr] Dropping "${key}" key to prevent prototype pollution.`);
    }
    function destr(value, options = {}) {
      if (typeof value !== "string") {
        return value;
      }
      const _value = value.trim();
      if (
        // eslint-disable-next-line unicorn/prefer-at
        value[0] === '"' && value.endsWith('"') && !value.includes("\\")
      ) {
        return _value.slice(1, -1);
      }
      if (_value.length <= 9) {
        const _lval = _value.toLowerCase();
        if (_lval === "true") {
          return true;
        }
        if (_lval === "false") {
          return false;
        }
        if (_lval === "undefined") {
          return void 0;
        }
        if (_lval === "null") {
          return null;
        }
        if (_lval === "nan") {
          return Number.NaN;
        }
        if (_lval === "infinity") {
          return Number.POSITIVE_INFINITY;
        }
        if (_lval === "-infinity") {
          return Number.NEGATIVE_INFINITY;
        }
      }
      if (!JsonSigRx.test(value)) {
        if (options.strict) {
          throw new SyntaxError("[destr] Invalid JSON");
        }
        return value;
      }
      try {
        if (suspectProtoRx.test(value) || suspectConstructorRx.test(value)) {
          if (options.strict) {
            throw new Error("[destr] Possible prototype pollution");
          }
          return JSON.parse(value, jsonParseTransform);
        }
        return JSON.parse(value);
      } catch (error) {
        if (options.strict) {
          throw error;
        }
        return value;
      }
    }

    function wrapToPromise(value) {
      if (!value || typeof value.then !== "function") {
        return Promise.resolve(value);
      }
      return value;
    }
    function asyncCall(function_, ...arguments_) {
      try {
        return wrapToPromise(function_(...arguments_));
      } catch (error) {
        return Promise.reject(error);
      }
    }
    function isPrimitive$1(value) {
      const type = typeof value;
      return value === null || type !== "object" && type !== "function";
    }
    function isPureObject(value) {
      const proto = Object.getPrototypeOf(value);
      return !proto || proto.isPrototypeOf(Object);
    }
    function stringify$2(value) {
      if (isPrimitive$1(value)) {
        return String(value);
      }
      if (isPureObject(value) || Array.isArray(value)) {
        return JSON.stringify(value);
      }
      if (typeof value.toJSON === "function") {
        return stringify$2(value.toJSON());
      }
      throw new Error("[unstorage] Cannot stringify value!");
    }
    function checkBufferSupport() {
      if (typeof Buffer === void 0) {
        throw new TypeError("[unstorage] Buffer is not supported!");
      }
    }
    const BASE64_PREFIX = "base64:";
    function serializeRaw(value) {
      if (typeof value === "string") {
        return value;
      }
      checkBufferSupport();
      const base64 = Buffer.from(value).toString("base64");
      return BASE64_PREFIX + base64;
    }
    function deserializeRaw(value) {
      if (typeof value !== "string") {
        return value;
      }
      if (!value.startsWith(BASE64_PREFIX)) {
        return value;
      }
      checkBufferSupport();
      return Buffer.from(value.slice(BASE64_PREFIX.length), "base64");
    }
    function normalizeKey(key) {
      if (!key) {
        return "";
      }
      return key.split("?")[0].replace(/[/\\]/g, ":").replace(/:+/g, ":").replace(/^:|:$/g, "");
    }
    function joinKeys(...keys) {
      return normalizeKey(keys.join(":"));
    }
    function normalizeBaseKey(base) {
      base = normalizeKey(base);
      return base ? base + ":" : "";
    }

    function defineDriver(factory) {
      return factory;
    }

    const DRIVER_NAME = "memory";
    const memory = defineDriver(() => {
      const data = /* @__PURE__ */ new Map();
      return {
        name: DRIVER_NAME,
        options: {},
        hasItem(key) {
          return data.has(key);
        },
        getItem(key) {
          return data.get(key) ?? null;
        },
        getItemRaw(key) {
          return data.get(key) ?? null;
        },
        setItem(key, value) {
          data.set(key, value);
        },
        setItemRaw(key, value) {
          data.set(key, value);
        },
        removeItem(key) {
          data.delete(key);
        },
        getKeys() {
          return Array.from(data.keys());
        },
        clear() {
          data.clear();
        },
        dispose() {
          data.clear();
        }
      };
    });

    function createStorage$1(options = {}) {
      const context = {
        mounts: { "": options.driver || memory() },
        mountpoints: [""],
        watching: false,
        watchListeners: [],
        unwatch: {}
      };
      const getMount = (key) => {
        for (const base of context.mountpoints) {
          if (key.startsWith(base)) {
            return {
              base,
              relativeKey: key.slice(base.length),
              driver: context.mounts[base]
            };
          }
        }
        return {
          base: "",
          relativeKey: key,
          driver: context.mounts[""]
        };
      };
      const getMounts = (base, includeParent) => {
        return context.mountpoints.filter(
          (mountpoint) => mountpoint.startsWith(base) || includeParent && base.startsWith(mountpoint)
        ).map((mountpoint) => ({
          relativeBase: base.length > mountpoint.length ? base.slice(mountpoint.length) : void 0,
          mountpoint,
          driver: context.mounts[mountpoint]
        }));
      };
      const onChange = (event, key) => {
        if (!context.watching) {
          return;
        }
        key = normalizeKey(key);
        for (const listener of context.watchListeners) {
          listener(event, key);
        }
      };
      const startWatch = async () => {
        if (context.watching) {
          return;
        }
        context.watching = true;
        for (const mountpoint in context.mounts) {
          context.unwatch[mountpoint] = await watch(
            context.mounts[mountpoint],
            onChange,
            mountpoint
          );
        }
      };
      const stopWatch = async () => {
        if (!context.watching) {
          return;
        }
        for (const mountpoint in context.unwatch) {
          await context.unwatch[mountpoint]();
        }
        context.unwatch = {};
        context.watching = false;
      };
      const runBatch = (items, commonOptions, cb) => {
        const batches = /* @__PURE__ */ new Map();
        const getBatch = (mount) => {
          let batch = batches.get(mount.base);
          if (!batch) {
            batch = {
              driver: mount.driver,
              base: mount.base,
              items: []
            };
            batches.set(mount.base, batch);
          }
          return batch;
        };
        for (const item of items) {
          const isStringItem = typeof item === "string";
          const key = normalizeKey(isStringItem ? item : item.key);
          const value = isStringItem ? void 0 : item.value;
          const options2 = isStringItem || !item.options ? commonOptions : { ...commonOptions, ...item.options };
          const mount = getMount(key);
          getBatch(mount).items.push({
            key,
            value,
            relativeKey: mount.relativeKey,
            options: options2
          });
        }
        return Promise.all([...batches.values()].map((batch) => cb(batch))).then(
          (r) => r.flat()
        );
      };
      const storage = {
        // Item
        hasItem(key, opts = {}) {
          key = normalizeKey(key);
          const { relativeKey, driver } = getMount(key);
          return asyncCall(driver.hasItem, relativeKey, opts);
        },
        getItem(key, opts = {}) {
          key = normalizeKey(key);
          const { relativeKey, driver } = getMount(key);
          return asyncCall(driver.getItem, relativeKey, opts).then(
            (value) => destr(value)
          );
        },
        getItems(items, commonOptions) {
          return runBatch(items, commonOptions, (batch) => {
            if (batch.driver.getItems) {
              return asyncCall(
                batch.driver.getItems,
                batch.items.map((item) => ({
                  key: item.relativeKey,
                  options: item.options
                })),
                commonOptions
              ).then(
                (r) => r.map((item) => ({
                  key: joinKeys(batch.base, item.key),
                  value: destr(item.value)
                }))
              );
            }
            return Promise.all(
              batch.items.map((item) => {
                return asyncCall(
                  batch.driver.getItem,
                  item.relativeKey,
                  item.options
                ).then((value) => ({
                  key: item.key,
                  value: destr(value)
                }));
              })
            );
          });
        },
        getItemRaw(key, opts = {}) {
          key = normalizeKey(key);
          const { relativeKey, driver } = getMount(key);
          if (driver.getItemRaw) {
            return asyncCall(driver.getItemRaw, relativeKey, opts);
          }
          return asyncCall(driver.getItem, relativeKey, opts).then(
            (value) => deserializeRaw(value)
          );
        },
        async setItem(key, value, opts = {}) {
          if (value === void 0) {
            return storage.removeItem(key);
          }
          key = normalizeKey(key);
          const { relativeKey, driver } = getMount(key);
          if (!driver.setItem) {
            return;
          }
          await asyncCall(driver.setItem, relativeKey, stringify$2(value), opts);
          if (!driver.watch) {
            onChange("update", key);
          }
        },
        async setItems(items, commonOptions) {
          await runBatch(items, commonOptions, async (batch) => {
            if (batch.driver.setItems) {
              return asyncCall(
                batch.driver.setItems,
                batch.items.map((item) => ({
                  key: item.relativeKey,
                  value: stringify$2(item.value),
                  options: item.options
                })),
                commonOptions
              );
            }
            if (!batch.driver.setItem) {
              return;
            }
            await Promise.all(
              batch.items.map((item) => {
                return asyncCall(
                  batch.driver.setItem,
                  item.relativeKey,
                  stringify$2(item.value),
                  item.options
                );
              })
            );
          });
        },
        async setItemRaw(key, value, opts = {}) {
          if (value === void 0) {
            return storage.removeItem(key, opts);
          }
          key = normalizeKey(key);
          const { relativeKey, driver } = getMount(key);
          if (driver.setItemRaw) {
            await asyncCall(driver.setItemRaw, relativeKey, value, opts);
          } else if (driver.setItem) {
            await asyncCall(driver.setItem, relativeKey, serializeRaw(value), opts);
          } else {
            return;
          }
          if (!driver.watch) {
            onChange("update", key);
          }
        },
        async removeItem(key, opts = {}) {
          if (typeof opts === "boolean") {
            opts = { removeMeta: opts };
          }
          key = normalizeKey(key);
          const { relativeKey, driver } = getMount(key);
          if (!driver.removeItem) {
            return;
          }
          await asyncCall(driver.removeItem, relativeKey, opts);
          if (opts.removeMeta || opts.removeMata) {
            await asyncCall(driver.removeItem, relativeKey + "$", opts);
          }
          if (!driver.watch) {
            onChange("remove", key);
          }
        },
        // Meta
        async getMeta(key, opts = {}) {
          if (typeof opts === "boolean") {
            opts = { nativeOnly: opts };
          }
          key = normalizeKey(key);
          const { relativeKey, driver } = getMount(key);
          const meta = /* @__PURE__ */ Object.create(null);
          if (driver.getMeta) {
            Object.assign(meta, await asyncCall(driver.getMeta, relativeKey, opts));
          }
          if (!opts.nativeOnly) {
            const value = await asyncCall(
              driver.getItem,
              relativeKey + "$",
              opts
            ).then((value_) => destr(value_));
            if (value && typeof value === "object") {
              if (typeof value.atime === "string") {
                value.atime = new Date(value.atime);
              }
              if (typeof value.mtime === "string") {
                value.mtime = new Date(value.mtime);
              }
              Object.assign(meta, value);
            }
          }
          return meta;
        },
        setMeta(key, value, opts = {}) {
          return this.setItem(key + "$", value, opts);
        },
        removeMeta(key, opts = {}) {
          return this.removeItem(key + "$", opts);
        },
        // Keys
        async getKeys(base, opts = {}) {
          base = normalizeBaseKey(base);
          const mounts = getMounts(base, true);
          let maskedMounts = [];
          const allKeys = [];
          for (const mount of mounts) {
            const rawKeys = await asyncCall(
              mount.driver.getKeys,
              mount.relativeBase,
              opts
            );
            const keys = rawKeys.map((key) => mount.mountpoint + normalizeKey(key)).filter((key) => !maskedMounts.some((p) => key.startsWith(p)));
            allKeys.push(...keys);
            maskedMounts = [
              mount.mountpoint,
              ...maskedMounts.filter((p) => !p.startsWith(mount.mountpoint))
            ];
          }
          return base ? allKeys.filter((key) => key.startsWith(base) && !key.endsWith("$")) : allKeys.filter((key) => !key.endsWith("$"));
        },
        // Utils
        async clear(base, opts = {}) {
          base = normalizeBaseKey(base);
          await Promise.all(
            getMounts(base, false).map(async (m) => {
              if (m.driver.clear) {
                return asyncCall(m.driver.clear, m.relativeBase, opts);
              }
              if (m.driver.removeItem) {
                const keys = await m.driver.getKeys(m.relativeBase || "", opts);
                return Promise.all(
                  keys.map((key) => m.driver.removeItem(key, opts))
                );
              }
            })
          );
        },
        async dispose() {
          await Promise.all(
            Object.values(context.mounts).map((driver) => dispose(driver))
          );
        },
        async watch(callback) {
          await startWatch();
          context.watchListeners.push(callback);
          return async () => {
            context.watchListeners = context.watchListeners.filter(
              (listener) => listener !== callback
            );
            if (context.watchListeners.length === 0) {
              await stopWatch();
            }
          };
        },
        async unwatch() {
          context.watchListeners = [];
          await stopWatch();
        },
        // Mount
        mount(base, driver) {
          base = normalizeBaseKey(base);
          if (base && context.mounts[base]) {
            throw new Error(`already mounted at ${base}`);
          }
          if (base) {
            context.mountpoints.push(base);
            context.mountpoints.sort((a, b) => b.length - a.length);
          }
          context.mounts[base] = driver;
          if (context.watching) {
            Promise.resolve(watch(driver, onChange, base)).then((unwatcher) => {
              context.unwatch[base] = unwatcher;
            }).catch(console.error);
          }
          return storage;
        },
        async unmount(base, _dispose = true) {
          base = normalizeBaseKey(base);
          if (!base || !context.mounts[base]) {
            return;
          }
          if (context.watching && base in context.unwatch) {
            context.unwatch[base]();
            delete context.unwatch[base];
          }
          if (_dispose) {
            await dispose(context.mounts[base]);
          }
          context.mountpoints = context.mountpoints.filter((key) => key !== base);
          delete context.mounts[base];
        },
        getMount(key = "") {
          key = normalizeKey(key) + ":";
          const m = getMount(key);
          return {
            driver: m.driver,
            base: m.base
          };
        },
        getMounts(base = "", opts = {}) {
          base = normalizeKey(base);
          const mounts = getMounts(base, opts.parents);
          return mounts.map((m) => ({
            driver: m.driver,
            base: m.mountpoint
          }));
        }
      };
      return storage;
    }
    function watch(driver, onChange, base) {
      return driver.watch ? driver.watch((event, key) => onChange(event, base + key)) : () => {
      };
    }
    async function dispose(driver) {
      if (typeof driver.dispose === "function") {
        await asyncCall(driver.dispose);
      }
    }

    function promisifyRequest(request) {
        return new Promise((resolve, reject) => {
            // @ts-ignore - file size hacks
            request.oncomplete = request.onsuccess = () => resolve(request.result);
            // @ts-ignore - file size hacks
            request.onabort = request.onerror = () => reject(request.error);
        });
    }
    function createStore$2(dbName, storeName) {
        const request = indexedDB.open(dbName);
        request.onupgradeneeded = () => request.result.createObjectStore(storeName);
        const dbp = promisifyRequest(request);
        return (txMode, callback) => dbp.then((db) => callback(db.transaction(storeName, txMode).objectStore(storeName)));
    }
    let defaultGetStoreFunc;
    function defaultGetStore() {
        if (!defaultGetStoreFunc) {
            defaultGetStoreFunc = createStore$2('keyval-store', 'keyval');
        }
        return defaultGetStoreFunc;
    }
    /**
     * Get a value by its key.
     *
     * @param key
     * @param customStore Method to get a custom store. Use with caution (see the docs).
     */
    function get(key, customStore = defaultGetStore()) {
        return customStore('readonly', (store) => promisifyRequest(store.get(key)));
    }
    /**
     * Set a value with a key.
     *
     * @param key
     * @param value
     * @param customStore Method to get a custom store. Use with caution (see the docs).
     */
    function set$1(key, value, customStore = defaultGetStore()) {
        return customStore('readwrite', (store) => {
            store.put(value, key);
            return promisifyRequest(store.transaction);
        });
    }
    /**
     * Delete a particular key from the store.
     *
     * @param key
     * @param customStore Method to get a custom store. Use with caution (see the docs).
     */
    function del(key, customStore = defaultGetStore()) {
        return customStore('readwrite', (store) => {
            store.delete(key);
            return promisifyRequest(store.transaction);
        });
    }
    /**
     * Clear all values in the store.
     *
     * @param customStore Method to get a custom store. Use with caution (see the docs).
     */
    function clear(customStore = defaultGetStore()) {
        return customStore('readwrite', (store) => {
            store.clear();
            return promisifyRequest(store.transaction);
        });
    }
    function eachCursor(store, callback) {
        store.openCursor().onsuccess = function () {
            if (!this.result)
                return;
            callback(this.result);
            this.result.continue();
        };
        return promisifyRequest(store.transaction);
    }
    /**
     * Get all keys in the store.
     *
     * @param customStore Method to get a custom store. Use with caution (see the docs).
     */
    function keys(customStore = defaultGetStore()) {
        return customStore('readonly', (store) => {
            // Fast path for modern browsers
            if (store.getAllKeys) {
                return promisifyRequest(store.getAllKeys());
            }
            const items = [];
            return eachCursor(store, (cursor) => items.push(cursor.key)).then(() => items);
        });
    }

    const JSONStringify = data => JSON.stringify(data, (_, value) => typeof value === "bigint" ? value.toString() + "n" : value);
    const JSONParse = json => {
        const numbersBiggerThanMaxInt = /([\[:])?(\d{17,}|(?:[9](?:[1-9]07199254740991|0[1-9]7199254740991|00[8-9]199254740991|007[2-9]99254740991|007199[3-9]54740991|0071992[6-9]4740991|00719925[5-9]740991|007199254[8-9]40991|0071992547[5-9]0991|00719925474[1-9]991|00719925474099[2-9])))([,\}\]])/g;
        const serializedData = json.replace(numbersBiggerThanMaxInt, "$1\"$2n\"$3");
        return JSON.parse(serializedData, (_, value) => {
            const isCustomFormatBigInt = typeof value === "string" && value.match(/^\d+n$/);
            if (isCustomFormatBigInt)
                return BigInt(value.substring(0, value.length - 1));
            return value;
        });
    };
    function safeJsonParse(value) {
        if (typeof value !== "string") {
            throw new Error(`Cannot safe json parse value of type ${typeof value}`);
        }
        try {
            return JSONParse(value);
        }
        catch (_a) {
            return value;
        }
    }
    function safeJsonStringify(value) {
        return typeof value === "string" ? value : JSONStringify(value) || "";
    }

    const x$6="idb-keyval";var z$6=(i={})=>{const t=i.base&&i.base.length>0?`${i.base}:`:"",e=s=>t+s;let n;return i.dbName&&i.storeName&&(n=createStore$2(i.dbName,i.storeName)),{name:x$6,options:i,async hasItem(s){return !(typeof await get(e(s),n)>"u")},async getItem(s){return await get(e(s),n)??null},setItem(s,a){return set$1(e(s),a,n)},removeItem(s){return del(e(s),n)},getKeys(){return keys(n)},clear(){return clear(n)}}};const D$8="WALLET_CONNECT_V2_INDEXED_DB",E$8="keyvaluestorage";let _$9 = class _{constructor(){this.indexedDb=createStorage$1({driver:z$6({dbName:D$8,storeName:E$8})});}async getKeys(){return this.indexedDb.getKeys()}async getEntries(){return (await this.indexedDb.getItems(await this.indexedDb.getKeys())).map(t=>[t.key,t.value])}async getItem(t){const e=await this.indexedDb.getItem(t);if(e!==null)return e}async setItem(t,e){await this.indexedDb.setItem(t,safeJsonStringify(e));}async removeItem(t){await this.indexedDb.removeItem(t);}};var l$d=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global$1<"u"?global$1:typeof self<"u"?self:{},c$i={exports:{}};(function(){let i;function t(){}i=t,i.prototype.getItem=function(e){return this.hasOwnProperty(e)?String(this[e]):null},i.prototype.setItem=function(e,n){this[e]=String(n);},i.prototype.removeItem=function(e){delete this[e];},i.prototype.clear=function(){const e=this;Object.keys(e).forEach(function(n){e[n]=void 0,delete e[n];});},i.prototype.key=function(e){return e=e||0,Object.keys(this)[e]},i.prototype.__defineGetter__("length",function(){return Object.keys(this).length}),typeof l$d<"u"&&l$d.localStorage?c$i.exports=l$d.localStorage:typeof window<"u"&&window.localStorage?c$i.exports=window.localStorage:c$i.exports=new t;})();function k$7(i){var t;return [i[0],safeJsonParse((t=i[1])!=null?t:"")]}let K$6 = class K{constructor(){this.localStorage=c$i.exports;}async getKeys(){return Object.keys(this.localStorage)}async getEntries(){return Object.entries(this.localStorage).map(k$7)}async getItem(t){const e=this.localStorage.getItem(t);if(e!==null)return safeJsonParse(e)}async setItem(t,e){this.localStorage.setItem(t,safeJsonStringify(e));}async removeItem(t){this.localStorage.removeItem(t);}};const N$7="wc_storage_version",y$d=1,O$4=async(i,t,e)=>{const n=N$7,s=await t.getItem(n);if(s&&s>=y$d){e(t);return}const a=await i.getKeys();if(!a.length){e(t);return}const m=[];for(;a.length;){const r=a.shift();if(!r)continue;const o=r.toLowerCase();if(o.includes("wc@")||o.includes("walletconnect")||o.includes("wc_")||o.includes("wallet_connect")){const f=await i.getItem(r);await t.setItem(r,f),m.push(r);}}await t.setItem(n,y$d),e(t),j$8(i,m);},j$8=async(i,t)=>{t.length&&t.forEach(async e=>{await i.removeItem(e);});};let h$i = class h{constructor(){this.initialized=!1,this.setInitialized=e=>{this.storage=e,this.initialized=!0;};const t=new K$6;this.storage=t;try{const e=new _$9;O$4(t,e,this.setInitialized);}catch{this.initialized=!0;}}async getKeys(){return await this.initialize(),this.storage.getKeys()}async getEntries(){return await this.initialize(),this.storage.getEntries()}async getItem(t){return await this.initialize(),this.storage.getItem(t)}async setItem(t,e){return await this.initialize(),this.storage.setItem(t,e)}async removeItem(t){return await this.initialize(),this.storage.removeItem(t)}async initialize(){this.initialized||await new Promise(t=>{const e=setInterval(()=>{this.initialized&&(clearInterval(e),t());},20);});}};

    var cjs$4 = {};

    var heartbeat$2 = {};

    var require$$0$3 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_events);

    var types = {};

    var heartbeat$1 = {};

    let IEvents$1 = class IEvents {
    };

    var esm = /*#__PURE__*/Object.freeze({
        __proto__: null,
        IEvents: IEvents$1
    });

    var require$$0$2 = /*@__PURE__*/getAugmentedNamespace(esm);

    var hasRequiredHeartbeat$2;

    function requireHeartbeat$2 () {
    	if (hasRequiredHeartbeat$2) return heartbeat$1;
    	hasRequiredHeartbeat$2 = 1;
    	Object.defineProperty(heartbeat$1, "__esModule", { value: true });
    	heartbeat$1.IHeartBeat = void 0;
    	const events_1 = require$$0$2;
    	class IHeartBeat extends events_1.IEvents {
    	    constructor(opts) {
    	        super();
    	    }
    	}
    	heartbeat$1.IHeartBeat = IHeartBeat;
    	
    	return heartbeat$1;
    }

    var hasRequiredTypes;

    function requireTypes () {
    	if (hasRequiredTypes) return types;
    	hasRequiredTypes = 1;
    	(function (exports) {
    		Object.defineProperty(exports, "__esModule", { value: true });
    		const tslib_1 = require$$0$4;
    		tslib_1.__exportStar(requireHeartbeat$2(), exports);
    		
    	} (types));
    	return types;
    }

    var constants$5 = {};

    var heartbeat = {};

    var hasRequiredHeartbeat$1;

    function requireHeartbeat$1 () {
    	if (hasRequiredHeartbeat$1) return heartbeat;
    	hasRequiredHeartbeat$1 = 1;
    	Object.defineProperty(heartbeat, "__esModule", { value: true });
    	heartbeat.HEARTBEAT_EVENTS = heartbeat.HEARTBEAT_INTERVAL = void 0;
    	const time_1 = cjs$7;
    	heartbeat.HEARTBEAT_INTERVAL = time_1.FIVE_SECONDS;
    	heartbeat.HEARTBEAT_EVENTS = {
    	    pulse: "heartbeat_pulse",
    	};
    	
    	return heartbeat;
    }

    var hasRequiredConstants$1;

    function requireConstants$1 () {
    	if (hasRequiredConstants$1) return constants$5;
    	hasRequiredConstants$1 = 1;
    	(function (exports) {
    		Object.defineProperty(exports, "__esModule", { value: true });
    		const tslib_1 = require$$0$4;
    		tslib_1.__exportStar(requireHeartbeat$1(), exports);
    		
    	} (constants$5));
    	return constants$5;
    }

    var hasRequiredHeartbeat;

    function requireHeartbeat () {
    	if (hasRequiredHeartbeat) return heartbeat$2;
    	hasRequiredHeartbeat = 1;
    	Object.defineProperty(heartbeat$2, "__esModule", { value: true });
    	heartbeat$2.HeartBeat = void 0;
    	const tslib_1 = require$$0$4;
    	const events_1 = require$$0$3;
    	const time_1 = cjs$7;
    	const types_1 = requireTypes();
    	const constants_1 = requireConstants$1();
    	class HeartBeat extends types_1.IHeartBeat {
    	    constructor(opts) {
    	        super(opts);
    	        this.events = new events_1.EventEmitter();
    	        this.interval = constants_1.HEARTBEAT_INTERVAL;
    	        this.interval = (opts === null || opts === void 0 ? void 0 : opts.interval) || constants_1.HEARTBEAT_INTERVAL;
    	    }
    	    static init(opts) {
    	        return tslib_1.__awaiter(this, void 0, void 0, function* () {
    	            const heartbeat = new HeartBeat(opts);
    	            yield heartbeat.init();
    	            return heartbeat;
    	        });
    	    }
    	    init() {
    	        return tslib_1.__awaiter(this, void 0, void 0, function* () {
    	            yield this.initialize();
    	        });
    	    }
    	    stop() {
    	        clearInterval(this.intervalRef);
    	    }
    	    on(event, listener) {
    	        this.events.on(event, listener);
    	    }
    	    once(event, listener) {
    	        this.events.once(event, listener);
    	    }
    	    off(event, listener) {
    	        this.events.off(event, listener);
    	    }
    	    removeListener(event, listener) {
    	        this.events.removeListener(event, listener);
    	    }
    	    initialize() {
    	        return tslib_1.__awaiter(this, void 0, void 0, function* () {
    	            this.intervalRef = setInterval(() => this.pulse(), time_1.toMiliseconds(this.interval));
    	        });
    	    }
    	    pulse() {
    	        this.events.emit(constants_1.HEARTBEAT_EVENTS.pulse);
    	    }
    	}
    	heartbeat$2.HeartBeat = HeartBeat;
    	
    	return heartbeat$2;
    }

    (function (exports) {
    	Object.defineProperty(exports, "__esModule", { value: true });
    	const tslib_1 = require$$0$4;
    	tslib_1.__exportStar(requireHeartbeat(), exports);
    	tslib_1.__exportStar(requireTypes(), exports);
    	tslib_1.__exportStar(requireConstants$1(), exports);
    	
    } (cjs$4));

    var cjs$3 = {};

    var quickFormatUnescaped;
    var hasRequiredQuickFormatUnescaped;

    function requireQuickFormatUnescaped () {
    	if (hasRequiredQuickFormatUnescaped) return quickFormatUnescaped;
    	hasRequiredQuickFormatUnescaped = 1;
    	function tryStringify (o) {
    	  try { return JSON.stringify(o) } catch(e) { return '"[Circular]"' }
    	}

    	quickFormatUnescaped = format;

    	function format(f, args, opts) {
    	  var ss = (opts && opts.stringify) || tryStringify;
    	  var offset = 1;
    	  if (typeof f === 'object' && f !== null) {
    	    var len = args.length + offset;
    	    if (len === 1) return f
    	    var objects = new Array(len);
    	    objects[0] = ss(f);
    	    for (var index = 1; index < len; index++) {
    	      objects[index] = ss(args[index]);
    	    }
    	    return objects.join(' ')
    	  }
    	  if (typeof f !== 'string') {
    	    return f
    	  }
    	  var argLen = args.length;
    	  if (argLen === 0) return f
    	  var str = '';
    	  var a = 1 - offset;
    	  var lastPos = -1;
    	  var flen = (f && f.length) || 0;
    	  for (var i = 0; i < flen;) {
    	    if (f.charCodeAt(i) === 37 && i + 1 < flen) {
    	      lastPos = lastPos > -1 ? lastPos : 0;
    	      switch (f.charCodeAt(i + 1)) {
    	        case 100: // 'd'
    	        case 102: // 'f'
    	          if (a >= argLen)
    	            break
    	          if (args[a] == null)  break
    	          if (lastPos < i)
    	            str += f.slice(lastPos, i);
    	          str += Number(args[a]);
    	          lastPos = i + 2;
    	          i++;
    	          break
    	        case 105: // 'i'
    	          if (a >= argLen)
    	            break
    	          if (args[a] == null)  break
    	          if (lastPos < i)
    	            str += f.slice(lastPos, i);
    	          str += Math.floor(Number(args[a]));
    	          lastPos = i + 2;
    	          i++;
    	          break
    	        case 79: // 'O'
    	        case 111: // 'o'
    	        case 106: // 'j'
    	          if (a >= argLen)
    	            break
    	          if (args[a] === undefined) break
    	          if (lastPos < i)
    	            str += f.slice(lastPos, i);
    	          var type = typeof args[a];
    	          if (type === 'string') {
    	            str += '\'' + args[a] + '\'';
    	            lastPos = i + 2;
    	            i++;
    	            break
    	          }
    	          if (type === 'function') {
    	            str += args[a].name || '<anonymous>';
    	            lastPos = i + 2;
    	            i++;
    	            break
    	          }
    	          str += ss(args[a]);
    	          lastPos = i + 2;
    	          i++;
    	          break
    	        case 115: // 's'
    	          if (a >= argLen)
    	            break
    	          if (lastPos < i)
    	            str += f.slice(lastPos, i);
    	          str += String(args[a]);
    	          lastPos = i + 2;
    	          i++;
    	          break
    	        case 37: // '%'
    	          if (lastPos < i)
    	            str += f.slice(lastPos, i);
    	          str += '%';
    	          lastPos = i + 2;
    	          i++;
    	          a--;
    	          break
    	      }
    	      ++a;
    	    }
    	    ++i;
    	  }
    	  if (lastPos === -1)
    	    return f
    	  else if (lastPos < flen) {
    	    str += f.slice(lastPos);
    	  }

    	  return str
    	}
    	return quickFormatUnescaped;
    }

    var browser$4;
    var hasRequiredBrowser$1;

    function requireBrowser$1 () {
    	if (hasRequiredBrowser$1) return browser$4;
    	hasRequiredBrowser$1 = 1;

    	const format = requireQuickFormatUnescaped();

    	browser$4 = pino;

    	const _console = pfGlobalThisOrFallback().console || {};
    	const stdSerializers = {
    	  mapHttpRequest: mock,
    	  mapHttpResponse: mock,
    	  wrapRequestSerializer: passthrough,
    	  wrapResponseSerializer: passthrough,
    	  wrapErrorSerializer: passthrough,
    	  req: mock,
    	  res: mock,
    	  err: asErrValue
    	};

    	function shouldSerialize (serialize, serializers) {
    	  if (Array.isArray(serialize)) {
    	    const hasToFilter = serialize.filter(function (k) {
    	      return k !== '!stdSerializers.err'
    	    });
    	    return hasToFilter
    	  } else if (serialize === true) {
    	    return Object.keys(serializers)
    	  }

    	  return false
    	}

    	function pino (opts) {
    	  opts = opts || {};
    	  opts.browser = opts.browser || {};

    	  const transmit = opts.browser.transmit;
    	  if (transmit && typeof transmit.send !== 'function') { throw Error('pino: transmit option must have a send function') }

    	  const proto = opts.browser.write || _console;
    	  if (opts.browser.write) opts.browser.asObject = true;
    	  const serializers = opts.serializers || {};
    	  const serialize = shouldSerialize(opts.browser.serialize, serializers);
    	  let stdErrSerialize = opts.browser.serialize;

    	  if (
    	    Array.isArray(opts.browser.serialize) &&
    	    opts.browser.serialize.indexOf('!stdSerializers.err') > -1
    	  ) stdErrSerialize = false;

    	  const levels = ['error', 'fatal', 'warn', 'info', 'debug', 'trace'];

    	  if (typeof proto === 'function') {
    	    proto.error = proto.fatal = proto.warn =
    	    proto.info = proto.debug = proto.trace = proto;
    	  }
    	  if (opts.enabled === false) opts.level = 'silent';
    	  const level = opts.level || 'info';
    	  const logger = Object.create(proto);
    	  if (!logger.log) logger.log = noop;

    	  Object.defineProperty(logger, 'levelVal', {
    	    get: getLevelVal
    	  });
    	  Object.defineProperty(logger, 'level', {
    	    get: getLevel,
    	    set: setLevel
    	  });

    	  const setOpts = {
    	    transmit,
    	    serialize,
    	    asObject: opts.browser.asObject,
    	    levels,
    	    timestamp: getTimeFunction(opts)
    	  };
    	  logger.levels = pino.levels;
    	  logger.level = level;

    	  logger.setMaxListeners = logger.getMaxListeners =
    	  logger.emit = logger.addListener = logger.on =
    	  logger.prependListener = logger.once =
    	  logger.prependOnceListener = logger.removeListener =
    	  logger.removeAllListeners = logger.listeners =
    	  logger.listenerCount = logger.eventNames =
    	  logger.write = logger.flush = noop;
    	  logger.serializers = serializers;
    	  logger._serialize = serialize;
    	  logger._stdErrSerialize = stdErrSerialize;
    	  logger.child = child;

    	  if (transmit) logger._logEvent = createLogEventShape();

    	  function getLevelVal () {
    	    return this.level === 'silent'
    	      ? Infinity
    	      : this.levels.values[this.level]
    	  }

    	  function getLevel () {
    	    return this._level
    	  }
    	  function setLevel (level) {
    	    if (level !== 'silent' && !this.levels.values[level]) {
    	      throw Error('unknown level ' + level)
    	    }
    	    this._level = level;

    	    set(setOpts, logger, 'error', 'log'); // <-- must stay first
    	    set(setOpts, logger, 'fatal', 'error');
    	    set(setOpts, logger, 'warn', 'error');
    	    set(setOpts, logger, 'info', 'log');
    	    set(setOpts, logger, 'debug', 'log');
    	    set(setOpts, logger, 'trace', 'log');
    	  }

    	  function child (bindings, childOptions) {
    	    if (!bindings) {
    	      throw new Error('missing bindings for child Pino')
    	    }
    	    childOptions = childOptions || {};
    	    if (serialize && bindings.serializers) {
    	      childOptions.serializers = bindings.serializers;
    	    }
    	    const childOptionsSerializers = childOptions.serializers;
    	    if (serialize && childOptionsSerializers) {
    	      var childSerializers = Object.assign({}, serializers, childOptionsSerializers);
    	      var childSerialize = opts.browser.serialize === true
    	        ? Object.keys(childSerializers)
    	        : serialize;
    	      delete bindings.serializers;
    	      applySerializers([bindings], childSerialize, childSerializers, this._stdErrSerialize);
    	    }
    	    function Child (parent) {
    	      this._childLevel = (parent._childLevel | 0) + 1;
    	      this.error = bind(parent, bindings, 'error');
    	      this.fatal = bind(parent, bindings, 'fatal');
    	      this.warn = bind(parent, bindings, 'warn');
    	      this.info = bind(parent, bindings, 'info');
    	      this.debug = bind(parent, bindings, 'debug');
    	      this.trace = bind(parent, bindings, 'trace');
    	      if (childSerializers) {
    	        this.serializers = childSerializers;
    	        this._serialize = childSerialize;
    	      }
    	      if (transmit) {
    	        this._logEvent = createLogEventShape(
    	          [].concat(parent._logEvent.bindings, bindings)
    	        );
    	      }
    	    }
    	    Child.prototype = this;
    	    return new Child(this)
    	  }
    	  return logger
    	}

    	pino.levels = {
    	  values: {
    	    fatal: 60,
    	    error: 50,
    	    warn: 40,
    	    info: 30,
    	    debug: 20,
    	    trace: 10
    	  },
    	  labels: {
    	    10: 'trace',
    	    20: 'debug',
    	    30: 'info',
    	    40: 'warn',
    	    50: 'error',
    	    60: 'fatal'
    	  }
    	};

    	pino.stdSerializers = stdSerializers;
    	pino.stdTimeFunctions = Object.assign({}, { nullTime, epochTime, unixTime, isoTime });

    	function set (opts, logger, level, fallback) {
    	  const proto = Object.getPrototypeOf(logger);
    	  logger[level] = logger.levelVal > logger.levels.values[level]
    	    ? noop
    	    : (proto[level] ? proto[level] : (_console[level] || _console[fallback] || noop));

    	  wrap(opts, logger, level);
    	}

    	function wrap (opts, logger, level) {
    	  if (!opts.transmit && logger[level] === noop) return

    	  logger[level] = (function (write) {
    	    return function LOG () {
    	      const ts = opts.timestamp();
    	      const args = new Array(arguments.length);
    	      const proto = (Object.getPrototypeOf && Object.getPrototypeOf(this) === _console) ? _console : this;
    	      for (var i = 0; i < args.length; i++) args[i] = arguments[i];

    	      if (opts.serialize && !opts.asObject) {
    	        applySerializers(args, this._serialize, this.serializers, this._stdErrSerialize);
    	      }
    	      if (opts.asObject) write.call(proto, asObject(this, level, args, ts));
    	      else write.apply(proto, args);

    	      if (opts.transmit) {
    	        const transmitLevel = opts.transmit.level || logger.level;
    	        const transmitValue = pino.levels.values[transmitLevel];
    	        const methodValue = pino.levels.values[level];
    	        if (methodValue < transmitValue) return
    	        transmit(this, {
    	          ts,
    	          methodLevel: level,
    	          methodValue,
    	          transmitLevel,
    	          transmitValue: pino.levels.values[opts.transmit.level || logger.level],
    	          send: opts.transmit.send,
    	          val: logger.levelVal
    	        }, args);
    	      }
    	    }
    	  })(logger[level]);
    	}

    	function asObject (logger, level, args, ts) {
    	  if (logger._serialize) applySerializers(args, logger._serialize, logger.serializers, logger._stdErrSerialize);
    	  const argsCloned = args.slice();
    	  let msg = argsCloned[0];
    	  const o = {};
    	  if (ts) {
    	    o.time = ts;
    	  }
    	  o.level = pino.levels.values[level];
    	  let lvl = (logger._childLevel | 0) + 1;
    	  if (lvl < 1) lvl = 1;
    	  // deliberate, catching objects, arrays
    	  if (msg !== null && typeof msg === 'object') {
    	    while (lvl-- && typeof argsCloned[0] === 'object') {
    	      Object.assign(o, argsCloned.shift());
    	    }
    	    msg = argsCloned.length ? format(argsCloned.shift(), argsCloned) : undefined;
    	  } else if (typeof msg === 'string') msg = format(argsCloned.shift(), argsCloned);
    	  if (msg !== undefined) o.msg = msg;
    	  return o
    	}

    	function applySerializers (args, serialize, serializers, stdErrSerialize) {
    	  for (const i in args) {
    	    if (stdErrSerialize && args[i] instanceof Error) {
    	      args[i] = pino.stdSerializers.err(args[i]);
    	    } else if (typeof args[i] === 'object' && !Array.isArray(args[i])) {
    	      for (const k in args[i]) {
    	        if (serialize && serialize.indexOf(k) > -1 && k in serializers) {
    	          args[i][k] = serializers[k](args[i][k]);
    	        }
    	      }
    	    }
    	  }
    	}

    	function bind (parent, bindings, level) {
    	  return function () {
    	    const args = new Array(1 + arguments.length);
    	    args[0] = bindings;
    	    for (var i = 1; i < args.length; i++) {
    	      args[i] = arguments[i - 1];
    	    }
    	    return parent[level].apply(this, args)
    	  }
    	}

    	function transmit (logger, opts, args) {
    	  const send = opts.send;
    	  const ts = opts.ts;
    	  const methodLevel = opts.methodLevel;
    	  const methodValue = opts.methodValue;
    	  const val = opts.val;
    	  const bindings = logger._logEvent.bindings;

    	  applySerializers(
    	    args,
    	    logger._serialize || Object.keys(logger.serializers),
    	    logger.serializers,
    	    logger._stdErrSerialize === undefined ? true : logger._stdErrSerialize
    	  );
    	  logger._logEvent.ts = ts;
    	  logger._logEvent.messages = args.filter(function (arg) {
    	    // bindings can only be objects, so reference equality check via indexOf is fine
    	    return bindings.indexOf(arg) === -1
    	  });

    	  logger._logEvent.level.label = methodLevel;
    	  logger._logEvent.level.value = methodValue;

    	  send(methodLevel, logger._logEvent, val);

    	  logger._logEvent = createLogEventShape(bindings);
    	}

    	function createLogEventShape (bindings) {
    	  return {
    	    ts: 0,
    	    messages: [],
    	    bindings: bindings || [],
    	    level: { label: '', value: 0 }
    	  }
    	}

    	function asErrValue (err) {
    	  const obj = {
    	    type: err.constructor.name,
    	    msg: err.message,
    	    stack: err.stack
    	  };
    	  for (const key in err) {
    	    if (obj[key] === undefined) {
    	      obj[key] = err[key];
    	    }
    	  }
    	  return obj
    	}

    	function getTimeFunction (opts) {
    	  if (typeof opts.timestamp === 'function') {
    	    return opts.timestamp
    	  }
    	  if (opts.timestamp === false) {
    	    return nullTime
    	  }
    	  return epochTime
    	}

    	function mock () { return {} }
    	function passthrough (a) { return a }
    	function noop () {}

    	function nullTime () { return false }
    	function epochTime () { return Date.now() }
    	function unixTime () { return Math.round(Date.now() / 1000.0) }
    	function isoTime () { return new Date(Date.now()).toISOString() } // using Date.now() for testability

    	/* eslint-disable */
    	/* istanbul ignore next */
    	function pfGlobalThisOrFallback () {
    	  function defd (o) { return typeof o !== 'undefined' && o }
    	  try {
    	    if (typeof globalThis !== 'undefined') return globalThis
    	    Object.defineProperty(Object.prototype, 'globalThis', {
    	      get: function () {
    	        delete Object.prototype.globalThis;
    	        return (this.globalThis = this)
    	      },
    	      configurable: true
    	    });
    	    return globalThis
    	  } catch (e) {
    	    return defd(self) || defd(window) || defd(this) || {}
    	  }
    	}
    	/* eslint-enable */
    	return browser$4;
    }

    var constants$4 = {};

    var hasRequiredConstants;

    function requireConstants () {
    	if (hasRequiredConstants) return constants$4;
    	hasRequiredConstants = 1;
    	Object.defineProperty(constants$4, "__esModule", { value: true });
    	constants$4.PINO_CUSTOM_CONTEXT_KEY = constants$4.PINO_LOGGER_DEFAULTS = void 0;
    	constants$4.PINO_LOGGER_DEFAULTS = {
    	    level: "info",
    	};
    	constants$4.PINO_CUSTOM_CONTEXT_KEY = "custom_context";
    	
    	return constants$4;
    }

    var utils$4 = {};

    var hasRequiredUtils;

    function requireUtils () {
    	if (hasRequiredUtils) return utils$4;
    	hasRequiredUtils = 1;
    	Object.defineProperty(utils$4, "__esModule", { value: true });
    	utils$4.generateChildLogger = utils$4.formatChildLoggerContext = utils$4.getLoggerContext = utils$4.setBrowserLoggerContext = utils$4.getBrowserLoggerContext = utils$4.getDefaultLoggerOptions = void 0;
    	const constants_1 = requireConstants();
    	function getDefaultLoggerOptions(opts) {
    	    return Object.assign(Object.assign({}, opts), { level: (opts === null || opts === void 0 ? void 0 : opts.level) || constants_1.PINO_LOGGER_DEFAULTS.level });
    	}
    	utils$4.getDefaultLoggerOptions = getDefaultLoggerOptions;
    	function getBrowserLoggerContext(logger, customContextKey = constants_1.PINO_CUSTOM_CONTEXT_KEY) {
    	    return logger[customContextKey] || "";
    	}
    	utils$4.getBrowserLoggerContext = getBrowserLoggerContext;
    	function setBrowserLoggerContext(logger, context, customContextKey = constants_1.PINO_CUSTOM_CONTEXT_KEY) {
    	    logger[customContextKey] = context;
    	    return logger;
    	}
    	utils$4.setBrowserLoggerContext = setBrowserLoggerContext;
    	function getLoggerContext(logger, customContextKey = constants_1.PINO_CUSTOM_CONTEXT_KEY) {
    	    let context = "";
    	    if (typeof logger.bindings === "undefined") {
    	        context = getBrowserLoggerContext(logger, customContextKey);
    	    }
    	    else {
    	        context = logger.bindings().context || "";
    	    }
    	    return context;
    	}
    	utils$4.getLoggerContext = getLoggerContext;
    	function formatChildLoggerContext(logger, childContext, customContextKey = constants_1.PINO_CUSTOM_CONTEXT_KEY) {
    	    const parentContext = getLoggerContext(logger, customContextKey);
    	    const context = parentContext.trim()
    	        ? `${parentContext}/${childContext}`
    	        : childContext;
    	    return context;
    	}
    	utils$4.formatChildLoggerContext = formatChildLoggerContext;
    	function generateChildLogger(logger, childContext, customContextKey = constants_1.PINO_CUSTOM_CONTEXT_KEY) {
    	    const context = formatChildLoggerContext(logger, childContext, customContextKey);
    	    const child = logger.child({ context });
    	    return setBrowserLoggerContext(child, context, customContextKey);
    	}
    	utils$4.generateChildLogger = generateChildLogger;
    	
    	return utils$4;
    }

    (function (exports) {
    	Object.defineProperty(exports, "__esModule", { value: true });
    	exports.pino = void 0;
    	const tslib_1 = require$$0$4;
    	const pino_1 = tslib_1.__importDefault(requireBrowser$1());
    	Object.defineProperty(exports, "pino", { enumerable: true, get: function () { return pino_1.default; } });
    	tslib_1.__exportStar(requireConstants(), exports);
    	tslib_1.__exportStar(requireUtils(), exports);
    	
    } (cjs$3));

    let n$n = class n extends IEvents$1{constructor(s){super(),this.opts=s,this.protocol="wc",this.version=2;}};let h$h = class h extends IEvents$1{constructor(s,t){super(),this.core=s,this.logger=t,this.records=new Map;}};let a$c = class a{constructor(s,t){this.logger=s,this.core=t;}};let u$b = class u extends IEvents$1{constructor(s,t){super(),this.relayer=s,this.logger=t;}};let g$a = class g extends IEvents$1{constructor(s){super();}};let p$b = class p{constructor(s,t,o,M){this.core=s,this.logger=t,this.name=o;}};let d$c = class d extends IEvents$1{constructor(s,t){super(),this.relayer=s,this.logger=t;}};let E$7 = class E extends IEvents$1{constructor(s,t){super(),this.core=s,this.logger=t;}};let y$c = class y{constructor(s,t){this.projectId=s,this.logger=t;}};let v$9 = class v{constructor(s,t){this.projectId=s,this.logger=t;}};let b$8 = class b{constructor(s){this.opts=s,this.protocol="wc",this.version=2;}};let w$9 = class w{constructor(s){this.client=s;}};

    var ed25519 = {};

    var sha512$1 = {};

    (function (exports) {
    	// Copyright (C) 2016 Dmitry Chestnykh
    	// MIT License. See LICENSE file for details.
    	Object.defineProperty(exports, "__esModule", { value: true });
    	var binary_1 = binary;
    	var wipe_1 = wipe$1;
    	exports.DIGEST_LENGTH = 64;
    	exports.BLOCK_SIZE = 128;
    	/**
    	 * SHA-2-512 cryptographic hash algorithm.
    	 */
    	var SHA512 = /** @class */ (function () {
    	    function SHA512() {
    	        /** Length of hash output */
    	        this.digestLength = exports.DIGEST_LENGTH;
    	        /** Block size */
    	        this.blockSize = exports.BLOCK_SIZE;
    	        // Note: Int32Array is used instead of Uint32Array for performance reasons.
    	        this._stateHi = new Int32Array(8); // hash state, high bytes
    	        this._stateLo = new Int32Array(8); // hash state, low bytes
    	        this._tempHi = new Int32Array(16); // temporary state, high bytes
    	        this._tempLo = new Int32Array(16); // temporary state, low bytes
    	        this._buffer = new Uint8Array(256); // buffer for data to hash
    	        this._bufferLength = 0; // number of bytes in buffer
    	        this._bytesHashed = 0; // number of total bytes hashed
    	        this._finished = false; // indicates whether the hash was finalized
    	        this.reset();
    	    }
    	    SHA512.prototype._initState = function () {
    	        this._stateHi[0] = 0x6a09e667;
    	        this._stateHi[1] = 0xbb67ae85;
    	        this._stateHi[2] = 0x3c6ef372;
    	        this._stateHi[3] = 0xa54ff53a;
    	        this._stateHi[4] = 0x510e527f;
    	        this._stateHi[5] = 0x9b05688c;
    	        this._stateHi[6] = 0x1f83d9ab;
    	        this._stateHi[7] = 0x5be0cd19;
    	        this._stateLo[0] = 0xf3bcc908;
    	        this._stateLo[1] = 0x84caa73b;
    	        this._stateLo[2] = 0xfe94f82b;
    	        this._stateLo[3] = 0x5f1d36f1;
    	        this._stateLo[4] = 0xade682d1;
    	        this._stateLo[5] = 0x2b3e6c1f;
    	        this._stateLo[6] = 0xfb41bd6b;
    	        this._stateLo[7] = 0x137e2179;
    	    };
    	    /**
    	     * Resets hash state making it possible
    	     * to re-use this instance to hash other data.
    	     */
    	    SHA512.prototype.reset = function () {
    	        this._initState();
    	        this._bufferLength = 0;
    	        this._bytesHashed = 0;
    	        this._finished = false;
    	        return this;
    	    };
    	    /**
    	     * Cleans internal buffers and resets hash state.
    	     */
    	    SHA512.prototype.clean = function () {
    	        wipe_1.wipe(this._buffer);
    	        wipe_1.wipe(this._tempHi);
    	        wipe_1.wipe(this._tempLo);
    	        this.reset();
    	    };
    	    /**
    	     * Updates hash state with the given data.
    	     *
    	     * Throws error when trying to update already finalized hash:
    	     * instance must be reset to update it again.
    	     */
    	    SHA512.prototype.update = function (data, dataLength) {
    	        if (dataLength === void 0) { dataLength = data.length; }
    	        if (this._finished) {
    	            throw new Error("SHA512: can't update because hash was finished.");
    	        }
    	        var dataPos = 0;
    	        this._bytesHashed += dataLength;
    	        if (this._bufferLength > 0) {
    	            while (this._bufferLength < exports.BLOCK_SIZE && dataLength > 0) {
    	                this._buffer[this._bufferLength++] = data[dataPos++];
    	                dataLength--;
    	            }
    	            if (this._bufferLength === this.blockSize) {
    	                hashBlocks(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, this.blockSize);
    	                this._bufferLength = 0;
    	            }
    	        }
    	        if (dataLength >= this.blockSize) {
    	            dataPos = hashBlocks(this._tempHi, this._tempLo, this._stateHi, this._stateLo, data, dataPos, dataLength);
    	            dataLength %= this.blockSize;
    	        }
    	        while (dataLength > 0) {
    	            this._buffer[this._bufferLength++] = data[dataPos++];
    	            dataLength--;
    	        }
    	        return this;
    	    };
    	    /**
    	     * Finalizes hash state and puts hash into out.
    	     * If hash was already finalized, puts the same value.
    	     */
    	    SHA512.prototype.finish = function (out) {
    	        if (!this._finished) {
    	            var bytesHashed = this._bytesHashed;
    	            var left = this._bufferLength;
    	            var bitLenHi = (bytesHashed / 0x20000000) | 0;
    	            var bitLenLo = bytesHashed << 3;
    	            var padLength = (bytesHashed % 128 < 112) ? 128 : 256;
    	            this._buffer[left] = 0x80;
    	            for (var i = left + 1; i < padLength - 8; i++) {
    	                this._buffer[i] = 0;
    	            }
    	            binary_1.writeUint32BE(bitLenHi, this._buffer, padLength - 8);
    	            binary_1.writeUint32BE(bitLenLo, this._buffer, padLength - 4);
    	            hashBlocks(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, padLength);
    	            this._finished = true;
    	        }
    	        for (var i = 0; i < this.digestLength / 8; i++) {
    	            binary_1.writeUint32BE(this._stateHi[i], out, i * 8);
    	            binary_1.writeUint32BE(this._stateLo[i], out, i * 8 + 4);
    	        }
    	        return this;
    	    };
    	    /**
    	     * Returns the final hash digest.
    	     */
    	    SHA512.prototype.digest = function () {
    	        var out = new Uint8Array(this.digestLength);
    	        this.finish(out);
    	        return out;
    	    };
    	    /**
    	     * Function useful for HMAC/PBKDF2 optimization. Returns hash state to be
    	     * used with restoreState(). Only chain value is saved, not buffers or
    	     * other state variables.
    	     */
    	    SHA512.prototype.saveState = function () {
    	        if (this._finished) {
    	            throw new Error("SHA256: cannot save finished state");
    	        }
    	        return {
    	            stateHi: new Int32Array(this._stateHi),
    	            stateLo: new Int32Array(this._stateLo),
    	            buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : undefined,
    	            bufferLength: this._bufferLength,
    	            bytesHashed: this._bytesHashed
    	        };
    	    };
    	    /**
    	     * Function useful for HMAC/PBKDF2 optimization. Restores state saved by
    	     * saveState() and sets bytesHashed to the given value.
    	     */
    	    SHA512.prototype.restoreState = function (savedState) {
    	        this._stateHi.set(savedState.stateHi);
    	        this._stateLo.set(savedState.stateLo);
    	        this._bufferLength = savedState.bufferLength;
    	        if (savedState.buffer) {
    	            this._buffer.set(savedState.buffer);
    	        }
    	        this._bytesHashed = savedState.bytesHashed;
    	        this._finished = false;
    	        return this;
    	    };
    	    /**
    	     * Cleans state returned by saveState().
    	     */
    	    SHA512.prototype.cleanSavedState = function (savedState) {
    	        wipe_1.wipe(savedState.stateHi);
    	        wipe_1.wipe(savedState.stateLo);
    	        if (savedState.buffer) {
    	            wipe_1.wipe(savedState.buffer);
    	        }
    	        savedState.bufferLength = 0;
    	        savedState.bytesHashed = 0;
    	    };
    	    return SHA512;
    	}());
    	exports.SHA512 = SHA512;
    	// Constants
    	var K = new Int32Array([
    	    0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
    	    0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
    	    0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
    	    0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
    	    0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
    	    0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
    	    0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
    	    0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
    	    0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
    	    0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
    	    0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
    	    0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
    	    0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
    	    0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
    	    0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
    	    0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
    	    0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
    	    0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
    	    0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
    	    0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
    	    0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
    	    0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
    	    0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
    	    0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
    	    0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
    	    0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
    	    0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
    	    0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
    	    0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
    	    0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
    	    0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
    	    0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
    	    0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
    	    0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
    	    0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
    	    0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
    	    0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
    	    0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
    	    0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
    	    0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
    	]);
    	function hashBlocks(wh, wl, hh, hl, m, pos, len) {
    	    var ah0 = hh[0], ah1 = hh[1], ah2 = hh[2], ah3 = hh[3], ah4 = hh[4], ah5 = hh[5], ah6 = hh[6], ah7 = hh[7], al0 = hl[0], al1 = hl[1], al2 = hl[2], al3 = hl[3], al4 = hl[4], al5 = hl[5], al6 = hl[6], al7 = hl[7];
    	    var h, l;
    	    var th, tl;
    	    var a, b, c, d;
    	    while (len >= 128) {
    	        for (var i = 0; i < 16; i++) {
    	            var j = 8 * i + pos;
    	            wh[i] = binary_1.readUint32BE(m, j);
    	            wl[i] = binary_1.readUint32BE(m, j + 4);
    	        }
    	        for (var i = 0; i < 80; i++) {
    	            var bh0 = ah0;
    	            var bh1 = ah1;
    	            var bh2 = ah2;
    	            var bh3 = ah3;
    	            var bh4 = ah4;
    	            var bh5 = ah5;
    	            var bh6 = ah6;
    	            var bh7 = ah7;
    	            var bl0 = al0;
    	            var bl1 = al1;
    	            var bl2 = al2;
    	            var bl3 = al3;
    	            var bl4 = al4;
    	            var bl5 = al5;
    	            var bl6 = al6;
    	            var bl7 = al7;
    	            // add
    	            h = ah7;
    	            l = al7;
    	            a = l & 0xffff;
    	            b = l >>> 16;
    	            c = h & 0xffff;
    	            d = h >>> 16;
    	            // Sigma1
    	            h = ((ah4 >>> 14) | (al4 << (32 - 14))) ^ ((ah4 >>> 18) |
    	                (al4 << (32 - 18))) ^ ((al4 >>> (41 - 32)) | (ah4 << (32 - (41 - 32))));
    	            l = ((al4 >>> 14) | (ah4 << (32 - 14))) ^ ((al4 >>> 18) |
    	                (ah4 << (32 - 18))) ^ ((ah4 >>> (41 - 32)) | (al4 << (32 - (41 - 32))));
    	            a += l & 0xffff;
    	            b += l >>> 16;
    	            c += h & 0xffff;
    	            d += h >>> 16;
    	            // Ch
    	            h = (ah4 & ah5) ^ (~ah4 & ah6);
    	            l = (al4 & al5) ^ (~al4 & al6);
    	            a += l & 0xffff;
    	            b += l >>> 16;
    	            c += h & 0xffff;
    	            d += h >>> 16;
    	            // K
    	            h = K[i * 2];
    	            l = K[i * 2 + 1];
    	            a += l & 0xffff;
    	            b += l >>> 16;
    	            c += h & 0xffff;
    	            d += h >>> 16;
    	            // w
    	            h = wh[i % 16];
    	            l = wl[i % 16];
    	            a += l & 0xffff;
    	            b += l >>> 16;
    	            c += h & 0xffff;
    	            d += h >>> 16;
    	            b += a >>> 16;
    	            c += b >>> 16;
    	            d += c >>> 16;
    	            th = c & 0xffff | d << 16;
    	            tl = a & 0xffff | b << 16;
    	            // add
    	            h = th;
    	            l = tl;
    	            a = l & 0xffff;
    	            b = l >>> 16;
    	            c = h & 0xffff;
    	            d = h >>> 16;
    	            // Sigma0
    	            h = ((ah0 >>> 28) | (al0 << (32 - 28))) ^ ((al0 >>> (34 - 32)) |
    	                (ah0 << (32 - (34 - 32)))) ^ ((al0 >>> (39 - 32)) | (ah0 << (32 - (39 - 32))));
    	            l = ((al0 >>> 28) | (ah0 << (32 - 28))) ^ ((ah0 >>> (34 - 32)) |
    	                (al0 << (32 - (34 - 32)))) ^ ((ah0 >>> (39 - 32)) | (al0 << (32 - (39 - 32))));
    	            a += l & 0xffff;
    	            b += l >>> 16;
    	            c += h & 0xffff;
    	            d += h >>> 16;
    	            // Maj
    	            h = (ah0 & ah1) ^ (ah0 & ah2) ^ (ah1 & ah2);
    	            l = (al0 & al1) ^ (al0 & al2) ^ (al1 & al2);
    	            a += l & 0xffff;
    	            b += l >>> 16;
    	            c += h & 0xffff;
    	            d += h >>> 16;
    	            b += a >>> 16;
    	            c += b >>> 16;
    	            d += c >>> 16;
    	            bh7 = (c & 0xffff) | (d << 16);
    	            bl7 = (a & 0xffff) | (b << 16);
    	            // add
    	            h = bh3;
    	            l = bl3;
    	            a = l & 0xffff;
    	            b = l >>> 16;
    	            c = h & 0xffff;
    	            d = h >>> 16;
    	            h = th;
    	            l = tl;
    	            a += l & 0xffff;
    	            b += l >>> 16;
    	            c += h & 0xffff;
    	            d += h >>> 16;
    	            b += a >>> 16;
    	            c += b >>> 16;
    	            d += c >>> 16;
    	            bh3 = (c & 0xffff) | (d << 16);
    	            bl3 = (a & 0xffff) | (b << 16);
    	            ah1 = bh0;
    	            ah2 = bh1;
    	            ah3 = bh2;
    	            ah4 = bh3;
    	            ah5 = bh4;
    	            ah6 = bh5;
    	            ah7 = bh6;
    	            ah0 = bh7;
    	            al1 = bl0;
    	            al2 = bl1;
    	            al3 = bl2;
    	            al4 = bl3;
    	            al5 = bl4;
    	            al6 = bl5;
    	            al7 = bl6;
    	            al0 = bl7;
    	            if (i % 16 === 15) {
    	                for (var j = 0; j < 16; j++) {
    	                    // add
    	                    h = wh[j];
    	                    l = wl[j];
    	                    a = l & 0xffff;
    	                    b = l >>> 16;
    	                    c = h & 0xffff;
    	                    d = h >>> 16;
    	                    h = wh[(j + 9) % 16];
    	                    l = wl[(j + 9) % 16];
    	                    a += l & 0xffff;
    	                    b += l >>> 16;
    	                    c += h & 0xffff;
    	                    d += h >>> 16;
    	                    // sigma0
    	                    th = wh[(j + 1) % 16];
    	                    tl = wl[(j + 1) % 16];
    	                    h = ((th >>> 1) | (tl << (32 - 1))) ^ ((th >>> 8) |
    	                        (tl << (32 - 8))) ^ (th >>> 7);
    	                    l = ((tl >>> 1) | (th << (32 - 1))) ^ ((tl >>> 8) |
    	                        (th << (32 - 8))) ^ ((tl >>> 7) | (th << (32 - 7)));
    	                    a += l & 0xffff;
    	                    b += l >>> 16;
    	                    c += h & 0xffff;
    	                    d += h >>> 16;
    	                    // sigma1
    	                    th = wh[(j + 14) % 16];
    	                    tl = wl[(j + 14) % 16];
    	                    h = ((th >>> 19) | (tl << (32 - 19))) ^ ((tl >>> (61 - 32)) |
    	                        (th << (32 - (61 - 32)))) ^ (th >>> 6);
    	                    l = ((tl >>> 19) | (th << (32 - 19))) ^ ((th >>> (61 - 32)) |
    	                        (tl << (32 - (61 - 32)))) ^ ((tl >>> 6) | (th << (32 - 6)));
    	                    a += l & 0xffff;
    	                    b += l >>> 16;
    	                    c += h & 0xffff;
    	                    d += h >>> 16;
    	                    b += a >>> 16;
    	                    c += b >>> 16;
    	                    d += c >>> 16;
    	                    wh[j] = (c & 0xffff) | (d << 16);
    	                    wl[j] = (a & 0xffff) | (b << 16);
    	                }
    	            }
    	        }
    	        // add
    	        h = ah0;
    	        l = al0;
    	        a = l & 0xffff;
    	        b = l >>> 16;
    	        c = h & 0xffff;
    	        d = h >>> 16;
    	        h = hh[0];
    	        l = hl[0];
    	        a += l & 0xffff;
    	        b += l >>> 16;
    	        c += h & 0xffff;
    	        d += h >>> 16;
    	        b += a >>> 16;
    	        c += b >>> 16;
    	        d += c >>> 16;
    	        hh[0] = ah0 = (c & 0xffff) | (d << 16);
    	        hl[0] = al0 = (a & 0xffff) | (b << 16);
    	        h = ah1;
    	        l = al1;
    	        a = l & 0xffff;
    	        b = l >>> 16;
    	        c = h & 0xffff;
    	        d = h >>> 16;
    	        h = hh[1];
    	        l = hl[1];
    	        a += l & 0xffff;
    	        b += l >>> 16;
    	        c += h & 0xffff;
    	        d += h >>> 16;
    	        b += a >>> 16;
    	        c += b >>> 16;
    	        d += c >>> 16;
    	        hh[1] = ah1 = (c & 0xffff) | (d << 16);
    	        hl[1] = al1 = (a & 0xffff) | (b << 16);
    	        h = ah2;
    	        l = al2;
    	        a = l & 0xffff;
    	        b = l >>> 16;
    	        c = h & 0xffff;
    	        d = h >>> 16;
    	        h = hh[2];
    	        l = hl[2];
    	        a += l & 0xffff;
    	        b += l >>> 16;
    	        c += h & 0xffff;
    	        d += h >>> 16;
    	        b += a >>> 16;
    	        c += b >>> 16;
    	        d += c >>> 16;
    	        hh[2] = ah2 = (c & 0xffff) | (d << 16);
    	        hl[2] = al2 = (a & 0xffff) | (b << 16);
    	        h = ah3;
    	        l = al3;
    	        a = l & 0xffff;
    	        b = l >>> 16;
    	        c = h & 0xffff;
    	        d = h >>> 16;
    	        h = hh[3];
    	        l = hl[3];
    	        a += l & 0xffff;
    	        b += l >>> 16;
    	        c += h & 0xffff;
    	        d += h >>> 16;
    	        b += a >>> 16;
    	        c += b >>> 16;
    	        d += c >>> 16;
    	        hh[3] = ah3 = (c & 0xffff) | (d << 16);
    	        hl[3] = al3 = (a & 0xffff) | (b << 16);
    	        h = ah4;
    	        l = al4;
    	        a = l & 0xffff;
    	        b = l >>> 16;
    	        c = h & 0xffff;
    	        d = h >>> 16;
    	        h = hh[4];
    	        l = hl[4];
    	        a += l & 0xffff;
    	        b += l >>> 16;
    	        c += h & 0xffff;
    	        d += h >>> 16;
    	        b += a >>> 16;
    	        c += b >>> 16;
    	        d += c >>> 16;
    	        hh[4] = ah4 = (c & 0xffff) | (d << 16);
    	        hl[4] = al4 = (a & 0xffff) | (b << 16);
    	        h = ah5;
    	        l = al5;
    	        a = l & 0xffff;
    	        b = l >>> 16;
    	        c = h & 0xffff;
    	        d = h >>> 16;
    	        h = hh[5];
    	        l = hl[5];
    	        a += l & 0xffff;
    	        b += l >>> 16;
    	        c += h & 0xffff;
    	        d += h >>> 16;
    	        b += a >>> 16;
    	        c += b >>> 16;
    	        d += c >>> 16;
    	        hh[5] = ah5 = (c & 0xffff) | (d << 16);
    	        hl[5] = al5 = (a & 0xffff) | (b << 16);
    	        h = ah6;
    	        l = al6;
    	        a = l & 0xffff;
    	        b = l >>> 16;
    	        c = h & 0xffff;
    	        d = h >>> 16;
    	        h = hh[6];
    	        l = hl[6];
    	        a += l & 0xffff;
    	        b += l >>> 16;
    	        c += h & 0xffff;
    	        d += h >>> 16;
    	        b += a >>> 16;
    	        c += b >>> 16;
    	        d += c >>> 16;
    	        hh[6] = ah6 = (c & 0xffff) | (d << 16);
    	        hl[6] = al6 = (a & 0xffff) | (b << 16);
    	        h = ah7;
    	        l = al7;
    	        a = l & 0xffff;
    	        b = l >>> 16;
    	        c = h & 0xffff;
    	        d = h >>> 16;
    	        h = hh[7];
    	        l = hl[7];
    	        a += l & 0xffff;
    	        b += l >>> 16;
    	        c += h & 0xffff;
    	        d += h >>> 16;
    	        b += a >>> 16;
    	        c += b >>> 16;
    	        d += c >>> 16;
    	        hh[7] = ah7 = (c & 0xffff) | (d << 16);
    	        hl[7] = al7 = (a & 0xffff) | (b << 16);
    	        pos += 128;
    	        len -= 128;
    	    }
    	    return pos;
    	}
    	function hash(data) {
    	    var h = new SHA512();
    	    h.update(data);
    	    var digest = h.digest();
    	    h.clean();
    	    return digest;
    	}
    	exports.hash = hash;
    	
    } (sha512$1));

    (function (exports) {
    	// Copyright (C) 2016 Dmitry Chestnykh
    	// MIT License. See LICENSE file for details.
    	Object.defineProperty(exports, "__esModule", { value: true });
    	exports.convertSecretKeyToX25519 = exports.convertPublicKeyToX25519 = exports.verify = exports.sign = exports.extractPublicKeyFromSecretKey = exports.generateKeyPair = exports.generateKeyPairFromSeed = exports.SEED_LENGTH = exports.SECRET_KEY_LENGTH = exports.PUBLIC_KEY_LENGTH = exports.SIGNATURE_LENGTH = void 0;
    	/**
    	 * Package ed25519 implements Ed25519 public-key signature algorithm.
    	 */
    	const random_1 = random;
    	const sha512_1 = sha512$1;
    	const wipe_1 = wipe$1;
    	exports.SIGNATURE_LENGTH = 64;
    	exports.PUBLIC_KEY_LENGTH = 32;
    	exports.SECRET_KEY_LENGTH = 64;
    	exports.SEED_LENGTH = 32;
    	// Returns new zero-filled 16-element GF (Float64Array).
    	// If passed an array of numbers, prefills the returned
    	// array with them.
    	//
    	// We use Float64Array, because we need 48-bit numbers
    	// for this implementation.
    	function gf(init) {
    	    const r = new Float64Array(16);
    	    if (init) {
    	        for (let i = 0; i < init.length; i++) {
    	            r[i] = init[i];
    	        }
    	    }
    	    return r;
    	}
    	// Base point.
    	const _9 = new Uint8Array(32);
    	_9[0] = 9;
    	const gf0 = gf();
    	const gf1 = gf([1]);
    	const D = gf([
    	    0x78a3, 0x1359, 0x4dca, 0x75eb, 0xd8ab, 0x4141, 0x0a4d, 0x0070,
    	    0xe898, 0x7779, 0x4079, 0x8cc7, 0xfe73, 0x2b6f, 0x6cee, 0x5203
    	]);
    	const D2 = gf([
    	    0xf159, 0x26b2, 0x9b94, 0xebd6, 0xb156, 0x8283, 0x149a, 0x00e0,
    	    0xd130, 0xeef3, 0x80f2, 0x198e, 0xfce7, 0x56df, 0xd9dc, 0x2406
    	]);
    	const X = gf([
    	    0xd51a, 0x8f25, 0x2d60, 0xc956, 0xa7b2, 0x9525, 0xc760, 0x692c,
    	    0xdc5c, 0xfdd6, 0xe231, 0xc0a4, 0x53fe, 0xcd6e, 0x36d3, 0x2169
    	]);
    	const Y = gf([
    	    0x6658, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666,
    	    0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666
    	]);
    	const I = gf([
    	    0xa0b0, 0x4a0e, 0x1b27, 0xc4ee, 0xe478, 0xad2f, 0x1806, 0x2f43,
    	    0xd7a7, 0x3dfb, 0x0099, 0x2b4d, 0xdf0b, 0x4fc1, 0x2480, 0x2b83
    	]);
    	function set25519(r, a) {
    	    for (let i = 0; i < 16; i++) {
    	        r[i] = a[i] | 0;
    	    }
    	}
    	function car25519(o) {
    	    let c = 1;
    	    for (let i = 0; i < 16; i++) {
    	        let v = o[i] + c + 65535;
    	        c = Math.floor(v / 65536);
    	        o[i] = v - c * 65536;
    	    }
    	    o[0] += c - 1 + 37 * (c - 1);
    	}
    	function sel25519(p, q, b) {
    	    const c = ~(b - 1);
    	    for (let i = 0; i < 16; i++) {
    	        const t = c & (p[i] ^ q[i]);
    	        p[i] ^= t;
    	        q[i] ^= t;
    	    }
    	}
    	function pack25519(o, n) {
    	    const m = gf();
    	    const t = gf();
    	    for (let i = 0; i < 16; i++) {
    	        t[i] = n[i];
    	    }
    	    car25519(t);
    	    car25519(t);
    	    car25519(t);
    	    for (let j = 0; j < 2; j++) {
    	        m[0] = t[0] - 0xffed;
    	        for (let i = 1; i < 15; i++) {
    	            m[i] = t[i] - 0xffff - ((m[i - 1] >> 16) & 1);
    	            m[i - 1] &= 0xffff;
    	        }
    	        m[15] = t[15] - 0x7fff - ((m[14] >> 16) & 1);
    	        const b = (m[15] >> 16) & 1;
    	        m[14] &= 0xffff;
    	        sel25519(t, m, 1 - b);
    	    }
    	    for (let i = 0; i < 16; i++) {
    	        o[2 * i] = t[i] & 0xff;
    	        o[2 * i + 1] = t[i] >> 8;
    	    }
    	}
    	function verify32(x, y) {
    	    let d = 0;
    	    for (let i = 0; i < 32; i++) {
    	        d |= x[i] ^ y[i];
    	    }
    	    return (1 & ((d - 1) >>> 8)) - 1;
    	}
    	function neq25519(a, b) {
    	    const c = new Uint8Array(32);
    	    const d = new Uint8Array(32);
    	    pack25519(c, a);
    	    pack25519(d, b);
    	    return verify32(c, d);
    	}
    	function par25519(a) {
    	    const d = new Uint8Array(32);
    	    pack25519(d, a);
    	    return d[0] & 1;
    	}
    	function unpack25519(o, n) {
    	    for (let i = 0; i < 16; i++) {
    	        o[i] = n[2 * i] + (n[2 * i + 1] << 8);
    	    }
    	    o[15] &= 0x7fff;
    	}
    	function add(o, a, b) {
    	    for (let i = 0; i < 16; i++) {
    	        o[i] = a[i] + b[i];
    	    }
    	}
    	function sub(o, a, b) {
    	    for (let i = 0; i < 16; i++) {
    	        o[i] = a[i] - b[i];
    	    }
    	}
    	function mul(o, a, b) {
    	    let v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
    	    v = a[0];
    	    t0 += v * b0;
    	    t1 += v * b1;
    	    t2 += v * b2;
    	    t3 += v * b3;
    	    t4 += v * b4;
    	    t5 += v * b5;
    	    t6 += v * b6;
    	    t7 += v * b7;
    	    t8 += v * b8;
    	    t9 += v * b9;
    	    t10 += v * b10;
    	    t11 += v * b11;
    	    t12 += v * b12;
    	    t13 += v * b13;
    	    t14 += v * b14;
    	    t15 += v * b15;
    	    v = a[1];
    	    t1 += v * b0;
    	    t2 += v * b1;
    	    t3 += v * b2;
    	    t4 += v * b3;
    	    t5 += v * b4;
    	    t6 += v * b5;
    	    t7 += v * b6;
    	    t8 += v * b7;
    	    t9 += v * b8;
    	    t10 += v * b9;
    	    t11 += v * b10;
    	    t12 += v * b11;
    	    t13 += v * b12;
    	    t14 += v * b13;
    	    t15 += v * b14;
    	    t16 += v * b15;
    	    v = a[2];
    	    t2 += v * b0;
    	    t3 += v * b1;
    	    t4 += v * b2;
    	    t5 += v * b3;
    	    t6 += v * b4;
    	    t7 += v * b5;
    	    t8 += v * b6;
    	    t9 += v * b7;
    	    t10 += v * b8;
    	    t11 += v * b9;
    	    t12 += v * b10;
    	    t13 += v * b11;
    	    t14 += v * b12;
    	    t15 += v * b13;
    	    t16 += v * b14;
    	    t17 += v * b15;
    	    v = a[3];
    	    t3 += v * b0;
    	    t4 += v * b1;
    	    t5 += v * b2;
    	    t6 += v * b3;
    	    t7 += v * b4;
    	    t8 += v * b5;
    	    t9 += v * b6;
    	    t10 += v * b7;
    	    t11 += v * b8;
    	    t12 += v * b9;
    	    t13 += v * b10;
    	    t14 += v * b11;
    	    t15 += v * b12;
    	    t16 += v * b13;
    	    t17 += v * b14;
    	    t18 += v * b15;
    	    v = a[4];
    	    t4 += v * b0;
    	    t5 += v * b1;
    	    t6 += v * b2;
    	    t7 += v * b3;
    	    t8 += v * b4;
    	    t9 += v * b5;
    	    t10 += v * b6;
    	    t11 += v * b7;
    	    t12 += v * b8;
    	    t13 += v * b9;
    	    t14 += v * b10;
    	    t15 += v * b11;
    	    t16 += v * b12;
    	    t17 += v * b13;
    	    t18 += v * b14;
    	    t19 += v * b15;
    	    v = a[5];
    	    t5 += v * b0;
    	    t6 += v * b1;
    	    t7 += v * b2;
    	    t8 += v * b3;
    	    t9 += v * b4;
    	    t10 += v * b5;
    	    t11 += v * b6;
    	    t12 += v * b7;
    	    t13 += v * b8;
    	    t14 += v * b9;
    	    t15 += v * b10;
    	    t16 += v * b11;
    	    t17 += v * b12;
    	    t18 += v * b13;
    	    t19 += v * b14;
    	    t20 += v * b15;
    	    v = a[6];
    	    t6 += v * b0;
    	    t7 += v * b1;
    	    t8 += v * b2;
    	    t9 += v * b3;
    	    t10 += v * b4;
    	    t11 += v * b5;
    	    t12 += v * b6;
    	    t13 += v * b7;
    	    t14 += v * b8;
    	    t15 += v * b9;
    	    t16 += v * b10;
    	    t17 += v * b11;
    	    t18 += v * b12;
    	    t19 += v * b13;
    	    t20 += v * b14;
    	    t21 += v * b15;
    	    v = a[7];
    	    t7 += v * b0;
    	    t8 += v * b1;
    	    t9 += v * b2;
    	    t10 += v * b3;
    	    t11 += v * b4;
    	    t12 += v * b5;
    	    t13 += v * b6;
    	    t14 += v * b7;
    	    t15 += v * b8;
    	    t16 += v * b9;
    	    t17 += v * b10;
    	    t18 += v * b11;
    	    t19 += v * b12;
    	    t20 += v * b13;
    	    t21 += v * b14;
    	    t22 += v * b15;
    	    v = a[8];
    	    t8 += v * b0;
    	    t9 += v * b1;
    	    t10 += v * b2;
    	    t11 += v * b3;
    	    t12 += v * b4;
    	    t13 += v * b5;
    	    t14 += v * b6;
    	    t15 += v * b7;
    	    t16 += v * b8;
    	    t17 += v * b9;
    	    t18 += v * b10;
    	    t19 += v * b11;
    	    t20 += v * b12;
    	    t21 += v * b13;
    	    t22 += v * b14;
    	    t23 += v * b15;
    	    v = a[9];
    	    t9 += v * b0;
    	    t10 += v * b1;
    	    t11 += v * b2;
    	    t12 += v * b3;
    	    t13 += v * b4;
    	    t14 += v * b5;
    	    t15 += v * b6;
    	    t16 += v * b7;
    	    t17 += v * b8;
    	    t18 += v * b9;
    	    t19 += v * b10;
    	    t20 += v * b11;
    	    t21 += v * b12;
    	    t22 += v * b13;
    	    t23 += v * b14;
    	    t24 += v * b15;
    	    v = a[10];
    	    t10 += v * b0;
    	    t11 += v * b1;
    	    t12 += v * b2;
    	    t13 += v * b3;
    	    t14 += v * b4;
    	    t15 += v * b5;
    	    t16 += v * b6;
    	    t17 += v * b7;
    	    t18 += v * b8;
    	    t19 += v * b9;
    	    t20 += v * b10;
    	    t21 += v * b11;
    	    t22 += v * b12;
    	    t23 += v * b13;
    	    t24 += v * b14;
    	    t25 += v * b15;
    	    v = a[11];
    	    t11 += v * b0;
    	    t12 += v * b1;
    	    t13 += v * b2;
    	    t14 += v * b3;
    	    t15 += v * b4;
    	    t16 += v * b5;
    	    t17 += v * b6;
    	    t18 += v * b7;
    	    t19 += v * b8;
    	    t20 += v * b9;
    	    t21 += v * b10;
    	    t22 += v * b11;
    	    t23 += v * b12;
    	    t24 += v * b13;
    	    t25 += v * b14;
    	    t26 += v * b15;
    	    v = a[12];
    	    t12 += v * b0;
    	    t13 += v * b1;
    	    t14 += v * b2;
    	    t15 += v * b3;
    	    t16 += v * b4;
    	    t17 += v * b5;
    	    t18 += v * b6;
    	    t19 += v * b7;
    	    t20 += v * b8;
    	    t21 += v * b9;
    	    t22 += v * b10;
    	    t23 += v * b11;
    	    t24 += v * b12;
    	    t25 += v * b13;
    	    t26 += v * b14;
    	    t27 += v * b15;
    	    v = a[13];
    	    t13 += v * b0;
    	    t14 += v * b1;
    	    t15 += v * b2;
    	    t16 += v * b3;
    	    t17 += v * b4;
    	    t18 += v * b5;
    	    t19 += v * b6;
    	    t20 += v * b7;
    	    t21 += v * b8;
    	    t22 += v * b9;
    	    t23 += v * b10;
    	    t24 += v * b11;
    	    t25 += v * b12;
    	    t26 += v * b13;
    	    t27 += v * b14;
    	    t28 += v * b15;
    	    v = a[14];
    	    t14 += v * b0;
    	    t15 += v * b1;
    	    t16 += v * b2;
    	    t17 += v * b3;
    	    t18 += v * b4;
    	    t19 += v * b5;
    	    t20 += v * b6;
    	    t21 += v * b7;
    	    t22 += v * b8;
    	    t23 += v * b9;
    	    t24 += v * b10;
    	    t25 += v * b11;
    	    t26 += v * b12;
    	    t27 += v * b13;
    	    t28 += v * b14;
    	    t29 += v * b15;
    	    v = a[15];
    	    t15 += v * b0;
    	    t16 += v * b1;
    	    t17 += v * b2;
    	    t18 += v * b3;
    	    t19 += v * b4;
    	    t20 += v * b5;
    	    t21 += v * b6;
    	    t22 += v * b7;
    	    t23 += v * b8;
    	    t24 += v * b9;
    	    t25 += v * b10;
    	    t26 += v * b11;
    	    t27 += v * b12;
    	    t28 += v * b13;
    	    t29 += v * b14;
    	    t30 += v * b15;
    	    t0 += 38 * t16;
    	    t1 += 38 * t17;
    	    t2 += 38 * t18;
    	    t3 += 38 * t19;
    	    t4 += 38 * t20;
    	    t5 += 38 * t21;
    	    t6 += 38 * t22;
    	    t7 += 38 * t23;
    	    t8 += 38 * t24;
    	    t9 += 38 * t25;
    	    t10 += 38 * t26;
    	    t11 += 38 * t27;
    	    t12 += 38 * t28;
    	    t13 += 38 * t29;
    	    t14 += 38 * t30;
    	    // t15 left as is
    	    // first car
    	    c = 1;
    	    v = t0 + c + 65535;
    	    c = Math.floor(v / 65536);
    	    t0 = v - c * 65536;
    	    v = t1 + c + 65535;
    	    c = Math.floor(v / 65536);
    	    t1 = v - c * 65536;
    	    v = t2 + c + 65535;
    	    c = Math.floor(v / 65536);
    	    t2 = v - c * 65536;
    	    v = t3 + c + 65535;
    	    c = Math.floor(v / 65536);
    	    t3 = v - c * 65536;
    	    v = t4 + c + 65535;
    	    c = Math.floor(v / 65536);
    	    t4 = v - c * 65536;
    	    v = t5 + c + 65535;
    	    c = Math.floor(v / 65536);
    	    t5 = v - c * 65536;
    	    v = t6 + c + 65535;
    	    c = Math.floor(v / 65536);
    	    t6 = v - c * 65536;
    	    v = t7 + c + 65535;
    	    c = Math.floor(v / 65536);
    	    t7 = v - c * 65536;
    	    v = t8 + c + 65535;
    	    c = Math.floor(v / 65536);
    	    t8 = v - c * 65536;
    	    v = t9 + c + 65535;
    	    c = Math.floor(v / 65536);
    	    t9 = v - c * 65536;
    	    v = t10 + c + 65535;
    	    c = Math.floor(v / 65536);
    	    t10 = v - c * 65536;
    	    v = t11 + c + 65535;
    	    c = Math.floor(v / 65536);
    	    t11 = v - c * 65536;
    	    v = t12 + c + 65535;
    	    c = Math.floor(v / 65536);
    	    t12 = v - c * 65536;
    	    v = t13 + c + 65535;
    	    c = Math.floor(v / 65536);
    	    t13 = v - c * 65536;
    	    v = t14 + c + 65535;
    	    c = Math.floor(v / 65536);
    	    t14 = v - c * 65536;
    	    v = t15 + c + 65535;
    	    c = Math.floor(v / 65536);
    	    t15 = v - c * 65536;
    	    t0 += c - 1 + 37 * (c - 1);
    	    // second car
    	    c = 1;
    	    v = t0 + c + 65535;
    	    c = Math.floor(v / 65536);
    	    t0 = v - c * 65536;
    	    v = t1 + c + 65535;
    	    c = Math.floor(v / 65536);
    	    t1 = v - c * 65536;
    	    v = t2 + c + 65535;
    	    c = Math.floor(v / 65536);
    	    t2 = v - c * 65536;
    	    v = t3 + c + 65535;
    	    c = Math.floor(v / 65536);
    	    t3 = v - c * 65536;
    	    v = t4 + c + 65535;
    	    c = Math.floor(v / 65536);
    	    t4 = v - c * 65536;
    	    v = t5 + c + 65535;
    	    c = Math.floor(v / 65536);
    	    t5 = v - c * 65536;
    	    v = t6 + c + 65535;
    	    c = Math.floor(v / 65536);
    	    t6 = v - c * 65536;
    	    v = t7 + c + 65535;
    	    c = Math.floor(v / 65536);
    	    t7 = v - c * 65536;
    	    v = t8 + c + 65535;
    	    c = Math.floor(v / 65536);
    	    t8 = v - c * 65536;
    	    v = t9 + c + 65535;
    	    c = Math.floor(v / 65536);
    	    t9 = v - c * 65536;
    	    v = t10 + c + 65535;
    	    c = Math.floor(v / 65536);
    	    t10 = v - c * 65536;
    	    v = t11 + c + 65535;
    	    c = Math.floor(v / 65536);
    	    t11 = v - c * 65536;
    	    v = t12 + c + 65535;
    	    c = Math.floor(v / 65536);
    	    t12 = v - c * 65536;
    	    v = t13 + c + 65535;
    	    c = Math.floor(v / 65536);
    	    t13 = v - c * 65536;
    	    v = t14 + c + 65535;
    	    c = Math.floor(v / 65536);
    	    t14 = v - c * 65536;
    	    v = t15 + c + 65535;
    	    c = Math.floor(v / 65536);
    	    t15 = v - c * 65536;
    	    t0 += c - 1 + 37 * (c - 1);
    	    o[0] = t0;
    	    o[1] = t1;
    	    o[2] = t2;
    	    o[3] = t3;
    	    o[4] = t4;
    	    o[5] = t5;
    	    o[6] = t6;
    	    o[7] = t7;
    	    o[8] = t8;
    	    o[9] = t9;
    	    o[10] = t10;
    	    o[11] = t11;
    	    o[12] = t12;
    	    o[13] = t13;
    	    o[14] = t14;
    	    o[15] = t15;
    	}
    	function square(o, a) {
    	    mul(o, a, a);
    	}
    	function inv25519(o, i) {
    	    const c = gf();
    	    let a;
    	    for (a = 0; a < 16; a++) {
    	        c[a] = i[a];
    	    }
    	    for (a = 253; a >= 0; a--) {
    	        square(c, c);
    	        if (a !== 2 && a !== 4) {
    	            mul(c, c, i);
    	        }
    	    }
    	    for (a = 0; a < 16; a++) {
    	        o[a] = c[a];
    	    }
    	}
    	function pow2523(o, i) {
    	    const c = gf();
    	    let a;
    	    for (a = 0; a < 16; a++) {
    	        c[a] = i[a];
    	    }
    	    for (a = 250; a >= 0; a--) {
    	        square(c, c);
    	        if (a !== 1) {
    	            mul(c, c, i);
    	        }
    	    }
    	    for (a = 0; a < 16; a++) {
    	        o[a] = c[a];
    	    }
    	}
    	function edadd(p, q) {
    	    const a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf(), g = gf(), h = gf(), t = gf();
    	    sub(a, p[1], p[0]);
    	    sub(t, q[1], q[0]);
    	    mul(a, a, t);
    	    add(b, p[0], p[1]);
    	    add(t, q[0], q[1]);
    	    mul(b, b, t);
    	    mul(c, p[3], q[3]);
    	    mul(c, c, D2);
    	    mul(d, p[2], q[2]);
    	    add(d, d, d);
    	    sub(e, b, a);
    	    sub(f, d, c);
    	    add(g, d, c);
    	    add(h, b, a);
    	    mul(p[0], e, f);
    	    mul(p[1], h, g);
    	    mul(p[2], g, f);
    	    mul(p[3], e, h);
    	}
    	function cswap(p, q, b) {
    	    for (let i = 0; i < 4; i++) {
    	        sel25519(p[i], q[i], b);
    	    }
    	}
    	function pack(r, p) {
    	    const tx = gf(), ty = gf(), zi = gf();
    	    inv25519(zi, p[2]);
    	    mul(tx, p[0], zi);
    	    mul(ty, p[1], zi);
    	    pack25519(r, ty);
    	    r[31] ^= par25519(tx) << 7;
    	}
    	function scalarmult(p, q, s) {
    	    set25519(p[0], gf0);
    	    set25519(p[1], gf1);
    	    set25519(p[2], gf1);
    	    set25519(p[3], gf0);
    	    for (let i = 255; i >= 0; --i) {
    	        const b = (s[(i / 8) | 0] >> (i & 7)) & 1;
    	        cswap(p, q, b);
    	        edadd(q, p);
    	        edadd(p, p);
    	        cswap(p, q, b);
    	    }
    	}
    	function scalarbase(p, s) {
    	    const q = [gf(), gf(), gf(), gf()];
    	    set25519(q[0], X);
    	    set25519(q[1], Y);
    	    set25519(q[2], gf1);
    	    mul(q[3], X, Y);
    	    scalarmult(p, q, s);
    	}
    	// Generates key pair from secret 32-byte seed.
    	function generateKeyPairFromSeed(seed) {
    	    if (seed.length !== exports.SEED_LENGTH) {
    	        throw new Error(`ed25519: seed must be ${exports.SEED_LENGTH} bytes`);
    	    }
    	    const d = (0, sha512_1.hash)(seed);
    	    d[0] &= 248;
    	    d[31] &= 127;
    	    d[31] |= 64;
    	    const publicKey = new Uint8Array(32);
    	    const p = [gf(), gf(), gf(), gf()];
    	    scalarbase(p, d);
    	    pack(publicKey, p);
    	    const secretKey = new Uint8Array(64);
    	    secretKey.set(seed);
    	    secretKey.set(publicKey, 32);
    	    return {
    	        publicKey,
    	        secretKey
    	    };
    	}
    	exports.generateKeyPairFromSeed = generateKeyPairFromSeed;
    	function generateKeyPair(prng) {
    	    const seed = (0, random_1.randomBytes)(32, prng);
    	    const result = generateKeyPairFromSeed(seed);
    	    (0, wipe_1.wipe)(seed);
    	    return result;
    	}
    	exports.generateKeyPair = generateKeyPair;
    	function extractPublicKeyFromSecretKey(secretKey) {
    	    if (secretKey.length !== exports.SECRET_KEY_LENGTH) {
    	        throw new Error(`ed25519: secret key must be ${exports.SECRET_KEY_LENGTH} bytes`);
    	    }
    	    return new Uint8Array(secretKey.subarray(32));
    	}
    	exports.extractPublicKeyFromSecretKey = extractPublicKeyFromSecretKey;
    	const L = new Float64Array([
    	    0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58, 0xd6, 0x9c, 0xf7, 0xa2,
    	    0xde, 0xf9, 0xde, 0x14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x10
    	]);
    	function modL(r, x) {
    	    let carry;
    	    let i;
    	    let j;
    	    let k;
    	    for (i = 63; i >= 32; --i) {
    	        carry = 0;
    	        for (j = i - 32, k = i - 12; j < k; ++j) {
    	            x[j] += carry - 16 * x[i] * L[j - (i - 32)];
    	            carry = Math.floor((x[j] + 128) / 256);
    	            x[j] -= carry * 256;
    	        }
    	        x[j] += carry;
    	        x[i] = 0;
    	    }
    	    carry = 0;
    	    for (j = 0; j < 32; j++) {
    	        x[j] += carry - (x[31] >> 4) * L[j];
    	        carry = x[j] >> 8;
    	        x[j] &= 255;
    	    }
    	    for (j = 0; j < 32; j++) {
    	        x[j] -= carry * L[j];
    	    }
    	    for (i = 0; i < 32; i++) {
    	        x[i + 1] += x[i] >> 8;
    	        r[i] = x[i] & 255;
    	    }
    	}
    	function reduce(r) {
    	    const x = new Float64Array(64);
    	    for (let i = 0; i < 64; i++) {
    	        x[i] = r[i];
    	    }
    	    for (let i = 0; i < 64; i++) {
    	        r[i] = 0;
    	    }
    	    modL(r, x);
    	}
    	// Returns 64-byte signature of the message under the 64-byte secret key.
    	function sign(secretKey, message) {
    	    const x = new Float64Array(64);
    	    const p = [gf(), gf(), gf(), gf()];
    	    const d = (0, sha512_1.hash)(secretKey.subarray(0, 32));
    	    d[0] &= 248;
    	    d[31] &= 127;
    	    d[31] |= 64;
    	    const signature = new Uint8Array(64);
    	    signature.set(d.subarray(32), 32);
    	    const hs = new sha512_1.SHA512();
    	    hs.update(signature.subarray(32));
    	    hs.update(message);
    	    const r = hs.digest();
    	    hs.clean();
    	    reduce(r);
    	    scalarbase(p, r);
    	    pack(signature, p);
    	    hs.reset();
    	    hs.update(signature.subarray(0, 32));
    	    hs.update(secretKey.subarray(32));
    	    hs.update(message);
    	    const h = hs.digest();
    	    reduce(h);
    	    for (let i = 0; i < 32; i++) {
    	        x[i] = r[i];
    	    }
    	    for (let i = 0; i < 32; i++) {
    	        for (let j = 0; j < 32; j++) {
    	            x[i + j] += h[i] * d[j];
    	        }
    	    }
    	    modL(signature.subarray(32), x);
    	    return signature;
    	}
    	exports.sign = sign;
    	function unpackneg(r, p) {
    	    const t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
    	    set25519(r[2], gf1);
    	    unpack25519(r[1], p);
    	    square(num, r[1]);
    	    mul(den, num, D);
    	    sub(num, num, r[2]);
    	    add(den, r[2], den);
    	    square(den2, den);
    	    square(den4, den2);
    	    mul(den6, den4, den2);
    	    mul(t, den6, num);
    	    mul(t, t, den);
    	    pow2523(t, t);
    	    mul(t, t, num);
    	    mul(t, t, den);
    	    mul(t, t, den);
    	    mul(r[0], t, den);
    	    square(chk, r[0]);
    	    mul(chk, chk, den);
    	    if (neq25519(chk, num)) {
    	        mul(r[0], r[0], I);
    	    }
    	    square(chk, r[0]);
    	    mul(chk, chk, den);
    	    if (neq25519(chk, num)) {
    	        return -1;
    	    }
    	    if (par25519(r[0]) === (p[31] >> 7)) {
    	        sub(r[0], gf0, r[0]);
    	    }
    	    mul(r[3], r[0], r[1]);
    	    return 0;
    	}
    	function verify(publicKey, message, signature) {
    	    const t = new Uint8Array(32);
    	    const p = [gf(), gf(), gf(), gf()];
    	    const q = [gf(), gf(), gf(), gf()];
    	    if (signature.length !== exports.SIGNATURE_LENGTH) {
    	        throw new Error(`ed25519: signature must be ${exports.SIGNATURE_LENGTH} bytes`);
    	    }
    	    if (unpackneg(q, publicKey)) {
    	        return false;
    	    }
    	    const hs = new sha512_1.SHA512();
    	    hs.update(signature.subarray(0, 32));
    	    hs.update(publicKey);
    	    hs.update(message);
    	    const h = hs.digest();
    	    reduce(h);
    	    scalarmult(p, q, h);
    	    scalarbase(q, signature.subarray(32));
    	    edadd(p, q);
    	    pack(t, p);
    	    if (verify32(signature, t)) {
    	        return false;
    	    }
    	    return true;
    	}
    	exports.verify = verify;
    	/**
    	 * Convert Ed25519 public key to X25519 public key.
    	 *
    	 * Throws if given an invalid public key.
    	 */
    	function convertPublicKeyToX25519(publicKey) {
    	    let q = [gf(), gf(), gf(), gf()];
    	    if (unpackneg(q, publicKey)) {
    	        throw new Error("Ed25519: invalid public key");
    	    }
    	    // Formula: montgomeryX = (edwardsY + 1)*inverse(1 - edwardsY) mod p
    	    let a = gf();
    	    let b = gf();
    	    let y = q[1];
    	    add(a, gf1, y);
    	    sub(b, gf1, y);
    	    inv25519(b, b);
    	    mul(a, a, b);
    	    let z = new Uint8Array(32);
    	    pack25519(z, a);
    	    return z;
    	}
    	exports.convertPublicKeyToX25519 = convertPublicKeyToX25519;
    	/**
    	 *  Convert Ed25519 secret (private) key to X25519 secret key.
    	 */
    	function convertSecretKeyToX25519(secretKey) {
    	    const d = (0, sha512_1.hash)(secretKey.subarray(0, 32));
    	    d[0] &= 248;
    	    d[31] &= 127;
    	    d[31] |= 64;
    	    const o = new Uint8Array(d.subarray(0, 32));
    	    (0, wipe_1.wipe)(d);
    	    return o;
    	}
    	exports.convertSecretKeyToX25519 = convertSecretKeyToX25519;
    	
    } (ed25519));

    const JWT_IRIDIUM_ALG = "EdDSA";
    const JWT_IRIDIUM_TYP = "JWT";
    const JWT_DELIMITER = ".";
    const JWT_ENCODING = "base64url";
    const JSON_ENCODING = "utf8";
    const DATA_ENCODING = "utf8";
    const DID_DELIMITER = ":";
    const DID_PREFIX = "did";
    const DID_METHOD = "key";
    const MULTICODEC_ED25519_ENCODING = "base58btc";
    const MULTICODEC_ED25519_BASE = "z";
    const MULTICODEC_ED25519_HEADER = "K36";
    const KEY_PAIR_SEED_LENGTH = 32;

    function encodeJSON(val) {
        return toString$1(fromString$1(safeJsonStringify(val), JSON_ENCODING), JWT_ENCODING);
    }
    function encodeIss(publicKey) {
        const header = fromString$1(MULTICODEC_ED25519_HEADER, MULTICODEC_ED25519_ENCODING);
        const multicodec = MULTICODEC_ED25519_BASE +
            toString$1(concat$1([header, publicKey]), MULTICODEC_ED25519_ENCODING);
        return [DID_PREFIX, DID_METHOD, multicodec].join(DID_DELIMITER);
    }
    function encodeSig(bytes) {
        return toString$1(bytes, JWT_ENCODING);
    }
    function encodeData(params) {
        return fromString$1([encodeJSON(params.header), encodeJSON(params.payload)].join(JWT_DELIMITER), DATA_ENCODING);
    }
    function encodeJWT(params) {
        return [
            encodeJSON(params.header),
            encodeJSON(params.payload),
            encodeSig(params.signature),
        ].join(JWT_DELIMITER);
    }

    function generateKeyPair(seed = random.randomBytes(KEY_PAIR_SEED_LENGTH)) {
        return ed25519.generateKeyPairFromSeed(seed);
    }
    async function signJWT(sub, aud, ttl, keyPair, iat = cjs$7.fromMiliseconds(Date.now())) {
        const header = { alg: JWT_IRIDIUM_ALG, typ: JWT_IRIDIUM_TYP };
        const iss = encodeIss(keyPair.publicKey);
        const exp = iat + ttl;
        const payload = { iss, sub, aud, iat, exp };
        const data = encodeData({ header, payload });
        const signature = ed25519.sign(keyPair.secretKey, data);
        return encodeJWT({ header, payload, signature });
    }

    const PARSE_ERROR = "PARSE_ERROR";
    const INVALID_REQUEST = "INVALID_REQUEST";
    const METHOD_NOT_FOUND = "METHOD_NOT_FOUND";
    const INVALID_PARAMS = "INVALID_PARAMS";
    const INTERNAL_ERROR = "INTERNAL_ERROR";
    const SERVER_ERROR = "SERVER_ERROR";
    const RESERVED_ERROR_CODES = [-32700, -32600, -32601, -32602, -32603];
    const STANDARD_ERROR_MAP = {
        [PARSE_ERROR]: { code: -32700, message: "Parse error" },
        [INVALID_REQUEST]: { code: -32600, message: "Invalid Request" },
        [METHOD_NOT_FOUND]: { code: -32601, message: "Method not found" },
        [INVALID_PARAMS]: { code: -32602, message: "Invalid params" },
        [INTERNAL_ERROR]: { code: -32603, message: "Internal error" },
        [SERVER_ERROR]: { code: -32000, message: "Server error" },
    };
    const DEFAULT_ERROR = SERVER_ERROR;

    function isReservedErrorCode(code) {
        return RESERVED_ERROR_CODES.includes(code);
    }
    function getError$1(type) {
        if (!Object.keys(STANDARD_ERROR_MAP).includes(type)) {
            return STANDARD_ERROR_MAP[DEFAULT_ERROR];
        }
        return STANDARD_ERROR_MAP[type];
    }
    function getErrorByCode(code) {
        const match = Object.values(STANDARD_ERROR_MAP).find(e => e.code === code);
        if (!match) {
            return STANDARD_ERROR_MAP[DEFAULT_ERROR];
        }
        return match;
    }
    function parseConnectionError(e, url, type) {
        return e.message.includes("getaddrinfo ENOTFOUND") || e.message.includes("connect ECONNREFUSED")
            ? new Error(`Unavailable ${type} RPC url at ${url}`)
            : e;
    }

    var cjs$2 = {};

    var crypto$1 = {};

    var hasRequiredCrypto;

    function requireCrypto () {
    	if (hasRequiredCrypto) return crypto$1;
    	hasRequiredCrypto = 1;
    	Object.defineProperty(crypto$1, "__esModule", { value: true });
    	crypto$1.isBrowserCryptoAvailable = crypto$1.getSubtleCrypto = crypto$1.getBrowerCrypto = void 0;
    	function getBrowerCrypto() {
    	    return (commonjsGlobal === null || commonjsGlobal === void 0 ? void 0 : commonjsGlobal.crypto) || (commonjsGlobal === null || commonjsGlobal === void 0 ? void 0 : commonjsGlobal.msCrypto) || {};
    	}
    	crypto$1.getBrowerCrypto = getBrowerCrypto;
    	function getSubtleCrypto() {
    	    const browserCrypto = getBrowerCrypto();
    	    return browserCrypto.subtle || browserCrypto.webkitSubtle;
    	}
    	crypto$1.getSubtleCrypto = getSubtleCrypto;
    	function isBrowserCryptoAvailable() {
    	    return !!getBrowerCrypto() && !!getSubtleCrypto();
    	}
    	crypto$1.isBrowserCryptoAvailable = isBrowserCryptoAvailable;
    	
    	return crypto$1;
    }

    var env = {};

    var hasRequiredEnv;

    function requireEnv () {
    	if (hasRequiredEnv) return env;
    	hasRequiredEnv = 1;
    	Object.defineProperty(env, "__esModule", { value: true });
    	env.isBrowser = env.isNode = env.isReactNative = void 0;
    	function isReactNative() {
    	    return (typeof document === "undefined" &&
    	        typeof navigator !== "undefined" &&
    	        navigator.product === "ReactNative");
    	}
    	env.isReactNative = isReactNative;
    	function isNode() {
    	    return (typeof browser$1$1 !== "undefined" &&
    	        typeof browser$1$1.versions !== "undefined" &&
    	        typeof browser$1$1.versions.node !== "undefined");
    	}
    	env.isNode = isNode;
    	function isBrowser() {
    	    return !isReactNative() && !isNode();
    	}
    	env.isBrowser = isBrowser;
    	
    	return env;
    }

    (function (exports) {
    	Object.defineProperty(exports, "__esModule", { value: true });
    	const tslib_1 = require$$0$4;
    	tslib_1.__exportStar(requireCrypto(), exports);
    	tslib_1.__exportStar(requireEnv(), exports);
    	
    } (cjs$2));

    function payloadId(entropy = 3) {
        const date = Date.now() * Math.pow(10, entropy);
        const extra = Math.floor(Math.random() * Math.pow(10, entropy));
        return date + extra;
    }
    function getBigIntRpcId(entropy = 6) {
        return BigInt(payloadId(entropy));
    }
    function formatJsonRpcRequest(method, params, id) {
        return {
            id: id || payloadId(),
            jsonrpc: "2.0",
            method,
            params,
        };
    }
    function formatJsonRpcResult(id, result) {
        return {
            id,
            jsonrpc: "2.0",
            result,
        };
    }
    function formatJsonRpcError(id, error, data) {
        return {
            id,
            jsonrpc: "2.0",
            error: formatErrorMessage(error, data),
        };
    }
    function formatErrorMessage(error, data) {
        if (typeof error === "undefined") {
            return getError$1(INTERNAL_ERROR);
        }
        if (typeof error === "string") {
            error = Object.assign(Object.assign({}, getError$1(SERVER_ERROR)), { message: error });
        }
        if (typeof data !== "undefined") {
            error.data = data;
        }
        if (isReservedErrorCode(error.code)) {
            error = getErrorByCode(error.code);
        }
        return error;
    }

    class IEvents {
    }

    class IBaseJsonRpcProvider extends IEvents {
        constructor() {
            super();
        }
    }
    class IJsonRpcProvider extends IBaseJsonRpcProvider {
        constructor(connection) {
            super();
        }
    }

    const HTTP_REGEX = "^https?:";
    const WS_REGEX = "^wss?:";
    function getUrlProtocol(url) {
        const matches = url.match(new RegExp(/^\w+:/, "gi"));
        if (!matches || !matches.length)
            return;
        return matches[0];
    }
    function matchRegexProtocol(url, regex) {
        const protocol = getUrlProtocol(url);
        if (typeof protocol === "undefined")
            return false;
        return new RegExp(regex).test(protocol);
    }
    function isHttpUrl(url) {
        return matchRegexProtocol(url, HTTP_REGEX);
    }
    function isWsUrl(url) {
        return matchRegexProtocol(url, WS_REGEX);
    }
    function isLocalhostUrl(url) {
        return new RegExp("wss?://localhost(:d{2,5})?").test(url);
    }

    function isJsonRpcPayload(payload) {
        return (typeof payload === "object" &&
            "id" in payload &&
            "jsonrpc" in payload &&
            payload.jsonrpc === "2.0");
    }
    function isJsonRpcRequest(payload) {
        return isJsonRpcPayload(payload) && "method" in payload;
    }
    function isJsonRpcResponse(payload) {
        return isJsonRpcPayload(payload) && (isJsonRpcResult(payload) || isJsonRpcError(payload));
    }
    function isJsonRpcResult(payload) {
        return "result" in payload;
    }
    function isJsonRpcError(payload) {
        return "error" in payload;
    }

    class JsonRpcProvider extends IJsonRpcProvider {
        constructor(connection) {
            super(connection);
            this.events = new EventEmitter$1();
            this.hasRegisteredEventListeners = false;
            this.connection = this.setConnection(connection);
            if (this.connection.connected) {
                this.registerEventListeners();
            }
        }
        async connect(connection = this.connection) {
            await this.open(connection);
        }
        async disconnect() {
            await this.close();
        }
        on(event, listener) {
            this.events.on(event, listener);
        }
        once(event, listener) {
            this.events.once(event, listener);
        }
        off(event, listener) {
            this.events.off(event, listener);
        }
        removeListener(event, listener) {
            this.events.removeListener(event, listener);
        }
        async request(request, context) {
            return this.requestStrict(formatJsonRpcRequest(request.method, request.params || [], request.id || getBigIntRpcId().toString()), context);
        }
        async requestStrict(request, context) {
            return new Promise(async (resolve, reject) => {
                if (!this.connection.connected) {
                    try {
                        await this.open();
                    }
                    catch (e) {
                        reject(e);
                    }
                }
                this.events.on(`${request.id}`, response => {
                    if (isJsonRpcError(response)) {
                        reject(response.error);
                    }
                    else {
                        resolve(response.result);
                    }
                });
                try {
                    await this.connection.send(request, context);
                }
                catch (e) {
                    reject(e);
                }
            });
        }
        setConnection(connection = this.connection) {
            return connection;
        }
        onPayload(payload) {
            this.events.emit("payload", payload);
            if (isJsonRpcResponse(payload)) {
                this.events.emit(`${payload.id}`, payload);
            }
            else {
                this.events.emit("message", {
                    type: payload.method,
                    data: payload.params,
                });
            }
        }
        onClose(event) {
            if (event && event.code === 3000) {
                this.events.emit("error", new Error(`WebSocket connection closed abnormally with code: ${event.code} ${event.reason ? `(${event.reason})` : ""}`));
            }
            this.events.emit("disconnect");
        }
        async open(connection = this.connection) {
            if (this.connection === connection && this.connection.connected)
                return;
            if (this.connection.connected)
                this.close();
            if (typeof connection === "string") {
                await this.connection.open(connection);
                connection = this.connection;
            }
            this.connection = this.setConnection(connection);
            await this.connection.open();
            this.registerEventListeners();
            this.events.emit("connect");
        }
        async close() {
            await this.connection.close();
        }
        registerEventListeners() {
            if (this.hasRegisteredEventListeners)
                return;
            this.connection.on("payload", (payload) => this.onPayload(payload));
            this.connection.on("close", (event) => this.onClose(event));
            this.connection.on("error", (error) => this.events.emit("error", error));
            this.connection.on("register_error", (error) => this.onClose());
            this.hasRegisteredEventListeners = true;
        }
    }

    const w$8=()=>typeof WebSocket<"u"?WebSocket:typeof global$1<"u"&&typeof global$1.WebSocket<"u"?global$1.WebSocket:typeof window<"u"&&typeof window.WebSocket<"u"?window.WebSocket:typeof self<"u"&&typeof self.WebSocket<"u"?self.WebSocket:require("ws"),b$7=()=>typeof WebSocket<"u"||typeof global$1<"u"&&typeof global$1.WebSocket<"u"||typeof window<"u"&&typeof window.WebSocket<"u"||typeof self<"u"&&typeof self.WebSocket<"u",a$b=c=>c.split("?")[0],h$g=10,S$c=w$8();let f$e = class f{constructor(e){if(this.url=e,this.events=new EventEmitter$1,this.registering=!1,!isWsUrl(e))throw new Error(`Provided URL is not compatible with WebSocket connection: ${e}`);this.url=e;}get connected(){return typeof this.socket<"u"}get connecting(){return this.registering}on(e,t){this.events.on(e,t);}once(e,t){this.events.once(e,t);}off(e,t){this.events.off(e,t);}removeListener(e,t){this.events.removeListener(e,t);}async open(e=this.url){await this.register(e);}async close(){return new Promise((e,t)=>{if(typeof this.socket>"u"){t(new Error("Connection already closed"));return}this.socket.onclose=n=>{this.onClose(n),e();},this.socket.close();})}async send(e){typeof this.socket>"u"&&(this.socket=await this.register());try{this.socket.send(safeJsonStringify(e));}catch(t){this.onError(e.id,t);}}register(e=this.url){if(!isWsUrl(e))throw new Error(`Provided URL is not compatible with WebSocket connection: ${e}`);if(this.registering){const t=this.events.getMaxListeners();return (this.events.listenerCount("register_error")>=t||this.events.listenerCount("open")>=t)&&this.events.setMaxListeners(t+1),new Promise((n,o)=>{this.events.once("register_error",s=>{this.resetMaxListeners(),o(s);}),this.events.once("open",()=>{if(this.resetMaxListeners(),typeof this.socket>"u")return o(new Error("WebSocket connection is missing or invalid"));n(this.socket);});})}return this.url=e,this.registering=!0,new Promise((t,n)=>{const o=new URLSearchParams(e).get("origin"),s=cjs$2.isReactNative()?{headers:{origin:o}}:{rejectUnauthorized:!isLocalhostUrl(e)},i=new S$c(e,[],s);b$7()?i.onerror=r=>{const l=r;n(this.emitError(l.error));}:i.on("error",r=>{n(this.emitError(r));}),i.onopen=()=>{this.onOpen(i),t(i);};})}onOpen(e){e.onmessage=t=>this.onPayload(t),e.onclose=t=>this.onClose(t),this.socket=e,this.registering=!1,this.events.emit("open");}onClose(e){this.socket=void 0,this.registering=!1,this.events.emit("close",e);}onPayload(e){if(typeof e.data>"u")return;const t=typeof e.data=="string"?safeJsonParse(e.data):e.data;this.events.emit("payload",t);}onError(e,t){const n=this.parseError(t),o=n.message||n.toString(),s=formatJsonRpcError(e,o);this.events.emit("payload",s);}parseError(e,t=this.url){return parseConnectionError(e,a$b(t),"WS")}resetMaxListeners(){this.events.getMaxListeners()>h$g&&this.events.setMaxListeners(h$g);}emitError(e){const t=this.parseError(new Error(e?.message||`WebSocket connection failed for host: ${a$b(this.url)}`));return this.events.emit("register_error",t),t}};

    var lodash_isequal = {exports: {}};

    /**
     * Lodash (Custom Build) <https://lodash.com/>
     * Build: `lodash modularize exports="npm" -o ./`
     * Copyright JS Foundation and other contributors <https://js.foundation/>
     * Released under MIT license <https://lodash.com/license>
     * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
     * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     */
    lodash_isequal.exports;

    (function (module, exports) {
    	/** Used as the size to enable large array optimizations. */
    	var LARGE_ARRAY_SIZE = 200;

    	/** Used to stand-in for `undefined` hash values. */
    	var HASH_UNDEFINED = '__lodash_hash_undefined__';

    	/** Used to compose bitmasks for value comparisons. */
    	var COMPARE_PARTIAL_FLAG = 1,
    	    COMPARE_UNORDERED_FLAG = 2;

    	/** Used as references for various `Number` constants. */
    	var MAX_SAFE_INTEGER = 9007199254740991;

    	/** `Object#toString` result references. */
    	var argsTag = '[object Arguments]',
    	    arrayTag = '[object Array]',
    	    asyncTag = '[object AsyncFunction]',
    	    boolTag = '[object Boolean]',
    	    dateTag = '[object Date]',
    	    errorTag = '[object Error]',
    	    funcTag = '[object Function]',
    	    genTag = '[object GeneratorFunction]',
    	    mapTag = '[object Map]',
    	    numberTag = '[object Number]',
    	    nullTag = '[object Null]',
    	    objectTag = '[object Object]',
    	    promiseTag = '[object Promise]',
    	    proxyTag = '[object Proxy]',
    	    regexpTag = '[object RegExp]',
    	    setTag = '[object Set]',
    	    stringTag = '[object String]',
    	    symbolTag = '[object Symbol]',
    	    undefinedTag = '[object Undefined]',
    	    weakMapTag = '[object WeakMap]';

    	var arrayBufferTag = '[object ArrayBuffer]',
    	    dataViewTag = '[object DataView]',
    	    float32Tag = '[object Float32Array]',
    	    float64Tag = '[object Float64Array]',
    	    int8Tag = '[object Int8Array]',
    	    int16Tag = '[object Int16Array]',
    	    int32Tag = '[object Int32Array]',
    	    uint8Tag = '[object Uint8Array]',
    	    uint8ClampedTag = '[object Uint8ClampedArray]',
    	    uint16Tag = '[object Uint16Array]',
    	    uint32Tag = '[object Uint32Array]';

    	/**
    	 * Used to match `RegExp`
    	 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
    	 */
    	var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

    	/** Used to detect host constructors (Safari). */
    	var reIsHostCtor = /^\[object .+?Constructor\]$/;

    	/** Used to detect unsigned integer values. */
    	var reIsUint = /^(?:0|[1-9]\d*)$/;

    	/** Used to identify `toStringTag` values of typed arrays. */
    	var typedArrayTags = {};
    	typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
    	typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
    	typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
    	typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
    	typedArrayTags[uint32Tag] = true;
    	typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
    	typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
    	typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
    	typedArrayTags[errorTag] = typedArrayTags[funcTag] =
    	typedArrayTags[mapTag] = typedArrayTags[numberTag] =
    	typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
    	typedArrayTags[setTag] = typedArrayTags[stringTag] =
    	typedArrayTags[weakMapTag] = false;

    	/** Detect free variable `global` from Node.js. */
    	var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

    	/** Detect free variable `self`. */
    	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

    	/** Used as a reference to the global object. */
    	var root = freeGlobal || freeSelf || Function('return this')();

    	/** Detect free variable `exports`. */
    	var freeExports = exports && !exports.nodeType && exports;

    	/** Detect free variable `module`. */
    	var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

    	/** Detect the popular CommonJS extension `module.exports`. */
    	var moduleExports = freeModule && freeModule.exports === freeExports;

    	/** Detect free variable `process` from Node.js. */
    	var freeProcess = moduleExports && freeGlobal.process;

    	/** Used to access faster Node.js helpers. */
    	var nodeUtil = (function() {
    	  try {
    	    return freeProcess && freeProcess.binding && freeProcess.binding('util');
    	  } catch (e) {}
    	}());

    	/* Node.js helper references. */
    	var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

    	/**
    	 * A specialized version of `_.filter` for arrays without support for
    	 * iteratee shorthands.
    	 *
    	 * @private
    	 * @param {Array} [array] The array to iterate over.
    	 * @param {Function} predicate The function invoked per iteration.
    	 * @returns {Array} Returns the new filtered array.
    	 */
    	function arrayFilter(array, predicate) {
    	  var index = -1,
    	      length = array == null ? 0 : array.length,
    	      resIndex = 0,
    	      result = [];

    	  while (++index < length) {
    	    var value = array[index];
    	    if (predicate(value, index, array)) {
    	      result[resIndex++] = value;
    	    }
    	  }
    	  return result;
    	}

    	/**
    	 * Appends the elements of `values` to `array`.
    	 *
    	 * @private
    	 * @param {Array} array The array to modify.
    	 * @param {Array} values The values to append.
    	 * @returns {Array} Returns `array`.
    	 */
    	function arrayPush(array, values) {
    	  var index = -1,
    	      length = values.length,
    	      offset = array.length;

    	  while (++index < length) {
    	    array[offset + index] = values[index];
    	  }
    	  return array;
    	}

    	/**
    	 * A specialized version of `_.some` for arrays without support for iteratee
    	 * shorthands.
    	 *
    	 * @private
    	 * @param {Array} [array] The array to iterate over.
    	 * @param {Function} predicate The function invoked per iteration.
    	 * @returns {boolean} Returns `true` if any element passes the predicate check,
    	 *  else `false`.
    	 */
    	function arraySome(array, predicate) {
    	  var index = -1,
    	      length = array == null ? 0 : array.length;

    	  while (++index < length) {
    	    if (predicate(array[index], index, array)) {
    	      return true;
    	    }
    	  }
    	  return false;
    	}

    	/**
    	 * The base implementation of `_.times` without support for iteratee shorthands
    	 * or max array length checks.
    	 *
    	 * @private
    	 * @param {number} n The number of times to invoke `iteratee`.
    	 * @param {Function} iteratee The function invoked per iteration.
    	 * @returns {Array} Returns the array of results.
    	 */
    	function baseTimes(n, iteratee) {
    	  var index = -1,
    	      result = Array(n);

    	  while (++index < n) {
    	    result[index] = iteratee(index);
    	  }
    	  return result;
    	}

    	/**
    	 * The base implementation of `_.unary` without support for storing metadata.
    	 *
    	 * @private
    	 * @param {Function} func The function to cap arguments for.
    	 * @returns {Function} Returns the new capped function.
    	 */
    	function baseUnary(func) {
    	  return function(value) {
    	    return func(value);
    	  };
    	}

    	/**
    	 * Checks if a `cache` value for `key` exists.
    	 *
    	 * @private
    	 * @param {Object} cache The cache to query.
    	 * @param {string} key The key of the entry to check.
    	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
    	 */
    	function cacheHas(cache, key) {
    	  return cache.has(key);
    	}

    	/**
    	 * Gets the value at `key` of `object`.
    	 *
    	 * @private
    	 * @param {Object} [object] The object to query.
    	 * @param {string} key The key of the property to get.
    	 * @returns {*} Returns the property value.
    	 */
    	function getValue(object, key) {
    	  return object == null ? undefined : object[key];
    	}

    	/**
    	 * Converts `map` to its key-value pairs.
    	 *
    	 * @private
    	 * @param {Object} map The map to convert.
    	 * @returns {Array} Returns the key-value pairs.
    	 */
    	function mapToArray(map) {
    	  var index = -1,
    	      result = Array(map.size);

    	  map.forEach(function(value, key) {
    	    result[++index] = [key, value];
    	  });
    	  return result;
    	}

    	/**
    	 * Creates a unary function that invokes `func` with its argument transformed.
    	 *
    	 * @private
    	 * @param {Function} func The function to wrap.
    	 * @param {Function} transform The argument transform.
    	 * @returns {Function} Returns the new function.
    	 */
    	function overArg(func, transform) {
    	  return function(arg) {
    	    return func(transform(arg));
    	  };
    	}

    	/**
    	 * Converts `set` to an array of its values.
    	 *
    	 * @private
    	 * @param {Object} set The set to convert.
    	 * @returns {Array} Returns the values.
    	 */
    	function setToArray(set) {
    	  var index = -1,
    	      result = Array(set.size);

    	  set.forEach(function(value) {
    	    result[++index] = value;
    	  });
    	  return result;
    	}

    	/** Used for built-in method references. */
    	var arrayProto = Array.prototype,
    	    funcProto = Function.prototype,
    	    objectProto = Object.prototype;

    	/** Used to detect overreaching core-js shims. */
    	var coreJsData = root['__core-js_shared__'];

    	/** Used to resolve the decompiled source of functions. */
    	var funcToString = funcProto.toString;

    	/** Used to check objects for own properties. */
    	var hasOwnProperty = objectProto.hasOwnProperty;

    	/** Used to detect methods masquerading as native. */
    	var maskSrcKey = (function() {
    	  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
    	  return uid ? ('Symbol(src)_1.' + uid) : '';
    	}());

    	/**
    	 * Used to resolve the
    	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
    	 * of values.
    	 */
    	var nativeObjectToString = objectProto.toString;

    	/** Used to detect if a method is native. */
    	var reIsNative = RegExp('^' +
    	  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
    	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
    	);

    	/** Built-in value references. */
    	var Buffer = moduleExports ? root.Buffer : undefined,
    	    Symbol = root.Symbol,
    	    Uint8Array = root.Uint8Array,
    	    propertyIsEnumerable = objectProto.propertyIsEnumerable,
    	    splice = arrayProto.splice,
    	    symToStringTag = Symbol ? Symbol.toStringTag : undefined;

    	/* Built-in method references for those with the same name as other `lodash` methods. */
    	var nativeGetSymbols = Object.getOwnPropertySymbols,
    	    nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
    	    nativeKeys = overArg(Object.keys, Object);

    	/* Built-in method references that are verified to be native. */
    	var DataView = getNative(root, 'DataView'),
    	    Map = getNative(root, 'Map'),
    	    Promise = getNative(root, 'Promise'),
    	    Set = getNative(root, 'Set'),
    	    WeakMap = getNative(root, 'WeakMap'),
    	    nativeCreate = getNative(Object, 'create');

    	/** Used to detect maps, sets, and weakmaps. */
    	var dataViewCtorString = toSource(DataView),
    	    mapCtorString = toSource(Map),
    	    promiseCtorString = toSource(Promise),
    	    setCtorString = toSource(Set),
    	    weakMapCtorString = toSource(WeakMap);

    	/** Used to convert symbols to primitives and strings. */
    	var symbolProto = Symbol ? Symbol.prototype : undefined,
    	    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

    	/**
    	 * Creates a hash object.
    	 *
    	 * @private
    	 * @constructor
    	 * @param {Array} [entries] The key-value pairs to cache.
    	 */
    	function Hash(entries) {
    	  var index = -1,
    	      length = entries == null ? 0 : entries.length;

    	  this.clear();
    	  while (++index < length) {
    	    var entry = entries[index];
    	    this.set(entry[0], entry[1]);
    	  }
    	}

    	/**
    	 * Removes all key-value entries from the hash.
    	 *
    	 * @private
    	 * @name clear
    	 * @memberOf Hash
    	 */
    	function hashClear() {
    	  this.__data__ = nativeCreate ? nativeCreate(null) : {};
    	  this.size = 0;
    	}

    	/**
    	 * Removes `key` and its value from the hash.
    	 *
    	 * @private
    	 * @name delete
    	 * @memberOf Hash
    	 * @param {Object} hash The hash to modify.
    	 * @param {string} key The key of the value to remove.
    	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
    	 */
    	function hashDelete(key) {
    	  var result = this.has(key) && delete this.__data__[key];
    	  this.size -= result ? 1 : 0;
    	  return result;
    	}

    	/**
    	 * Gets the hash value for `key`.
    	 *
    	 * @private
    	 * @name get
    	 * @memberOf Hash
    	 * @param {string} key The key of the value to get.
    	 * @returns {*} Returns the entry value.
    	 */
    	function hashGet(key) {
    	  var data = this.__data__;
    	  if (nativeCreate) {
    	    var result = data[key];
    	    return result === HASH_UNDEFINED ? undefined : result;
    	  }
    	  return hasOwnProperty.call(data, key) ? data[key] : undefined;
    	}

    	/**
    	 * Checks if a hash value for `key` exists.
    	 *
    	 * @private
    	 * @name has
    	 * @memberOf Hash
    	 * @param {string} key The key of the entry to check.
    	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
    	 */
    	function hashHas(key) {
    	  var data = this.__data__;
    	  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
    	}

    	/**
    	 * Sets the hash `key` to `value`.
    	 *
    	 * @private
    	 * @name set
    	 * @memberOf Hash
    	 * @param {string} key The key of the value to set.
    	 * @param {*} value The value to set.
    	 * @returns {Object} Returns the hash instance.
    	 */
    	function hashSet(key, value) {
    	  var data = this.__data__;
    	  this.size += this.has(key) ? 0 : 1;
    	  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
    	  return this;
    	}

    	// Add methods to `Hash`.
    	Hash.prototype.clear = hashClear;
    	Hash.prototype['delete'] = hashDelete;
    	Hash.prototype.get = hashGet;
    	Hash.prototype.has = hashHas;
    	Hash.prototype.set = hashSet;

    	/**
    	 * Creates an list cache object.
    	 *
    	 * @private
    	 * @constructor
    	 * @param {Array} [entries] The key-value pairs to cache.
    	 */
    	function ListCache(entries) {
    	  var index = -1,
    	      length = entries == null ? 0 : entries.length;

    	  this.clear();
    	  while (++index < length) {
    	    var entry = entries[index];
    	    this.set(entry[0], entry[1]);
    	  }
    	}

    	/**
    	 * Removes all key-value entries from the list cache.
    	 *
    	 * @private
    	 * @name clear
    	 * @memberOf ListCache
    	 */
    	function listCacheClear() {
    	  this.__data__ = [];
    	  this.size = 0;
    	}

    	/**
    	 * Removes `key` and its value from the list cache.
    	 *
    	 * @private
    	 * @name delete
    	 * @memberOf ListCache
    	 * @param {string} key The key of the value to remove.
    	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
    	 */
    	function listCacheDelete(key) {
    	  var data = this.__data__,
    	      index = assocIndexOf(data, key);

    	  if (index < 0) {
    	    return false;
    	  }
    	  var lastIndex = data.length - 1;
    	  if (index == lastIndex) {
    	    data.pop();
    	  } else {
    	    splice.call(data, index, 1);
    	  }
    	  --this.size;
    	  return true;
    	}

    	/**
    	 * Gets the list cache value for `key`.
    	 *
    	 * @private
    	 * @name get
    	 * @memberOf ListCache
    	 * @param {string} key The key of the value to get.
    	 * @returns {*} Returns the entry value.
    	 */
    	function listCacheGet(key) {
    	  var data = this.__data__,
    	      index = assocIndexOf(data, key);

    	  return index < 0 ? undefined : data[index][1];
    	}

    	/**
    	 * Checks if a list cache value for `key` exists.
    	 *
    	 * @private
    	 * @name has
    	 * @memberOf ListCache
    	 * @param {string} key The key of the entry to check.
    	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
    	 */
    	function listCacheHas(key) {
    	  return assocIndexOf(this.__data__, key) > -1;
    	}

    	/**
    	 * Sets the list cache `key` to `value`.
    	 *
    	 * @private
    	 * @name set
    	 * @memberOf ListCache
    	 * @param {string} key The key of the value to set.
    	 * @param {*} value The value to set.
    	 * @returns {Object} Returns the list cache instance.
    	 */
    	function listCacheSet(key, value) {
    	  var data = this.__data__,
    	      index = assocIndexOf(data, key);

    	  if (index < 0) {
    	    ++this.size;
    	    data.push([key, value]);
    	  } else {
    	    data[index][1] = value;
    	  }
    	  return this;
    	}

    	// Add methods to `ListCache`.
    	ListCache.prototype.clear = listCacheClear;
    	ListCache.prototype['delete'] = listCacheDelete;
    	ListCache.prototype.get = listCacheGet;
    	ListCache.prototype.has = listCacheHas;
    	ListCache.prototype.set = listCacheSet;

    	/**
    	 * Creates a map cache object to store key-value pairs.
    	 *
    	 * @private
    	 * @constructor
    	 * @param {Array} [entries] The key-value pairs to cache.
    	 */
    	function MapCache(entries) {
    	  var index = -1,
    	      length = entries == null ? 0 : entries.length;

    	  this.clear();
    	  while (++index < length) {
    	    var entry = entries[index];
    	    this.set(entry[0], entry[1]);
    	  }
    	}

    	/**
    	 * Removes all key-value entries from the map.
    	 *
    	 * @private
    	 * @name clear
    	 * @memberOf MapCache
    	 */
    	function mapCacheClear() {
    	  this.size = 0;
    	  this.__data__ = {
    	    'hash': new Hash,
    	    'map': new (Map || ListCache),
    	    'string': new Hash
    	  };
    	}

    	/**
    	 * Removes `key` and its value from the map.
    	 *
    	 * @private
    	 * @name delete
    	 * @memberOf MapCache
    	 * @param {string} key The key of the value to remove.
    	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
    	 */
    	function mapCacheDelete(key) {
    	  var result = getMapData(this, key)['delete'](key);
    	  this.size -= result ? 1 : 0;
    	  return result;
    	}

    	/**
    	 * Gets the map value for `key`.
    	 *
    	 * @private
    	 * @name get
    	 * @memberOf MapCache
    	 * @param {string} key The key of the value to get.
    	 * @returns {*} Returns the entry value.
    	 */
    	function mapCacheGet(key) {
    	  return getMapData(this, key).get(key);
    	}

    	/**
    	 * Checks if a map value for `key` exists.
    	 *
    	 * @private
    	 * @name has
    	 * @memberOf MapCache
    	 * @param {string} key The key of the entry to check.
    	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
    	 */
    	function mapCacheHas(key) {
    	  return getMapData(this, key).has(key);
    	}

    	/**
    	 * Sets the map `key` to `value`.
    	 *
    	 * @private
    	 * @name set
    	 * @memberOf MapCache
    	 * @param {string} key The key of the value to set.
    	 * @param {*} value The value to set.
    	 * @returns {Object} Returns the map cache instance.
    	 */
    	function mapCacheSet(key, value) {
    	  var data = getMapData(this, key),
    	      size = data.size;

    	  data.set(key, value);
    	  this.size += data.size == size ? 0 : 1;
    	  return this;
    	}

    	// Add methods to `MapCache`.
    	MapCache.prototype.clear = mapCacheClear;
    	MapCache.prototype['delete'] = mapCacheDelete;
    	MapCache.prototype.get = mapCacheGet;
    	MapCache.prototype.has = mapCacheHas;
    	MapCache.prototype.set = mapCacheSet;

    	/**
    	 *
    	 * Creates an array cache object to store unique values.
    	 *
    	 * @private
    	 * @constructor
    	 * @param {Array} [values] The values to cache.
    	 */
    	function SetCache(values) {
    	  var index = -1,
    	      length = values == null ? 0 : values.length;

    	  this.__data__ = new MapCache;
    	  while (++index < length) {
    	    this.add(values[index]);
    	  }
    	}

    	/**
    	 * Adds `value` to the array cache.
    	 *
    	 * @private
    	 * @name add
    	 * @memberOf SetCache
    	 * @alias push
    	 * @param {*} value The value to cache.
    	 * @returns {Object} Returns the cache instance.
    	 */
    	function setCacheAdd(value) {
    	  this.__data__.set(value, HASH_UNDEFINED);
    	  return this;
    	}

    	/**
    	 * Checks if `value` is in the array cache.
    	 *
    	 * @private
    	 * @name has
    	 * @memberOf SetCache
    	 * @param {*} value The value to search for.
    	 * @returns {number} Returns `true` if `value` is found, else `false`.
    	 */
    	function setCacheHas(value) {
    	  return this.__data__.has(value);
    	}

    	// Add methods to `SetCache`.
    	SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    	SetCache.prototype.has = setCacheHas;

    	/**
    	 * Creates a stack cache object to store key-value pairs.
    	 *
    	 * @private
    	 * @constructor
    	 * @param {Array} [entries] The key-value pairs to cache.
    	 */
    	function Stack(entries) {
    	  var data = this.__data__ = new ListCache(entries);
    	  this.size = data.size;
    	}

    	/**
    	 * Removes all key-value entries from the stack.
    	 *
    	 * @private
    	 * @name clear
    	 * @memberOf Stack
    	 */
    	function stackClear() {
    	  this.__data__ = new ListCache;
    	  this.size = 0;
    	}

    	/**
    	 * Removes `key` and its value from the stack.
    	 *
    	 * @private
    	 * @name delete
    	 * @memberOf Stack
    	 * @param {string} key The key of the value to remove.
    	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
    	 */
    	function stackDelete(key) {
    	  var data = this.__data__,
    	      result = data['delete'](key);

    	  this.size = data.size;
    	  return result;
    	}

    	/**
    	 * Gets the stack value for `key`.
    	 *
    	 * @private
    	 * @name get
    	 * @memberOf Stack
    	 * @param {string} key The key of the value to get.
    	 * @returns {*} Returns the entry value.
    	 */
    	function stackGet(key) {
    	  return this.__data__.get(key);
    	}

    	/**
    	 * Checks if a stack value for `key` exists.
    	 *
    	 * @private
    	 * @name has
    	 * @memberOf Stack
    	 * @param {string} key The key of the entry to check.
    	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
    	 */
    	function stackHas(key) {
    	  return this.__data__.has(key);
    	}

    	/**
    	 * Sets the stack `key` to `value`.
    	 *
    	 * @private
    	 * @name set
    	 * @memberOf Stack
    	 * @param {string} key The key of the value to set.
    	 * @param {*} value The value to set.
    	 * @returns {Object} Returns the stack cache instance.
    	 */
    	function stackSet(key, value) {
    	  var data = this.__data__;
    	  if (data instanceof ListCache) {
    	    var pairs = data.__data__;
    	    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
    	      pairs.push([key, value]);
    	      this.size = ++data.size;
    	      return this;
    	    }
    	    data = this.__data__ = new MapCache(pairs);
    	  }
    	  data.set(key, value);
    	  this.size = data.size;
    	  return this;
    	}

    	// Add methods to `Stack`.
    	Stack.prototype.clear = stackClear;
    	Stack.prototype['delete'] = stackDelete;
    	Stack.prototype.get = stackGet;
    	Stack.prototype.has = stackHas;
    	Stack.prototype.set = stackSet;

    	/**
    	 * Creates an array of the enumerable property names of the array-like `value`.
    	 *
    	 * @private
    	 * @param {*} value The value to query.
    	 * @param {boolean} inherited Specify returning inherited property names.
    	 * @returns {Array} Returns the array of property names.
    	 */
    	function arrayLikeKeys(value, inherited) {
    	  var isArr = isArray(value),
    	      isArg = !isArr && isArguments(value),
    	      isBuff = !isArr && !isArg && isBuffer(value),
    	      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
    	      skipIndexes = isArr || isArg || isBuff || isType,
    	      result = skipIndexes ? baseTimes(value.length, String) : [],
    	      length = result.length;

    	  for (var key in value) {
    	    if ((inherited || hasOwnProperty.call(value, key)) &&
    	        !(skipIndexes && (
    	           // Safari 9 has enumerable `arguments.length` in strict mode.
    	           key == 'length' ||
    	           // Node.js 0.10 has enumerable non-index properties on buffers.
    	           (isBuff && (key == 'offset' || key == 'parent')) ||
    	           // PhantomJS 2 has enumerable non-index properties on typed arrays.
    	           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
    	           // Skip index properties.
    	           isIndex(key, length)
    	        ))) {
    	      result.push(key);
    	    }
    	  }
    	  return result;
    	}

    	/**
    	 * Gets the index at which the `key` is found in `array` of key-value pairs.
    	 *
    	 * @private
    	 * @param {Array} array The array to inspect.
    	 * @param {*} key The key to search for.
    	 * @returns {number} Returns the index of the matched value, else `-1`.
    	 */
    	function assocIndexOf(array, key) {
    	  var length = array.length;
    	  while (length--) {
    	    if (eq(array[length][0], key)) {
    	      return length;
    	    }
    	  }
    	  return -1;
    	}

    	/**
    	 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
    	 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
    	 * symbols of `object`.
    	 *
    	 * @private
    	 * @param {Object} object The object to query.
    	 * @param {Function} keysFunc The function to get the keys of `object`.
    	 * @param {Function} symbolsFunc The function to get the symbols of `object`.
    	 * @returns {Array} Returns the array of property names and symbols.
    	 */
    	function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    	  var result = keysFunc(object);
    	  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    	}

    	/**
    	 * The base implementation of `getTag` without fallbacks for buggy environments.
    	 *
    	 * @private
    	 * @param {*} value The value to query.
    	 * @returns {string} Returns the `toStringTag`.
    	 */
    	function baseGetTag(value) {
    	  if (value == null) {
    	    return value === undefined ? undefinedTag : nullTag;
    	  }
    	  return (symToStringTag && symToStringTag in Object(value))
    	    ? getRawTag(value)
    	    : objectToString(value);
    	}

    	/**
    	 * The base implementation of `_.isArguments`.
    	 *
    	 * @private
    	 * @param {*} value The value to check.
    	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
    	 */
    	function baseIsArguments(value) {
    	  return isObjectLike(value) && baseGetTag(value) == argsTag;
    	}

    	/**
    	 * The base implementation of `_.isEqual` which supports partial comparisons
    	 * and tracks traversed objects.
    	 *
    	 * @private
    	 * @param {*} value The value to compare.
    	 * @param {*} other The other value to compare.
    	 * @param {boolean} bitmask The bitmask flags.
    	 *  1 - Unordered comparison
    	 *  2 - Partial comparison
    	 * @param {Function} [customizer] The function to customize comparisons.
    	 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
    	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
    	 */
    	function baseIsEqual(value, other, bitmask, customizer, stack) {
    	  if (value === other) {
    	    return true;
    	  }
    	  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
    	    return value !== value && other !== other;
    	  }
    	  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    	}

    	/**
    	 * A specialized version of `baseIsEqual` for arrays and objects which performs
    	 * deep comparisons and tracks traversed objects enabling objects with circular
    	 * references to be compared.
    	 *
    	 * @private
    	 * @param {Object} object The object to compare.
    	 * @param {Object} other The other object to compare.
    	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
    	 * @param {Function} customizer The function to customize comparisons.
    	 * @param {Function} equalFunc The function to determine equivalents of values.
    	 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
    	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
    	 */
    	function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
    	  var objIsArr = isArray(object),
    	      othIsArr = isArray(other),
    	      objTag = objIsArr ? arrayTag : getTag(object),
    	      othTag = othIsArr ? arrayTag : getTag(other);

    	  objTag = objTag == argsTag ? objectTag : objTag;
    	  othTag = othTag == argsTag ? objectTag : othTag;

    	  var objIsObj = objTag == objectTag,
    	      othIsObj = othTag == objectTag,
    	      isSameTag = objTag == othTag;

    	  if (isSameTag && isBuffer(object)) {
    	    if (!isBuffer(other)) {
    	      return false;
    	    }
    	    objIsArr = true;
    	    objIsObj = false;
    	  }
    	  if (isSameTag && !objIsObj) {
    	    stack || (stack = new Stack);
    	    return (objIsArr || isTypedArray(object))
    	      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
    	      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
    	  }
    	  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
    	    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
    	        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    	    if (objIsWrapped || othIsWrapped) {
    	      var objUnwrapped = objIsWrapped ? object.value() : object,
    	          othUnwrapped = othIsWrapped ? other.value() : other;

    	      stack || (stack = new Stack);
    	      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    	    }
    	  }
    	  if (!isSameTag) {
    	    return false;
    	  }
    	  stack || (stack = new Stack);
    	  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    	}

    	/**
    	 * The base implementation of `_.isNative` without bad shim checks.
    	 *
    	 * @private
    	 * @param {*} value The value to check.
    	 * @returns {boolean} Returns `true` if `value` is a native function,
    	 *  else `false`.
    	 */
    	function baseIsNative(value) {
    	  if (!isObject(value) || isMasked(value)) {
    	    return false;
    	  }
    	  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
    	  return pattern.test(toSource(value));
    	}

    	/**
    	 * The base implementation of `_.isTypedArray` without Node.js optimizations.
    	 *
    	 * @private
    	 * @param {*} value The value to check.
    	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
    	 */
    	function baseIsTypedArray(value) {
    	  return isObjectLike(value) &&
    	    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    	}

    	/**
    	 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
    	 *
    	 * @private
    	 * @param {Object} object The object to query.
    	 * @returns {Array} Returns the array of property names.
    	 */
    	function baseKeys(object) {
    	  if (!isPrototype(object)) {
    	    return nativeKeys(object);
    	  }
    	  var result = [];
    	  for (var key in Object(object)) {
    	    if (hasOwnProperty.call(object, key) && key != 'constructor') {
    	      result.push(key);
    	    }
    	  }
    	  return result;
    	}

    	/**
    	 * A specialized version of `baseIsEqualDeep` for arrays with support for
    	 * partial deep comparisons.
    	 *
    	 * @private
    	 * @param {Array} array The array to compare.
    	 * @param {Array} other The other array to compare.
    	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
    	 * @param {Function} customizer The function to customize comparisons.
    	 * @param {Function} equalFunc The function to determine equivalents of values.
    	 * @param {Object} stack Tracks traversed `array` and `other` objects.
    	 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
    	 */
    	function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
    	  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
    	      arrLength = array.length,
    	      othLength = other.length;

    	  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    	    return false;
    	  }
    	  // Assume cyclic values are equal.
    	  var stacked = stack.get(array);
    	  if (stacked && stack.get(other)) {
    	    return stacked == other;
    	  }
    	  var index = -1,
    	      result = true,
    	      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

    	  stack.set(array, other);
    	  stack.set(other, array);

    	  // Ignore non-index properties.
    	  while (++index < arrLength) {
    	    var arrValue = array[index],
    	        othValue = other[index];

    	    if (customizer) {
    	      var compared = isPartial
    	        ? customizer(othValue, arrValue, index, other, array, stack)
    	        : customizer(arrValue, othValue, index, array, other, stack);
    	    }
    	    if (compared !== undefined) {
    	      if (compared) {
    	        continue;
    	      }
    	      result = false;
    	      break;
    	    }
    	    // Recursively compare arrays (susceptible to call stack limits).
    	    if (seen) {
    	      if (!arraySome(other, function(othValue, othIndex) {
    	            if (!cacheHas(seen, othIndex) &&
    	                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
    	              return seen.push(othIndex);
    	            }
    	          })) {
    	        result = false;
    	        break;
    	      }
    	    } else if (!(
    	          arrValue === othValue ||
    	            equalFunc(arrValue, othValue, bitmask, customizer, stack)
    	        )) {
    	      result = false;
    	      break;
    	    }
    	  }
    	  stack['delete'](array);
    	  stack['delete'](other);
    	  return result;
    	}

    	/**
    	 * A specialized version of `baseIsEqualDeep` for comparing objects of
    	 * the same `toStringTag`.
    	 *
    	 * **Note:** This function only supports comparing values with tags of
    	 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
    	 *
    	 * @private
    	 * @param {Object} object The object to compare.
    	 * @param {Object} other The other object to compare.
    	 * @param {string} tag The `toStringTag` of the objects to compare.
    	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
    	 * @param {Function} customizer The function to customize comparisons.
    	 * @param {Function} equalFunc The function to determine equivalents of values.
    	 * @param {Object} stack Tracks traversed `object` and `other` objects.
    	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
    	 */
    	function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
    	  switch (tag) {
    	    case dataViewTag:
    	      if ((object.byteLength != other.byteLength) ||
    	          (object.byteOffset != other.byteOffset)) {
    	        return false;
    	      }
    	      object = object.buffer;
    	      other = other.buffer;

    	    case arrayBufferTag:
    	      if ((object.byteLength != other.byteLength) ||
    	          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
    	        return false;
    	      }
    	      return true;

    	    case boolTag:
    	    case dateTag:
    	    case numberTag:
    	      // Coerce booleans to `1` or `0` and dates to milliseconds.
    	      // Invalid dates are coerced to `NaN`.
    	      return eq(+object, +other);

    	    case errorTag:
    	      return object.name == other.name && object.message == other.message;

    	    case regexpTag:
    	    case stringTag:
    	      // Coerce regexes to strings and treat strings, primitives and objects,
    	      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
    	      // for more details.
    	      return object == (other + '');

    	    case mapTag:
    	      var convert = mapToArray;

    	    case setTag:
    	      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
    	      convert || (convert = setToArray);

    	      if (object.size != other.size && !isPartial) {
    	        return false;
    	      }
    	      // Assume cyclic values are equal.
    	      var stacked = stack.get(object);
    	      if (stacked) {
    	        return stacked == other;
    	      }
    	      bitmask |= COMPARE_UNORDERED_FLAG;

    	      // Recursively compare objects (susceptible to call stack limits).
    	      stack.set(object, other);
    	      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
    	      stack['delete'](object);
    	      return result;

    	    case symbolTag:
    	      if (symbolValueOf) {
    	        return symbolValueOf.call(object) == symbolValueOf.call(other);
    	      }
    	  }
    	  return false;
    	}

    	/**
    	 * A specialized version of `baseIsEqualDeep` for objects with support for
    	 * partial deep comparisons.
    	 *
    	 * @private
    	 * @param {Object} object The object to compare.
    	 * @param {Object} other The other object to compare.
    	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
    	 * @param {Function} customizer The function to customize comparisons.
    	 * @param {Function} equalFunc The function to determine equivalents of values.
    	 * @param {Object} stack Tracks traversed `object` and `other` objects.
    	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
    	 */
    	function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
    	  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
    	      objProps = getAllKeys(object),
    	      objLength = objProps.length,
    	      othProps = getAllKeys(other),
    	      othLength = othProps.length;

    	  if (objLength != othLength && !isPartial) {
    	    return false;
    	  }
    	  var index = objLength;
    	  while (index--) {
    	    var key = objProps[index];
    	    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
    	      return false;
    	    }
    	  }
    	  // Assume cyclic values are equal.
    	  var stacked = stack.get(object);
    	  if (stacked && stack.get(other)) {
    	    return stacked == other;
    	  }
    	  var result = true;
    	  stack.set(object, other);
    	  stack.set(other, object);

    	  var skipCtor = isPartial;
    	  while (++index < objLength) {
    	    key = objProps[index];
    	    var objValue = object[key],
    	        othValue = other[key];

    	    if (customizer) {
    	      var compared = isPartial
    	        ? customizer(othValue, objValue, key, other, object, stack)
    	        : customizer(objValue, othValue, key, object, other, stack);
    	    }
    	    // Recursively compare objects (susceptible to call stack limits).
    	    if (!(compared === undefined
    	          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
    	          : compared
    	        )) {
    	      result = false;
    	      break;
    	    }
    	    skipCtor || (skipCtor = key == 'constructor');
    	  }
    	  if (result && !skipCtor) {
    	    var objCtor = object.constructor,
    	        othCtor = other.constructor;

    	    // Non `Object` object instances with different constructors are not equal.
    	    if (objCtor != othCtor &&
    	        ('constructor' in object && 'constructor' in other) &&
    	        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
    	          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
    	      result = false;
    	    }
    	  }
    	  stack['delete'](object);
    	  stack['delete'](other);
    	  return result;
    	}

    	/**
    	 * Creates an array of own enumerable property names and symbols of `object`.
    	 *
    	 * @private
    	 * @param {Object} object The object to query.
    	 * @returns {Array} Returns the array of property names and symbols.
    	 */
    	function getAllKeys(object) {
    	  return baseGetAllKeys(object, keys, getSymbols);
    	}

    	/**
    	 * Gets the data for `map`.
    	 *
    	 * @private
    	 * @param {Object} map The map to query.
    	 * @param {string} key The reference key.
    	 * @returns {*} Returns the map data.
    	 */
    	function getMapData(map, key) {
    	  var data = map.__data__;
    	  return isKeyable(key)
    	    ? data[typeof key == 'string' ? 'string' : 'hash']
    	    : data.map;
    	}

    	/**
    	 * Gets the native function at `key` of `object`.
    	 *
    	 * @private
    	 * @param {Object} object The object to query.
    	 * @param {string} key The key of the method to get.
    	 * @returns {*} Returns the function if it's native, else `undefined`.
    	 */
    	function getNative(object, key) {
    	  var value = getValue(object, key);
    	  return baseIsNative(value) ? value : undefined;
    	}

    	/**
    	 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
    	 *
    	 * @private
    	 * @param {*} value The value to query.
    	 * @returns {string} Returns the raw `toStringTag`.
    	 */
    	function getRawTag(value) {
    	  var isOwn = hasOwnProperty.call(value, symToStringTag),
    	      tag = value[symToStringTag];

    	  try {
    	    value[symToStringTag] = undefined;
    	    var unmasked = true;
    	  } catch (e) {}

    	  var result = nativeObjectToString.call(value);
    	  if (unmasked) {
    	    if (isOwn) {
    	      value[symToStringTag] = tag;
    	    } else {
    	      delete value[symToStringTag];
    	    }
    	  }
    	  return result;
    	}

    	/**
    	 * Creates an array of the own enumerable symbols of `object`.
    	 *
    	 * @private
    	 * @param {Object} object The object to query.
    	 * @returns {Array} Returns the array of symbols.
    	 */
    	var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
    	  if (object == null) {
    	    return [];
    	  }
    	  object = Object(object);
    	  return arrayFilter(nativeGetSymbols(object), function(symbol) {
    	    return propertyIsEnumerable.call(object, symbol);
    	  });
    	};

    	/**
    	 * Gets the `toStringTag` of `value`.
    	 *
    	 * @private
    	 * @param {*} value The value to query.
    	 * @returns {string} Returns the `toStringTag`.
    	 */
    	var getTag = baseGetTag;

    	// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
    	if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    	    (Map && getTag(new Map) != mapTag) ||
    	    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    	    (Set && getTag(new Set) != setTag) ||
    	    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
    	  getTag = function(value) {
    	    var result = baseGetTag(value),
    	        Ctor = result == objectTag ? value.constructor : undefined,
    	        ctorString = Ctor ? toSource(Ctor) : '';

    	    if (ctorString) {
    	      switch (ctorString) {
    	        case dataViewCtorString: return dataViewTag;
    	        case mapCtorString: return mapTag;
    	        case promiseCtorString: return promiseTag;
    	        case setCtorString: return setTag;
    	        case weakMapCtorString: return weakMapTag;
    	      }
    	    }
    	    return result;
    	  };
    	}

    	/**
    	 * Checks if `value` is a valid array-like index.
    	 *
    	 * @private
    	 * @param {*} value The value to check.
    	 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
    	 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
    	 */
    	function isIndex(value, length) {
    	  length = length == null ? MAX_SAFE_INTEGER : length;
    	  return !!length &&
    	    (typeof value == 'number' || reIsUint.test(value)) &&
    	    (value > -1 && value % 1 == 0 && value < length);
    	}

    	/**
    	 * Checks if `value` is suitable for use as unique object key.
    	 *
    	 * @private
    	 * @param {*} value The value to check.
    	 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
    	 */
    	function isKeyable(value) {
    	  var type = typeof value;
    	  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    	    ? (value !== '__proto__')
    	    : (value === null);
    	}

    	/**
    	 * Checks if `func` has its source masked.
    	 *
    	 * @private
    	 * @param {Function} func The function to check.
    	 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
    	 */
    	function isMasked(func) {
    	  return !!maskSrcKey && (maskSrcKey in func);
    	}

    	/**
    	 * Checks if `value` is likely a prototype object.
    	 *
    	 * @private
    	 * @param {*} value The value to check.
    	 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
    	 */
    	function isPrototype(value) {
    	  var Ctor = value && value.constructor,
    	      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

    	  return value === proto;
    	}

    	/**
    	 * Converts `value` to a string using `Object.prototype.toString`.
    	 *
    	 * @private
    	 * @param {*} value The value to convert.
    	 * @returns {string} Returns the converted string.
    	 */
    	function objectToString(value) {
    	  return nativeObjectToString.call(value);
    	}

    	/**
    	 * Converts `func` to its source code.
    	 *
    	 * @private
    	 * @param {Function} func The function to convert.
    	 * @returns {string} Returns the source code.
    	 */
    	function toSource(func) {
    	  if (func != null) {
    	    try {
    	      return funcToString.call(func);
    	    } catch (e) {}
    	    try {
    	      return (func + '');
    	    } catch (e) {}
    	  }
    	  return '';
    	}

    	/**
    	 * Performs a
    	 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
    	 * comparison between two values to determine if they are equivalent.
    	 *
    	 * @static
    	 * @memberOf _
    	 * @since 4.0.0
    	 * @category Lang
    	 * @param {*} value The value to compare.
    	 * @param {*} other The other value to compare.
    	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
    	 * @example
    	 *
    	 * var object = { 'a': 1 };
    	 * var other = { 'a': 1 };
    	 *
    	 * _.eq(object, object);
    	 * // => true
    	 *
    	 * _.eq(object, other);
    	 * // => false
    	 *
    	 * _.eq('a', 'a');
    	 * // => true
    	 *
    	 * _.eq('a', Object('a'));
    	 * // => false
    	 *
    	 * _.eq(NaN, NaN);
    	 * // => true
    	 */
    	function eq(value, other) {
    	  return value === other || (value !== value && other !== other);
    	}

    	/**
    	 * Checks if `value` is likely an `arguments` object.
    	 *
    	 * @static
    	 * @memberOf _
    	 * @since 0.1.0
    	 * @category Lang
    	 * @param {*} value The value to check.
    	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
    	 *  else `false`.
    	 * @example
    	 *
    	 * _.isArguments(function() { return arguments; }());
    	 * // => true
    	 *
    	 * _.isArguments([1, 2, 3]);
    	 * // => false
    	 */
    	var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
    	  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
    	    !propertyIsEnumerable.call(value, 'callee');
    	};

    	/**
    	 * Checks if `value` is classified as an `Array` object.
    	 *
    	 * @static
    	 * @memberOf _
    	 * @since 0.1.0
    	 * @category Lang
    	 * @param {*} value The value to check.
    	 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
    	 * @example
    	 *
    	 * _.isArray([1, 2, 3]);
    	 * // => true
    	 *
    	 * _.isArray(document.body.children);
    	 * // => false
    	 *
    	 * _.isArray('abc');
    	 * // => false
    	 *
    	 * _.isArray(_.noop);
    	 * // => false
    	 */
    	var isArray = Array.isArray;

    	/**
    	 * Checks if `value` is array-like. A value is considered array-like if it's
    	 * not a function and has a `value.length` that's an integer greater than or
    	 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
    	 *
    	 * @static
    	 * @memberOf _
    	 * @since 4.0.0
    	 * @category Lang
    	 * @param {*} value The value to check.
    	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
    	 * @example
    	 *
    	 * _.isArrayLike([1, 2, 3]);
    	 * // => true
    	 *
    	 * _.isArrayLike(document.body.children);
    	 * // => true
    	 *
    	 * _.isArrayLike('abc');
    	 * // => true
    	 *
    	 * _.isArrayLike(_.noop);
    	 * // => false
    	 */
    	function isArrayLike(value) {
    	  return value != null && isLength(value.length) && !isFunction(value);
    	}

    	/**
    	 * Checks if `value` is a buffer.
    	 *
    	 * @static
    	 * @memberOf _
    	 * @since 4.3.0
    	 * @category Lang
    	 * @param {*} value The value to check.
    	 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
    	 * @example
    	 *
    	 * _.isBuffer(new Buffer(2));
    	 * // => true
    	 *
    	 * _.isBuffer(new Uint8Array(2));
    	 * // => false
    	 */
    	var isBuffer = nativeIsBuffer || stubFalse;

    	/**
    	 * Performs a deep comparison between two values to determine if they are
    	 * equivalent.
    	 *
    	 * **Note:** This method supports comparing arrays, array buffers, booleans,
    	 * date objects, error objects, maps, numbers, `Object` objects, regexes,
    	 * sets, strings, symbols, and typed arrays. `Object` objects are compared
    	 * by their own, not inherited, enumerable properties. Functions and DOM
    	 * nodes are compared by strict equality, i.e. `===`.
    	 *
    	 * @static
    	 * @memberOf _
    	 * @since 0.1.0
    	 * @category Lang
    	 * @param {*} value The value to compare.
    	 * @param {*} other The other value to compare.
    	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
    	 * @example
    	 *
    	 * var object = { 'a': 1 };
    	 * var other = { 'a': 1 };
    	 *
    	 * _.isEqual(object, other);
    	 * // => true
    	 *
    	 * object === other;
    	 * // => false
    	 */
    	function isEqual(value, other) {
    	  return baseIsEqual(value, other);
    	}

    	/**
    	 * Checks if `value` is classified as a `Function` object.
    	 *
    	 * @static
    	 * @memberOf _
    	 * @since 0.1.0
    	 * @category Lang
    	 * @param {*} value The value to check.
    	 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
    	 * @example
    	 *
    	 * _.isFunction(_);
    	 * // => true
    	 *
    	 * _.isFunction(/abc/);
    	 * // => false
    	 */
    	function isFunction(value) {
    	  if (!isObject(value)) {
    	    return false;
    	  }
    	  // The use of `Object#toString` avoids issues with the `typeof` operator
    	  // in Safari 9 which returns 'object' for typed arrays and other constructors.
    	  var tag = baseGetTag(value);
    	  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    	}

    	/**
    	 * Checks if `value` is a valid array-like length.
    	 *
    	 * **Note:** This method is loosely based on
    	 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
    	 *
    	 * @static
    	 * @memberOf _
    	 * @since 4.0.0
    	 * @category Lang
    	 * @param {*} value The value to check.
    	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
    	 * @example
    	 *
    	 * _.isLength(3);
    	 * // => true
    	 *
    	 * _.isLength(Number.MIN_VALUE);
    	 * // => false
    	 *
    	 * _.isLength(Infinity);
    	 * // => false
    	 *
    	 * _.isLength('3');
    	 * // => false
    	 */
    	function isLength(value) {
    	  return typeof value == 'number' &&
    	    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    	}

    	/**
    	 * Checks if `value` is the
    	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
    	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
    	 *
    	 * @static
    	 * @memberOf _
    	 * @since 0.1.0
    	 * @category Lang
    	 * @param {*} value The value to check.
    	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
    	 * @example
    	 *
    	 * _.isObject({});
    	 * // => true
    	 *
    	 * _.isObject([1, 2, 3]);
    	 * // => true
    	 *
    	 * _.isObject(_.noop);
    	 * // => true
    	 *
    	 * _.isObject(null);
    	 * // => false
    	 */
    	function isObject(value) {
    	  var type = typeof value;
    	  return value != null && (type == 'object' || type == 'function');
    	}

    	/**
    	 * Checks if `value` is object-like. A value is object-like if it's not `null`
    	 * and has a `typeof` result of "object".
    	 *
    	 * @static
    	 * @memberOf _
    	 * @since 4.0.0
    	 * @category Lang
    	 * @param {*} value The value to check.
    	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
    	 * @example
    	 *
    	 * _.isObjectLike({});
    	 * // => true
    	 *
    	 * _.isObjectLike([1, 2, 3]);
    	 * // => true
    	 *
    	 * _.isObjectLike(_.noop);
    	 * // => false
    	 *
    	 * _.isObjectLike(null);
    	 * // => false
    	 */
    	function isObjectLike(value) {
    	  return value != null && typeof value == 'object';
    	}

    	/**
    	 * Checks if `value` is classified as a typed array.
    	 *
    	 * @static
    	 * @memberOf _
    	 * @since 3.0.0
    	 * @category Lang
    	 * @param {*} value The value to check.
    	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
    	 * @example
    	 *
    	 * _.isTypedArray(new Uint8Array);
    	 * // => true
    	 *
    	 * _.isTypedArray([]);
    	 * // => false
    	 */
    	var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

    	/**
    	 * Creates an array of the own enumerable property names of `object`.
    	 *
    	 * **Note:** Non-object values are coerced to objects. See the
    	 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
    	 * for more details.
    	 *
    	 * @static
    	 * @since 0.1.0
    	 * @memberOf _
    	 * @category Object
    	 * @param {Object} object The object to query.
    	 * @returns {Array} Returns the array of property names.
    	 * @example
    	 *
    	 * function Foo() {
    	 *   this.a = 1;
    	 *   this.b = 2;
    	 * }
    	 *
    	 * Foo.prototype.c = 3;
    	 *
    	 * _.keys(new Foo);
    	 * // => ['a', 'b'] (iteration order is not guaranteed)
    	 *
    	 * _.keys('hi');
    	 * // => ['0', '1']
    	 */
    	function keys(object) {
    	  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    	}

    	/**
    	 * This method returns a new empty array.
    	 *
    	 * @static
    	 * @memberOf _
    	 * @since 4.13.0
    	 * @category Util
    	 * @returns {Array} Returns the new empty array.
    	 * @example
    	 *
    	 * var arrays = _.times(2, _.stubArray);
    	 *
    	 * console.log(arrays);
    	 * // => [[], []]
    	 *
    	 * console.log(arrays[0] === arrays[1]);
    	 * // => false
    	 */
    	function stubArray() {
    	  return [];
    	}

    	/**
    	 * This method returns `false`.
    	 *
    	 * @static
    	 * @memberOf _
    	 * @since 4.13.0
    	 * @category Util
    	 * @returns {boolean} Returns `false`.
    	 * @example
    	 *
    	 * _.times(2, _.stubFalse);
    	 * // => [false, false]
    	 */
    	function stubFalse() {
    	  return false;
    	}

    	module.exports = isEqual; 
    } (lodash_isequal, lodash_isequal.exports));

    var lodash_isequalExports = lodash_isequal.exports;
    var Gi = /*@__PURE__*/getDefaultExportFromCjs(lodash_isequalExports);

    function unfetch_module(e,n){return n=n||{},new Promise(function(t,r){var s=new XMLHttpRequest,o=[],u=[],i={},a=function(){return {ok:2==(s.status/100|0),statusText:s.statusText,status:s.status,url:s.responseURL,text:function(){return Promise.resolve(s.responseText)},json:function(){return Promise.resolve(s.responseText).then(JSON.parse)},blob:function(){return Promise.resolve(new Blob([s.response]))},clone:a,headers:{keys:function(){return o},entries:function(){return u},get:function(e){return i[e.toLowerCase()]},has:function(e){return e.toLowerCase()in i}}}};for(var l in s.open(n.method||"get",e,!0),s.onload=function(){s.getAllResponseHeaders().replace(/^(.*?):[^\S\n]*([\s\S]*?)$/gm,function(e,n,t){o.push(n=n.toLowerCase()),u.push([n,t]),i[n]=i[n]?i[n]+","+t:t;}),t(a());},s.onerror=r,s.withCredentials="include"==n.credentials,n.headers)s.setRequestHeader(l,n.headers[l]);s.send(n.body||null);})}

    var unfetch_module$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        default: unfetch_module
    });

    var require$$0$1 = /*@__PURE__*/getAugmentedNamespace(unfetch_module$1);

    var browser$3 = self.fetch || (self.fetch = require$$0$1.default || require$$0$1);

    var Yi = /*@__PURE__*/getDefaultExportFromCjs(browser$3);

    function Hi(n,e){if(n.length>=255)throw new TypeError("Alphabet too long");for(var t=new Uint8Array(256),i=0;i<t.length;i++)t[i]=255;for(var s=0;s<n.length;s++){var r=n.charAt(s),o=r.charCodeAt(0);if(t[o]!==255)throw new TypeError(r+" is ambiguous");t[o]=s;}var a=n.length,h=n.charAt(0),l=Math.log(a)/Math.log(256),d=Math.log(256)/Math.log(a);function p(u){if(u instanceof Uint8Array||(ArrayBuffer.isView(u)?u=new Uint8Array(u.buffer,u.byteOffset,u.byteLength):Array.isArray(u)&&(u=Uint8Array.from(u))),!(u instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(u.length===0)return "";for(var m=0,z=0,I=0,_=u.length;I!==_&&u[I]===0;)I++,m++;for(var T=(_-I)*d+1>>>0,f=new Uint8Array(T);I!==_;){for(var S=u[I],A=0,C=T-1;(S!==0||A<z)&&C!==-1;C--,A++)S+=256*f[C]>>>0,f[C]=S%a>>>0,S=S/a>>>0;if(S!==0)throw new Error("Non-zero carry");z=A,I++;}for(var x=T-z;x!==T&&f[x]===0;)x++;for(var j=h.repeat(m);x<T;++x)j+=n.charAt(f[x]);return j}function y(u){if(typeof u!="string")throw new TypeError("Expected String");if(u.length===0)return new Uint8Array;var m=0;if(u[m]!==" "){for(var z=0,I=0;u[m]===h;)z++,m++;for(var _=(u.length-m)*l+1>>>0,T=new Uint8Array(_);u[m];){var f=t[u.charCodeAt(m)];if(f===255)return;for(var S=0,A=_-1;(f!==0||S<I)&&A!==-1;A--,S++)f+=a*T[A]>>>0,T[A]=f%256>>>0,f=f/256>>>0;if(f!==0)throw new Error("Non-zero carry");I=S,m++;}if(u[m]!==" "){for(var C=_-I;C!==_&&T[C]===0;)C++;for(var x=new Uint8Array(z+(_-C)),j=z;C!==_;)x[j++]=T[C++];return x}}}function M(u){var m=y(u);if(m)return m;throw new Error(`Non-${e} character`)}return {encode:p,decodeUnsafe:y,decode:M}}var Ji=Hi,Xi=Ji;const Ne=n=>{if(n instanceof Uint8Array&&n.constructor.name==="Uint8Array")return n;if(n instanceof ArrayBuffer)return new Uint8Array(n);if(ArrayBuffer.isView(n))return new Uint8Array(n.buffer,n.byteOffset,n.byteLength);throw new Error("Unknown type, must be binary type")},Wi$1=n=>new TextEncoder().encode(n),Qi=n=>new TextDecoder().decode(n);class Zi{constructor(e,t,i){this.name=e,this.prefix=t,this.baseEncode=i;}encode(e){if(e instanceof Uint8Array)return `${this.prefix}${this.baseEncode(e)}`;throw Error("Unknown type, must be binary type")}}class es{constructor(e,t,i){if(this.name=e,this.prefix=t,t.codePointAt(0)===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=t.codePointAt(0),this.baseDecode=i;}decode(e){if(typeof e=="string"){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(e.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(e){return Ue$1(this,e)}}class ts{constructor(e){this.decoders=e;}or(e){return Ue$1(this,e)}decode(e){const t=e[0],i=this.decoders[t];if(i)return i.decode(e);throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}}const Ue$1=(n,e)=>new ts({...n.decoders||{[n.prefix]:n},...e.decoders||{[e.prefix]:e}});let is$1 = class is{constructor(e,t,i,s){this.name=e,this.prefix=t,this.baseEncode=i,this.baseDecode=s,this.encoder=new Zi(e,t,i),this.decoder=new es(e,t,s);}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}};const W$7=({name:n,prefix:e,encode:t,decode:i})=>new is$1(n,e,t,i),B$5=({prefix:n,name:e,alphabet:t})=>{const{encode:i,decode:s}=Xi(t,e);return W$7({prefix:n,name:e,encode:i,decode:r=>Ne(s(r))})},ss=(n,e,t,i)=>{const s={};for(let d=0;d<e.length;++d)s[e[d]]=d;let r=n.length;for(;n[r-1]==="=";)--r;const o=new Uint8Array(r*t/8|0);let a=0,h=0,l=0;for(let d=0;d<r;++d){const p=s[n[d]];if(p===void 0)throw new SyntaxError(`Non-${i} character`);h=h<<t|p,a+=t,a>=8&&(a-=8,o[l++]=255&h>>a);}if(a>=t||255&h<<8-a)throw new SyntaxError("Unexpected end of data");return o},rs=(n,e,t)=>{const i=e[e.length-1]==="=",s=(1<<t)-1;let r="",o=0,a=0;for(let h=0;h<n.length;++h)for(a=a<<8|n[h],o+=8;o>t;)o-=t,r+=e[s&a>>o];if(o&&(r+=e[s&a<<t-o]),i)for(;r.length*t&7;)r+="=";return r},g$9=({name:n,prefix:e,bitsPerChar:t,alphabet:i})=>W$7({prefix:e,name:n,encode(s){return rs(s,i,t)},decode(s){return ss(s,i,t,n)}}),ns=W$7({prefix:"\0",name:"identity",encode:n=>Qi(n),decode:n=>Wi$1(n)});var os=Object.freeze({__proto__:null,identity:ns});const as$1=g$9({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1});var hs$1=Object.freeze({__proto__:null,base2:as$1});const cs$1=g$9({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3});var us$1=Object.freeze({__proto__:null,base8:cs$1});const ls$1=B$5({prefix:"9",name:"base10",alphabet:"0123456789"});var ds$1=Object.freeze({__proto__:null,base10:ls$1});const gs$1=g$9({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),ps$1=g$9({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4});var Ds=Object.freeze({__proto__:null,base16:gs$1,base16upper:ps$1});const ys=g$9({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),ms$1=g$9({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),bs=g$9({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),fs=g$9({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),Es=g$9({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),ws=g$9({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),vs=g$9({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),Is=g$9({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),Cs=g$9({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5});var Rs=Object.freeze({__proto__:null,base32:ys,base32upper:ms$1,base32pad:bs,base32padupper:fs,base32hex:Es,base32hexupper:ws,base32hexpad:vs,base32hexpadupper:Is,base32z:Cs});const _s=B$5({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),Ts=B$5({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"});var Ss=Object.freeze({__proto__:null,base36:_s,base36upper:Ts});const Ps=B$5({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),xs=B$5({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"});var Os=Object.freeze({__proto__:null,base58btc:Ps,base58flickr:xs});const As=g$9({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),zs=g$9({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),Ns=g$9({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),Us=g$9({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6});var Ls=Object.freeze({__proto__:null,base64:As,base64pad:zs,base64url:Ns,base64urlpad:Us});const Le$1=Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}"),$s=Le$1.reduce((n,e,t)=>(n[t]=e,n),[]),Fs=Le$1.reduce((n,e,t)=>(n[e.codePointAt(0)]=t,n),[]);function Ms(n){return n.reduce((e,t)=>(e+=$s[t],e),"")}function ks(n){const e=[];for(const t of n){const i=Fs[t.codePointAt(0)];if(i===void 0)throw new Error(`Non-base256emoji character: ${t}`);e.push(i);}return new Uint8Array(e)}const Ks=W$7({prefix:"\u{1F680}",name:"base256emoji",encode:Ms,decode:ks});var Bs=Object.freeze({__proto__:null,base256emoji:Ks}),Vs=Fe$1,$e$1=128,qs=127,js$1=~qs,Gs=Math.pow(2,31);function Fe$1(n,e,t){e=e||[],t=t||0;for(var i=t;n>=Gs;)e[t++]=n&255|$e$1,n/=128;for(;n&js$1;)e[t++]=n&255|$e$1,n>>>=7;return e[t]=n|0,Fe$1.bytes=t-i+1,e}var Ys=he$2,Hs=128,Me$1=127;function he$2(n,i){var t=0,i=i||0,s=0,r=i,o,a=n.length;do{if(r>=a)throw he$2.bytes=0,new RangeError("Could not decode varint");o=n[r++],t+=s<28?(o&Me$1)<<s:(o&Me$1)*Math.pow(2,s),s+=7;}while(o>=Hs);return he$2.bytes=r-i,t}var Js=Math.pow(2,7),Xs=Math.pow(2,14),Ws=Math.pow(2,21),Qs=Math.pow(2,28),Zs=Math.pow(2,35),er$1=Math.pow(2,42),tr$1=Math.pow(2,49),ir$1=Math.pow(2,56),sr$1=Math.pow(2,63),rr$1=function(n){return n<Js?1:n<Xs?2:n<Ws?3:n<Qs?4:n<Zs?5:n<er$1?6:n<tr$1?7:n<ir$1?8:n<sr$1?9:10},nr$1={encode:Vs,decode:Ys,encodingLength:rr$1},ke$1=nr$1;const Ke$1=(n,e,t=0)=>(ke$1.encode(n,e,t),e),Be$1=n=>ke$1.encodingLength(n),ce$2=(n,e)=>{const t=e.byteLength,i=Be$1(n),s=i+Be$1(t),r=new Uint8Array(s+t);return Ke$1(n,r,0),Ke$1(t,r,i),r.set(e,s),new or$1(n,t,e,r)};let or$1 = class or{constructor(e,t,i,s){this.code=e,this.size=t,this.digest=i,this.bytes=s;}};const Ve$1=({name:n,code:e,encode:t})=>new ar$1(n,e,t);let ar$1 = class ar{constructor(e,t,i){this.name=e,this.code=t,this.encode=i;}digest(e){if(e instanceof Uint8Array){const t=this.encode(e);return t instanceof Uint8Array?ce$2(this.code,t):t.then(i=>ce$2(this.code,i))}else throw Error("Unknown type, must be binary type")}};const qe$1=n=>async e=>new Uint8Array(await crypto.subtle.digest(n,e)),hr$2=Ve$1({name:"sha2-256",code:18,encode:qe$1("SHA-256")}),cr$2=Ve$1({name:"sha2-512",code:19,encode:qe$1("SHA-512")});var ur=Object.freeze({__proto__:null,sha256:hr$2,sha512:cr$2});const je$1=0,lr$2="identity",Ge$1=Ne,dr$1=n=>ce$2(je$1,Ge$1(n)),gr={code:je$1,name:lr$2,encode:Ge$1,digest:dr$1};var pr=Object.freeze({__proto__:null,identity:gr});new TextEncoder,new TextDecoder;const Ye$1={...os,...hs$1,...us$1,...ds$1,...Ds,...Rs,...Ss,...Os,...Ls,...Bs};({...ur,...pr});function He$1(n){return globalThis.Buffer!=null?new Uint8Array(n.buffer,n.byteOffset,n.byteLength):n}function Dr(n=0){return globalThis.Buffer!=null&&globalThis.Buffer.allocUnsafe!=null?He$1(globalThis.Buffer.allocUnsafe(n)):new Uint8Array(n)}function Je(n,e,t,i){return {name:n,prefix:e,encoder:{name:n,prefix:e,encode:t},decoder:{decode:i}}}const Xe=Je("utf8","u",n=>"u"+new TextDecoder("utf8").decode(n),n=>new TextEncoder().encode(n.substring(1))),ue$2=Je("ascii","a",n=>{let e="a";for(let t=0;t<n.length;t++)e+=String.fromCharCode(n[t]);return e},n=>{n=n.substring(1);const e=Dr(n.length);for(let t=0;t<n.length;t++)e[t]=n.charCodeAt(t);return e}),yr={utf8:Xe,"utf-8":Xe,hex:Ye$1.base16,latin1:ue$2,ascii:ue$2,binary:ue$2,...Ye$1};function mr$1(n,e="utf8"){const t=yr[e];if(!t)throw new Error(`Unsupported encoding "${e}"`);return (e==="utf8"||e==="utf-8")&&globalThis.Buffer!=null&&globalThis.Buffer.from!=null?He$1(globalThis.Buffer.from(n,"utf-8")):t.decoder.decode(`${t.prefix}${n}`)}const le$2="wc",We$1=2,Q$4="core",O$3=`${le$2}@2:${Q$4}:`,Qe$1={name:Q$4,logger:"error"},Ze={database:":memory:"},et$1="crypto",de$2="client_ed25519_seed",tt$1=cjs$7.ONE_DAY,it$1="keychain",st$1="0.3",rt$1="messages",nt$1="0.3",ot$1=cjs$7.SIX_HOURS,at$1="publisher",ht$1="irn",ct$1="error",ge$2="wss://relay.walletconnect.com",pe$1="wss://relay.walletconnect.org",ut$1="relayer",D$7={message:"relayer_message",message_ack:"relayer_message_ack",connect:"relayer_connect",disconnect:"relayer_disconnect",error:"relayer_error",connection_stalled:"relayer_connection_stalled",transport_closed:"relayer_transport_closed",publish:"relayer_publish"},lt$5="_subscription",P$7={payload:"payload",connect:"connect",disconnect:"disconnect",error:"error"},dt$1=cjs$7.ONE_SECOND,gt$6="2.11.2",pt$1=1e4,Dt$1="0.3",yt$1="WALLETCONNECT_CLIENT_ID",w$7={created:"subscription_created",deleted:"subscription_deleted",expired:"subscription_expired",disabled:"subscription_disabled",sync:"subscription_sync",resubscribed:"subscription_resubscribed"},mt$1="subscription",bt$1="0.3",ft$4=cjs$7.FIVE_SECONDS*1e3,Et$1="pairing",wt$1="0.3",$$7={wc_pairingDelete:{req:{ttl:cjs$7.ONE_DAY,prompt:!1,tag:1e3},res:{ttl:cjs$7.ONE_DAY,prompt:!1,tag:1001}},wc_pairingPing:{req:{ttl:cjs$7.THIRTY_SECONDS,prompt:!1,tag:1002},res:{ttl:cjs$7.THIRTY_SECONDS,prompt:!1,tag:1003}},unregistered_method:{req:{ttl:cjs$7.ONE_DAY,prompt:!1,tag:0},res:{ttl:cjs$7.ONE_DAY,prompt:!1,tag:0}}},V$6={create:"pairing_create",expire:"pairing_expire",delete:"pairing_delete",ping:"pairing_ping"},R$6={created:"history_created",updated:"history_updated",deleted:"history_deleted",sync:"history_sync"},vt$1="history",It$1="0.3",Ct$2="expirer",v$8={created:"expirer_created",deleted:"expirer_deleted",expired:"expirer_expired",sync:"expirer_sync"},Rt$1="0.3",Z$6="verify-api",F$5="https://verify.walletconnect.com",ee$1="https://verify.walletconnect.org",_t$1=[F$5,ee$1],Tt$1="echo",St$1="https://echo.walletconnect.com";let Pt$1 = class Pt{constructor(e,t){this.core=e,this.logger=t,this.keychain=new Map,this.name=it$1,this.version=st$1,this.initialized=!1,this.storagePrefix=O$3,this.init=async()=>{if(!this.initialized){const i=await this.getKeyChain();typeof i<"u"&&(this.keychain=i),this.initialized=!0;}},this.has=i=>(this.isInitialized(),this.keychain.has(i)),this.set=async(i,s)=>{this.isInitialized(),this.keychain.set(i,s),await this.persist();},this.get=i=>{this.isInitialized();const s=this.keychain.get(i);if(typeof s>"u"){const{message:r}=N$8("NO_MATCHING_KEY",`${this.name}: ${i}`);throw new Error(r)}return s},this.del=async i=>{this.isInitialized(),this.keychain.delete(i),await this.persist();},this.core=e,this.logger=cjs$3.generateChildLogger(t,this.name);}get context(){return cjs$3.getLoggerContext(this.logger)}get storageKey(){return this.storagePrefix+this.version+this.core.customStoragePrefix+"//"+this.name}async setKeyChain(e){await this.core.storage.setItem(this.storageKey,rt$2(e));}async getKeyChain(){const e=await this.core.storage.getItem(this.storageKey);return typeof e<"u"?ot$2(e):void 0}async persist(){await this.setKeyChain(this.keychain);}isInitialized(){if(!this.initialized){const{message:e}=N$8("NOT_INITIALIZED",this.name);throw new Error(e)}}};let xt$1 = class xt{constructor(e,t,i){this.core=e,this.logger=t,this.name=et$1,this.initialized=!1,this.init=async()=>{this.initialized||(await this.keychain.init(),this.initialized=!0);},this.hasKeys=s=>(this.isInitialized(),this.keychain.has(s)),this.getClientId=async()=>{this.isInitialized();const s=await this.getClientSeed(),r=generateKeyPair(s);return encodeIss(r.publicKey)},this.generateKeyPair=()=>{this.isInitialized();const s=kn();return this.setPrivateKey(s.publicKey,s.privateKey)},this.signJWT=async s=>{this.isInitialized();const r=await this.getClientSeed(),o=generateKeyPair(r),a=Vn$1(),h=tt$1;return await signJWT(a,s,h,o)},this.generateSharedKey=(s,r,o)=>{this.isInitialized();const a=this.getPrivateKey(s),h=Mn(a,r);return this.setSymKey(h,o)},this.setSymKey=async(s,r)=>{this.isInitialized();const o=r||Kn(s);return await this.keychain.set(o,s),o},this.deleteKeyPair=async s=>{this.isInitialized(),await this.keychain.del(s);},this.deleteSymKey=async s=>{this.isInitialized(),await this.keychain.del(s);},this.encode=async(s,r,o)=>{this.isInitialized();const a=Ae$1(o),h=safeJsonStringify(r);if(qn(a)){const y=a.senderPublicKey,M=a.receiverPublicKey;s=await this.generateSharedKey(y,M);}const l=this.getSymKey(s),{type:d,senderPublicKey:p}=a;return xn({type:d,symKey:l,message:h,senderPublicKey:p})},this.decode=async(s,r,o)=>{this.isInitialized();const a=Hn(r,o);if(qn(a)){const h=a.receiverPublicKey,l=a.senderPublicKey;s=await this.generateSharedKey(h,l);}try{const h=this.getSymKey(s),l=Fn({symKey:h,encoded:r});return safeJsonParse(l)}catch(h){this.logger.error(`Failed to decode message from topic: '${s}', clientId: '${await this.getClientId()}'`),this.logger.error(h);}},this.getPayloadType=s=>{const r=ee$2(s);return j$9(r.type)},this.getPayloadSenderPublicKey=s=>{const r=ee$2(s);return r.senderPublicKey?toString$1(r.senderPublicKey,p$c):void 0},this.core=e,this.logger=cjs$3.generateChildLogger(t,this.name),this.keychain=i||new Pt$1(this.core,this.logger);}get context(){return cjs$3.getLoggerContext(this.logger)}async setPrivateKey(e,t){return await this.keychain.set(e,t),e}getPrivateKey(e){return this.keychain.get(e)}async getClientSeed(){let e="";try{e=this.keychain.get(de$2);}catch{e=Vn$1(),await this.keychain.set(de$2,e);}return mr$1(e,"base16")}getSymKey(e){return this.keychain.get(e)}isInitialized(){if(!this.initialized){const{message:e}=N$8("NOT_INITIALIZED",this.name);throw new Error(e)}}};let Ot$1 = class Ot extends a$c{constructor(e,t){super(e,t),this.logger=e,this.core=t,this.messages=new Map,this.name=rt$1,this.version=nt$1,this.initialized=!1,this.storagePrefix=O$3,this.init=async()=>{if(!this.initialized){this.logger.trace("Initialized");try{const i=await this.getRelayerMessages();typeof i<"u"&&(this.messages=i),this.logger.debug(`Successfully Restored records for ${this.name}`),this.logger.trace({type:"method",method:"restore",size:this.messages.size});}catch(i){this.logger.debug(`Failed to Restore records for ${this.name}`),this.logger.error(i);}finally{this.initialized=!0;}}},this.set=async(i,s)=>{this.isInitialized();const r=Ln(s);let o=this.messages.get(i);return typeof o>"u"&&(o={}),typeof o[r]<"u"||(o[r]=s,this.messages.set(i,o),await this.persist()),r},this.get=i=>{this.isInitialized();let s=this.messages.get(i);return typeof s>"u"&&(s={}),s},this.has=(i,s)=>{this.isInitialized();const r=this.get(i),o=Ln(s);return typeof r[o]<"u"},this.del=async i=>{this.isInitialized(),this.messages.delete(i),await this.persist();},this.logger=cjs$3.generateChildLogger(e,this.name),this.core=t;}get context(){return cjs$3.getLoggerContext(this.logger)}get storageKey(){return this.storagePrefix+this.version+this.core.customStoragePrefix+"//"+this.name}async setRelayerMessages(e){await this.core.storage.setItem(this.storageKey,rt$2(e));}async getRelayerMessages(){const e=await this.core.storage.getItem(this.storageKey);return typeof e<"u"?ot$2(e):void 0}async persist(){await this.setRelayerMessages(this.messages);}isInitialized(){if(!this.initialized){const{message:e}=N$8("NOT_INITIALIZED",this.name);throw new Error(e)}}};class vr extends u$b{constructor(e,t){super(e,t),this.relayer=e,this.logger=t,this.events=new EventEmitter$1,this.name=at$1,this.queue=new Map,this.publishTimeout=cjs$7.toMiliseconds(cjs$7.TEN_SECONDS*2),this.needsTransportRestart=!1,this.publish=async(i,s,r)=>{var o;this.logger.debug("Publishing Payload"),this.logger.trace({type:"method",method:"publish",params:{topic:i,message:s,opts:r}});try{const a=r?.ttl||ot$1,h=vt$2(r),l=r?.prompt||!1,d=r?.tag||0,p=r?.id||getBigIntRpcId().toString(),y={topic:i,message:s,opts:{ttl:a,relay:h,prompt:l,tag:d,id:p}},M=setTimeout(()=>this.queue.set(p,y),this.publishTimeout);try{await await ut$2(this.rpcPublish(i,s,a,h,l,d,p),this.publishTimeout,`Failed to publish payload, please try again. id:${p} tag:${d}`),this.removeRequestFromQueue(p),this.relayer.events.emit(D$7.publish,y);}catch(u){if(this.logger.debug("Publishing Payload stalled"),this.needsTransportRestart=!0,(o=r?.internal)!=null&&o.throwOnFailedPublish)throw this.removeRequestFromQueue(p),u;return}finally{clearTimeout(M);}this.logger.debug("Successfully Published Payload"),this.logger.trace({type:"method",method:"publish",params:{topic:i,message:s,opts:r}});}catch(a){throw this.logger.debug("Failed to Publish Payload"),this.logger.error(a),a}},this.on=(i,s)=>{this.events.on(i,s);},this.once=(i,s)=>{this.events.once(i,s);},this.off=(i,s)=>{this.events.off(i,s);},this.removeListener=(i,s)=>{this.events.removeListener(i,s);},this.relayer=e,this.logger=cjs$3.generateChildLogger(t,this.name),this.registerEventListeners();}get context(){return cjs$3.getLoggerContext(this.logger)}rpcPublish(e,t,i,s,r,o,a){var h,l,d,p;const y={method:Et$2(s.protocol).publish,params:{topic:e,message:t,ttl:i,prompt:r,tag:o},id:a};return w$a((h=y.params)==null?void 0:h.prompt)&&((l=y.params)==null||delete l.prompt),w$a((d=y.params)==null?void 0:d.tag)&&((p=y.params)==null||delete p.tag),this.logger.debug("Outgoing Relay Payload"),this.logger.trace({type:"message",direction:"outgoing",request:y}),this.relayer.request(y)}removeRequestFromQueue(e){this.queue.delete(e);}checkQueue(){this.queue.forEach(async e=>{const{topic:t,message:i,opts:s}=e;await this.publish(t,i,s);});}registerEventListeners(){this.relayer.core.heartbeat.on(cjs$4.HEARTBEAT_EVENTS.pulse,()=>{if(this.needsTransportRestart){this.needsTransportRestart=!1,this.relayer.events.emit(D$7.connection_stalled);return}this.checkQueue();}),this.relayer.on(D$7.message_ack,e=>{this.removeRequestFromQueue(e.id.toString());});}}class Ir{constructor(){this.map=new Map,this.set=(e,t)=>{const i=this.get(e);this.exists(e,t)||this.map.set(e,[...i,t]);},this.get=e=>this.map.get(e)||[],this.exists=(e,t)=>this.get(e).includes(t),this.delete=(e,t)=>{if(typeof t>"u"){this.map.delete(e);return}if(!this.map.has(e))return;const i=this.get(e);if(!this.exists(e,t))return;const s=i.filter(r=>r!==t);if(!s.length){this.map.delete(e);return}this.map.set(e,s);},this.clear=()=>{this.map.clear();};}get topics(){return Array.from(this.map.keys())}}var Cr=Object.defineProperty,Rr=Object.defineProperties,_r=Object.getOwnPropertyDescriptors,At$1=Object.getOwnPropertySymbols,Tr=Object.prototype.hasOwnProperty,Sr=Object.prototype.propertyIsEnumerable,zt$1=(n,e,t)=>e in n?Cr(n,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[e]=t,q$5=(n,e)=>{for(var t in e||(e={}))Tr.call(e,t)&&zt$1(n,t,e[t]);if(At$1)for(var t of At$1(e))Sr.call(e,t)&&zt$1(n,t,e[t]);return n},De$1=(n,e)=>Rr(n,_r(e));let Nt$1 = class Nt extends d$c{constructor(e,t){super(e,t),this.relayer=e,this.logger=t,this.subscriptions=new Map,this.topicMap=new Ir,this.events=new EventEmitter$1,this.name=mt$1,this.version=bt$1,this.pending=new Map,this.cached=[],this.initialized=!1,this.pendingSubscriptionWatchLabel="pending_sub_watch_label",this.pollingInterval=20,this.storagePrefix=O$3,this.subscribeTimeout=1e4,this.restartInProgress=!1,this.batchSubscribeTopicsLimit=500,this.init=async()=>{this.initialized||(this.logger.trace("Initialized"),this.registerEventListeners(),this.clientId=await this.relayer.core.crypto.getClientId());},this.subscribe=async(i,s)=>{await this.restartToComplete(),this.isInitialized(),this.logger.debug("Subscribing Topic"),this.logger.trace({type:"method",method:"subscribe",params:{topic:i,opts:s}});try{const r=vt$2(s),o={topic:i,relay:r};this.pending.set(i,o);const a=await this.rpcSubscribe(i,r);return this.onSubscribe(a,o),this.logger.debug("Successfully Subscribed Topic"),this.logger.trace({type:"method",method:"subscribe",params:{topic:i,opts:s}}),a}catch(r){throw this.logger.debug("Failed to Subscribe Topic"),this.logger.error(r),r}},this.unsubscribe=async(i,s)=>{await this.restartToComplete(),this.isInitialized(),typeof s?.id<"u"?await this.unsubscribeById(i,s.id,s):await this.unsubscribeByTopic(i,s);},this.isSubscribed=async i=>{if(this.topics.includes(i))return !0;const s=`${this.pendingSubscriptionWatchLabel}_${i}`;return await new Promise((r,o)=>{const a=new cjs$7.Watch;a.start(s);const h=setInterval(()=>{!this.pending.has(i)&&this.topics.includes(i)&&(clearInterval(h),a.stop(s),r(!0)),a.elapsed(s)>=ft$4&&(clearInterval(h),a.stop(s),o(new Error("Subscription resolution timeout")));},this.pollingInterval);}).catch(()=>!1)},this.on=(i,s)=>{this.events.on(i,s);},this.once=(i,s)=>{this.events.once(i,s);},this.off=(i,s)=>{this.events.off(i,s);},this.removeListener=(i,s)=>{this.events.removeListener(i,s);},this.restart=async()=>{this.restartInProgress=!0,await this.restore(),await this.reset(),this.restartInProgress=!1;},this.relayer=e,this.logger=cjs$3.generateChildLogger(t,this.name),this.clientId="";}get context(){return cjs$3.getLoggerContext(this.logger)}get storageKey(){return this.storagePrefix+this.version+this.relayer.core.customStoragePrefix+"//"+this.name}get length(){return this.subscriptions.size}get ids(){return Array.from(this.subscriptions.keys())}get values(){return Array.from(this.subscriptions.values())}get topics(){return this.topicMap.topics}hasSubscription(e,t){let i=!1;try{i=this.getSubscription(e).topic===t;}catch{}return i}onEnable(){this.cached=[],this.initialized=!0;}onDisable(){this.cached=this.values,this.subscriptions.clear(),this.topicMap.clear();}async unsubscribeByTopic(e,t){const i=this.topicMap.get(e);await Promise.all(i.map(async s=>await this.unsubscribeById(e,s,t)));}async unsubscribeById(e,t,i){this.logger.debug("Unsubscribing Topic"),this.logger.trace({type:"method",method:"unsubscribe",params:{topic:e,id:t,opts:i}});try{const s=vt$2(i);await this.rpcUnsubscribe(e,t,s);const r=U$3("USER_DISCONNECTED",`${this.name}, ${e}`);await this.onUnsubscribe(e,t,r),this.logger.debug("Successfully Unsubscribed Topic"),this.logger.trace({type:"method",method:"unsubscribe",params:{topic:e,id:t,opts:i}});}catch(s){throw this.logger.debug("Failed to Unsubscribe Topic"),this.logger.error(s),s}}async rpcSubscribe(e,t){const i={method:Et$2(t.protocol).subscribe,params:{topic:e}};this.logger.debug("Outgoing Relay Payload"),this.logger.trace({type:"payload",direction:"outgoing",request:i});try{await await ut$2(this.relayer.request(i),this.subscribeTimeout);}catch{this.logger.debug("Outgoing Relay Subscribe Payload stalled"),this.relayer.events.emit(D$7.connection_stalled);}return Ln(e+this.clientId)}async rpcBatchSubscribe(e){if(!e.length)return;const t=e[0].relay,i={method:Et$2(t.protocol).batchSubscribe,params:{topics:e.map(s=>s.topic)}};this.logger.debug("Outgoing Relay Payload"),this.logger.trace({type:"payload",direction:"outgoing",request:i});try{return await await ut$2(this.relayer.request(i),this.subscribeTimeout)}catch{this.logger.debug("Outgoing Relay Payload stalled"),this.relayer.events.emit(D$7.connection_stalled);}}rpcUnsubscribe(e,t,i){const s={method:Et$2(i.protocol).unsubscribe,params:{topic:e,id:t}};return this.logger.debug("Outgoing Relay Payload"),this.logger.trace({type:"payload",direction:"outgoing",request:s}),this.relayer.request(s)}onSubscribe(e,t){this.setSubscription(e,De$1(q$5({},t),{id:e})),this.pending.delete(t.topic);}onBatchSubscribe(e){e.length&&e.forEach(t=>{this.setSubscription(t.id,q$5({},t)),this.pending.delete(t.topic);});}async onUnsubscribe(e,t,i){this.events.removeAllListeners(t),this.hasSubscription(t,e)&&this.deleteSubscription(t,i),await this.relayer.messages.del(e);}async setRelayerSubscriptions(e){await this.relayer.core.storage.setItem(this.storageKey,e);}async getRelayerSubscriptions(){return await this.relayer.core.storage.getItem(this.storageKey)}setSubscription(e,t){this.subscriptions.has(e)||(this.logger.debug("Setting subscription"),this.logger.trace({type:"method",method:"setSubscription",id:e,subscription:t}),this.addSubscription(e,t));}addSubscription(e,t){this.subscriptions.set(e,q$5({},t)),this.topicMap.set(t.topic,e),this.events.emit(w$7.created,t);}getSubscription(e){this.logger.debug("Getting subscription"),this.logger.trace({type:"method",method:"getSubscription",id:e});const t=this.subscriptions.get(e);if(!t){const{message:i}=N$8("NO_MATCHING_KEY",`${this.name}: ${e}`);throw new Error(i)}return t}deleteSubscription(e,t){this.logger.debug("Deleting subscription"),this.logger.trace({type:"method",method:"deleteSubscription",id:e,reason:t});const i=this.getSubscription(e);this.subscriptions.delete(e),this.topicMap.delete(i.topic,e),this.events.emit(w$7.deleted,De$1(q$5({},i),{reason:t}));}async persist(){await this.setRelayerSubscriptions(this.values),this.events.emit(w$7.sync);}async reset(){if(this.cached.length){const e=Math.ceil(this.cached.length/this.batchSubscribeTopicsLimit);for(let t=0;t<e;t++){const i=this.cached.splice(0,this.batchSubscribeTopicsLimit);await this.batchSubscribe(i);}}this.events.emit(w$7.resubscribed);}async restore(){try{const e=await this.getRelayerSubscriptions();if(typeof e>"u"||!e.length)return;if(this.subscriptions.size){const{message:t}=N$8("RESTORE_WILL_OVERRIDE",this.name);throw this.logger.error(t),this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`),new Error(t)}this.cached=e,this.logger.debug(`Successfully Restored subscriptions for ${this.name}`),this.logger.trace({type:"method",method:"restore",subscriptions:this.values});}catch(e){this.logger.debug(`Failed to Restore subscriptions for ${this.name}`),this.logger.error(e);}}async batchSubscribe(e){if(!e.length)return;const t=await this.rpcBatchSubscribe(e);k$8(t)&&this.onBatchSubscribe(t.map((i,s)=>De$1(q$5({},e[s]),{id:i})));}async onConnect(){this.restartInProgress||(await this.restart(),this.onEnable());}onDisconnect(){this.onDisable();}async checkPending(){if(!this.initialized||this.relayer.transportExplicitlyClosed)return;const e=[];this.pending.forEach(t=>{e.push(t);}),await this.batchSubscribe(e);}registerEventListeners(){this.relayer.core.heartbeat.on(cjs$4.HEARTBEAT_EVENTS.pulse,async()=>{await this.checkPending();}),this.relayer.on(D$7.connect,async()=>{await this.onConnect();}),this.relayer.on(D$7.disconnect,()=>{this.onDisconnect();}),this.events.on(w$7.created,async e=>{const t=w$7.created;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,data:e}),await this.persist();}),this.events.on(w$7.deleted,async e=>{const t=w$7.deleted;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,data:e}),await this.persist();});}isInitialized(){if(!this.initialized){const{message:e}=N$8("NOT_INITIALIZED",this.name);throw new Error(e)}}async restartToComplete(){this.restartInProgress&&await new Promise(e=>{const t=setInterval(()=>{this.restartInProgress||(clearInterval(t),e());},this.pollingInterval);});}};var Pr=Object.defineProperty,Ut$1=Object.getOwnPropertySymbols,xr=Object.prototype.hasOwnProperty,Or=Object.prototype.propertyIsEnumerable,Lt$1=(n,e,t)=>e in n?Pr(n,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[e]=t,Ar=(n,e)=>{for(var t in e||(e={}))xr.call(e,t)&&Lt$1(n,t,e[t]);if(Ut$1)for(var t of Ut$1(e))Or.call(e,t)&&Lt$1(n,t,e[t]);return n};let $t$1 = class $t extends g$a{constructor(e){super(e),this.protocol="wc",this.version=2,this.events=new EventEmitter$1,this.name=ut$1,this.transportExplicitlyClosed=!1,this.initialized=!1,this.connectionAttemptInProgress=!1,this.connectionStatusPollingInterval=20,this.staleConnectionErrors=["socket hang up","socket stalled"],this.hasExperiencedNetworkDisruption=!1,this.requestsInFlight=new Map,this.request=async t=>{this.logger.debug("Publishing Request Payload");const i=t.id;try{await this.toEstablishConnection();const s=this.provider.request(t);return this.requestsInFlight.set(i,{promise:s,request:t}),await s}catch(s){throw this.logger.debug("Failed to Publish Request"),this.logger.error(s),s}finally{this.requestsInFlight.delete(i);}},this.onPayloadHandler=t=>{this.onProviderPayload(t);},this.onConnectHandler=()=>{this.events.emit(D$7.connect);},this.onDisconnectHandler=()=>{this.onProviderDisconnect();},this.onProviderErrorHandler=t=>{this.logger.error(t),this.events.emit(D$7.error,t),this.logger.info("Fatal socket error received, closing transport"),this.transportClose();},this.registerProviderListeners=()=>{this.provider.on(P$7.payload,this.onPayloadHandler),this.provider.on(P$7.connect,this.onConnectHandler),this.provider.on(P$7.disconnect,this.onDisconnectHandler),this.provider.on(P$7.error,this.onProviderErrorHandler);},this.core=e.core,this.logger=typeof e.logger<"u"&&typeof e.logger!="string"?cjs$3.generateChildLogger(e.logger,this.name):cjs$3.pino(cjs$3.getDefaultLoggerOptions({level:e.logger||ct$1})),this.messages=new Ot$1(this.logger,e.core),this.subscriber=new Nt$1(this,this.logger),this.publisher=new vr(this,this.logger),this.relayUrl=e?.relayUrl||ge$2,this.projectId=e.projectId,this.bundleId=Jn(),this.provider={};}async init(){this.logger.trace("Initialized"),this.registerEventListeners(),await this.createProvider(),await Promise.all([this.messages.init(),this.subscriber.init()]);try{await this.transportOpen();}catch{this.logger.warn(`Connection via ${this.relayUrl} failed, attempting to connect via failover domain ${pe$1}...`),await this.restartTransport(pe$1);}this.initialized=!0,setTimeout(async()=>{this.subscriber.topics.length===0&&(this.logger.info("No topics subscribed to after init, closing transport"),await this.transportClose(),this.transportExplicitlyClosed=!1);},pt$1);}get context(){return cjs$3.getLoggerContext(this.logger)}get connected(){return this.provider.connection.connected}get connecting(){return this.provider.connection.connecting}async publish(e,t,i){this.isInitialized(),await this.publisher.publish(e,t,i),await this.recordMessageEvent({topic:e,message:t,publishedAt:Date.now()});}async subscribe(e,t){var i;this.isInitialized();let s=((i=this.subscriber.topicMap.get(e))==null?void 0:i[0])||"";if(s)return s;let r;const o=a=>{a.topic===e&&(this.subscriber.off(w$7.created,o),r());};return await Promise.all([new Promise(a=>{r=a,this.subscriber.on(w$7.created,o);}),new Promise(async a=>{s=await this.subscriber.subscribe(e,t),a();})]),s}async unsubscribe(e,t){this.isInitialized(),await this.subscriber.unsubscribe(e,t);}on(e,t){this.events.on(e,t);}once(e,t){this.events.once(e,t);}off(e,t){this.events.off(e,t);}removeListener(e,t){this.events.removeListener(e,t);}async transportClose(){this.requestsInFlight.size>0&&(this.logger.debug("Waiting for all in-flight requests to finish before closing transport..."),this.requestsInFlight.forEach(async e=>{await e.promise;})),this.transportExplicitlyClosed=!0,this.hasExperiencedNetworkDisruption&&this.connected?await ut$2(this.provider.disconnect(),1e3,"provider.disconnect()").catch(()=>this.onProviderDisconnect()):this.connected&&await this.provider.disconnect();}async transportOpen(e){if(this.transportExplicitlyClosed=!1,await this.confirmOnlineStateOrThrow(),!this.connectionAttemptInProgress){e&&e!==this.relayUrl&&(this.relayUrl=e,await this.transportClose(),await this.createProvider()),this.connectionAttemptInProgress=!0;try{await Promise.all([new Promise(t=>{if(!this.initialized)return t();this.subscriber.once(w$7.resubscribed,()=>{t();});}),new Promise(async(t,i)=>{try{await ut$2(this.provider.connect(),1e4,`Socket stalled when trying to connect to ${this.relayUrl}`);}catch(s){i(s);return}t();})]);}catch(t){this.logger.error(t);const i=t;if(!this.isConnectionStalled(i.message))throw t;this.provider.events.emit(P$7.disconnect);}finally{this.connectionAttemptInProgress=!1,this.hasExperiencedNetworkDisruption=!1;}}}async restartTransport(e){await this.confirmOnlineStateOrThrow(),!this.connectionAttemptInProgress&&(this.relayUrl=e||this.relayUrl,await this.transportClose(),await this.createProvider(),await this.transportOpen());}async confirmOnlineStateOrThrow(){if(!await rr$2())throw new Error("No internet connection detected. Please restart your network and try again.")}isConnectionStalled(e){return this.staleConnectionErrors.some(t=>e.includes(t))}async createProvider(){this.provider.connection&&this.unregisterProviderListeners();const e=await this.core.crypto.signJWT(this.relayUrl);this.provider=new JsonRpcProvider(new f$e(Xn({sdkVersion:gt$6,protocol:this.protocol,version:this.version,relayUrl:this.relayUrl,projectId:this.projectId,auth:e,useOnCloseEvent:!0,bundleId:this.bundleId}))),this.registerProviderListeners();}async recordMessageEvent(e){const{topic:t,message:i}=e;await this.messages.set(t,i);}async shouldIgnoreMessageEvent(e){const{topic:t,message:i}=e;if(!i||i.length===0)return this.logger.debug(`Ignoring invalid/empty message: ${i}`),!0;if(!await this.subscriber.isSubscribed(t))return this.logger.debug(`Ignoring message for non-subscribed topic ${t}`),!0;const s=this.messages.has(t,i);return s&&this.logger.debug(`Ignoring duplicate message: ${i}`),s}async onProviderPayload(e){if(this.logger.debug("Incoming Relay Payload"),this.logger.trace({type:"payload",direction:"incoming",payload:e}),isJsonRpcRequest(e)){if(!e.method.endsWith(lt$5))return;const t=e.params,{topic:i,message:s,publishedAt:r}=t.data,o={topic:i,message:s,publishedAt:r};this.logger.debug("Emitting Relayer Payload"),this.logger.trace(Ar({type:"event",event:t.id},o)),this.events.emit(t.id,o),await this.acknowledgePayload(e),await this.onMessageEvent(o);}else isJsonRpcResponse(e)&&this.events.emit(D$7.message_ack,e);}async onMessageEvent(e){await this.shouldIgnoreMessageEvent(e)||(this.events.emit(D$7.message,e),await this.recordMessageEvent(e));}async acknowledgePayload(e){const t=formatJsonRpcResult(e.id,!0);await this.provider.connection.send(t);}unregisterProviderListeners(){this.provider.off(P$7.payload,this.onPayloadHandler),this.provider.off(P$7.connect,this.onConnectHandler),this.provider.off(P$7.disconnect,this.onDisconnectHandler),this.provider.off(P$7.error,this.onProviderErrorHandler);}async registerEventListeners(){this.events.on(D$7.connection_stalled,()=>{this.restartTransport().catch(t=>this.logger.error(t));});let e=await rr$2();or$2(async t=>{this.initialized&&e!==t&&(e=t,t?await this.restartTransport().catch(i=>this.logger.error(i)):(this.hasExperiencedNetworkDisruption=!0,await this.transportClose().catch(i=>this.logger.error(i))));});}onProviderDisconnect(){this.events.emit(D$7.disconnect),this.attemptToReconnect();}attemptToReconnect(){this.transportExplicitlyClosed||(this.logger.info("attemptToReconnect called. Connecting..."),setTimeout(async()=>{await this.restartTransport().catch(e=>this.logger.error(e));},cjs$7.toMiliseconds(dt$1)));}isInitialized(){if(!this.initialized){const{message:e}=N$8("NOT_INITIALIZED",this.name);throw new Error(e)}}async toEstablishConnection(){if(await this.confirmOnlineStateOrThrow(),!this.connected){if(this.connectionAttemptInProgress)return await new Promise(e=>{const t=setInterval(()=>{this.connected&&(clearInterval(t),e());},this.connectionStatusPollingInterval);});await this.restartTransport();}}};var zr=Object.defineProperty,Ft$1=Object.getOwnPropertySymbols,Nr=Object.prototype.hasOwnProperty,Ur=Object.prototype.propertyIsEnumerable,Mt$1=(n,e,t)=>e in n?zr(n,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[e]=t,kt$1=(n,e)=>{for(var t in e||(e={}))Nr.call(e,t)&&Mt$1(n,t,e[t]);if(Ft$1)for(var t of Ft$1(e))Ur.call(e,t)&&Mt$1(n,t,e[t]);return n};let Kt$1 = class Kt extends p$b{constructor(e,t,i,s=O$3,r=void 0){super(e,t,i,s),this.core=e,this.logger=t,this.name=i,this.map=new Map,this.version=Dt$1,this.cached=[],this.initialized=!1,this.storagePrefix=O$3,this.init=async()=>{this.initialized||(this.logger.trace("Initialized"),await this.restore(),this.cached.forEach(o=>{this.getKey&&o!==null&&!w$a(o)?this.map.set(this.getKey(o),o):Lt$2(o)?this.map.set(o.id,o):xt$2(o)&&this.map.set(o.topic,o);}),this.cached=[],this.initialized=!0);},this.set=async(o,a)=>{this.isInitialized(),this.map.has(o)?await this.update(o,a):(this.logger.debug("Setting value"),this.logger.trace({type:"method",method:"set",key:o,value:a}),this.map.set(o,a),await this.persist());},this.get=o=>(this.isInitialized(),this.logger.debug("Getting value"),this.logger.trace({type:"method",method:"get",key:o}),this.getData(o)),this.getAll=o=>(this.isInitialized(),o?this.values.filter(a=>Object.keys(o).every(h=>Gi(a[h],o[h]))):this.values),this.update=async(o,a)=>{this.isInitialized(),this.logger.debug("Updating value"),this.logger.trace({type:"method",method:"update",key:o,update:a});const h=kt$1(kt$1({},this.getData(o)),a);this.map.set(o,h),await this.persist();},this.delete=async(o,a)=>{this.isInitialized(),this.map.has(o)&&(this.logger.debug("Deleting value"),this.logger.trace({type:"method",method:"delete",key:o,reason:a}),this.map.delete(o),await this.persist());},this.logger=cjs$3.generateChildLogger(t,this.name),this.storagePrefix=s,this.getKey=r;}get context(){return cjs$3.getLoggerContext(this.logger)}get storageKey(){return this.storagePrefix+this.version+this.core.customStoragePrefix+"//"+this.name}get length(){return this.map.size}get keys(){return Array.from(this.map.keys())}get values(){return Array.from(this.map.values())}async setDataStore(e){await this.core.storage.setItem(this.storageKey,e);}async getDataStore(){return await this.core.storage.getItem(this.storageKey)}getData(e){const t=this.map.get(e);if(!t){const{message:i}=N$8("NO_MATCHING_KEY",`${this.name}: ${e}`);throw this.logger.error(i),new Error(i)}return t}async persist(){await this.setDataStore(this.values);}async restore(){try{const e=await this.getDataStore();if(typeof e>"u"||!e.length)return;if(this.map.size){const{message:t}=N$8("RESTORE_WILL_OVERRIDE",this.name);throw this.logger.error(t),new Error(t)}this.cached=e,this.logger.debug(`Successfully Restored value for ${this.name}`),this.logger.trace({type:"method",method:"restore",value:this.values});}catch(e){this.logger.debug(`Failed to Restore value for ${this.name}`),this.logger.error(e);}}isInitialized(){if(!this.initialized){const{message:e}=N$8("NOT_INITIALIZED",this.name);throw new Error(e)}}};let Bt$1 = class Bt{constructor(e,t){this.core=e,this.logger=t,this.name=Et$1,this.version=wt$1,this.events=new EventEmitter$1,this.initialized=!1,this.storagePrefix=O$3,this.ignoredPayloadTypes=[_$a],this.registeredMethods=[],this.init=async()=>{this.initialized||(await this.pairings.init(),await this.cleanup(),this.registerRelayerEvents(),this.registerExpirerEvents(),this.initialized=!0,this.logger.trace("Initialized"));},this.register=({methods:i})=>{this.isInitialized(),this.registeredMethods=[...new Set([...this.registeredMethods,...i])];},this.create=async()=>{this.isInitialized();const i=Vn$1(),s=await this.core.crypto.setSymKey(i),r=pt$2(cjs$7.FIVE_MINUTES),o={protocol:ht$1},a={topic:s,expiry:r,relay:o,active:!1},h=Rt$2({protocol:this.core.protocol,version:this.core.version,topic:s,symKey:i,relay:o,expiryTimestamp:r});return await this.pairings.set(s,a),await this.core.relayer.subscribe(s),this.core.expirer.set(s,r),{topic:s,uri:h}},this.pair=async i=>{this.isInitialized(),this.isValidPair(i);const{topic:s,symKey:r,relay:o,expiryTimestamp:a}=Pt$2(i.uri);let h;if(this.pairings.keys.includes(s)&&(h=this.pairings.get(s),h.active))throw new Error(`Pairing already exists: ${s}. Please try again with a new connection URI.`);const l=a||pt$2(cjs$7.FIVE_MINUTES),d={topic:s,relay:o,expiry:l,active:!1};return await this.pairings.set(s,d),this.core.expirer.set(s,l),i.activatePairing&&await this.activate({topic:s}),this.events.emit(V$6.create,d),this.core.crypto.keychain.has(s)||(await this.core.crypto.setSymKey(r,s),await this.core.relayer.subscribe(s,{relay:o})),d},this.activate=async({topic:i})=>{this.isInitialized();const s=pt$2(cjs$7.THIRTY_DAYS);await this.pairings.update(i,{active:!0,expiry:s}),this.core.expirer.set(i,s);},this.ping=async i=>{this.isInitialized(),await this.isValidPing(i);const{topic:s}=i;if(this.pairings.keys.includes(s)){const r=await this.sendRequest(s,"wc_pairingPing",{}),{done:o,resolve:a,reject:h}=at$2();this.events.once(yt$2("pairing_ping",r),({error:l})=>{l?h(l):a();}),await o();}},this.updateExpiry=async({topic:i,expiry:s})=>{this.isInitialized(),await this.pairings.update(i,{expiry:s});},this.updateMetadata=async({topic:i,metadata:s})=>{this.isInitialized(),await this.pairings.update(i,{peerMetadata:s});},this.getPairings=()=>(this.isInitialized(),this.pairings.values),this.disconnect=async i=>{this.isInitialized(),await this.isValidDisconnect(i);const{topic:s}=i;this.pairings.keys.includes(s)&&(await this.sendRequest(s,"wc_pairingDelete",U$3("USER_DISCONNECTED")),await this.deletePairing(s));},this.sendRequest=async(i,s,r)=>{const o=formatJsonRpcRequest(s,r),a=await this.core.crypto.encode(i,o),h=$$7[s].req;return this.core.history.set(i,o),this.core.relayer.publish(i,a,h),o.id},this.sendResult=async(i,s,r)=>{const o=formatJsonRpcResult(i,r),a=await this.core.crypto.encode(s,o),h=await this.core.history.get(s,i),l=$$7[h.request.method].res;await this.core.relayer.publish(s,a,l),await this.core.history.resolve(o);},this.sendError=async(i,s,r)=>{const o=formatJsonRpcError(i,r),a=await this.core.crypto.encode(s,o),h=await this.core.history.get(s,i),l=$$7[h.request.method]?$$7[h.request.method].res:$$7.unregistered_method.res;await this.core.relayer.publish(s,a,l),await this.core.history.resolve(o);},this.deletePairing=async(i,s)=>{await this.core.relayer.unsubscribe(i),await Promise.all([this.pairings.delete(i,U$3("USER_DISCONNECTED")),this.core.crypto.deleteSymKey(i),s?Promise.resolve():this.core.expirer.del(i)]);},this.cleanup=async()=>{const i=this.pairings.getAll().filter(s=>mt$2(s.expiry));await Promise.all(i.map(s=>this.deletePairing(s.topic)));},this.onRelayEventRequest=i=>{const{topic:s,payload:r}=i;switch(r.method){case"wc_pairingPing":return this.onPairingPingRequest(s,r);case"wc_pairingDelete":return this.onPairingDeleteRequest(s,r);default:return this.onUnknownRpcMethodRequest(s,r)}},this.onRelayEventResponse=async i=>{const{topic:s,payload:r}=i,o=(await this.core.history.get(s,r.id)).request.method;switch(o){case"wc_pairingPing":return this.onPairingPingResponse(s,r);default:return this.onUnknownRpcMethodResponse(o)}},this.onPairingPingRequest=async(i,s)=>{const{id:r}=s;try{this.isValidPing({topic:i}),await this.sendResult(r,i,!0),this.events.emit(V$6.ping,{id:r,topic:i});}catch(o){await this.sendError(r,i,o),this.logger.error(o);}},this.onPairingPingResponse=(i,s)=>{const{id:r}=s;setTimeout(()=>{isJsonRpcResult(s)?this.events.emit(yt$2("pairing_ping",r),{}):isJsonRpcError(s)&&this.events.emit(yt$2("pairing_ping",r),{error:s.error});},500);},this.onPairingDeleteRequest=async(i,s)=>{const{id:r}=s;try{this.isValidDisconnect({topic:i}),await this.deletePairing(i),this.events.emit(V$6.delete,{id:r,topic:i});}catch(o){await this.sendError(r,i,o),this.logger.error(o);}},this.onUnknownRpcMethodRequest=async(i,s)=>{const{id:r,method:o}=s;try{if(this.registeredMethods.includes(o))return;const a=U$3("WC_METHOD_UNSUPPORTED",o);await this.sendError(r,i,a),this.logger.error(a);}catch(a){await this.sendError(r,i,a),this.logger.error(a);}},this.onUnknownRpcMethodResponse=i=>{this.registeredMethods.includes(i)||this.logger.error(U$3("WC_METHOD_UNSUPPORTED",i));},this.isValidPair=i=>{var s;if(!Gt$2(i)){const{message:o}=N$8("MISSING_OR_INVALID",`pair() params: ${i}`);throw new Error(o)}if(!Kt$2(i.uri)){const{message:o}=N$8("MISSING_OR_INVALID",`pair() uri: ${i.uri}`);throw new Error(o)}const r=Pt$2(i.uri);if(!((s=r?.relay)!=null&&s.protocol)){const{message:o}=N$8("MISSING_OR_INVALID","pair() uri#relay-protocol");throw new Error(o)}if(!(r!=null&&r.symKey)){const{message:o}=N$8("MISSING_OR_INVALID","pair() uri#symKey");throw new Error(o)}if(r!=null&&r.expiryTimestamp&&cjs$7.toMiliseconds(r?.expiryTimestamp)<Date.now()){const{message:o}=N$8("EXPIRED","pair() URI has expired. Please try again with a new connection URI.");throw new Error(o)}},this.isValidPing=async i=>{if(!Gt$2(i)){const{message:r}=N$8("MISSING_OR_INVALID",`ping() params: ${i}`);throw new Error(r)}const{topic:s}=i;await this.isValidPairingTopic(s);},this.isValidDisconnect=async i=>{if(!Gt$2(i)){const{message:r}=N$8("MISSING_OR_INVALID",`disconnect() params: ${i}`);throw new Error(r)}const{topic:s}=i;await this.isValidPairingTopic(s);},this.isValidPairingTopic=async i=>{if(!g$b(i,!1)){const{message:s}=N$8("MISSING_OR_INVALID",`pairing topic should be a string: ${i}`);throw new Error(s)}if(!this.pairings.keys.includes(i)){const{message:s}=N$8("NO_MATCHING_KEY",`pairing topic doesn't exist: ${i}`);throw new Error(s)}if(mt$2(this.pairings.get(i).expiry)){await this.deletePairing(i);const{message:s}=N$8("EXPIRED",`pairing topic: ${i}`);throw new Error(s)}},this.core=e,this.logger=cjs$3.generateChildLogger(t,this.name),this.pairings=new Kt$1(this.core,this.logger,this.name,this.storagePrefix);}get context(){return cjs$3.getLoggerContext(this.logger)}isInitialized(){if(!this.initialized){const{message:e}=N$8("NOT_INITIALIZED",this.name);throw new Error(e)}}registerRelayerEvents(){this.core.relayer.on(D$7.message,async e=>{const{topic:t,message:i}=e;if(!this.pairings.keys.includes(t)||this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(i)))return;const s=await this.core.crypto.decode(t,i);try{isJsonRpcRequest(s)?(this.core.history.set(t,s),this.onRelayEventRequest({topic:t,payload:s})):isJsonRpcResponse(s)&&(await this.core.history.resolve(s),await this.onRelayEventResponse({topic:t,payload:s}),this.core.history.delete(t,s.id));}catch(r){this.logger.error(r);}});}registerExpirerEvents(){this.core.expirer.on(v$8.expired,async e=>{const{topic:t}=ft$5(e.target);t&&this.pairings.keys.includes(t)&&(await this.deletePairing(t,!0),this.events.emit(V$6.expire,{topic:t}));});}};let Vt$1 = class Vt extends h$h{constructor(e,t){super(e,t),this.core=e,this.logger=t,this.records=new Map,this.events=new EventEmitter$1,this.name=vt$1,this.version=It$1,this.cached=[],this.initialized=!1,this.storagePrefix=O$3,this.init=async()=>{this.initialized||(this.logger.trace("Initialized"),await this.restore(),this.cached.forEach(i=>this.records.set(i.id,i)),this.cached=[],this.registerEventListeners(),this.initialized=!0);},this.set=(i,s,r)=>{if(this.isInitialized(),this.logger.debug("Setting JSON-RPC request history record"),this.logger.trace({type:"method",method:"set",topic:i,request:s,chainId:r}),this.records.has(s.id))return;const o={id:s.id,topic:i,request:{method:s.method,params:s.params||null},chainId:r,expiry:pt$2(cjs$7.THIRTY_DAYS)};this.records.set(o.id,o),this.events.emit(R$6.created,o);},this.resolve=async i=>{if(this.isInitialized(),this.logger.debug("Updating JSON-RPC response history record"),this.logger.trace({type:"method",method:"update",response:i}),!this.records.has(i.id))return;const s=await this.getRecord(i.id);typeof s.response>"u"&&(s.response=isJsonRpcError(i)?{error:i.error}:{result:i.result},this.records.set(s.id,s),this.events.emit(R$6.updated,s));},this.get=async(i,s)=>(this.isInitialized(),this.logger.debug("Getting record"),this.logger.trace({type:"method",method:"get",topic:i,id:s}),await this.getRecord(s)),this.delete=(i,s)=>{this.isInitialized(),this.logger.debug("Deleting record"),this.logger.trace({type:"method",method:"delete",id:s}),this.values.forEach(r=>{if(r.topic===i){if(typeof s<"u"&&r.id!==s)return;this.records.delete(r.id),this.events.emit(R$6.deleted,r);}});},this.exists=async(i,s)=>(this.isInitialized(),this.records.has(s)?(await this.getRecord(s)).topic===i:!1),this.on=(i,s)=>{this.events.on(i,s);},this.once=(i,s)=>{this.events.once(i,s);},this.off=(i,s)=>{this.events.off(i,s);},this.removeListener=(i,s)=>{this.events.removeListener(i,s);},this.logger=cjs$3.generateChildLogger(t,this.name);}get context(){return cjs$3.getLoggerContext(this.logger)}get storageKey(){return this.storagePrefix+this.version+this.core.customStoragePrefix+"//"+this.name}get size(){return this.records.size}get keys(){return Array.from(this.records.keys())}get values(){return Array.from(this.records.values())}get pending(){const e=[];return this.values.forEach(t=>{if(typeof t.response<"u")return;const i={topic:t.topic,request:formatJsonRpcRequest(t.request.method,t.request.params,t.id),chainId:t.chainId};return e.push(i)}),e}async setJsonRpcRecords(e){await this.core.storage.setItem(this.storageKey,e);}async getJsonRpcRecords(){return await this.core.storage.getItem(this.storageKey)}getRecord(e){this.isInitialized();const t=this.records.get(e);if(!t){const{message:i}=N$8("NO_MATCHING_KEY",`${this.name}: ${e}`);throw new Error(i)}return t}async persist(){await this.setJsonRpcRecords(this.values),this.events.emit(R$6.sync);}async restore(){try{const e=await this.getJsonRpcRecords();if(typeof e>"u"||!e.length)return;if(this.records.size){const{message:t}=N$8("RESTORE_WILL_OVERRIDE",this.name);throw this.logger.error(t),new Error(t)}this.cached=e,this.logger.debug(`Successfully Restored records for ${this.name}`),this.logger.trace({type:"method",method:"restore",records:this.values});}catch(e){this.logger.debug(`Failed to Restore records for ${this.name}`),this.logger.error(e);}}registerEventListeners(){this.events.on(R$6.created,e=>{const t=R$6.created;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,record:e}),this.persist();}),this.events.on(R$6.updated,e=>{const t=R$6.updated;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,record:e}),this.persist();}),this.events.on(R$6.deleted,e=>{const t=R$6.deleted;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,record:e}),this.persist();}),this.core.heartbeat.on(cjs$4.HEARTBEAT_EVENTS.pulse,()=>{this.cleanup();});}cleanup(){try{this.records.forEach(e=>{cjs$7.toMiliseconds(e.expiry||0)-Date.now()<=0&&(this.logger.info(`Deleting expired history log: ${e.id}`),this.delete(e.topic,e.id));});}catch(e){this.logger.warn(e);}}isInitialized(){if(!this.initialized){const{message:e}=N$8("NOT_INITIALIZED",this.name);throw new Error(e)}}};let qt$1 = class qt extends E$7{constructor(e,t){super(e,t),this.core=e,this.logger=t,this.expirations=new Map,this.events=new EventEmitter$1,this.name=Ct$2,this.version=Rt$1,this.cached=[],this.initialized=!1,this.storagePrefix=O$3,this.init=async()=>{this.initialized||(this.logger.trace("Initialized"),await this.restore(),this.cached.forEach(i=>this.expirations.set(i.target,i)),this.cached=[],this.registerEventListeners(),this.initialized=!0);},this.has=i=>{try{const s=this.formatTarget(i);return typeof this.getExpiration(s)<"u"}catch{return !1}},this.set=(i,s)=>{this.isInitialized();const r=this.formatTarget(i),o={target:r,expiry:s};this.expirations.set(r,o),this.checkExpiry(r,o),this.events.emit(v$8.created,{target:r,expiration:o});},this.get=i=>{this.isInitialized();const s=this.formatTarget(i);return this.getExpiration(s)},this.del=i=>{if(this.isInitialized(),this.has(i)){const s=this.formatTarget(i),r=this.getExpiration(s);this.expirations.delete(s),this.events.emit(v$8.deleted,{target:s,expiration:r});}},this.on=(i,s)=>{this.events.on(i,s);},this.once=(i,s)=>{this.events.once(i,s);},this.off=(i,s)=>{this.events.off(i,s);},this.removeListener=(i,s)=>{this.events.removeListener(i,s);},this.logger=cjs$3.generateChildLogger(t,this.name);}get context(){return cjs$3.getLoggerContext(this.logger)}get storageKey(){return this.storagePrefix+this.version+this.core.customStoragePrefix+"//"+this.name}get length(){return this.expirations.size}get keys(){return Array.from(this.expirations.keys())}get values(){return Array.from(this.expirations.values())}formatTarget(e){if(typeof e=="string")return lt$6(e);if(typeof e=="number")return dt$2(e);const{message:t}=N$8("UNKNOWN_TYPE",`Target type: ${typeof e}`);throw new Error(t)}async setExpirations(e){await this.core.storage.setItem(this.storageKey,e);}async getExpirations(){return await this.core.storage.getItem(this.storageKey)}async persist(){await this.setExpirations(this.values),this.events.emit(v$8.sync);}async restore(){try{const e=await this.getExpirations();if(typeof e>"u"||!e.length)return;if(this.expirations.size){const{message:t}=N$8("RESTORE_WILL_OVERRIDE",this.name);throw this.logger.error(t),new Error(t)}this.cached=e,this.logger.debug(`Successfully Restored expirations for ${this.name}`),this.logger.trace({type:"method",method:"restore",expirations:this.values});}catch(e){this.logger.debug(`Failed to Restore expirations for ${this.name}`),this.logger.error(e);}}getExpiration(e){const t=this.expirations.get(e);if(!t){const{message:i}=N$8("NO_MATCHING_KEY",`${this.name}: ${e}`);throw this.logger.error(i),new Error(i)}return t}checkExpiry(e,t){const{expiry:i}=t;cjs$7.toMiliseconds(i)-Date.now()<=0&&this.expire(e,t);}expire(e,t){this.expirations.delete(e),this.events.emit(v$8.expired,{target:e,expiration:t});}checkExpirations(){this.core.relayer.connected&&this.expirations.forEach((e,t)=>this.checkExpiry(t,e));}registerEventListeners(){this.core.heartbeat.on(cjs$4.HEARTBEAT_EVENTS.pulse,()=>this.checkExpirations()),this.events.on(v$8.created,e=>{const t=v$8.created;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,data:e}),this.persist();}),this.events.on(v$8.expired,e=>{const t=v$8.expired;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,data:e}),this.persist();}),this.events.on(v$8.deleted,e=>{const t=v$8.deleted;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,data:e}),this.persist();});}isInitialized(){if(!this.initialized){const{message:e}=N$8("NOT_INITIALIZED",this.name);throw new Error(e)}}};let jt$1 = class jt extends y$c{constructor(e,t){super(e,t),this.projectId=e,this.logger=t,this.name=Z$6,this.initialized=!1,this.queue=[],this.verifyDisabled=!1,this.init=async i=>{if(this.verifyDisabled||$$8()||!D$9())return;const s=this.getVerifyUrl(i?.verifyUrl);this.verifyUrl!==s&&this.removeIframe(),this.verifyUrl=s;try{await this.createIframe();}catch(r){this.logger.info(`Verify iframe failed to load: ${this.verifyUrl}`),this.logger.info(r);}if(!this.initialized){this.removeIframe(),this.verifyUrl=ee$1;try{await this.createIframe();}catch(r){this.logger.info(`Verify iframe failed to load: ${this.verifyUrl}`),this.logger.info(r),this.verifyDisabled=!0;}}},this.register=async i=>{this.initialized?this.sendPost(i.attestationId):(this.addToQueue(i.attestationId),await this.init());},this.resolve=async i=>{if(this.isDevEnv)return "";const s=this.getVerifyUrl(i?.verifyUrl);let r;try{r=await this.fetchAttestation(i.attestationId,s);}catch(o){this.logger.info(`failed to resolve attestation: ${i.attestationId} from url: ${s}`),this.logger.info(o),r=await this.fetchAttestation(i.attestationId,ee$1);}return r},this.fetchAttestation=async(i,s)=>{this.logger.info(`resolving attestation: ${i} from url: ${s}`);const r=this.startAbortTimer(cjs$7.ONE_SECOND*2),o=await fetch(`${s}/attestation/${i}`,{signal:this.abortController.signal});return clearTimeout(r),o.status===200?await o.json():void 0},this.addToQueue=i=>{this.queue.push(i);},this.processQueue=()=>{this.queue.length!==0&&(this.queue.forEach(i=>this.sendPost(i)),this.queue=[]);},this.sendPost=i=>{var s;try{if(!this.iframe)return;(s=this.iframe.contentWindow)==null||s.postMessage(i,"*"),this.logger.info(`postMessage sent: ${i} ${this.verifyUrl}`);}catch{}},this.createIframe=async()=>{let i;const s=r=>{r.data==="verify_ready"&&(this.initialized=!0,this.processQueue(),window.removeEventListener("message",s),i());};await Promise.race([new Promise(r=>{if(document.getElementById(Z$6))return r();window.addEventListener("message",s);const o=document.createElement("iframe");o.id=Z$6,o.src=`${this.verifyUrl}/${this.projectId}`,o.style.display="none",document.body.append(o),this.iframe=o,i=r;}),new Promise((r,o)=>setTimeout(()=>{window.removeEventListener("message",s),o("verify iframe load timeout");},cjs$7.toMiliseconds(cjs$7.FIVE_SECONDS)))]);},this.removeIframe=()=>{this.iframe&&(this.iframe.remove(),this.iframe=void 0,this.initialized=!1);},this.getVerifyUrl=i=>{let s=i||F$5;return _t$1.includes(s)||(this.logger.info(`verify url: ${s}, not included in trusted list, assigning default: ${F$5}`),s=F$5),s},this.logger=cjs$3.generateChildLogger(t,this.name),this.verifyUrl=F$5,this.abortController=new AbortController,this.isDevEnv=te$3()&&browser$1$1.env.IS_VITEST;}get context(){return cjs$3.getLoggerContext(this.logger)}startAbortTimer(e){return this.abortController=new AbortController,setTimeout(()=>this.abortController.abort(),cjs$7.toMiliseconds(e))}};let Gt$1 = class Gt extends v$9{constructor(e,t){super(e,t),this.projectId=e,this.logger=t,this.context=Tt$1,this.registerDeviceToken=async i=>{const{clientId:s,token:r,notificationType:o,enableEncrypted:a=!1}=i,h=`${St$1}/${this.projectId}/clients`;await Yi(h,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({client_id:s,type:o,token:r,always_raw:a})});},this.logger=cjs$3.generateChildLogger(t,this.context);}};var Lr=Object.defineProperty,Yt$1=Object.getOwnPropertySymbols,$r=Object.prototype.hasOwnProperty,Fr=Object.prototype.propertyIsEnumerable,Ht$1=(n,e,t)=>e in n?Lr(n,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[e]=t,Jt$1=(n,e)=>{for(var t in e||(e={}))$r.call(e,t)&&Ht$1(n,t,e[t]);if(Yt$1)for(var t of Yt$1(e))Fr.call(e,t)&&Ht$1(n,t,e[t]);return n};let te$2 = class te extends n$n{constructor(e){super(e),this.protocol=le$2,this.version=We$1,this.name=Q$4,this.events=new EventEmitter$1,this.initialized=!1,this.on=(i,s)=>this.events.on(i,s),this.once=(i,s)=>this.events.once(i,s),this.off=(i,s)=>this.events.off(i,s),this.removeListener=(i,s)=>this.events.removeListener(i,s),this.projectId=e?.projectId,this.relayUrl=e?.relayUrl||ge$2,this.customStoragePrefix=e!=null&&e.customStoragePrefix?`:${e.customStoragePrefix}`:"";const t=typeof e?.logger<"u"&&typeof e?.logger!="string"?e.logger:cjs$3.pino(cjs$3.getDefaultLoggerOptions({level:e?.logger||Qe$1.logger}));this.logger=cjs$3.generateChildLogger(t,this.name),this.heartbeat=new cjs$4.HeartBeat,this.crypto=new xt$1(this,this.logger,e?.keychain),this.history=new Vt$1(this,this.logger),this.expirer=new qt$1(this,this.logger),this.storage=e!=null&&e.storage?e.storage:new h$i(Jt$1(Jt$1({},Ze),e?.storageOptions)),this.relayer=new $t$1({core:this,logger:this.logger,relayUrl:this.relayUrl,projectId:this.projectId}),this.pairing=new Bt$1(this,this.logger),this.verify=new jt$1(this.projectId||"",this.logger),this.echoClient=new Gt$1(this.projectId||"",this.logger);}static async init(e){const t=new te(e);await t.initialize();const i=await t.crypto.getClientId();return await t.storage.setItem(yt$1,i),t}get context(){return cjs$3.getLoggerContext(this.logger)}async start(){this.initialized||await this.initialize();}async initialize(){this.logger.trace("Initialized");try{await this.crypto.init(),await this.history.init(),await this.expirer.init(),await this.relayer.init(),await this.heartbeat.init(),await this.pairing.init(),this.initialized=!0,this.logger.info("Core Initialization Success");}catch(e){throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`,e),this.logger.error(e.message),e}}};const Mr=te$2;

    const J$1="wc",F$4=2,X$1="client",G$3=`${J$1}@${F$4}:${X$1}:`,M$7={name:X$1,logger:"error",controller:!1,relayUrl:"wss://relay.walletconnect.com"},H$6="WALLETCONNECT_DEEPLINK_CHOICE",oe$2="proposal",ae$1="Proposal expired",ce$1="session",L$8=cjs$7.SEVEN_DAYS,le$1="engine",R$5={wc_sessionPropose:{req:{ttl:cjs$7.FIVE_MINUTES,prompt:!0,tag:1100},res:{ttl:cjs$7.FIVE_MINUTES,prompt:!1,tag:1101}},wc_sessionSettle:{req:{ttl:cjs$7.FIVE_MINUTES,prompt:!1,tag:1102},res:{ttl:cjs$7.FIVE_MINUTES,prompt:!1,tag:1103}},wc_sessionUpdate:{req:{ttl:cjs$7.ONE_DAY,prompt:!1,tag:1104},res:{ttl:cjs$7.ONE_DAY,prompt:!1,tag:1105}},wc_sessionExtend:{req:{ttl:cjs$7.ONE_DAY,prompt:!1,tag:1106},res:{ttl:cjs$7.ONE_DAY,prompt:!1,tag:1107}},wc_sessionRequest:{req:{ttl:cjs$7.FIVE_MINUTES,prompt:!0,tag:1108},res:{ttl:cjs$7.FIVE_MINUTES,prompt:!1,tag:1109}},wc_sessionEvent:{req:{ttl:cjs$7.FIVE_MINUTES,prompt:!0,tag:1110},res:{ttl:cjs$7.FIVE_MINUTES,prompt:!1,tag:1111}},wc_sessionDelete:{req:{ttl:cjs$7.ONE_DAY,prompt:!1,tag:1112},res:{ttl:cjs$7.ONE_DAY,prompt:!1,tag:1113}},wc_sessionPing:{req:{ttl:cjs$7.THIRTY_SECONDS,prompt:!1,tag:1114},res:{ttl:cjs$7.THIRTY_SECONDS,prompt:!1,tag:1115}}},U$2={min:cjs$7.FIVE_MINUTES,max:cjs$7.SEVEN_DAYS},I$6={idle:"IDLE",active:"ACTIVE"},pe="request",he$1=["wc_sessionPropose","wc_sessionRequest","wc_authRequest"];var as=Object.defineProperty,cs=Object.defineProperties,ls=Object.getOwnPropertyDescriptors,de$1=Object.getOwnPropertySymbols,ps=Object.prototype.hasOwnProperty,hs=Object.prototype.propertyIsEnumerable,ue$1=(w,r,e)=>r in w?as(w,r,{enumerable:!0,configurable:!0,writable:!0,value:e}):w[r]=e,g$8=(w,r)=>{for(var e in r||(r={}))ps.call(r,e)&&ue$1(w,e,r[e]);if(de$1)for(var e of de$1(r))hs.call(r,e)&&ue$1(w,e,r[e]);return w},D$6=(w,r)=>cs(w,ls(r));class ds extends w$9{constructor(r){super(r),this.name=le$1,this.events=new EventEmitter$1,this.initialized=!1,this.ignoredPayloadTypes=[_$a],this.requestQueue={state:I$6.idle,queue:[]},this.sessionRequestQueue={state:I$6.idle,queue:[]},this.requestQueueDelay=cjs$7.ONE_SECOND,this.init=async()=>{this.initialized||(await this.cleanup(),this.registerRelayerEvents(),this.registerExpirerEvents(),this.registerPairingEvents(),this.client.core.pairing.register({methods:Object.keys(R$5)}),this.initialized=!0,setTimeout(()=>{this.sessionRequestQueue.queue=this.getPendingSessionRequests(),this.processSessionRequestQueue();},cjs$7.toMiliseconds(this.requestQueueDelay)));},this.connect=async e=>{await this.isInitialized();const s=D$6(g$8({},e),{requiredNamespaces:e.requiredNamespaces||{},optionalNamespaces:e.optionalNamespaces||{}});await this.isValidConnect(s);const{pairingTopic:t,requiredNamespaces:i,optionalNamespaces:n,sessionProperties:o,relays:a}=s;let c=t,p,d=!1;if(c&&(d=this.client.core.pairing.pairings.get(c).active),!c||!d){const{topic:T,uri:_}=await this.client.core.pairing.create();c=T,p=_;}const h=await this.client.core.crypto.generateKeyPair(),N=R$5.wc_sessionPropose.req.ttl||cjs$7.FIVE_MINUTES,m=pt$2(N),f=g$8({requiredNamespaces:i,optionalNamespaces:n,relays:a??[{protocol:ht$1}],proposer:{publicKey:h,metadata:this.client.metadata},expiryTimestamp:m},o&&{sessionProperties:o}),{reject:k,resolve:O,done:we}=at$2(N,ae$1);if(this.events.once(yt$2("session_connect"),async({error:T,session:_})=>{if(T)k(T);else if(_){_.self.publicKey=h;const B=D$6(g$8({},_),{requiredNamespaces:f.requiredNamespaces,optionalNamespaces:f.optionalNamespaces});await this.client.session.set(_.topic,B),await this.setExpiry(_.topic,_.expiry),c&&await this.client.core.pairing.updateMetadata({topic:c,metadata:_.peer.metadata}),O(B);}}),!c){const{message:T}=N$8("NO_MATCHING_KEY",`connect() pairing topic: ${c}`);throw new Error(T)}const W=await this.sendRequest({topic:c,method:"wc_sessionPropose",params:f,throwOnFailedPublish:!0});return await this.setProposal(W,g$8({id:W},f)),{uri:p,approval:we}},this.pair=async e=>(await this.isInitialized(),await this.client.core.pairing.pair(e)),this.approve=async e=>{await this.isInitialized(),await this.isValidApprove(e);const{id:s,relayProtocol:t,namespaces:i,sessionProperties:n}=e,o=this.client.proposal.get(s);let{pairingTopic:a,proposer:c,requiredNamespaces:p,optionalNamespaces:d}=o;a=a||"";const h=await this.client.core.crypto.generateKeyPair(),N=c.publicKey,m=await this.client.core.crypto.generateSharedKey(h,N);a&&s&&(await this.client.core.pairing.updateMetadata({topic:a,metadata:c.metadata}),await this.sendResult({id:s,topic:a,result:{relay:{protocol:t??"irn"},responderPublicKey:h}}),await this.client.proposal.delete(s,U$3("USER_DISCONNECTED")),await this.client.core.pairing.activate({topic:a}));const f=g$8({relay:{protocol:t??"irn"},namespaces:i,pairingTopic:a,controller:{publicKey:h,metadata:this.client.metadata},expiry:pt$2(L$8)},n&&{sessionProperties:n});await this.client.core.relayer.subscribe(m);const k=D$6(g$8({},f),{topic:m,requiredNamespaces:p,optionalNamespaces:d,pairingTopic:a,acknowledged:!1,self:f.controller,peer:{publicKey:c.publicKey,metadata:c.metadata},controller:h});await this.client.session.set(m,k);try{await this.sendRequest({topic:m,method:"wc_sessionSettle",params:f,throwOnFailedPublish:!0});}catch(O){throw this.client.logger.error(O),this.client.session.delete(m,U$3("USER_DISCONNECTED")),await this.client.core.relayer.unsubscribe(m),O}return await this.setExpiry(m,pt$2(L$8)),{topic:m,acknowledged:()=>new Promise(O=>setTimeout(()=>O(this.client.session.get(m)),500))}},this.reject=async e=>{await this.isInitialized(),await this.isValidReject(e);const{id:s,reason:t}=e,{pairingTopic:i}=this.client.proposal.get(s);i&&(await this.sendError(s,i,t),await this.client.proposal.delete(s,U$3("USER_DISCONNECTED")));},this.update=async e=>{await this.isInitialized(),await this.isValidUpdate(e);const{topic:s,namespaces:t}=e,i=await this.sendRequest({topic:s,method:"wc_sessionUpdate",params:{namespaces:t}}),{done:n,resolve:o,reject:a}=at$2();return this.events.once(yt$2("session_update",i),({error:c})=>{c?a(c):o();}),await this.client.session.update(s,{namespaces:t}),{acknowledged:n}},this.extend=async e=>{await this.isInitialized(),await this.isValidExtend(e);const{topic:s}=e,t=await this.sendRequest({topic:s,method:"wc_sessionExtend",params:{}}),{done:i,resolve:n,reject:o}=at$2();return this.events.once(yt$2("session_extend",t),({error:a})=>{a?o(a):n();}),await this.setExpiry(s,pt$2(L$8)),{acknowledged:i}},this.request=async e=>{await this.isInitialized(),await this.isValidRequest(e);const{chainId:s,request:t,topic:i,expiry:n=R$5.wc_sessionRequest.req.ttl}=e,o=payloadId(),{done:a,resolve:c,reject:p}=at$2(n,"Request expired. Please try again.");return this.events.once(yt$2("session_request",o),({error:d,result:h})=>{d?p(d):c(h);}),await Promise.all([new Promise(async d=>{await this.sendRequest({clientRpcId:o,topic:i,method:"wc_sessionRequest",params:{request:D$6(g$8({},t),{expiryTimestamp:pt$2(n)}),chainId:s},expiry:n,throwOnFailedPublish:!0}).catch(h=>p(h)),this.client.events.emit("session_request_sent",{topic:i,request:t,chainId:s,id:o}),d();}),new Promise(async d=>{const h=await ht$2(this.client.core.storage,H$6);gt$7({id:o,topic:i,wcDeepLink:h}),d();}),a()]).then(d=>d[2])},this.respond=async e=>{await this.isInitialized(),await this.isValidRespond(e);const{topic:s,response:t}=e,{id:i}=t;isJsonRpcResult(t)?await this.sendResult({id:i,topic:s,result:t.result,throwOnFailedPublish:!0}):isJsonRpcError(t)&&await this.sendError(i,s,t.error),this.cleanupAfterResponse(e);},this.ping=async e=>{await this.isInitialized(),await this.isValidPing(e);const{topic:s}=e;if(this.client.session.keys.includes(s)){const t=await this.sendRequest({topic:s,method:"wc_sessionPing",params:{}}),{done:i,resolve:n,reject:o}=at$2();this.events.once(yt$2("session_ping",t),({error:a})=>{a?o(a):n();}),await i();}else this.client.core.pairing.pairings.keys.includes(s)&&await this.client.core.pairing.ping({topic:s});},this.emit=async e=>{await this.isInitialized(),await this.isValidEmit(e);const{topic:s,event:t,chainId:i}=e;await this.sendRequest({topic:s,method:"wc_sessionEvent",params:{event:t,chainId:i}});},this.disconnect=async e=>{await this.isInitialized(),await this.isValidDisconnect(e);const{topic:s}=e;if(this.client.session.keys.includes(s))await this.sendRequest({topic:s,method:"wc_sessionDelete",params:U$3("USER_DISCONNECTED"),throwOnFailedPublish:!0}),await this.deleteSession({topic:s,emitEvent:!1});else if(this.client.core.pairing.pairings.keys.includes(s))await this.client.core.pairing.disconnect({topic:s});else {const{message:t}=N$8("MISMATCHED_TOPIC",`Session or pairing topic not found: ${s}`);throw new Error(t)}},this.find=e=>(this.isInitialized(),this.client.session.getAll().filter(s=>Mt$2(s,e))),this.getPendingSessionRequests=()=>this.client.pendingRequest.getAll(),this.cleanupDuplicatePairings=async e=>{if(e.pairingTopic)try{const s=this.client.core.pairing.pairings.get(e.pairingTopic),t=this.client.core.pairing.pairings.getAll().filter(i=>{var n,o;return ((n=i.peerMetadata)==null?void 0:n.url)&&((o=i.peerMetadata)==null?void 0:o.url)===e.peer.metadata.url&&i.topic&&i.topic!==s.topic});if(t.length===0)return;this.client.logger.info(`Cleaning up ${t.length} duplicate pairing(s)`),await Promise.all(t.map(i=>this.client.core.pairing.disconnect({topic:i.topic}))),this.client.logger.info("Duplicate pairings clean up finished");}catch(s){this.client.logger.error(s);}},this.deleteSession=async e=>{const{topic:s,expirerHasDeleted:t=!1,emitEvent:i=!0,id:n=0}=e,{self:o}=this.client.session.get(s);await this.client.core.relayer.unsubscribe(s),await this.client.session.delete(s,U$3("USER_DISCONNECTED")),this.client.core.crypto.keychain.has(o.publicKey)&&await this.client.core.crypto.deleteKeyPair(o.publicKey),this.client.core.crypto.keychain.has(s)&&await this.client.core.crypto.deleteSymKey(s),t||this.client.core.expirer.del(s),this.client.core.storage.removeItem(H$6).catch(a=>this.client.logger.warn(a)),this.getPendingSessionRequests().forEach(a=>{a.topic===s&&this.deletePendingSessionRequest(a.id,U$3("USER_DISCONNECTED"));}),i&&this.client.events.emit("session_delete",{id:n,topic:s});},this.deleteProposal=async(e,s)=>{await Promise.all([this.client.proposal.delete(e,U$3("USER_DISCONNECTED")),s?Promise.resolve():this.client.core.expirer.del(e)]);},this.deletePendingSessionRequest=async(e,s,t=!1)=>{await Promise.all([this.client.pendingRequest.delete(e,s),t?Promise.resolve():this.client.core.expirer.del(e)]),this.sessionRequestQueue.queue=this.sessionRequestQueue.queue.filter(i=>i.id!==e),t&&(this.sessionRequestQueue.state=I$6.idle,this.client.events.emit("session_request_expire",{id:e}));},this.setExpiry=async(e,s)=>{this.client.session.keys.includes(e)&&await this.client.session.update(e,{expiry:s}),this.client.core.expirer.set(e,s);},this.setProposal=async(e,s)=>{await this.client.proposal.set(e,s),this.client.core.expirer.set(e,pt$2(R$5.wc_sessionPropose.req.ttl));},this.setPendingSessionRequest=async e=>{const{id:s,topic:t,params:i,verifyContext:n}=e,o=i.request.expiryTimestamp||pt$2(R$5.wc_sessionRequest.req.ttl);await this.client.pendingRequest.set(s,{id:s,topic:t,params:i,verifyContext:n}),o&&this.client.core.expirer.set(s,o);},this.sendRequest=async e=>{const{topic:s,method:t,params:i,expiry:n,relayRpcId:o,clientRpcId:a,throwOnFailedPublish:c}=e,p=formatJsonRpcRequest(t,i,a);if(D$9()&&he$1.includes(t)){const N=Ln(JSON.stringify(p));this.client.core.verify.register({attestationId:N});}const d=await this.client.core.crypto.encode(s,p),h=R$5[t].req;return n&&(h.ttl=n),o&&(h.id=o),this.client.core.history.set(s,p),c?(h.internal=D$6(g$8({},h.internal),{throwOnFailedPublish:!0}),await this.client.core.relayer.publish(s,d,h)):this.client.core.relayer.publish(s,d,h).catch(N=>this.client.logger.error(N)),p.id},this.sendResult=async e=>{const{id:s,topic:t,result:i,throwOnFailedPublish:n}=e,o=formatJsonRpcResult(s,i),a=await this.client.core.crypto.encode(t,o),c=await this.client.core.history.get(t,s),p=R$5[c.request.method].res;n?(p.internal=D$6(g$8({},p.internal),{throwOnFailedPublish:!0}),await this.client.core.relayer.publish(t,a,p)):this.client.core.relayer.publish(t,a,p).catch(d=>this.client.logger.error(d)),await this.client.core.history.resolve(o);},this.sendError=async(e,s,t)=>{const i=formatJsonRpcError(e,t),n=await this.client.core.crypto.encode(s,i),o=await this.client.core.history.get(s,e),a=R$5[o.request.method].res;this.client.core.relayer.publish(s,n,a),await this.client.core.history.resolve(i);},this.cleanup=async()=>{const e=[],s=[];this.client.session.getAll().forEach(t=>{let i=!1;mt$2(t.expiry)&&(i=!0),this.client.core.crypto.keychain.has(t.topic)||(i=!0),i&&e.push(t.topic);}),this.client.proposal.getAll().forEach(t=>{mt$2(t.expiryTimestamp)&&s.push(t.id);}),await Promise.all([...e.map(t=>this.deleteSession({topic:t})),...s.map(t=>this.deleteProposal(t))]);},this.onRelayEventRequest=async e=>{this.requestQueue.queue.push(e),await this.processRequestsQueue();},this.processRequestsQueue=async()=>{if(this.requestQueue.state===I$6.active){this.client.logger.info("Request queue already active, skipping...");return}for(this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`);this.requestQueue.queue.length>0;){this.requestQueue.state=I$6.active;const e=this.requestQueue.queue.shift();if(e)try{this.processRequest(e),await new Promise(s=>setTimeout(s,300));}catch(s){this.client.logger.warn(s);}}this.requestQueue.state=I$6.idle;},this.processRequest=e=>{const{topic:s,payload:t}=e,i=t.method;switch(i){case"wc_sessionPropose":return this.onSessionProposeRequest(s,t);case"wc_sessionSettle":return this.onSessionSettleRequest(s,t);case"wc_sessionUpdate":return this.onSessionUpdateRequest(s,t);case"wc_sessionExtend":return this.onSessionExtendRequest(s,t);case"wc_sessionPing":return this.onSessionPingRequest(s,t);case"wc_sessionDelete":return this.onSessionDeleteRequest(s,t);case"wc_sessionRequest":return this.onSessionRequest(s,t);case"wc_sessionEvent":return this.onSessionEventRequest(s,t);default:return this.client.logger.info(`Unsupported request method ${i}`)}},this.onRelayEventResponse=async e=>{const{topic:s,payload:t}=e,i=(await this.client.core.history.get(s,t.id)).request.method;switch(i){case"wc_sessionPropose":return this.onSessionProposeResponse(s,t);case"wc_sessionSettle":return this.onSessionSettleResponse(s,t);case"wc_sessionUpdate":return this.onSessionUpdateResponse(s,t);case"wc_sessionExtend":return this.onSessionExtendResponse(s,t);case"wc_sessionPing":return this.onSessionPingResponse(s,t);case"wc_sessionRequest":return this.onSessionRequestResponse(s,t);default:return this.client.logger.info(`Unsupported response method ${i}`)}},this.onRelayEventUnknownPayload=e=>{const{topic:s}=e,{message:t}=N$8("MISSING_OR_INVALID",`Decoded payload on topic ${s} is not identifiable as a JSON-RPC request or a response.`);throw new Error(t)},this.onSessionProposeRequest=async(e,s)=>{const{params:t,id:i}=s;try{this.isValidConnect(g$8({},s.params));const n=t.expiryTimestamp||pt$2(R$5.wc_sessionPropose.req.ttl),o=g$8({id:i,pairingTopic:e,expiryTimestamp:n},t);await this.setProposal(i,o);const a=Ln(JSON.stringify(s)),c=await this.getVerifyContext(a,o.proposer.metadata);this.client.events.emit("session_proposal",{id:i,params:o,verifyContext:c});}catch(n){await this.sendError(i,e,n),this.client.logger.error(n);}},this.onSessionProposeResponse=async(e,s)=>{const{id:t}=s;if(isJsonRpcResult(s)){const{result:i}=s;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",result:i});const n=this.client.proposal.get(t);this.client.logger.trace({type:"method",method:"onSessionProposeResponse",proposal:n});const o=n.proposer.publicKey;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",selfPublicKey:o});const a=i.responderPublicKey;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",peerPublicKey:a});const c=await this.client.core.crypto.generateSharedKey(o,a);this.client.logger.trace({type:"method",method:"onSessionProposeResponse",sessionTopic:c});const p=await this.client.core.relayer.subscribe(c);this.client.logger.trace({type:"method",method:"onSessionProposeResponse",subscriptionId:p}),await this.client.core.pairing.activate({topic:e});}else isJsonRpcError(s)&&(await this.client.proposal.delete(t,U$3("USER_DISCONNECTED")),this.events.emit(yt$2("session_connect"),{error:s.error}));},this.onSessionSettleRequest=async(e,s)=>{const{id:t,params:i}=s;try{this.isValidSessionSettleRequest(i);const{relay:n,controller:o,expiry:a,namespaces:c,sessionProperties:p,pairingTopic:d}=s.params,h=g$8({topic:e,relay:n,expiry:a,namespaces:c,acknowledged:!0,pairingTopic:d,requiredNamespaces:{},optionalNamespaces:{},controller:o.publicKey,self:{publicKey:"",metadata:this.client.metadata},peer:{publicKey:o.publicKey,metadata:o.metadata}},p&&{sessionProperties:p});await this.sendResult({id:s.id,topic:e,result:!0}),this.events.emit(yt$2("session_connect"),{session:h}),this.cleanupDuplicatePairings(h);}catch(n){await this.sendError(t,e,n),this.client.logger.error(n);}},this.onSessionSettleResponse=async(e,s)=>{const{id:t}=s;isJsonRpcResult(s)?(await this.client.session.update(e,{acknowledged:!0}),this.events.emit(yt$2("session_approve",t),{})):isJsonRpcError(s)&&(await this.client.session.delete(e,U$3("USER_DISCONNECTED")),this.events.emit(yt$2("session_approve",t),{error:s.error}));},this.onSessionUpdateRequest=async(e,s)=>{const{params:t,id:i}=s;try{const n=`${e}_session_update`,o=sr$2.get(n);if(o&&this.isRequestOutOfSync(o,i)){this.client.logger.info(`Discarding out of sync request - ${i}`);return}this.isValidUpdate(g$8({topic:e},t)),await this.client.session.update(e,{namespaces:t.namespaces}),await this.sendResult({id:i,topic:e,result:!0}),this.client.events.emit("session_update",{id:i,topic:e,params:t}),sr$2.set(n,i);}catch(n){await this.sendError(i,e,n),this.client.logger.error(n);}},this.isRequestOutOfSync=(e,s)=>parseInt(s.toString().slice(0,-3))<=parseInt(e.toString().slice(0,-3)),this.onSessionUpdateResponse=(e,s)=>{const{id:t}=s;isJsonRpcResult(s)?this.events.emit(yt$2("session_update",t),{}):isJsonRpcError(s)&&this.events.emit(yt$2("session_update",t),{error:s.error});},this.onSessionExtendRequest=async(e,s)=>{const{id:t}=s;try{this.isValidExtend({topic:e}),await this.setExpiry(e,pt$2(L$8)),await this.sendResult({id:t,topic:e,result:!0}),this.client.events.emit("session_extend",{id:t,topic:e});}catch(i){await this.sendError(t,e,i),this.client.logger.error(i);}},this.onSessionExtendResponse=(e,s)=>{const{id:t}=s;isJsonRpcResult(s)?this.events.emit(yt$2("session_extend",t),{}):isJsonRpcError(s)&&this.events.emit(yt$2("session_extend",t),{error:s.error});},this.onSessionPingRequest=async(e,s)=>{const{id:t}=s;try{this.isValidPing({topic:e}),await this.sendResult({id:t,topic:e,result:!0}),this.client.events.emit("session_ping",{id:t,topic:e});}catch(i){await this.sendError(t,e,i),this.client.logger.error(i);}},this.onSessionPingResponse=(e,s)=>{const{id:t}=s;setTimeout(()=>{isJsonRpcResult(s)?this.events.emit(yt$2("session_ping",t),{}):isJsonRpcError(s)&&this.events.emit(yt$2("session_ping",t),{error:s.error});},500);},this.onSessionDeleteRequest=async(e,s)=>{const{id:t}=s;try{this.isValidDisconnect({topic:e,reason:s.params}),await Promise.all([new Promise(i=>{this.client.core.relayer.once(D$7.publish,async()=>{i(await this.deleteSession({topic:e,id:t}));});}),this.sendResult({id:t,topic:e,result:!0}),this.cleanupPendingSentRequestsForTopic({topic:e,error:U$3("USER_DISCONNECTED")})]);}catch(i){this.client.logger.error(i);}},this.onSessionRequest=async(e,s)=>{const{id:t,params:i}=s;try{this.isValidRequest(g$8({topic:e},i));const n=Ln(JSON.stringify(formatJsonRpcRequest("wc_sessionRequest",i,t))),o=this.client.session.get(e),a=await this.getVerifyContext(n,o.peer.metadata),c={id:t,topic:e,params:i,verifyContext:a};await this.setPendingSessionRequest(c),this.addSessionRequestToSessionRequestQueue(c),this.processSessionRequestQueue();}catch(n){await this.sendError(t,e,n),this.client.logger.error(n);}},this.onSessionRequestResponse=(e,s)=>{const{id:t}=s;isJsonRpcResult(s)?this.events.emit(yt$2("session_request",t),{result:s.result}):isJsonRpcError(s)&&this.events.emit(yt$2("session_request",t),{error:s.error});},this.onSessionEventRequest=async(e,s)=>{const{id:t,params:i}=s;try{const n=`${e}_session_event_${i.event.name}`,o=sr$2.get(n);if(o&&this.isRequestOutOfSync(o,t)){this.client.logger.info(`Discarding out of sync request - ${t}`);return}this.isValidEmit(g$8({topic:e},i)),this.client.events.emit("session_event",{id:t,topic:e,params:i}),sr$2.set(n,t);}catch(n){await this.sendError(t,e,n),this.client.logger.error(n);}},this.addSessionRequestToSessionRequestQueue=e=>{this.sessionRequestQueue.queue.push(e);},this.cleanupAfterResponse=e=>{this.deletePendingSessionRequest(e.response.id,{message:"fulfilled",code:0}),setTimeout(()=>{this.sessionRequestQueue.state=I$6.idle,this.processSessionRequestQueue();},cjs$7.toMiliseconds(this.requestQueueDelay));},this.cleanupPendingSentRequestsForTopic=({topic:e,error:s})=>{const t=this.client.core.history.pending;t.length>0&&t.filter(i=>i.topic===e&&i.request.method==="wc_sessionRequest").forEach(i=>{this.events.emit(yt$2("session_request",i.request.id),{error:s});});},this.processSessionRequestQueue=()=>{if(this.sessionRequestQueue.state===I$6.active){this.client.logger.info("session request queue is already active.");return}const e=this.sessionRequestQueue.queue[0];if(!e){this.client.logger.info("session request queue is empty.");return}try{this.sessionRequestQueue.state=I$6.active,this.client.events.emit("session_request",e);}catch(s){this.client.logger.error(s);}},this.onPairingCreated=e=>{if(e.active)return;const s=this.client.proposal.getAll().find(t=>t.pairingTopic===e.topic);s&&this.onSessionProposeRequest(e.topic,formatJsonRpcRequest("wc_sessionPropose",{requiredNamespaces:s.requiredNamespaces,optionalNamespaces:s.optionalNamespaces,relays:s.relays,proposer:s.proposer,sessionProperties:s.sessionProperties},s.id));},this.isValidConnect=async e=>{if(!Gt$2(e)){const{message:a}=N$8("MISSING_OR_INVALID",`connect() params: ${JSON.stringify(e)}`);throw new Error(a)}const{pairingTopic:s,requiredNamespaces:t,optionalNamespaces:i,sessionProperties:n,relays:o}=e;if(w$a(s)||await this.isValidPairingTopic(s),!qt$2(o,!0)){const{message:a}=N$8("MISSING_OR_INVALID",`connect() relays: ${o}`);throw new Error(a)}!w$a(t)&&B$6(t)!==0&&this.validateNamespaces(t,"requiredNamespaces"),!w$a(i)&&B$6(i)!==0&&this.validateNamespaces(i,"optionalNamespaces"),w$a(n)||this.validateSessionProps(n,"sessionProperties");},this.validateNamespaces=(e,s)=>{const t=Ht$2(e,"connect()",s);if(t)throw new Error(t.message)},this.isValidApprove=async e=>{if(!Gt$2(e))throw new Error(N$8("MISSING_OR_INVALID",`approve() params: ${e}`).message);const{id:s,namespaces:t,relayProtocol:i,sessionProperties:n}=e;await this.isValidProposalId(s);const o=this.client.proposal.get(s),a=ln(t,"approve()");if(a)throw new Error(a.message);const c=fn(o.requiredNamespaces,t,"approve()");if(c)throw new Error(c.message);if(!g$b(i,!0)){const{message:p}=N$8("MISSING_OR_INVALID",`approve() relayProtocol: ${i}`);throw new Error(p)}w$a(n)||this.validateSessionProps(n,"sessionProperties");},this.isValidReject=async e=>{if(!Gt$2(e)){const{message:i}=N$8("MISSING_OR_INVALID",`reject() params: ${e}`);throw new Error(i)}const{id:s,reason:t}=e;if(await this.isValidProposalId(s),!Wt$1(t)){const{message:i}=N$8("MISSING_OR_INVALID",`reject() reason: ${JSON.stringify(t)}`);throw new Error(i)}},this.isValidSessionSettleRequest=e=>{if(!Gt$2(e)){const{message:c}=N$8("MISSING_OR_INVALID",`onSessionSettleRequest() params: ${e}`);throw new Error(c)}const{relay:s,controller:t,namespaces:i,expiry:n}=e;if(!dn(s)){const{message:c}=N$8("MISSING_OR_INVALID","onSessionSettleRequest() relay protocol should be a string");throw new Error(c)}const o=Ft$2(t,"onSessionSettleRequest()");if(o)throw new Error(o.message);const a=ln(i,"onSessionSettleRequest()");if(a)throw new Error(a.message);if(mt$2(n)){const{message:c}=N$8("EXPIRED","onSessionSettleRequest()");throw new Error(c)}},this.isValidUpdate=async e=>{if(!Gt$2(e)){const{message:a}=N$8("MISSING_OR_INVALID",`update() params: ${e}`);throw new Error(a)}const{topic:s,namespaces:t}=e;await this.isValidSessionTopic(s);const i=this.client.session.get(s),n=ln(t,"update()");if(n)throw new Error(n.message);const o=fn(i.requiredNamespaces,t,"update()");if(o)throw new Error(o.message)},this.isValidExtend=async e=>{if(!Gt$2(e)){const{message:t}=N$8("MISSING_OR_INVALID",`extend() params: ${e}`);throw new Error(t)}const{topic:s}=e;await this.isValidSessionTopic(s);},this.isValidRequest=async e=>{if(!Gt$2(e)){const{message:a}=N$8("MISSING_OR_INVALID",`request() params: ${e}`);throw new Error(a)}const{topic:s,request:t,chainId:i,expiry:n}=e;await this.isValidSessionTopic(s);const{namespaces:o}=this.client.session.get(s);if(!Qt$1(o,i)){const{message:a}=N$8("MISSING_OR_INVALID",`request() chainId: ${i}`);throw new Error(a)}if(!zt$2(t)){const{message:a}=N$8("MISSING_OR_INVALID",`request() ${JSON.stringify(t)}`);throw new Error(a)}if(!Zt$1(o,i,t.method)){const{message:a}=N$8("MISSING_OR_INVALID",`request() method: ${t.method}`);throw new Error(a)}if(n&&!tr$2(n,U$2)){const{message:a}=N$8("MISSING_OR_INVALID",`request() expiry: ${n}. Expiry must be a number (in seconds) between ${U$2.min} and ${U$2.max}`);throw new Error(a)}},this.isValidRespond=async e=>{var s;if(!Gt$2(e)){const{message:n}=N$8("MISSING_OR_INVALID",`respond() params: ${e}`);throw new Error(n)}const{topic:t,response:i}=e;try{await this.isValidSessionTopic(t);}catch(n){throw (s=e?.response)!=null&&s.id&&this.cleanupAfterResponse(e),n}if(!Yt$2(i)){const{message:n}=N$8("MISSING_OR_INVALID",`respond() response: ${JSON.stringify(i)}`);throw new Error(n)}},this.isValidPing=async e=>{if(!Gt$2(e)){const{message:t}=N$8("MISSING_OR_INVALID",`ping() params: ${e}`);throw new Error(t)}const{topic:s}=e;await this.isValidSessionOrPairingTopic(s);},this.isValidEmit=async e=>{if(!Gt$2(e)){const{message:o}=N$8("MISSING_OR_INVALID",`emit() params: ${e}`);throw new Error(o)}const{topic:s,event:t,chainId:i}=e;await this.isValidSessionTopic(s);const{namespaces:n}=this.client.session.get(s);if(!Qt$1(n,i)){const{message:o}=N$8("MISSING_OR_INVALID",`emit() chainId: ${i}`);throw new Error(o)}if(!Jt$2(t)){const{message:o}=N$8("MISSING_OR_INVALID",`emit() event: ${JSON.stringify(t)}`);throw new Error(o)}if(!Xt$1(n,i,t.name)){const{message:o}=N$8("MISSING_OR_INVALID",`emit() event: ${JSON.stringify(t)}`);throw new Error(o)}},this.isValidDisconnect=async e=>{if(!Gt$2(e)){const{message:t}=N$8("MISSING_OR_INVALID",`disconnect() params: ${e}`);throw new Error(t)}const{topic:s}=e;await this.isValidSessionOrPairingTopic(s);},this.getVerifyContext=async(e,s)=>{const t={verified:{verifyUrl:s.verifyUrl||F$5,validation:"UNKNOWN",origin:s.url||""}};try{const i=await this.client.core.verify.resolve({attestationId:e,verifyUrl:s.verifyUrl});i&&(t.verified.origin=i.origin,t.verified.isScam=i.isScam,t.verified.validation=i.origin===new URL(s.url).origin?"VALID":"INVALID");}catch(i){this.client.logger.info(i);}return this.client.logger.info(`Verify context: ${JSON.stringify(t)}`),t},this.validateSessionProps=(e,s)=>{Object.values(e).forEach(t=>{if(!g$b(t,!1)){const{message:i}=N$8("MISSING_OR_INVALID",`${s} must be in Record<string, string> format. Received: ${JSON.stringify(t)}`);throw new Error(i)}});};}async isInitialized(){if(!this.initialized){const{message:r}=N$8("NOT_INITIALIZED",this.name);throw new Error(r)}await this.client.core.relayer.confirmOnlineStateOrThrow();}registerRelayerEvents(){this.client.core.relayer.on(D$7.message,async r=>{const{topic:e,message:s}=r;if(this.ignoredPayloadTypes.includes(this.client.core.crypto.getPayloadType(s)))return;const t=await this.client.core.crypto.decode(e,s);try{isJsonRpcRequest(t)?(this.client.core.history.set(e,t),this.onRelayEventRequest({topic:e,payload:t})):isJsonRpcResponse(t)?(await this.client.core.history.resolve(t),await this.onRelayEventResponse({topic:e,payload:t}),this.client.core.history.delete(e,t.id)):this.onRelayEventUnknownPayload({topic:e,payload:t});}catch(i){this.client.logger.error(i);}});}registerExpirerEvents(){this.client.core.expirer.on(v$8.expired,async r=>{const{topic:e,id:s}=ft$5(r.target);if(s&&this.client.pendingRequest.keys.includes(s))return await this.deletePendingSessionRequest(s,N$8("EXPIRED"),!0);e?this.client.session.keys.includes(e)&&(await this.deleteSession({topic:e,expirerHasDeleted:!0}),this.client.events.emit("session_expire",{topic:e})):s&&(await this.deleteProposal(s,!0),this.client.events.emit("proposal_expire",{id:s}));});}registerPairingEvents(){this.client.core.pairing.events.on(V$6.create,r=>this.onPairingCreated(r));}isValidPairingTopic(r){if(!g$b(r,!1)){const{message:e}=N$8("MISSING_OR_INVALID",`pairing topic should be a string: ${r}`);throw new Error(e)}if(!this.client.core.pairing.pairings.keys.includes(r)){const{message:e}=N$8("NO_MATCHING_KEY",`pairing topic doesn't exist: ${r}`);throw new Error(e)}if(mt$2(this.client.core.pairing.pairings.get(r).expiry)){const{message:e}=N$8("EXPIRED",`pairing topic: ${r}`);throw new Error(e)}}async isValidSessionTopic(r){if(!g$b(r,!1)){const{message:e}=N$8("MISSING_OR_INVALID",`session topic should be a string: ${r}`);throw new Error(e)}if(!this.client.session.keys.includes(r)){const{message:e}=N$8("NO_MATCHING_KEY",`session topic doesn't exist: ${r}`);throw new Error(e)}if(mt$2(this.client.session.get(r).expiry)){await this.deleteSession({topic:r});const{message:e}=N$8("EXPIRED",`session topic: ${r}`);throw new Error(e)}if(!this.client.core.crypto.keychain.has(r)){const{message:e}=N$8("MISSING_OR_INVALID",`session topic does not exist in keychain: ${r}`);throw await this.deleteSession({topic:r}),new Error(e)}}async isValidSessionOrPairingTopic(r){if(this.client.session.keys.includes(r))await this.isValidSessionTopic(r);else if(this.client.core.pairing.pairings.keys.includes(r))this.isValidPairingTopic(r);else if(g$b(r,!1)){const{message:e}=N$8("NO_MATCHING_KEY",`session or pairing topic doesn't exist: ${r}`);throw new Error(e)}else {const{message:e}=N$8("MISSING_OR_INVALID",`session or pairing topic should be a string: ${r}`);throw new Error(e)}}async isValidProposalId(r){if(!Bt$2(r)){const{message:e}=N$8("MISSING_OR_INVALID",`proposal id should be a number: ${r}`);throw new Error(e)}if(!this.client.proposal.keys.includes(r)){const{message:e}=N$8("NO_MATCHING_KEY",`proposal id doesn't exist: ${r}`);throw new Error(e)}if(mt$2(this.client.proposal.get(r).expiryTimestamp)){await this.deleteProposal(r);const{message:e}=N$8("EXPIRED",`proposal id: ${r}`);throw new Error(e)}}}class us extends Kt$1{constructor(r,e){super(r,e,oe$2,G$3),this.core=r,this.logger=e;}}let ge$1 = class ge extends Kt$1{constructor(r,e){super(r,e,ce$1,G$3),this.core=r,this.logger=e;}};class gs extends Kt$1{constructor(r,e){super(r,e,pe,G$3,s=>s.id),this.core=r,this.logger=e;}}let Q$3 = class Q extends b$8{constructor(r){super(r),this.protocol=J$1,this.version=F$4,this.name=M$7.name,this.events=new EventEmitter$1,this.on=(s,t)=>this.events.on(s,t),this.once=(s,t)=>this.events.once(s,t),this.off=(s,t)=>this.events.off(s,t),this.removeListener=(s,t)=>this.events.removeListener(s,t),this.removeAllListeners=s=>this.events.removeAllListeners(s),this.connect=async s=>{try{return await this.engine.connect(s)}catch(t){throw this.logger.error(t.message),t}},this.pair=async s=>{try{return await this.engine.pair(s)}catch(t){throw this.logger.error(t.message),t}},this.approve=async s=>{try{return await this.engine.approve(s)}catch(t){throw this.logger.error(t.message),t}},this.reject=async s=>{try{return await this.engine.reject(s)}catch(t){throw this.logger.error(t.message),t}},this.update=async s=>{try{return await this.engine.update(s)}catch(t){throw this.logger.error(t.message),t}},this.extend=async s=>{try{return await this.engine.extend(s)}catch(t){throw this.logger.error(t.message),t}},this.request=async s=>{try{return await this.engine.request(s)}catch(t){throw this.logger.error(t.message),t}},this.respond=async s=>{try{return await this.engine.respond(s)}catch(t){throw this.logger.error(t.message),t}},this.ping=async s=>{try{return await this.engine.ping(s)}catch(t){throw this.logger.error(t.message),t}},this.emit=async s=>{try{return await this.engine.emit(s)}catch(t){throw this.logger.error(t.message),t}},this.disconnect=async s=>{try{return await this.engine.disconnect(s)}catch(t){throw this.logger.error(t.message),t}},this.find=s=>{try{return this.engine.find(s)}catch(t){throw this.logger.error(t.message),t}},this.getPendingSessionRequests=()=>{try{return this.engine.getPendingSessionRequests()}catch(s){throw this.logger.error(s.message),s}},this.name=r?.name||M$7.name,this.metadata=r?.metadata||Qn();const e=typeof r?.logger<"u"&&typeof r?.logger!="string"?r.logger:cjs$3.pino(cjs$3.getDefaultLoggerOptions({level:r?.logger||M$7.logger}));this.core=r?.core||new Mr(r),this.logger=cjs$3.generateChildLogger(e,this.name),this.session=new ge$1(this.core,this.logger),this.proposal=new us(this.core,this.logger),this.pendingRequest=new gs(this.core,this.logger),this.engine=new ds(this);}static async init(r){const e=new Q(r);return await e.initialize(),e}get context(){return cjs$3.getLoggerContext(this.logger)}get pairing(){return this.core.pairing.pairings}async initialize(){this.logger.trace("Initialized");try{await this.core.start(),await this.session.init(),await this.proposal.init(),await this.pendingRequest.init(),await this.engine.init(),this.core.verify.init({verifyUrl:this.metadata.verifyUrl}),this.logger.info("SignClient Initialization Success");}catch(r){throw this.logger.info("SignClient Initialization Failure"),this.logger.error(r.message),r}}};

    var browserPonyfill = {exports: {}};

    (function (module, exports) {
    	var global = typeof self !== 'undefined' ? self : commonjsGlobal;
    	var __self__ = (function () {
    	function F() {
    	this.fetch = false;
    	this.DOMException = global.DOMException;
    	}
    	F.prototype = global;
    	return new F();
    	})();
    	(function(self) {

    	((function (exports) {

    	  var support = {
    	    searchParams: 'URLSearchParams' in self,
    	    iterable: 'Symbol' in self && 'iterator' in Symbol,
    	    blob:
    	      'FileReader' in self &&
    	      'Blob' in self &&
    	      (function() {
    	        try {
    	          new Blob();
    	          return true
    	        } catch (e) {
    	          return false
    	        }
    	      })(),
    	    formData: 'FormData' in self,
    	    arrayBuffer: 'ArrayBuffer' in self
    	  };

    	  function isDataView(obj) {
    	    return obj && DataView.prototype.isPrototypeOf(obj)
    	  }

    	  if (support.arrayBuffer) {
    	    var viewClasses = [
    	      '[object Int8Array]',
    	      '[object Uint8Array]',
    	      '[object Uint8ClampedArray]',
    	      '[object Int16Array]',
    	      '[object Uint16Array]',
    	      '[object Int32Array]',
    	      '[object Uint32Array]',
    	      '[object Float32Array]',
    	      '[object Float64Array]'
    	    ];

    	    var isArrayBufferView =
    	      ArrayBuffer.isView ||
    	      function(obj) {
    	        return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
    	      };
    	  }

    	  function normalizeName(name) {
    	    if (typeof name !== 'string') {
    	      name = String(name);
    	    }
    	    if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
    	      throw new TypeError('Invalid character in header field name')
    	    }
    	    return name.toLowerCase()
    	  }

    	  function normalizeValue(value) {
    	    if (typeof value !== 'string') {
    	      value = String(value);
    	    }
    	    return value
    	  }

    	  // Build a destructive iterator for the value list
    	  function iteratorFor(items) {
    	    var iterator = {
    	      next: function() {
    	        var value = items.shift();
    	        return {done: value === undefined, value: value}
    	      }
    	    };

    	    if (support.iterable) {
    	      iterator[Symbol.iterator] = function() {
    	        return iterator
    	      };
    	    }

    	    return iterator
    	  }

    	  function Headers(headers) {
    	    this.map = {};

    	    if (headers instanceof Headers) {
    	      headers.forEach(function(value, name) {
    	        this.append(name, value);
    	      }, this);
    	    } else if (Array.isArray(headers)) {
    	      headers.forEach(function(header) {
    	        this.append(header[0], header[1]);
    	      }, this);
    	    } else if (headers) {
    	      Object.getOwnPropertyNames(headers).forEach(function(name) {
    	        this.append(name, headers[name]);
    	      }, this);
    	    }
    	  }

    	  Headers.prototype.append = function(name, value) {
    	    name = normalizeName(name);
    	    value = normalizeValue(value);
    	    var oldValue = this.map[name];
    	    this.map[name] = oldValue ? oldValue + ', ' + value : value;
    	  };

    	  Headers.prototype['delete'] = function(name) {
    	    delete this.map[normalizeName(name)];
    	  };

    	  Headers.prototype.get = function(name) {
    	    name = normalizeName(name);
    	    return this.has(name) ? this.map[name] : null
    	  };

    	  Headers.prototype.has = function(name) {
    	    return this.map.hasOwnProperty(normalizeName(name))
    	  };

    	  Headers.prototype.set = function(name, value) {
    	    this.map[normalizeName(name)] = normalizeValue(value);
    	  };

    	  Headers.prototype.forEach = function(callback, thisArg) {
    	    for (var name in this.map) {
    	      if (this.map.hasOwnProperty(name)) {
    	        callback.call(thisArg, this.map[name], name, this);
    	      }
    	    }
    	  };

    	  Headers.prototype.keys = function() {
    	    var items = [];
    	    this.forEach(function(value, name) {
    	      items.push(name);
    	    });
    	    return iteratorFor(items)
    	  };

    	  Headers.prototype.values = function() {
    	    var items = [];
    	    this.forEach(function(value) {
    	      items.push(value);
    	    });
    	    return iteratorFor(items)
    	  };

    	  Headers.prototype.entries = function() {
    	    var items = [];
    	    this.forEach(function(value, name) {
    	      items.push([name, value]);
    	    });
    	    return iteratorFor(items)
    	  };

    	  if (support.iterable) {
    	    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
    	  }

    	  function consumed(body) {
    	    if (body.bodyUsed) {
    	      return Promise.reject(new TypeError('Already read'))
    	    }
    	    body.bodyUsed = true;
    	  }

    	  function fileReaderReady(reader) {
    	    return new Promise(function(resolve, reject) {
    	      reader.onload = function() {
    	        resolve(reader.result);
    	      };
    	      reader.onerror = function() {
    	        reject(reader.error);
    	      };
    	    })
    	  }

    	  function readBlobAsArrayBuffer(blob) {
    	    var reader = new FileReader();
    	    var promise = fileReaderReady(reader);
    	    reader.readAsArrayBuffer(blob);
    	    return promise
    	  }

    	  function readBlobAsText(blob) {
    	    var reader = new FileReader();
    	    var promise = fileReaderReady(reader);
    	    reader.readAsText(blob);
    	    return promise
    	  }

    	  function readArrayBufferAsText(buf) {
    	    var view = new Uint8Array(buf);
    	    var chars = new Array(view.length);

    	    for (var i = 0; i < view.length; i++) {
    	      chars[i] = String.fromCharCode(view[i]);
    	    }
    	    return chars.join('')
    	  }

    	  function bufferClone(buf) {
    	    if (buf.slice) {
    	      return buf.slice(0)
    	    } else {
    	      var view = new Uint8Array(buf.byteLength);
    	      view.set(new Uint8Array(buf));
    	      return view.buffer
    	    }
    	  }

    	  function Body() {
    	    this.bodyUsed = false;

    	    this._initBody = function(body) {
    	      this._bodyInit = body;
    	      if (!body) {
    	        this._bodyText = '';
    	      } else if (typeof body === 'string') {
    	        this._bodyText = body;
    	      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
    	        this._bodyBlob = body;
    	      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
    	        this._bodyFormData = body;
    	      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
    	        this._bodyText = body.toString();
    	      } else if (support.arrayBuffer && support.blob && isDataView(body)) {
    	        this._bodyArrayBuffer = bufferClone(body.buffer);
    	        // IE 10-11 can't handle a DataView body.
    	        this._bodyInit = new Blob([this._bodyArrayBuffer]);
    	      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
    	        this._bodyArrayBuffer = bufferClone(body);
    	      } else {
    	        this._bodyText = body = Object.prototype.toString.call(body);
    	      }

    	      if (!this.headers.get('content-type')) {
    	        if (typeof body === 'string') {
    	          this.headers.set('content-type', 'text/plain;charset=UTF-8');
    	        } else if (this._bodyBlob && this._bodyBlob.type) {
    	          this.headers.set('content-type', this._bodyBlob.type);
    	        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
    	          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
    	        }
    	      }
    	    };

    	    if (support.blob) {
    	      this.blob = function() {
    	        var rejected = consumed(this);
    	        if (rejected) {
    	          return rejected
    	        }

    	        if (this._bodyBlob) {
    	          return Promise.resolve(this._bodyBlob)
    	        } else if (this._bodyArrayBuffer) {
    	          return Promise.resolve(new Blob([this._bodyArrayBuffer]))
    	        } else if (this._bodyFormData) {
    	          throw new Error('could not read FormData body as blob')
    	        } else {
    	          return Promise.resolve(new Blob([this._bodyText]))
    	        }
    	      };

    	      this.arrayBuffer = function() {
    	        if (this._bodyArrayBuffer) {
    	          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)
    	        } else {
    	          return this.blob().then(readBlobAsArrayBuffer)
    	        }
    	      };
    	    }

    	    this.text = function() {
    	      var rejected = consumed(this);
    	      if (rejected) {
    	        return rejected
    	      }

    	      if (this._bodyBlob) {
    	        return readBlobAsText(this._bodyBlob)
    	      } else if (this._bodyArrayBuffer) {
    	        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
    	      } else if (this._bodyFormData) {
    	        throw new Error('could not read FormData body as text')
    	      } else {
    	        return Promise.resolve(this._bodyText)
    	      }
    	    };

    	    if (support.formData) {
    	      this.formData = function() {
    	        return this.text().then(decode)
    	      };
    	    }

    	    this.json = function() {
    	      return this.text().then(JSON.parse)
    	    };

    	    return this
    	  }

    	  // HTTP methods whose capitalization should be normalized
    	  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];

    	  function normalizeMethod(method) {
    	    var upcased = method.toUpperCase();
    	    return methods.indexOf(upcased) > -1 ? upcased : method
    	  }

    	  function Request(input, options) {
    	    options = options || {};
    	    var body = options.body;

    	    if (input instanceof Request) {
    	      if (input.bodyUsed) {
    	        throw new TypeError('Already read')
    	      }
    	      this.url = input.url;
    	      this.credentials = input.credentials;
    	      if (!options.headers) {
    	        this.headers = new Headers(input.headers);
    	      }
    	      this.method = input.method;
    	      this.mode = input.mode;
    	      this.signal = input.signal;
    	      if (!body && input._bodyInit != null) {
    	        body = input._bodyInit;
    	        input.bodyUsed = true;
    	      }
    	    } else {
    	      this.url = String(input);
    	    }

    	    this.credentials = options.credentials || this.credentials || 'same-origin';
    	    if (options.headers || !this.headers) {
    	      this.headers = new Headers(options.headers);
    	    }
    	    this.method = normalizeMethod(options.method || this.method || 'GET');
    	    this.mode = options.mode || this.mode || null;
    	    this.signal = options.signal || this.signal;
    	    this.referrer = null;

    	    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
    	      throw new TypeError('Body not allowed for GET or HEAD requests')
    	    }
    	    this._initBody(body);
    	  }

    	  Request.prototype.clone = function() {
    	    return new Request(this, {body: this._bodyInit})
    	  };

    	  function decode(body) {
    	    var form = new FormData();
    	    body
    	      .trim()
    	      .split('&')
    	      .forEach(function(bytes) {
    	        if (bytes) {
    	          var split = bytes.split('=');
    	          var name = split.shift().replace(/\+/g, ' ');
    	          var value = split.join('=').replace(/\+/g, ' ');
    	          form.append(decodeURIComponent(name), decodeURIComponent(value));
    	        }
    	      });
    	    return form
    	  }

    	  function parseHeaders(rawHeaders) {
    	    var headers = new Headers();
    	    // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
    	    // https://tools.ietf.org/html/rfc7230#section-3.2
    	    var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ');
    	    preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
    	      var parts = line.split(':');
    	      var key = parts.shift().trim();
    	      if (key) {
    	        var value = parts.join(':').trim();
    	        headers.append(key, value);
    	      }
    	    });
    	    return headers
    	  }

    	  Body.call(Request.prototype);

    	  function Response(bodyInit, options) {
    	    if (!options) {
    	      options = {};
    	    }

    	    this.type = 'default';
    	    this.status = options.status === undefined ? 200 : options.status;
    	    this.ok = this.status >= 200 && this.status < 300;
    	    this.statusText = 'statusText' in options ? options.statusText : 'OK';
    	    this.headers = new Headers(options.headers);
    	    this.url = options.url || '';
    	    this._initBody(bodyInit);
    	  }

    	  Body.call(Response.prototype);

    	  Response.prototype.clone = function() {
    	    return new Response(this._bodyInit, {
    	      status: this.status,
    	      statusText: this.statusText,
    	      headers: new Headers(this.headers),
    	      url: this.url
    	    })
    	  };

    	  Response.error = function() {
    	    var response = new Response(null, {status: 0, statusText: ''});
    	    response.type = 'error';
    	    return response
    	  };

    	  var redirectStatuses = [301, 302, 303, 307, 308];

    	  Response.redirect = function(url, status) {
    	    if (redirectStatuses.indexOf(status) === -1) {
    	      throw new RangeError('Invalid status code')
    	    }

    	    return new Response(null, {status: status, headers: {location: url}})
    	  };

    	  exports.DOMException = self.DOMException;
    	  try {
    	    new exports.DOMException();
    	  } catch (err) {
    	    exports.DOMException = function(message, name) {
    	      this.message = message;
    	      this.name = name;
    	      var error = Error(message);
    	      this.stack = error.stack;
    	    };
    	    exports.DOMException.prototype = Object.create(Error.prototype);
    	    exports.DOMException.prototype.constructor = exports.DOMException;
    	  }

    	  function fetch(input, init) {
    	    return new Promise(function(resolve, reject) {
    	      var request = new Request(input, init);

    	      if (request.signal && request.signal.aborted) {
    	        return reject(new exports.DOMException('Aborted', 'AbortError'))
    	      }

    	      var xhr = new XMLHttpRequest();

    	      function abortXhr() {
    	        xhr.abort();
    	      }

    	      xhr.onload = function() {
    	        var options = {
    	          status: xhr.status,
    	          statusText: xhr.statusText,
    	          headers: parseHeaders(xhr.getAllResponseHeaders() || '')
    	        };
    	        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
    	        var body = 'response' in xhr ? xhr.response : xhr.responseText;
    	        resolve(new Response(body, options));
    	      };

    	      xhr.onerror = function() {
    	        reject(new TypeError('Network request failed'));
    	      };

    	      xhr.ontimeout = function() {
    	        reject(new TypeError('Network request failed'));
    	      };

    	      xhr.onabort = function() {
    	        reject(new exports.DOMException('Aborted', 'AbortError'));
    	      };

    	      xhr.open(request.method, request.url, true);

    	      if (request.credentials === 'include') {
    	        xhr.withCredentials = true;
    	      } else if (request.credentials === 'omit') {
    	        xhr.withCredentials = false;
    	      }

    	      if ('responseType' in xhr && support.blob) {
    	        xhr.responseType = 'blob';
    	      }

    	      request.headers.forEach(function(value, name) {
    	        xhr.setRequestHeader(name, value);
    	      });

    	      if (request.signal) {
    	        request.signal.addEventListener('abort', abortXhr);

    	        xhr.onreadystatechange = function() {
    	          // DONE (success or failure)
    	          if (xhr.readyState === 4) {
    	            request.signal.removeEventListener('abort', abortXhr);
    	          }
    	        };
    	      }

    	      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
    	    })
    	  }

    	  fetch.polyfill = true;

    	  if (!self.fetch) {
    	    self.fetch = fetch;
    	    self.Headers = Headers;
    	    self.Request = Request;
    	    self.Response = Response;
    	  }

    	  exports.Headers = Headers;
    	  exports.Request = Request;
    	  exports.Response = Response;
    	  exports.fetch = fetch;

    	  Object.defineProperty(exports, '__esModule', { value: true });

    	  return exports;

    	}))({});
    	})(__self__);
    	__self__.fetch.ponyfill = true;
    	// Remove "polyfill" property added by whatwg-fetch
    	delete __self__.fetch.polyfill;
    	// Choose between native implementation (global) or custom implementation (__self__)
    	// var ctx = global.fetch ? global : __self__;
    	var ctx = __self__; // this line disable service worker support temporarily
    	exports = ctx.fetch; // To enable: import fetch from 'cross-fetch'
    	exports.default = ctx.fetch; // For TypeScript consumers without esModuleInterop.
    	exports.fetch = ctx.fetch; // To enable: import {fetch} from 'cross-fetch'
    	exports.Headers = ctx.Headers;
    	exports.Request = ctx.Request;
    	exports.Response = ctx.Response;
    	module.exports = exports; 
    } (browserPonyfill, browserPonyfill.exports));

    var browserPonyfillExports = browserPonyfill.exports;
    var fetch$1 = /*@__PURE__*/getDefaultExportFromCjs(browserPonyfillExports);

    const DEFAULT_HTTP_HEADERS = {
        Accept: "application/json",
        "Content-Type": "application/json",
    };
    const DEFAULT_HTTP_METHOD = "POST";
    const DEFAULT_FETCH_OPTS = {
        headers: DEFAULT_HTTP_HEADERS,
        method: DEFAULT_HTTP_METHOD,
    };
    const EVENT_EMITTER_MAX_LISTENERS_DEFAULT = 10;
    class HttpConnection {
        constructor(url, disableProviderPing = false) {
            this.url = url;
            this.disableProviderPing = disableProviderPing;
            this.events = new EventEmitter$1();
            this.isAvailable = false;
            this.registering = false;
            if (!isHttpUrl(url)) {
                throw new Error(`Provided URL is not compatible with HTTP connection: ${url}`);
            }
            this.url = url;
            this.disableProviderPing = disableProviderPing;
        }
        get connected() {
            return this.isAvailable;
        }
        get connecting() {
            return this.registering;
        }
        on(event, listener) {
            this.events.on(event, listener);
        }
        once(event, listener) {
            this.events.once(event, listener);
        }
        off(event, listener) {
            this.events.off(event, listener);
        }
        removeListener(event, listener) {
            this.events.removeListener(event, listener);
        }
        async open(url = this.url) {
            await this.register(url);
        }
        async close() {
            if (!this.isAvailable) {
                throw new Error("Connection already closed");
            }
            this.onClose();
        }
        async send(payload, context) {
            if (!this.isAvailable) {
                await this.register();
            }
            try {
                const body = safeJsonStringify(payload);
                const res = await fetch$1(this.url, Object.assign(Object.assign({}, DEFAULT_FETCH_OPTS), { body }));
                const data = await res.json();
                this.onPayload({ data });
            }
            catch (e) {
                this.onError(payload.id, e);
            }
        }
        async register(url = this.url) {
            if (!isHttpUrl(url)) {
                throw new Error(`Provided URL is not compatible with HTTP connection: ${url}`);
            }
            if (this.registering) {
                const currentMaxListeners = this.events.getMaxListeners();
                if (this.events.listenerCount("register_error") >= currentMaxListeners ||
                    this.events.listenerCount("open") >= currentMaxListeners) {
                    this.events.setMaxListeners(currentMaxListeners + 1);
                }
                return new Promise((resolve, reject) => {
                    this.events.once("register_error", error => {
                        this.resetMaxListeners();
                        reject(error);
                    });
                    this.events.once("open", () => {
                        this.resetMaxListeners();
                        if (typeof this.isAvailable === "undefined") {
                            return reject(new Error("HTTP connection is missing or invalid"));
                        }
                        resolve();
                    });
                });
            }
            this.url = url;
            this.registering = true;
            try {
                if (!this.disableProviderPing) {
                    const body = safeJsonStringify({ id: 1, jsonrpc: "2.0", method: "test", params: [] });
                    await fetch$1(url, Object.assign(Object.assign({}, DEFAULT_FETCH_OPTS), { body }));
                }
                this.onOpen();
            }
            catch (e) {
                const error = this.parseError(e);
                this.events.emit("register_error", error);
                this.onClose();
                throw error;
            }
        }
        onOpen() {
            this.isAvailable = true;
            this.registering = false;
            this.events.emit("open");
        }
        onClose() {
            this.isAvailable = false;
            this.registering = false;
            this.events.emit("close");
        }
        onPayload(e) {
            if (typeof e.data === "undefined")
                return;
            const payload = typeof e.data === "string" ? safeJsonParse(e.data) : e.data;
            this.events.emit("payload", payload);
        }
        onError(id, e) {
            const error = this.parseError(e);
            const message = error.message || error.toString();
            const payload = formatJsonRpcError(id, message);
            this.events.emit("payload", payload);
        }
        parseError(e, url = this.url) {
            return parseConnectionError(e, url, "HTTP");
        }
        resetMaxListeners() {
            if (this.events.getMaxListeners() > EVENT_EMITTER_MAX_LISTENERS_DEFAULT) {
                this.events.setMaxListeners(EVENT_EMITTER_MAX_LISTENERS_DEFAULT);
            }
        }
    }

    const Ia="error",Fg="wss://relay.walletconnect.com",Mg="wc",qg="universal_provider",xa=`${Mg}@2:${qg}:`,Bg="https://rpc.walletconnect.com/v1/",Vn={DEFAULT_CHAIN_CHANGED:"default_chain_changed"};var ge=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global$1<"u"?global$1:typeof self<"u"?self:{},Ui={exports:{}};/**
     * @license
     * Lodash <https://lodash.com/>
     * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
     * Released under MIT license <https://lodash.com/license>
     * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
     * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     */(function(A,u){(function(){var i,d="4.17.21",w=200,L="Unsupported core-js use. Try https://npms.io/search?q=ponyfill.",D="Expected a function",En="Invalid `variable` option passed into `_.template`",zt="__lodash_hash_undefined__",pr=500,It="__lodash_placeholder__",Ln=1,Fn=2,xt=4,Et=1,ve=2,vn=1,ct=2,qi=4,Dn=8,yt=16,Hn=32,St=64,Mn=128,Kt=256,dr=512,Da=30,Ha="...",Na=800,$a=16,Bi=1,Ua=2,Wa=3,ht=1/0,kn=9007199254740991,Fa=17976931348623157e292,_e=0/0,Nn=4294967295,Ma=Nn-1,qa=Nn>>>1,Ba=[["ary",Mn],["bind",vn],["bindKey",ct],["curry",Dn],["curryRight",yt],["flip",dr],["partial",Hn],["partialRight",St],["rearg",Kt]],Ot="[object Arguments]",me="[object Array]",Ga="[object AsyncFunction]",Yt="[object Boolean]",Zt="[object Date]",za="[object DOMException]",we="[object Error]",Pe="[object Function]",Gi="[object GeneratorFunction]",yn="[object Map]",Jt="[object Number]",Ka="[object Null]",qn="[object Object]",zi="[object Promise]",Ya="[object Proxy]",Xt="[object RegExp]",Sn="[object Set]",Qt="[object String]",Ae="[object Symbol]",Za="[object Undefined]",Vt="[object WeakMap]",Ja="[object WeakSet]",kt="[object ArrayBuffer]",Rt="[object DataView]",gr="[object Float32Array]",vr="[object Float64Array]",_r="[object Int8Array]",mr="[object Int16Array]",wr="[object Int32Array]",Pr="[object Uint8Array]",Ar="[object Uint8ClampedArray]",Cr="[object Uint16Array]",Ir="[object Uint32Array]",Xa=/\b__p \+= '';/g,Qa=/\b(__p \+=) '' \+/g,Va=/(__e\(.*?\)|\b__t\)) \+\n'';/g,Ki=/&(?:amp|lt|gt|quot|#39);/g,Yi=/[&<>"']/g,ka=RegExp(Ki.source),ja=RegExp(Yi.source),no=/<%-([\s\S]+?)%>/g,to=/<%([\s\S]+?)%>/g,Zi=/<%=([\s\S]+?)%>/g,eo=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,ro=/^\w*$/,io=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,xr=/[\\^$.*+?()[\]{}|]/g,so=RegExp(xr.source),Er=/^\s+/,uo=/\s/,ao=/\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,oo=/\{\n\/\* \[wrapped with (.+)\] \*/,fo=/,? & /,co=/[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g,ho=/[()=,{}\[\]\/\s]/,lo=/\\(\\)?/g,po=/\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g,Ji=/\w*$/,go=/^[-+]0x[0-9a-f]+$/i,vo=/^0b[01]+$/i,_o=/^\[object .+?Constructor\]$/,mo=/^0o[0-7]+$/i,wo=/^(?:0|[1-9]\d*)$/,Po=/[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g,Ce=/($^)/,Ao=/['\n\r\u2028\u2029\\]/g,Ie="\\ud800-\\udfff",Co="\\u0300-\\u036f",Io="\\ufe20-\\ufe2f",xo="\\u20d0-\\u20ff",Xi=Co+Io+xo,Qi="\\u2700-\\u27bf",Vi="a-z\\xdf-\\xf6\\xf8-\\xff",Eo="\\xac\\xb1\\xd7\\xf7",yo="\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf",So="\\u2000-\\u206f",Oo=" \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000",ki="A-Z\\xc0-\\xd6\\xd8-\\xde",ji="\\ufe0e\\ufe0f",ns=Eo+yo+So+Oo,yr="['\u2019]",Ro="["+Ie+"]",ts="["+ns+"]",xe="["+Xi+"]",es="\\d+",bo="["+Qi+"]",rs="["+Vi+"]",is="[^"+Ie+ns+es+Qi+Vi+ki+"]",Sr="\\ud83c[\\udffb-\\udfff]",To="(?:"+xe+"|"+Sr+")",ss="[^"+Ie+"]",Or="(?:\\ud83c[\\udde6-\\uddff]){2}",Rr="[\\ud800-\\udbff][\\udc00-\\udfff]",bt="["+ki+"]",us="\\u200d",as="(?:"+rs+"|"+is+")",Lo="(?:"+bt+"|"+is+")",os="(?:"+yr+"(?:d|ll|m|re|s|t|ve))?",fs="(?:"+yr+"(?:D|LL|M|RE|S|T|VE))?",cs=To+"?",hs="["+ji+"]?",Do="(?:"+us+"(?:"+[ss,Or,Rr].join("|")+")"+hs+cs+")*",Ho="\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])",No="\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])",ls=hs+cs+Do,$o="(?:"+[bo,Or,Rr].join("|")+")"+ls,Uo="(?:"+[ss+xe+"?",xe,Or,Rr,Ro].join("|")+")",Wo=RegExp(yr,"g"),Fo=RegExp(xe,"g"),br=RegExp(Sr+"(?="+Sr+")|"+Uo+ls,"g"),Mo=RegExp([bt+"?"+rs+"+"+os+"(?="+[ts,bt,"$"].join("|")+")",Lo+"+"+fs+"(?="+[ts,bt+as,"$"].join("|")+")",bt+"?"+as+"+"+os,bt+"+"+fs,No,Ho,es,$o].join("|"),"g"),qo=RegExp("["+us+Ie+Xi+ji+"]"),Bo=/[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/,Go=["Array","Buffer","DataView","Date","Error","Float32Array","Float64Array","Function","Int8Array","Int16Array","Int32Array","Map","Math","Object","Promise","RegExp","Set","String","Symbol","TypeError","Uint8Array","Uint8ClampedArray","Uint16Array","Uint32Array","WeakMap","_","clearTimeout","isFinite","parseInt","setTimeout"],zo=-1,B={};B[gr]=B[vr]=B[_r]=B[mr]=B[wr]=B[Pr]=B[Ar]=B[Cr]=B[Ir]=!0,B[Ot]=B[me]=B[kt]=B[Yt]=B[Rt]=B[Zt]=B[we]=B[Pe]=B[yn]=B[Jt]=B[qn]=B[Xt]=B[Sn]=B[Qt]=B[Vt]=!1;var q={};q[Ot]=q[me]=q[kt]=q[Rt]=q[Yt]=q[Zt]=q[gr]=q[vr]=q[_r]=q[mr]=q[wr]=q[yn]=q[Jt]=q[qn]=q[Xt]=q[Sn]=q[Qt]=q[Ae]=q[Pr]=q[Ar]=q[Cr]=q[Ir]=!0,q[we]=q[Pe]=q[Vt]=!1;var Ko={\u00C0:"A",\u00C1:"A",\u00C2:"A",\u00C3:"A",\u00C4:"A",\u00C5:"A",\u00E0:"a",\u00E1:"a",\u00E2:"a",\u00E3:"a",\u00E4:"a",\u00E5:"a",\u00C7:"C",\u00E7:"c",\u00D0:"D",\u00F0:"d",\u00C8:"E",\u00C9:"E",\u00CA:"E",\u00CB:"E",\u00E8:"e",\u00E9:"e",\u00EA:"e",\u00EB:"e",\u00CC:"I",\u00CD:"I",\u00CE:"I",\u00CF:"I",\u00EC:"i",\u00ED:"i",\u00EE:"i",\u00EF:"i",\u00D1:"N",\u00F1:"n",\u00D2:"O",\u00D3:"O",\u00D4:"O",\u00D5:"O",\u00D6:"O",\u00D8:"O",\u00F2:"o",\u00F3:"o",\u00F4:"o",\u00F5:"o",\u00F6:"o",\u00F8:"o",\u00D9:"U",\u00DA:"U",\u00DB:"U",\u00DC:"U",\u00F9:"u",\u00FA:"u",\u00FB:"u",\u00FC:"u",\u00DD:"Y",\u00FD:"y",\u00FF:"y",\u00C6:"Ae",\u00E6:"ae",\u00DE:"Th",\u00FE:"th",\u00DF:"ss",\u0100:"A",\u0102:"A",\u0104:"A",\u0101:"a",\u0103:"a",\u0105:"a",\u0106:"C",\u0108:"C",\u010A:"C",\u010C:"C",\u0107:"c",\u0109:"c",\u010B:"c",\u010D:"c",\u010E:"D",\u0110:"D",\u010F:"d",\u0111:"d",\u0112:"E",\u0114:"E",\u0116:"E",\u0118:"E",\u011A:"E",\u0113:"e",\u0115:"e",\u0117:"e",\u0119:"e",\u011B:"e",\u011C:"G",\u011E:"G",\u0120:"G",\u0122:"G",\u011D:"g",\u011F:"g",\u0121:"g",\u0123:"g",\u0124:"H",\u0126:"H",\u0125:"h",\u0127:"h",\u0128:"I",\u012A:"I",\u012C:"I",\u012E:"I",\u0130:"I",\u0129:"i",\u012B:"i",\u012D:"i",\u012F:"i",\u0131:"i",\u0134:"J",\u0135:"j",\u0136:"K",\u0137:"k",\u0138:"k",\u0139:"L",\u013B:"L",\u013D:"L",\u013F:"L",\u0141:"L",\u013A:"l",\u013C:"l",\u013E:"l",\u0140:"l",\u0142:"l",\u0143:"N",\u0145:"N",\u0147:"N",\u014A:"N",\u0144:"n",\u0146:"n",\u0148:"n",\u014B:"n",\u014C:"O",\u014E:"O",\u0150:"O",\u014D:"o",\u014F:"o",\u0151:"o",\u0154:"R",\u0156:"R",\u0158:"R",\u0155:"r",\u0157:"r",\u0159:"r",\u015A:"S",\u015C:"S",\u015E:"S",\u0160:"S",\u015B:"s",\u015D:"s",\u015F:"s",\u0161:"s",\u0162:"T",\u0164:"T",\u0166:"T",\u0163:"t",\u0165:"t",\u0167:"t",\u0168:"U",\u016A:"U",\u016C:"U",\u016E:"U",\u0170:"U",\u0172:"U",\u0169:"u",\u016B:"u",\u016D:"u",\u016F:"u",\u0171:"u",\u0173:"u",\u0174:"W",\u0175:"w",\u0176:"Y",\u0177:"y",\u0178:"Y",\u0179:"Z",\u017B:"Z",\u017D:"Z",\u017A:"z",\u017C:"z",\u017E:"z",\u0132:"IJ",\u0133:"ij",\u0152:"Oe",\u0153:"oe",\u0149:"'n",\u017F:"s"},Yo={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"},Zo={"&amp;":"&","&lt;":"<","&gt;":">","&quot;":'"',"&#39;":"'"},Jo={"\\":"\\","'":"'","\n":"n","\r":"r","\u2028":"u2028","\u2029":"u2029"},Xo=parseFloat,Qo=parseInt,ps=typeof ge=="object"&&ge&&ge.Object===Object&&ge,Vo=typeof self=="object"&&self&&self.Object===Object&&self,k=ps||Vo||Function("return this")(),Tr=u&&!u.nodeType&&u,lt=Tr&&!0&&A&&!A.nodeType&&A,ds=lt&&lt.exports===Tr,Lr=ds&&ps.process,_n=function(){try{var h=lt&&lt.require&&lt.require("util").types;return h||Lr&&Lr.binding&&Lr.binding("util")}catch{}}(),gs=_n&&_n.isArrayBuffer,vs=_n&&_n.isDate,_s=_n&&_n.isMap,ms=_n&&_n.isRegExp,ws=_n&&_n.isSet,Ps=_n&&_n.isTypedArray;function cn(h,g,p){switch(p.length){case 0:return h.call(g);case 1:return h.call(g,p[0]);case 2:return h.call(g,p[0],p[1]);case 3:return h.call(g,p[0],p[1],p[2])}return h.apply(g,p)}function ko(h,g,p,C){for(var S=-1,U=h==null?0:h.length;++S<U;){var X=h[S];g(C,X,p(X),h);}return C}function mn(h,g){for(var p=-1,C=h==null?0:h.length;++p<C&&g(h[p],p,h)!==!1;);return h}function jo(h,g){for(var p=h==null?0:h.length;p--&&g(h[p],p,h)!==!1;);return h}function As(h,g){for(var p=-1,C=h==null?0:h.length;++p<C;)if(!g(h[p],p,h))return !1;return !0}function jn(h,g){for(var p=-1,C=h==null?0:h.length,S=0,U=[];++p<C;){var X=h[p];g(X,p,h)&&(U[S++]=X);}return U}function Ee(h,g){var p=h==null?0:h.length;return !!p&&Tt(h,g,0)>-1}function Dr(h,g,p){for(var C=-1,S=h==null?0:h.length;++C<S;)if(p(g,h[C]))return !0;return !1}function G(h,g){for(var p=-1,C=h==null?0:h.length,S=Array(C);++p<C;)S[p]=g(h[p],p,h);return S}function nt(h,g){for(var p=-1,C=g.length,S=h.length;++p<C;)h[S+p]=g[p];return h}function Hr(h,g,p,C){var S=-1,U=h==null?0:h.length;for(C&&U&&(p=h[++S]);++S<U;)p=g(p,h[S],S,h);return p}function nf(h,g,p,C){var S=h==null?0:h.length;for(C&&S&&(p=h[--S]);S--;)p=g(p,h[S],S,h);return p}function Nr(h,g){for(var p=-1,C=h==null?0:h.length;++p<C;)if(g(h[p],p,h))return !0;return !1}var tf=$r("length");function ef(h){return h.split("")}function rf(h){return h.match(co)||[]}function Cs(h,g,p){var C;return p(h,function(S,U,X){if(g(S,U,X))return C=U,!1}),C}function ye(h,g,p,C){for(var S=h.length,U=p+(C?1:-1);C?U--:++U<S;)if(g(h[U],U,h))return U;return -1}function Tt(h,g,p){return g===g?vf(h,g,p):ye(h,Is,p)}function sf(h,g,p,C){for(var S=p-1,U=h.length;++S<U;)if(C(h[S],g))return S;return -1}function Is(h){return h!==h}function xs(h,g){var p=h==null?0:h.length;return p?Wr(h,g)/p:_e}function $r(h){return function(g){return g==null?i:g[h]}}function Ur(h){return function(g){return h==null?i:h[g]}}function Es(h,g,p,C,S){return S(h,function(U,X,M){p=C?(C=!1,U):g(p,U,X,M);}),p}function uf(h,g){var p=h.length;for(h.sort(g);p--;)h[p]=h[p].value;return h}function Wr(h,g){for(var p,C=-1,S=h.length;++C<S;){var U=g(h[C]);U!==i&&(p=p===i?U:p+U);}return p}function Fr(h,g){for(var p=-1,C=Array(h);++p<h;)C[p]=g(p);return C}function af(h,g){return G(g,function(p){return [p,h[p]]})}function ys(h){return h&&h.slice(0,bs(h)+1).replace(Er,"")}function hn(h){return function(g){return h(g)}}function Mr(h,g){return G(g,function(p){return h[p]})}function jt(h,g){return h.has(g)}function Ss(h,g){for(var p=-1,C=h.length;++p<C&&Tt(g,h[p],0)>-1;);return p}function Os(h,g){for(var p=h.length;p--&&Tt(g,h[p],0)>-1;);return p}function of(h,g){for(var p=h.length,C=0;p--;)h[p]===g&&++C;return C}var ff=Ur(Ko),cf=Ur(Yo);function hf(h){return "\\"+Jo[h]}function lf(h,g){return h==null?i:h[g]}function Lt(h){return qo.test(h)}function pf(h){return Bo.test(h)}function df(h){for(var g,p=[];!(g=h.next()).done;)p.push(g.value);return p}function qr(h){var g=-1,p=Array(h.size);return h.forEach(function(C,S){p[++g]=[S,C];}),p}function Rs(h,g){return function(p){return h(g(p))}}function tt(h,g){for(var p=-1,C=h.length,S=0,U=[];++p<C;){var X=h[p];(X===g||X===It)&&(h[p]=It,U[S++]=p);}return U}function Se(h){var g=-1,p=Array(h.size);return h.forEach(function(C){p[++g]=C;}),p}function gf(h){var g=-1,p=Array(h.size);return h.forEach(function(C){p[++g]=[C,C];}),p}function vf(h,g,p){for(var C=p-1,S=h.length;++C<S;)if(h[C]===g)return C;return -1}function _f(h,g,p){for(var C=p+1;C--;)if(h[C]===g)return C;return C}function Dt(h){return Lt(h)?wf(h):tf(h)}function On(h){return Lt(h)?Pf(h):ef(h)}function bs(h){for(var g=h.length;g--&&uo.test(h.charAt(g)););return g}var mf=Ur(Zo);function wf(h){for(var g=br.lastIndex=0;br.test(h);)++g;return g}function Pf(h){return h.match(br)||[]}function Af(h){return h.match(Mo)||[]}var Cf=function h(g){g=g==null?k:Ht.defaults(k.Object(),g,Ht.pick(k,Go));var p=g.Array,C=g.Date,S=g.Error,U=g.Function,X=g.Math,M=g.Object,Br=g.RegExp,If=g.String,wn=g.TypeError,Oe=p.prototype,xf=U.prototype,Nt=M.prototype,Re=g["__core-js_shared__"],be=xf.toString,F=Nt.hasOwnProperty,Ef=0,Ts=function(){var n=/[^.]+$/.exec(Re&&Re.keys&&Re.keys.IE_PROTO||"");return n?"Symbol(src)_1."+n:""}(),Te=Nt.toString,yf=be.call(M),Sf=k._,Of=Br("^"+be.call(F).replace(xr,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$"),Le=ds?g.Buffer:i,et=g.Symbol,De=g.Uint8Array,Ls=Le?Le.allocUnsafe:i,He=Rs(M.getPrototypeOf,M),Ds=M.create,Hs=Nt.propertyIsEnumerable,Ne=Oe.splice,Ns=et?et.isConcatSpreadable:i,ne=et?et.iterator:i,pt=et?et.toStringTag:i,$e=function(){try{var n=mt(M,"defineProperty");return n({},"",{}),n}catch{}}(),Rf=g.clearTimeout!==k.clearTimeout&&g.clearTimeout,bf=C&&C.now!==k.Date.now&&C.now,Tf=g.setTimeout!==k.setTimeout&&g.setTimeout,Ue=X.ceil,We=X.floor,Gr=M.getOwnPropertySymbols,Lf=Le?Le.isBuffer:i,$s=g.isFinite,Df=Oe.join,Hf=Rs(M.keys,M),Q=X.max,nn=X.min,Nf=C.now,$f=g.parseInt,Us=X.random,Uf=Oe.reverse,zr=mt(g,"DataView"),te=mt(g,"Map"),Kr=mt(g,"Promise"),$t=mt(g,"Set"),ee=mt(g,"WeakMap"),re=mt(M,"create"),Fe=ee&&new ee,Ut={},Wf=wt(zr),Ff=wt(te),Mf=wt(Kr),qf=wt($t),Bf=wt(ee),Me=et?et.prototype:i,ie=Me?Me.valueOf:i,Ws=Me?Me.toString:i;function a(n){if(Y(n)&&!O(n)&&!(n instanceof N)){if(n instanceof Pn)return n;if(F.call(n,"__wrapped__"))return Fu(n)}return new Pn(n)}var Wt=function(){function n(){}return function(t){if(!K(t))return {};if(Ds)return Ds(t);n.prototype=t;var e=new n;return n.prototype=i,e}}();function qe(){}function Pn(n,t){this.__wrapped__=n,this.__actions__=[],this.__chain__=!!t,this.__index__=0,this.__values__=i;}a.templateSettings={escape:no,evaluate:to,interpolate:Zi,variable:"",imports:{_:a}},a.prototype=qe.prototype,a.prototype.constructor=a,Pn.prototype=Wt(qe.prototype),Pn.prototype.constructor=Pn;function N(n){this.__wrapped__=n,this.__actions__=[],this.__dir__=1,this.__filtered__=!1,this.__iteratees__=[],this.__takeCount__=Nn,this.__views__=[];}function Gf(){var n=new N(this.__wrapped__);return n.__actions__=un(this.__actions__),n.__dir__=this.__dir__,n.__filtered__=this.__filtered__,n.__iteratees__=un(this.__iteratees__),n.__takeCount__=this.__takeCount__,n.__views__=un(this.__views__),n}function zf(){if(this.__filtered__){var n=new N(this);n.__dir__=-1,n.__filtered__=!0;}else n=this.clone(),n.__dir__*=-1;return n}function Kf(){var n=this.__wrapped__.value(),t=this.__dir__,e=O(n),r=t<0,s=e?n.length:0,o=rh(0,s,this.__views__),f=o.start,c=o.end,l=c-f,v=r?c:f-1,_=this.__iteratees__,m=_.length,P=0,I=nn(l,this.__takeCount__);if(!e||!r&&s==l&&I==l)return ou(n,this.__actions__);var E=[];n:for(;l--&&P<I;){v+=t;for(var b=-1,y=n[v];++b<m;){var H=_[b],$=H.iteratee,dn=H.type,sn=$(y);if(dn==Ua)y=sn;else if(!sn){if(dn==Bi)continue n;break n}}E[P++]=y;}return E}N.prototype=Wt(qe.prototype),N.prototype.constructor=N;function dt(n){var t=-1,e=n==null?0:n.length;for(this.clear();++t<e;){var r=n[t];this.set(r[0],r[1]);}}function Yf(){this.__data__=re?re(null):{},this.size=0;}function Zf(n){var t=this.has(n)&&delete this.__data__[n];return this.size-=t?1:0,t}function Jf(n){var t=this.__data__;if(re){var e=t[n];return e===zt?i:e}return F.call(t,n)?t[n]:i}function Xf(n){var t=this.__data__;return re?t[n]!==i:F.call(t,n)}function Qf(n,t){var e=this.__data__;return this.size+=this.has(n)?0:1,e[n]=re&&t===i?zt:t,this}dt.prototype.clear=Yf,dt.prototype.delete=Zf,dt.prototype.get=Jf,dt.prototype.has=Xf,dt.prototype.set=Qf;function Bn(n){var t=-1,e=n==null?0:n.length;for(this.clear();++t<e;){var r=n[t];this.set(r[0],r[1]);}}function Vf(){this.__data__=[],this.size=0;}function kf(n){var t=this.__data__,e=Be(t,n);if(e<0)return !1;var r=t.length-1;return e==r?t.pop():Ne.call(t,e,1),--this.size,!0}function jf(n){var t=this.__data__,e=Be(t,n);return e<0?i:t[e][1]}function nc(n){return Be(this.__data__,n)>-1}function tc(n,t){var e=this.__data__,r=Be(e,n);return r<0?(++this.size,e.push([n,t])):e[r][1]=t,this}Bn.prototype.clear=Vf,Bn.prototype.delete=kf,Bn.prototype.get=jf,Bn.prototype.has=nc,Bn.prototype.set=tc;function Gn(n){var t=-1,e=n==null?0:n.length;for(this.clear();++t<e;){var r=n[t];this.set(r[0],r[1]);}}function ec(){this.size=0,this.__data__={hash:new dt,map:new(te||Bn),string:new dt};}function rc(n){var t=nr(this,n).delete(n);return this.size-=t?1:0,t}function ic(n){return nr(this,n).get(n)}function sc(n){return nr(this,n).has(n)}function uc(n,t){var e=nr(this,n),r=e.size;return e.set(n,t),this.size+=e.size==r?0:1,this}Gn.prototype.clear=ec,Gn.prototype.delete=rc,Gn.prototype.get=ic,Gn.prototype.has=sc,Gn.prototype.set=uc;function gt(n){var t=-1,e=n==null?0:n.length;for(this.__data__=new Gn;++t<e;)this.add(n[t]);}function ac(n){return this.__data__.set(n,zt),this}function oc(n){return this.__data__.has(n)}gt.prototype.add=gt.prototype.push=ac,gt.prototype.has=oc;function Rn(n){var t=this.__data__=new Bn(n);this.size=t.size;}function fc(){this.__data__=new Bn,this.size=0;}function cc(n){var t=this.__data__,e=t.delete(n);return this.size=t.size,e}function hc(n){return this.__data__.get(n)}function lc(n){return this.__data__.has(n)}function pc(n,t){var e=this.__data__;if(e instanceof Bn){var r=e.__data__;if(!te||r.length<w-1)return r.push([n,t]),this.size=++e.size,this;e=this.__data__=new Gn(r);}return e.set(n,t),this.size=e.size,this}Rn.prototype.clear=fc,Rn.prototype.delete=cc,Rn.prototype.get=hc,Rn.prototype.has=lc,Rn.prototype.set=pc;function Fs(n,t){var e=O(n),r=!e&&Pt(n),s=!e&&!r&&at(n),o=!e&&!r&&!s&&Bt(n),f=e||r||s||o,c=f?Fr(n.length,If):[],l=c.length;for(var v in n)(t||F.call(n,v))&&!(f&&(v=="length"||s&&(v=="offset"||v=="parent")||o&&(v=="buffer"||v=="byteLength"||v=="byteOffset")||Zn(v,l)))&&c.push(v);return c}function Ms(n){var t=n.length;return t?n[ei(0,t-1)]:i}function dc(n,t){return tr(un(n),vt(t,0,n.length))}function gc(n){return tr(un(n))}function Yr(n,t,e){(e!==i&&!bn(n[t],e)||e===i&&!(t in n))&&zn(n,t,e);}function se(n,t,e){var r=n[t];(!(F.call(n,t)&&bn(r,e))||e===i&&!(t in n))&&zn(n,t,e);}function Be(n,t){for(var e=n.length;e--;)if(bn(n[e][0],t))return e;return -1}function vc(n,t,e,r){return rt(n,function(s,o,f){t(r,s,e(s),f);}),r}function qs(n,t){return n&&Un(t,V(t),n)}function _c(n,t){return n&&Un(t,on(t),n)}function zn(n,t,e){t=="__proto__"&&$e?$e(n,t,{configurable:!0,enumerable:!0,value:e,writable:!0}):n[t]=e;}function Zr(n,t){for(var e=-1,r=t.length,s=p(r),o=n==null;++e<r;)s[e]=o?i:Si(n,t[e]);return s}function vt(n,t,e){return n===n&&(e!==i&&(n=n<=e?n:e),t!==i&&(n=n>=t?n:t)),n}function An(n,t,e,r,s,o){var f,c=t&Ln,l=t&Fn,v=t&xt;if(e&&(f=s?e(n,r,s,o):e(n)),f!==i)return f;if(!K(n))return n;var _=O(n);if(_){if(f=sh(n),!c)return un(n,f)}else {var m=tn(n),P=m==Pe||m==Gi;if(at(n))return hu(n,c);if(m==qn||m==Ot||P&&!s){if(f=l||P?{}:bu(n),!c)return l?Jc(n,_c(f,n)):Zc(n,qs(f,n))}else {if(!q[m])return s?n:{};f=uh(n,m,c);}}o||(o=new Rn);var I=o.get(n);if(I)return I;o.set(n,f),sa(n)?n.forEach(function(y){f.add(An(y,t,e,y,n,o));}):ra(n)&&n.forEach(function(y,H){f.set(H,An(y,t,e,H,n,o));});var E=v?l?pi:li:l?on:V,b=_?i:E(n);return mn(b||n,function(y,H){b&&(H=y,y=n[H]),se(f,H,An(y,t,e,H,n,o));}),f}function mc(n){var t=V(n);return function(e){return Bs(e,n,t)}}function Bs(n,t,e){var r=e.length;if(n==null)return !r;for(n=M(n);r--;){var s=e[r],o=t[s],f=n[s];if(f===i&&!(s in n)||!o(f))return !1}return !0}function Gs(n,t,e){if(typeof n!="function")throw new wn(D);return le(function(){n.apply(i,e);},t)}function ue(n,t,e,r){var s=-1,o=Ee,f=!0,c=n.length,l=[],v=t.length;if(!c)return l;e&&(t=G(t,hn(e))),r?(o=Dr,f=!1):t.length>=w&&(o=jt,f=!1,t=new gt(t));n:for(;++s<c;){var _=n[s],m=e==null?_:e(_);if(_=r||_!==0?_:0,f&&m===m){for(var P=v;P--;)if(t[P]===m)continue n;l.push(_);}else o(t,m,r)||l.push(_);}return l}var rt=vu($n),zs=vu(Xr,!0);function wc(n,t){var e=!0;return rt(n,function(r,s,o){return e=!!t(r,s,o),e}),e}function Ge(n,t,e){for(var r=-1,s=n.length;++r<s;){var o=n[r],f=t(o);if(f!=null&&(c===i?f===f&&!pn(f):e(f,c)))var c=f,l=o;}return l}function Pc(n,t,e,r){var s=n.length;for(e=R(e),e<0&&(e=-e>s?0:s+e),r=r===i||r>s?s:R(r),r<0&&(r+=s),r=e>r?0:aa(r);e<r;)n[e++]=t;return n}function Ks(n,t){var e=[];return rt(n,function(r,s,o){t(r,s,o)&&e.push(r);}),e}function j(n,t,e,r,s){var o=-1,f=n.length;for(e||(e=oh),s||(s=[]);++o<f;){var c=n[o];t>0&&e(c)?t>1?j(c,t-1,e,r,s):nt(s,c):r||(s[s.length]=c);}return s}var Jr=_u(),Ys=_u(!0);function $n(n,t){return n&&Jr(n,t,V)}function Xr(n,t){return n&&Ys(n,t,V)}function ze(n,t){return jn(t,function(e){return Jn(n[e])})}function _t(n,t){t=st(t,n);for(var e=0,r=t.length;n!=null&&e<r;)n=n[Wn(t[e++])];return e&&e==r?n:i}function Zs(n,t,e){var r=t(n);return O(n)?r:nt(r,e(n))}function en(n){return n==null?n===i?Za:Ka:pt&&pt in M(n)?eh(n):gh(n)}function Qr(n,t){return n>t}function Ac(n,t){return n!=null&&F.call(n,t)}function Cc(n,t){return n!=null&&t in M(n)}function Ic(n,t,e){return n>=nn(t,e)&&n<Q(t,e)}function Vr(n,t,e){for(var r=e?Dr:Ee,s=n[0].length,o=n.length,f=o,c=p(o),l=1/0,v=[];f--;){var _=n[f];f&&t&&(_=G(_,hn(t))),l=nn(_.length,l),c[f]=!e&&(t||s>=120&&_.length>=120)?new gt(f&&_):i;}_=n[0];var m=-1,P=c[0];n:for(;++m<s&&v.length<l;){var I=_[m],E=t?t(I):I;if(I=e||I!==0?I:0,!(P?jt(P,E):r(v,E,e))){for(f=o;--f;){var b=c[f];if(!(b?jt(b,E):r(n[f],E,e)))continue n}P&&P.push(E),v.push(I);}}return v}function xc(n,t,e,r){return $n(n,function(s,o,f){t(r,e(s),o,f);}),r}function ae(n,t,e){t=st(t,n),n=Hu(n,t);var r=n==null?n:n[Wn(In(t))];return r==null?i:cn(r,n,e)}function Js(n){return Y(n)&&en(n)==Ot}function Ec(n){return Y(n)&&en(n)==kt}function yc(n){return Y(n)&&en(n)==Zt}function oe(n,t,e,r,s){return n===t?!0:n==null||t==null||!Y(n)&&!Y(t)?n!==n&&t!==t:Sc(n,t,e,r,oe,s)}function Sc(n,t,e,r,s,o){var f=O(n),c=O(t),l=f?me:tn(n),v=c?me:tn(t);l=l==Ot?qn:l,v=v==Ot?qn:v;var _=l==qn,m=v==qn,P=l==v;if(P&&at(n)){if(!at(t))return !1;f=!0,_=!1;}if(P&&!_)return o||(o=new Rn),f||Bt(n)?Su(n,t,e,r,s,o):nh(n,t,l,e,r,s,o);if(!(e&Et)){var I=_&&F.call(n,"__wrapped__"),E=m&&F.call(t,"__wrapped__");if(I||E){var b=I?n.value():n,y=E?t.value():t;return o||(o=new Rn),s(b,y,e,r,o)}}return P?(o||(o=new Rn),th(n,t,e,r,s,o)):!1}function Oc(n){return Y(n)&&tn(n)==yn}function kr(n,t,e,r){var s=e.length,o=s,f=!r;if(n==null)return !o;for(n=M(n);s--;){var c=e[s];if(f&&c[2]?c[1]!==n[c[0]]:!(c[0]in n))return !1}for(;++s<o;){c=e[s];var l=c[0],v=n[l],_=c[1];if(f&&c[2]){if(v===i&&!(l in n))return !1}else {var m=new Rn;if(r)var P=r(v,_,l,n,t,m);if(!(P===i?oe(_,v,Et|ve,r,m):P))return !1}}return !0}function Xs(n){if(!K(n)||ch(n))return !1;var t=Jn(n)?Of:_o;return t.test(wt(n))}function Rc(n){return Y(n)&&en(n)==Xt}function bc(n){return Y(n)&&tn(n)==Sn}function Tc(n){return Y(n)&&ar(n.length)&&!!B[en(n)]}function Qs(n){return typeof n=="function"?n:n==null?fn:typeof n=="object"?O(n)?js(n[0],n[1]):ks(n):ma(n)}function jr(n){if(!he(n))return Hf(n);var t=[];for(var e in M(n))F.call(n,e)&&e!="constructor"&&t.push(e);return t}function Lc(n){if(!K(n))return dh(n);var t=he(n),e=[];for(var r in n)r=="constructor"&&(t||!F.call(n,r))||e.push(r);return e}function ni(n,t){return n<t}function Vs(n,t){var e=-1,r=an(n)?p(n.length):[];return rt(n,function(s,o,f){r[++e]=t(s,o,f);}),r}function ks(n){var t=gi(n);return t.length==1&&t[0][2]?Lu(t[0][0],t[0][1]):function(e){return e===n||kr(e,n,t)}}function js(n,t){return _i(n)&&Tu(t)?Lu(Wn(n),t):function(e){var r=Si(e,n);return r===i&&r===t?Oi(e,n):oe(t,r,Et|ve)}}function Ke(n,t,e,r,s){n!==t&&Jr(t,function(o,f){if(s||(s=new Rn),K(o))Dc(n,t,f,e,Ke,r,s);else {var c=r?r(wi(n,f),o,f+"",n,t,s):i;c===i&&(c=o),Yr(n,f,c);}},on);}function Dc(n,t,e,r,s,o,f){var c=wi(n,e),l=wi(t,e),v=f.get(l);if(v){Yr(n,e,v);return}var _=o?o(c,l,e+"",n,t,f):i,m=_===i;if(m){var P=O(l),I=!P&&at(l),E=!P&&!I&&Bt(l);_=l,P||I||E?O(c)?_=c:Z(c)?_=un(c):I?(m=!1,_=hu(l,!0)):E?(m=!1,_=lu(l,!0)):_=[]:pe(l)||Pt(l)?(_=c,Pt(c)?_=oa(c):(!K(c)||Jn(c))&&(_=bu(l))):m=!1;}m&&(f.set(l,_),s(_,l,r,o,f),f.delete(l)),Yr(n,e,_);}function nu(n,t){var e=n.length;if(e)return t+=t<0?e:0,Zn(t,e)?n[t]:i}function tu(n,t,e){t.length?t=G(t,function(o){return O(o)?function(f){return _t(f,o.length===1?o[0]:o)}:o}):t=[fn];var r=-1;t=G(t,hn(x()));var s=Vs(n,function(o,f,c){var l=G(t,function(v){return v(o)});return {criteria:l,index:++r,value:o}});return uf(s,function(o,f){return Yc(o,f,e)})}function Hc(n,t){return eu(n,t,function(e,r){return Oi(n,r)})}function eu(n,t,e){for(var r=-1,s=t.length,o={};++r<s;){var f=t[r],c=_t(n,f);e(c,f)&&fe(o,st(f,n),c);}return o}function Nc(n){return function(t){return _t(t,n)}}function ti(n,t,e,r){var s=r?sf:Tt,o=-1,f=t.length,c=n;for(n===t&&(t=un(t)),e&&(c=G(n,hn(e)));++o<f;)for(var l=0,v=t[o],_=e?e(v):v;(l=s(c,_,l,r))>-1;)c!==n&&Ne.call(c,l,1),Ne.call(n,l,1);return n}function ru(n,t){for(var e=n?t.length:0,r=e-1;e--;){var s=t[e];if(e==r||s!==o){var o=s;Zn(s)?Ne.call(n,s,1):si(n,s);}}return n}function ei(n,t){return n+We(Us()*(t-n+1))}function $c(n,t,e,r){for(var s=-1,o=Q(Ue((t-n)/(e||1)),0),f=p(o);o--;)f[r?o:++s]=n,n+=e;return f}function ri(n,t){var e="";if(!n||t<1||t>kn)return e;do t%2&&(e+=n),t=We(t/2),t&&(n+=n);while(t);return e}function T(n,t){return Pi(Du(n,t,fn),n+"")}function Uc(n){return Ms(Gt(n))}function Wc(n,t){var e=Gt(n);return tr(e,vt(t,0,e.length))}function fe(n,t,e,r){if(!K(n))return n;t=st(t,n);for(var s=-1,o=t.length,f=o-1,c=n;c!=null&&++s<o;){var l=Wn(t[s]),v=e;if(l==="__proto__"||l==="constructor"||l==="prototype")return n;if(s!=f){var _=c[l];v=r?r(_,l,c):i,v===i&&(v=K(_)?_:Zn(t[s+1])?[]:{});}se(c,l,v),c=c[l];}return n}var iu=Fe?function(n,t){return Fe.set(n,t),n}:fn,Fc=$e?function(n,t){return $e(n,"toString",{configurable:!0,enumerable:!1,value:bi(t),writable:!0})}:fn;function Mc(n){return tr(Gt(n))}function Cn(n,t,e){var r=-1,s=n.length;t<0&&(t=-t>s?0:s+t),e=e>s?s:e,e<0&&(e+=s),s=t>e?0:e-t>>>0,t>>>=0;for(var o=p(s);++r<s;)o[r]=n[r+t];return o}function qc(n,t){var e;return rt(n,function(r,s,o){return e=t(r,s,o),!e}),!!e}function Ye(n,t,e){var r=0,s=n==null?r:n.length;if(typeof t=="number"&&t===t&&s<=qa){for(;r<s;){var o=r+s>>>1,f=n[o];f!==null&&!pn(f)&&(e?f<=t:f<t)?r=o+1:s=o;}return s}return ii(n,t,fn,e)}function ii(n,t,e,r){var s=0,o=n==null?0:n.length;if(o===0)return 0;t=e(t);for(var f=t!==t,c=t===null,l=pn(t),v=t===i;s<o;){var _=We((s+o)/2),m=e(n[_]),P=m!==i,I=m===null,E=m===m,b=pn(m);if(f)var y=r||E;else v?y=E&&(r||P):c?y=E&&P&&(r||!I):l?y=E&&P&&!I&&(r||!b):I||b?y=!1:y=r?m<=t:m<t;y?s=_+1:o=_;}return nn(o,Ma)}function su(n,t){for(var e=-1,r=n.length,s=0,o=[];++e<r;){var f=n[e],c=t?t(f):f;if(!e||!bn(c,l)){var l=c;o[s++]=f===0?0:f;}}return o}function uu(n){return typeof n=="number"?n:pn(n)?_e:+n}function ln(n){if(typeof n=="string")return n;if(O(n))return G(n,ln)+"";if(pn(n))return Ws?Ws.call(n):"";var t=n+"";return t=="0"&&1/n==-ht?"-0":t}function it(n,t,e){var r=-1,s=Ee,o=n.length,f=!0,c=[],l=c;if(e)f=!1,s=Dr;else if(o>=w){var v=t?null:kc(n);if(v)return Se(v);f=!1,s=jt,l=new gt;}else l=t?[]:c;n:for(;++r<o;){var _=n[r],m=t?t(_):_;if(_=e||_!==0?_:0,f&&m===m){for(var P=l.length;P--;)if(l[P]===m)continue n;t&&l.push(m),c.push(_);}else s(l,m,e)||(l!==c&&l.push(m),c.push(_));}return c}function si(n,t){return t=st(t,n),n=Hu(n,t),n==null||delete n[Wn(In(t))]}function au(n,t,e,r){return fe(n,t,e(_t(n,t)),r)}function Ze(n,t,e,r){for(var s=n.length,o=r?s:-1;(r?o--:++o<s)&&t(n[o],o,n););return e?Cn(n,r?0:o,r?o+1:s):Cn(n,r?o+1:0,r?s:o)}function ou(n,t){var e=n;return e instanceof N&&(e=e.value()),Hr(t,function(r,s){return s.func.apply(s.thisArg,nt([r],s.args))},e)}function ui(n,t,e){var r=n.length;if(r<2)return r?it(n[0]):[];for(var s=-1,o=p(r);++s<r;)for(var f=n[s],c=-1;++c<r;)c!=s&&(o[s]=ue(o[s]||f,n[c],t,e));return it(j(o,1),t,e)}function fu(n,t,e){for(var r=-1,s=n.length,o=t.length,f={};++r<s;){var c=r<o?t[r]:i;e(f,n[r],c);}return f}function ai(n){return Z(n)?n:[]}function oi(n){return typeof n=="function"?n:fn}function st(n,t){return O(n)?n:_i(n,t)?[n]:Wu(W(n))}var Bc=T;function ut(n,t,e){var r=n.length;return e=e===i?r:e,!t&&e>=r?n:Cn(n,t,e)}var cu=Rf||function(n){return k.clearTimeout(n)};function hu(n,t){if(t)return n.slice();var e=n.length,r=Ls?Ls(e):new n.constructor(e);return n.copy(r),r}function fi(n){var t=new n.constructor(n.byteLength);return new De(t).set(new De(n)),t}function Gc(n,t){var e=t?fi(n.buffer):n.buffer;return new n.constructor(e,n.byteOffset,n.byteLength)}function zc(n){var t=new n.constructor(n.source,Ji.exec(n));return t.lastIndex=n.lastIndex,t}function Kc(n){return ie?M(ie.call(n)):{}}function lu(n,t){var e=t?fi(n.buffer):n.buffer;return new n.constructor(e,n.byteOffset,n.length)}function pu(n,t){if(n!==t){var e=n!==i,r=n===null,s=n===n,o=pn(n),f=t!==i,c=t===null,l=t===t,v=pn(t);if(!c&&!v&&!o&&n>t||o&&f&&l&&!c&&!v||r&&f&&l||!e&&l||!s)return 1;if(!r&&!o&&!v&&n<t||v&&e&&s&&!r&&!o||c&&e&&s||!f&&s||!l)return -1}return 0}function Yc(n,t,e){for(var r=-1,s=n.criteria,o=t.criteria,f=s.length,c=e.length;++r<f;){var l=pu(s[r],o[r]);if(l){if(r>=c)return l;var v=e[r];return l*(v=="desc"?-1:1)}}return n.index-t.index}function du(n,t,e,r){for(var s=-1,o=n.length,f=e.length,c=-1,l=t.length,v=Q(o-f,0),_=p(l+v),m=!r;++c<l;)_[c]=t[c];for(;++s<f;)(m||s<o)&&(_[e[s]]=n[s]);for(;v--;)_[c++]=n[s++];return _}function gu(n,t,e,r){for(var s=-1,o=n.length,f=-1,c=e.length,l=-1,v=t.length,_=Q(o-c,0),m=p(_+v),P=!r;++s<_;)m[s]=n[s];for(var I=s;++l<v;)m[I+l]=t[l];for(;++f<c;)(P||s<o)&&(m[I+e[f]]=n[s++]);return m}function un(n,t){var e=-1,r=n.length;for(t||(t=p(r));++e<r;)t[e]=n[e];return t}function Un(n,t,e,r){var s=!e;e||(e={});for(var o=-1,f=t.length;++o<f;){var c=t[o],l=r?r(e[c],n[c],c,e,n):i;l===i&&(l=n[c]),s?zn(e,c,l):se(e,c,l);}return e}function Zc(n,t){return Un(n,vi(n),t)}function Jc(n,t){return Un(n,Ou(n),t)}function Je(n,t){return function(e,r){var s=O(e)?ko:vc,o=t?t():{};return s(e,n,x(r,2),o)}}function Ft(n){return T(function(t,e){var r=-1,s=e.length,o=s>1?e[s-1]:i,f=s>2?e[2]:i;for(o=n.length>3&&typeof o=="function"?(s--,o):i,f&&rn(e[0],e[1],f)&&(o=s<3?i:o,s=1),t=M(t);++r<s;){var c=e[r];c&&n(t,c,r,o);}return t})}function vu(n,t){return function(e,r){if(e==null)return e;if(!an(e))return n(e,r);for(var s=e.length,o=t?s:-1,f=M(e);(t?o--:++o<s)&&r(f[o],o,f)!==!1;);return e}}function _u(n){return function(t,e,r){for(var s=-1,o=M(t),f=r(t),c=f.length;c--;){var l=f[n?c:++s];if(e(o[l],l,o)===!1)break}return t}}function Xc(n,t,e){var r=t&vn,s=ce(n);function o(){var f=this&&this!==k&&this instanceof o?s:n;return f.apply(r?e:this,arguments)}return o}function mu(n){return function(t){t=W(t);var e=Lt(t)?On(t):i,r=e?e[0]:t.charAt(0),s=e?ut(e,1).join(""):t.slice(1);return r[n]()+s}}function Mt(n){return function(t){return Hr(va(ga(t).replace(Wo,"")),n,"")}}function ce(n){return function(){var t=arguments;switch(t.length){case 0:return new n;case 1:return new n(t[0]);case 2:return new n(t[0],t[1]);case 3:return new n(t[0],t[1],t[2]);case 4:return new n(t[0],t[1],t[2],t[3]);case 5:return new n(t[0],t[1],t[2],t[3],t[4]);case 6:return new n(t[0],t[1],t[2],t[3],t[4],t[5]);case 7:return new n(t[0],t[1],t[2],t[3],t[4],t[5],t[6])}var e=Wt(n.prototype),r=n.apply(e,t);return K(r)?r:e}}function Qc(n,t,e){var r=ce(n);function s(){for(var o=arguments.length,f=p(o),c=o,l=qt(s);c--;)f[c]=arguments[c];var v=o<3&&f[0]!==l&&f[o-1]!==l?[]:tt(f,l);if(o-=v.length,o<e)return Iu(n,t,Xe,s.placeholder,i,f,v,i,i,e-o);var _=this&&this!==k&&this instanceof s?r:n;return cn(_,this,f)}return s}function wu(n){return function(t,e,r){var s=M(t);if(!an(t)){var o=x(e,3);t=V(t),e=function(c){return o(s[c],c,s)};}var f=n(t,e,r);return f>-1?s[o?t[f]:f]:i}}function Pu(n){return Yn(function(t){var e=t.length,r=e,s=Pn.prototype.thru;for(n&&t.reverse();r--;){var o=t[r];if(typeof o!="function")throw new wn(D);if(s&&!f&&je(o)=="wrapper")var f=new Pn([],!0);}for(r=f?r:e;++r<e;){o=t[r];var c=je(o),l=c=="wrapper"?di(o):i;l&&mi(l[0])&&l[1]==(Mn|Dn|Hn|Kt)&&!l[4].length&&l[9]==1?f=f[je(l[0])].apply(f,l[3]):f=o.length==1&&mi(o)?f[c]():f.thru(o);}return function(){var v=arguments,_=v[0];if(f&&v.length==1&&O(_))return f.plant(_).value();for(var m=0,P=e?t[m].apply(this,v):_;++m<e;)P=t[m].call(this,P);return P}})}function Xe(n,t,e,r,s,o,f,c,l,v){var _=t&Mn,m=t&vn,P=t&ct,I=t&(Dn|yt),E=t&dr,b=P?i:ce(n);function y(){for(var H=arguments.length,$=p(H),dn=H;dn--;)$[dn]=arguments[dn];if(I)var sn=qt(y),gn=of($,sn);if(r&&($=du($,r,s,I)),o&&($=gu($,o,f,I)),H-=gn,I&&H<v){var J=tt($,sn);return Iu(n,t,Xe,y.placeholder,e,$,J,c,l,v-H)}var Tn=m?e:this,Qn=P?Tn[n]:n;return H=$.length,c?$=vh($,c):E&&H>1&&$.reverse(),_&&l<H&&($.length=l),this&&this!==k&&this instanceof y&&(Qn=b||ce(Qn)),Qn.apply(Tn,$)}return y}function Au(n,t){return function(e,r){return xc(e,n,t(r),{})}}function Qe(n,t){return function(e,r){var s;if(e===i&&r===i)return t;if(e!==i&&(s=e),r!==i){if(s===i)return r;typeof e=="string"||typeof r=="string"?(e=ln(e),r=ln(r)):(e=uu(e),r=uu(r)),s=n(e,r);}return s}}function ci(n){return Yn(function(t){return t=G(t,hn(x())),T(function(e){var r=this;return n(t,function(s){return cn(s,r,e)})})})}function Ve(n,t){t=t===i?" ":ln(t);var e=t.length;if(e<2)return e?ri(t,n):t;var r=ri(t,Ue(n/Dt(t)));return Lt(t)?ut(On(r),0,n).join(""):r.slice(0,n)}function Vc(n,t,e,r){var s=t&vn,o=ce(n);function f(){for(var c=-1,l=arguments.length,v=-1,_=r.length,m=p(_+l),P=this&&this!==k&&this instanceof f?o:n;++v<_;)m[v]=r[v];for(;l--;)m[v++]=arguments[++c];return cn(P,s?e:this,m)}return f}function Cu(n){return function(t,e,r){return r&&typeof r!="number"&&rn(t,e,r)&&(e=r=i),t=Xn(t),e===i?(e=t,t=0):e=Xn(e),r=r===i?t<e?1:-1:Xn(r),$c(t,e,r,n)}}function ke(n){return function(t,e){return typeof t=="string"&&typeof e=="string"||(t=xn(t),e=xn(e)),n(t,e)}}function Iu(n,t,e,r,s,o,f,c,l,v){var _=t&Dn,m=_?f:i,P=_?i:f,I=_?o:i,E=_?i:o;t|=_?Hn:St,t&=~(_?St:Hn),t&qi||(t&=~(vn|ct));var b=[n,t,s,I,m,E,P,c,l,v],y=e.apply(i,b);return mi(n)&&Nu(y,b),y.placeholder=r,$u(y,n,t)}function hi(n){var t=X[n];return function(e,r){if(e=xn(e),r=r==null?0:nn(R(r),292),r&&$s(e)){var s=(W(e)+"e").split("e"),o=t(s[0]+"e"+(+s[1]+r));return s=(W(o)+"e").split("e"),+(s[0]+"e"+(+s[1]-r))}return t(e)}}var kc=$t&&1/Se(new $t([,-0]))[1]==ht?function(n){return new $t(n)}:Di;function xu(n){return function(t){var e=tn(t);return e==yn?qr(t):e==Sn?gf(t):af(t,n(t))}}function Kn(n,t,e,r,s,o,f,c){var l=t&ct;if(!l&&typeof n!="function")throw new wn(D);var v=r?r.length:0;if(v||(t&=~(Hn|St),r=s=i),f=f===i?f:Q(R(f),0),c=c===i?c:R(c),v-=s?s.length:0,t&St){var _=r,m=s;r=s=i;}var P=l?i:di(n),I=[n,t,e,r,s,_,m,o,f,c];if(P&&ph(I,P),n=I[0],t=I[1],e=I[2],r=I[3],s=I[4],c=I[9]=I[9]===i?l?0:n.length:Q(I[9]-v,0),!c&&t&(Dn|yt)&&(t&=~(Dn|yt)),!t||t==vn)var E=Xc(n,t,e);else t==Dn||t==yt?E=Qc(n,t,c):(t==Hn||t==(vn|Hn))&&!s.length?E=Vc(n,t,e,r):E=Xe.apply(i,I);var b=P?iu:Nu;return $u(b(E,I),n,t)}function Eu(n,t,e,r){return n===i||bn(n,Nt[e])&&!F.call(r,e)?t:n}function yu(n,t,e,r,s,o){return K(n)&&K(t)&&(o.set(t,n),Ke(n,t,i,yu,o),o.delete(t)),n}function jc(n){return pe(n)?i:n}function Su(n,t,e,r,s,o){var f=e&Et,c=n.length,l=t.length;if(c!=l&&!(f&&l>c))return !1;var v=o.get(n),_=o.get(t);if(v&&_)return v==t&&_==n;var m=-1,P=!0,I=e&ve?new gt:i;for(o.set(n,t),o.set(t,n);++m<c;){var E=n[m],b=t[m];if(r)var y=f?r(b,E,m,t,n,o):r(E,b,m,n,t,o);if(y!==i){if(y)continue;P=!1;break}if(I){if(!Nr(t,function(H,$){if(!jt(I,$)&&(E===H||s(E,H,e,r,o)))return I.push($)})){P=!1;break}}else if(!(E===b||s(E,b,e,r,o))){P=!1;break}}return o.delete(n),o.delete(t),P}function nh(n,t,e,r,s,o,f){switch(e){case Rt:if(n.byteLength!=t.byteLength||n.byteOffset!=t.byteOffset)return !1;n=n.buffer,t=t.buffer;case kt:return !(n.byteLength!=t.byteLength||!o(new De(n),new De(t)));case Yt:case Zt:case Jt:return bn(+n,+t);case we:return n.name==t.name&&n.message==t.message;case Xt:case Qt:return n==t+"";case yn:var c=qr;case Sn:var l=r&Et;if(c||(c=Se),n.size!=t.size&&!l)return !1;var v=f.get(n);if(v)return v==t;r|=ve,f.set(n,t);var _=Su(c(n),c(t),r,s,o,f);return f.delete(n),_;case Ae:if(ie)return ie.call(n)==ie.call(t)}return !1}function th(n,t,e,r,s,o){var f=e&Et,c=li(n),l=c.length,v=li(t),_=v.length;if(l!=_&&!f)return !1;for(var m=l;m--;){var P=c[m];if(!(f?P in t:F.call(t,P)))return !1}var I=o.get(n),E=o.get(t);if(I&&E)return I==t&&E==n;var b=!0;o.set(n,t),o.set(t,n);for(var y=f;++m<l;){P=c[m];var H=n[P],$=t[P];if(r)var dn=f?r($,H,P,t,n,o):r(H,$,P,n,t,o);if(!(dn===i?H===$||s(H,$,e,r,o):dn)){b=!1;break}y||(y=P=="constructor");}if(b&&!y){var sn=n.constructor,gn=t.constructor;sn!=gn&&"constructor"in n&&"constructor"in t&&!(typeof sn=="function"&&sn instanceof sn&&typeof gn=="function"&&gn instanceof gn)&&(b=!1);}return o.delete(n),o.delete(t),b}function Yn(n){return Pi(Du(n,i,Bu),n+"")}function li(n){return Zs(n,V,vi)}function pi(n){return Zs(n,on,Ou)}var di=Fe?function(n){return Fe.get(n)}:Di;function je(n){for(var t=n.name+"",e=Ut[t],r=F.call(Ut,t)?e.length:0;r--;){var s=e[r],o=s.func;if(o==null||o==n)return s.name}return t}function qt(n){var t=F.call(a,"placeholder")?a:n;return t.placeholder}function x(){var n=a.iteratee||Ti;return n=n===Ti?Qs:n,arguments.length?n(arguments[0],arguments[1]):n}function nr(n,t){var e=n.__data__;return fh(t)?e[typeof t=="string"?"string":"hash"]:e.map}function gi(n){for(var t=V(n),e=t.length;e--;){var r=t[e],s=n[r];t[e]=[r,s,Tu(s)];}return t}function mt(n,t){var e=lf(n,t);return Xs(e)?e:i}function eh(n){var t=F.call(n,pt),e=n[pt];try{n[pt]=i;var r=!0;}catch{}var s=Te.call(n);return r&&(t?n[pt]=e:delete n[pt]),s}var vi=Gr?function(n){return n==null?[]:(n=M(n),jn(Gr(n),function(t){return Hs.call(n,t)}))}:Hi,Ou=Gr?function(n){for(var t=[];n;)nt(t,vi(n)),n=He(n);return t}:Hi,tn=en;(zr&&tn(new zr(new ArrayBuffer(1)))!=Rt||te&&tn(new te)!=yn||Kr&&tn(Kr.resolve())!=zi||$t&&tn(new $t)!=Sn||ee&&tn(new ee)!=Vt)&&(tn=function(n){var t=en(n),e=t==qn?n.constructor:i,r=e?wt(e):"";if(r)switch(r){case Wf:return Rt;case Ff:return yn;case Mf:return zi;case qf:return Sn;case Bf:return Vt}return t});function rh(n,t,e){for(var r=-1,s=e.length;++r<s;){var o=e[r],f=o.size;switch(o.type){case"drop":n+=f;break;case"dropRight":t-=f;break;case"take":t=nn(t,n+f);break;case"takeRight":n=Q(n,t-f);break}}return {start:n,end:t}}function ih(n){var t=n.match(oo);return t?t[1].split(fo):[]}function Ru(n,t,e){t=st(t,n);for(var r=-1,s=t.length,o=!1;++r<s;){var f=Wn(t[r]);if(!(o=n!=null&&e(n,f)))break;n=n[f];}return o||++r!=s?o:(s=n==null?0:n.length,!!s&&ar(s)&&Zn(f,s)&&(O(n)||Pt(n)))}function sh(n){var t=n.length,e=new n.constructor(t);return t&&typeof n[0]=="string"&&F.call(n,"index")&&(e.index=n.index,e.input=n.input),e}function bu(n){return typeof n.constructor=="function"&&!he(n)?Wt(He(n)):{}}function uh(n,t,e){var r=n.constructor;switch(t){case kt:return fi(n);case Yt:case Zt:return new r(+n);case Rt:return Gc(n,e);case gr:case vr:case _r:case mr:case wr:case Pr:case Ar:case Cr:case Ir:return lu(n,e);case yn:return new r;case Jt:case Qt:return new r(n);case Xt:return zc(n);case Sn:return new r;case Ae:return Kc(n)}}function ah(n,t){var e=t.length;if(!e)return n;var r=e-1;return t[r]=(e>1?"& ":"")+t[r],t=t.join(e>2?", ":" "),n.replace(ao,`{
/* [wrapped with `+t+`] */
`)}function oh(n){return O(n)||Pt(n)||!!(Ns&&n&&n[Ns])}function Zn(n,t){var e=typeof n;return t=t??kn,!!t&&(e=="number"||e!="symbol"&&wo.test(n))&&n>-1&&n%1==0&&n<t}function rn(n,t,e){if(!K(e))return !1;var r=typeof t;return (r=="number"?an(e)&&Zn(t,e.length):r=="string"&&t in e)?bn(e[t],n):!1}function _i(n,t){if(O(n))return !1;var e=typeof n;return e=="number"||e=="symbol"||e=="boolean"||n==null||pn(n)?!0:ro.test(n)||!eo.test(n)||t!=null&&n in M(t)}function fh(n){var t=typeof n;return t=="string"||t=="number"||t=="symbol"||t=="boolean"?n!=="__proto__":n===null}function mi(n){var t=je(n),e=a[t];if(typeof e!="function"||!(t in N.prototype))return !1;if(n===e)return !0;var r=di(e);return !!r&&n===r[0]}function ch(n){return !!Ts&&Ts in n}var hh=Re?Jn:Ni;function he(n){var t=n&&n.constructor,e=typeof t=="function"&&t.prototype||Nt;return n===e}function Tu(n){return n===n&&!K(n)}function Lu(n,t){return function(e){return e==null?!1:e[n]===t&&(t!==i||n in M(e))}}function lh(n){var t=sr(n,function(r){return e.size===pr&&e.clear(),r}),e=t.cache;return t}function ph(n,t){var e=n[1],r=t[1],s=e|r,o=s<(vn|ct|Mn),f=r==Mn&&e==Dn||r==Mn&&e==Kt&&n[7].length<=t[8]||r==(Mn|Kt)&&t[7].length<=t[8]&&e==Dn;if(!(o||f))return n;r&vn&&(n[2]=t[2],s|=e&vn?0:qi);var c=t[3];if(c){var l=n[3];n[3]=l?du(l,c,t[4]):c,n[4]=l?tt(n[3],It):t[4];}return c=t[5],c&&(l=n[5],n[5]=l?gu(l,c,t[6]):c,n[6]=l?tt(n[5],It):t[6]),c=t[7],c&&(n[7]=c),r&Mn&&(n[8]=n[8]==null?t[8]:nn(n[8],t[8])),n[9]==null&&(n[9]=t[9]),n[0]=t[0],n[1]=s,n}function dh(n){var t=[];if(n!=null)for(var e in M(n))t.push(e);return t}function gh(n){return Te.call(n)}function Du(n,t,e){return t=Q(t===i?n.length-1:t,0),function(){for(var r=arguments,s=-1,o=Q(r.length-t,0),f=p(o);++s<o;)f[s]=r[t+s];s=-1;for(var c=p(t+1);++s<t;)c[s]=r[s];return c[t]=e(f),cn(n,this,c)}}function Hu(n,t){return t.length<2?n:_t(n,Cn(t,0,-1))}function vh(n,t){for(var e=n.length,r=nn(t.length,e),s=un(n);r--;){var o=t[r];n[r]=Zn(o,e)?s[o]:i;}return n}function wi(n,t){if(!(t==="constructor"&&typeof n[t]=="function")&&t!="__proto__")return n[t]}var Nu=Uu(iu),le=Tf||function(n,t){return k.setTimeout(n,t)},Pi=Uu(Fc);function $u(n,t,e){var r=t+"";return Pi(n,ah(r,_h(ih(r),e)))}function Uu(n){var t=0,e=0;return function(){var r=Nf(),s=$a-(r-e);if(e=r,s>0){if(++t>=Na)return arguments[0]}else t=0;return n.apply(i,arguments)}}function tr(n,t){var e=-1,r=n.length,s=r-1;for(t=t===i?r:t;++e<t;){var o=ei(e,s),f=n[o];n[o]=n[e],n[e]=f;}return n.length=t,n}var Wu=lh(function(n){var t=[];return n.charCodeAt(0)===46&&t.push(""),n.replace(io,function(e,r,s,o){t.push(s?o.replace(lo,"$1"):r||e);}),t});function Wn(n){if(typeof n=="string"||pn(n))return n;var t=n+"";return t=="0"&&1/n==-ht?"-0":t}function wt(n){if(n!=null){try{return be.call(n)}catch{}try{return n+""}catch{}}return ""}function _h(n,t){return mn(Ba,function(e){var r="_."+e[0];t&e[1]&&!Ee(n,r)&&n.push(r);}),n.sort()}function Fu(n){if(n instanceof N)return n.clone();var t=new Pn(n.__wrapped__,n.__chain__);return t.__actions__=un(n.__actions__),t.__index__=n.__index__,t.__values__=n.__values__,t}function mh(n,t,e){(e?rn(n,t,e):t===i)?t=1:t=Q(R(t),0);var r=n==null?0:n.length;if(!r||t<1)return [];for(var s=0,o=0,f=p(Ue(r/t));s<r;)f[o++]=Cn(n,s,s+=t);return f}function wh(n){for(var t=-1,e=n==null?0:n.length,r=0,s=[];++t<e;){var o=n[t];o&&(s[r++]=o);}return s}function Ph(){var n=arguments.length;if(!n)return [];for(var t=p(n-1),e=arguments[0],r=n;r--;)t[r-1]=arguments[r];return nt(O(e)?un(e):[e],j(t,1))}var Ah=T(function(n,t){return Z(n)?ue(n,j(t,1,Z,!0)):[]}),Ch=T(function(n,t){var e=In(t);return Z(e)&&(e=i),Z(n)?ue(n,j(t,1,Z,!0),x(e,2)):[]}),Ih=T(function(n,t){var e=In(t);return Z(e)&&(e=i),Z(n)?ue(n,j(t,1,Z,!0),i,e):[]});function xh(n,t,e){var r=n==null?0:n.length;return r?(t=e||t===i?1:R(t),Cn(n,t<0?0:t,r)):[]}function Eh(n,t,e){var r=n==null?0:n.length;return r?(t=e||t===i?1:R(t),t=r-t,Cn(n,0,t<0?0:t)):[]}function yh(n,t){return n&&n.length?Ze(n,x(t,3),!0,!0):[]}function Sh(n,t){return n&&n.length?Ze(n,x(t,3),!0):[]}function Oh(n,t,e,r){var s=n==null?0:n.length;return s?(e&&typeof e!="number"&&rn(n,t,e)&&(e=0,r=s),Pc(n,t,e,r)):[]}function Mu(n,t,e){var r=n==null?0:n.length;if(!r)return -1;var s=e==null?0:R(e);return s<0&&(s=Q(r+s,0)),ye(n,x(t,3),s)}function qu(n,t,e){var r=n==null?0:n.length;if(!r)return -1;var s=r-1;return e!==i&&(s=R(e),s=e<0?Q(r+s,0):nn(s,r-1)),ye(n,x(t,3),s,!0)}function Bu(n){var t=n==null?0:n.length;return t?j(n,1):[]}function Rh(n){var t=n==null?0:n.length;return t?j(n,ht):[]}function bh(n,t){var e=n==null?0:n.length;return e?(t=t===i?1:R(t),j(n,t)):[]}function Th(n){for(var t=-1,e=n==null?0:n.length,r={};++t<e;){var s=n[t];r[s[0]]=s[1];}return r}function Gu(n){return n&&n.length?n[0]:i}function Lh(n,t,e){var r=n==null?0:n.length;if(!r)return -1;var s=e==null?0:R(e);return s<0&&(s=Q(r+s,0)),Tt(n,t,s)}function Dh(n){var t=n==null?0:n.length;return t?Cn(n,0,-1):[]}var Hh=T(function(n){var t=G(n,ai);return t.length&&t[0]===n[0]?Vr(t):[]}),Nh=T(function(n){var t=In(n),e=G(n,ai);return t===In(e)?t=i:e.pop(),e.length&&e[0]===n[0]?Vr(e,x(t,2)):[]}),$h=T(function(n){var t=In(n),e=G(n,ai);return t=typeof t=="function"?t:i,t&&e.pop(),e.length&&e[0]===n[0]?Vr(e,i,t):[]});function Uh(n,t){return n==null?"":Df.call(n,t)}function In(n){var t=n==null?0:n.length;return t?n[t-1]:i}function Wh(n,t,e){var r=n==null?0:n.length;if(!r)return -1;var s=r;return e!==i&&(s=R(e),s=s<0?Q(r+s,0):nn(s,r-1)),t===t?_f(n,t,s):ye(n,Is,s,!0)}function Fh(n,t){return n&&n.length?nu(n,R(t)):i}var Mh=T(zu);function zu(n,t){return n&&n.length&&t&&t.length?ti(n,t):n}function qh(n,t,e){return n&&n.length&&t&&t.length?ti(n,t,x(e,2)):n}function Bh(n,t,e){return n&&n.length&&t&&t.length?ti(n,t,i,e):n}var Gh=Yn(function(n,t){var e=n==null?0:n.length,r=Zr(n,t);return ru(n,G(t,function(s){return Zn(s,e)?+s:s}).sort(pu)),r});function zh(n,t){var e=[];if(!(n&&n.length))return e;var r=-1,s=[],o=n.length;for(t=x(t,3);++r<o;){var f=n[r];t(f,r,n)&&(e.push(f),s.push(r));}return ru(n,s),e}function Ai(n){return n==null?n:Uf.call(n)}function Kh(n,t,e){var r=n==null?0:n.length;return r?(e&&typeof e!="number"&&rn(n,t,e)?(t=0,e=r):(t=t==null?0:R(t),e=e===i?r:R(e)),Cn(n,t,e)):[]}function Yh(n,t){return Ye(n,t)}function Zh(n,t,e){return ii(n,t,x(e,2))}function Jh(n,t){var e=n==null?0:n.length;if(e){var r=Ye(n,t);if(r<e&&bn(n[r],t))return r}return -1}function Xh(n,t){return Ye(n,t,!0)}function Qh(n,t,e){return ii(n,t,x(e,2),!0)}function Vh(n,t){var e=n==null?0:n.length;if(e){var r=Ye(n,t,!0)-1;if(bn(n[r],t))return r}return -1}function kh(n){return n&&n.length?su(n):[]}function jh(n,t){return n&&n.length?su(n,x(t,2)):[]}function nl(n){var t=n==null?0:n.length;return t?Cn(n,1,t):[]}function tl(n,t,e){return n&&n.length?(t=e||t===i?1:R(t),Cn(n,0,t<0?0:t)):[]}function el(n,t,e){var r=n==null?0:n.length;return r?(t=e||t===i?1:R(t),t=r-t,Cn(n,t<0?0:t,r)):[]}function rl(n,t){return n&&n.length?Ze(n,x(t,3),!1,!0):[]}function il(n,t){return n&&n.length?Ze(n,x(t,3)):[]}var sl=T(function(n){return it(j(n,1,Z,!0))}),ul=T(function(n){var t=In(n);return Z(t)&&(t=i),it(j(n,1,Z,!0),x(t,2))}),al=T(function(n){var t=In(n);return t=typeof t=="function"?t:i,it(j(n,1,Z,!0),i,t)});function ol(n){return n&&n.length?it(n):[]}function fl(n,t){return n&&n.length?it(n,x(t,2)):[]}function cl(n,t){return t=typeof t=="function"?t:i,n&&n.length?it(n,i,t):[]}function Ci(n){if(!(n&&n.length))return [];var t=0;return n=jn(n,function(e){if(Z(e))return t=Q(e.length,t),!0}),Fr(t,function(e){return G(n,$r(e))})}function Ku(n,t){if(!(n&&n.length))return [];var e=Ci(n);return t==null?e:G(e,function(r){return cn(t,i,r)})}var hl=T(function(n,t){return Z(n)?ue(n,t):[]}),ll=T(function(n){return ui(jn(n,Z))}),pl=T(function(n){var t=In(n);return Z(t)&&(t=i),ui(jn(n,Z),x(t,2))}),dl=T(function(n){var t=In(n);return t=typeof t=="function"?t:i,ui(jn(n,Z),i,t)}),gl=T(Ci);function vl(n,t){return fu(n||[],t||[],se)}function _l(n,t){return fu(n||[],t||[],fe)}var ml=T(function(n){var t=n.length,e=t>1?n[t-1]:i;return e=typeof e=="function"?(n.pop(),e):i,Ku(n,e)});function Yu(n){var t=a(n);return t.__chain__=!0,t}function wl(n,t){return t(n),n}function er(n,t){return t(n)}var Pl=Yn(function(n){var t=n.length,e=t?n[0]:0,r=this.__wrapped__,s=function(o){return Zr(o,n)};return t>1||this.__actions__.length||!(r instanceof N)||!Zn(e)?this.thru(s):(r=r.slice(e,+e+(t?1:0)),r.__actions__.push({func:er,args:[s],thisArg:i}),new Pn(r,this.__chain__).thru(function(o){return t&&!o.length&&o.push(i),o}))});function Al(){return Yu(this)}function Cl(){return new Pn(this.value(),this.__chain__)}function Il(){this.__values__===i&&(this.__values__=ua(this.value()));var n=this.__index__>=this.__values__.length,t=n?i:this.__values__[this.__index__++];return {done:n,value:t}}function xl(){return this}function El(n){for(var t,e=this;e instanceof qe;){var r=Fu(e);r.__index__=0,r.__values__=i,t?s.__wrapped__=r:t=r;var s=r;e=e.__wrapped__;}return s.__wrapped__=n,t}function yl(){var n=this.__wrapped__;if(n instanceof N){var t=n;return this.__actions__.length&&(t=new N(this)),t=t.reverse(),t.__actions__.push({func:er,args:[Ai],thisArg:i}),new Pn(t,this.__chain__)}return this.thru(Ai)}function Sl(){return ou(this.__wrapped__,this.__actions__)}var Ol=Je(function(n,t,e){F.call(n,e)?++n[e]:zn(n,e,1);});function Rl(n,t,e){var r=O(n)?As:wc;return e&&rn(n,t,e)&&(t=i),r(n,x(t,3))}function bl(n,t){var e=O(n)?jn:Ks;return e(n,x(t,3))}var Tl=wu(Mu),Ll=wu(qu);function Dl(n,t){return j(rr(n,t),1)}function Hl(n,t){return j(rr(n,t),ht)}function Nl(n,t,e){return e=e===i?1:R(e),j(rr(n,t),e)}function Zu(n,t){var e=O(n)?mn:rt;return e(n,x(t,3))}function Ju(n,t){var e=O(n)?jo:zs;return e(n,x(t,3))}var $l=Je(function(n,t,e){F.call(n,e)?n[e].push(t):zn(n,e,[t]);});function Ul(n,t,e,r){n=an(n)?n:Gt(n),e=e&&!r?R(e):0;var s=n.length;return e<0&&(e=Q(s+e,0)),or(n)?e<=s&&n.indexOf(t,e)>-1:!!s&&Tt(n,t,e)>-1}var Wl=T(function(n,t,e){var r=-1,s=typeof t=="function",o=an(n)?p(n.length):[];return rt(n,function(f){o[++r]=s?cn(t,f,e):ae(f,t,e);}),o}),Fl=Je(function(n,t,e){zn(n,e,t);});function rr(n,t){var e=O(n)?G:Vs;return e(n,x(t,3))}function Ml(n,t,e,r){return n==null?[]:(O(t)||(t=t==null?[]:[t]),e=r?i:e,O(e)||(e=e==null?[]:[e]),tu(n,t,e))}var ql=Je(function(n,t,e){n[e?0:1].push(t);},function(){return [[],[]]});function Bl(n,t,e){var r=O(n)?Hr:Es,s=arguments.length<3;return r(n,x(t,4),e,s,rt)}function Gl(n,t,e){var r=O(n)?nf:Es,s=arguments.length<3;return r(n,x(t,4),e,s,zs)}function zl(n,t){var e=O(n)?jn:Ks;return e(n,ur(x(t,3)))}function Kl(n){var t=O(n)?Ms:Uc;return t(n)}function Yl(n,t,e){(e?rn(n,t,e):t===i)?t=1:t=R(t);var r=O(n)?dc:Wc;return r(n,t)}function Zl(n){var t=O(n)?gc:Mc;return t(n)}function Jl(n){if(n==null)return 0;if(an(n))return or(n)?Dt(n):n.length;var t=tn(n);return t==yn||t==Sn?n.size:jr(n).length}function Xl(n,t,e){var r=O(n)?Nr:qc;return e&&rn(n,t,e)&&(t=i),r(n,x(t,3))}var Ql=T(function(n,t){if(n==null)return [];var e=t.length;return e>1&&rn(n,t[0],t[1])?t=[]:e>2&&rn(t[0],t[1],t[2])&&(t=[t[0]]),tu(n,j(t,1),[])}),ir=bf||function(){return k.Date.now()};function Vl(n,t){if(typeof t!="function")throw new wn(D);return n=R(n),function(){if(--n<1)return t.apply(this,arguments)}}function Xu(n,t,e){return t=e?i:t,t=n&&t==null?n.length:t,Kn(n,Mn,i,i,i,i,t)}function Qu(n,t){var e;if(typeof t!="function")throw new wn(D);return n=R(n),function(){return --n>0&&(e=t.apply(this,arguments)),n<=1&&(t=i),e}}var Ii=T(function(n,t,e){var r=vn;if(e.length){var s=tt(e,qt(Ii));r|=Hn;}return Kn(n,r,t,e,s)}),Vu=T(function(n,t,e){var r=vn|ct;if(e.length){var s=tt(e,qt(Vu));r|=Hn;}return Kn(t,r,n,e,s)});function ku(n,t,e){t=e?i:t;var r=Kn(n,Dn,i,i,i,i,i,t);return r.placeholder=ku.placeholder,r}function ju(n,t,e){t=e?i:t;var r=Kn(n,yt,i,i,i,i,i,t);return r.placeholder=ju.placeholder,r}function na(n,t,e){var r,s,o,f,c,l,v=0,_=!1,m=!1,P=!0;if(typeof n!="function")throw new wn(D);t=xn(t)||0,K(e)&&(_=!!e.leading,m="maxWait"in e,o=m?Q(xn(e.maxWait)||0,t):o,P="trailing"in e?!!e.trailing:P);function I(J){var Tn=r,Qn=s;return r=s=i,v=J,f=n.apply(Qn,Tn),f}function E(J){return v=J,c=le(H,t),_?I(J):f}function b(J){var Tn=J-l,Qn=J-v,wa=t-Tn;return m?nn(wa,o-Qn):wa}function y(J){var Tn=J-l,Qn=J-v;return l===i||Tn>=t||Tn<0||m&&Qn>=o}function H(){var J=ir();if(y(J))return $(J);c=le(H,b(J));}function $(J){return c=i,P&&r?I(J):(r=s=i,f)}function dn(){c!==i&&cu(c),v=0,r=l=s=c=i;}function sn(){return c===i?f:$(ir())}function gn(){var J=ir(),Tn=y(J);if(r=arguments,s=this,l=J,Tn){if(c===i)return E(l);if(m)return cu(c),c=le(H,t),I(l)}return c===i&&(c=le(H,t)),f}return gn.cancel=dn,gn.flush=sn,gn}var kl=T(function(n,t){return Gs(n,1,t)}),jl=T(function(n,t,e){return Gs(n,xn(t)||0,e)});function np(n){return Kn(n,dr)}function sr(n,t){if(typeof n!="function"||t!=null&&typeof t!="function")throw new wn(D);var e=function(){var r=arguments,s=t?t.apply(this,r):r[0],o=e.cache;if(o.has(s))return o.get(s);var f=n.apply(this,r);return e.cache=o.set(s,f)||o,f};return e.cache=new(sr.Cache||Gn),e}sr.Cache=Gn;function ur(n){if(typeof n!="function")throw new wn(D);return function(){var t=arguments;switch(t.length){case 0:return !n.call(this);case 1:return !n.call(this,t[0]);case 2:return !n.call(this,t[0],t[1]);case 3:return !n.call(this,t[0],t[1],t[2])}return !n.apply(this,t)}}function tp(n){return Qu(2,n)}var ep=Bc(function(n,t){t=t.length==1&&O(t[0])?G(t[0],hn(x())):G(j(t,1),hn(x()));var e=t.length;return T(function(r){for(var s=-1,o=nn(r.length,e);++s<o;)r[s]=t[s].call(this,r[s]);return cn(n,this,r)})}),xi=T(function(n,t){var e=tt(t,qt(xi));return Kn(n,Hn,i,t,e)}),ta=T(function(n,t){var e=tt(t,qt(ta));return Kn(n,St,i,t,e)}),rp=Yn(function(n,t){return Kn(n,Kt,i,i,i,t)});function ip(n,t){if(typeof n!="function")throw new wn(D);return t=t===i?t:R(t),T(n,t)}function sp(n,t){if(typeof n!="function")throw new wn(D);return t=t==null?0:Q(R(t),0),T(function(e){var r=e[t],s=ut(e,0,t);return r&&nt(s,r),cn(n,this,s)})}function up(n,t,e){var r=!0,s=!0;if(typeof n!="function")throw new wn(D);return K(e)&&(r="leading"in e?!!e.leading:r,s="trailing"in e?!!e.trailing:s),na(n,t,{leading:r,maxWait:t,trailing:s})}function ap(n){return Xu(n,1)}function op(n,t){return xi(oi(t),n)}function fp(){if(!arguments.length)return [];var n=arguments[0];return O(n)?n:[n]}function cp(n){return An(n,xt)}function hp(n,t){return t=typeof t=="function"?t:i,An(n,xt,t)}function lp(n){return An(n,Ln|xt)}function pp(n,t){return t=typeof t=="function"?t:i,An(n,Ln|xt,t)}function dp(n,t){return t==null||Bs(n,t,V(t))}function bn(n,t){return n===t||n!==n&&t!==t}var gp=ke(Qr),vp=ke(function(n,t){return n>=t}),Pt=Js(function(){return arguments}())?Js:function(n){return Y(n)&&F.call(n,"callee")&&!Hs.call(n,"callee")},O=p.isArray,_p=gs?hn(gs):Ec;function an(n){return n!=null&&ar(n.length)&&!Jn(n)}function Z(n){return Y(n)&&an(n)}function mp(n){return n===!0||n===!1||Y(n)&&en(n)==Yt}var at=Lf||Ni,wp=vs?hn(vs):yc;function Pp(n){return Y(n)&&n.nodeType===1&&!pe(n)}function Ap(n){if(n==null)return !0;if(an(n)&&(O(n)||typeof n=="string"||typeof n.splice=="function"||at(n)||Bt(n)||Pt(n)))return !n.length;var t=tn(n);if(t==yn||t==Sn)return !n.size;if(he(n))return !jr(n).length;for(var e in n)if(F.call(n,e))return !1;return !0}function Cp(n,t){return oe(n,t)}function Ip(n,t,e){e=typeof e=="function"?e:i;var r=e?e(n,t):i;return r===i?oe(n,t,i,e):!!r}function Ei(n){if(!Y(n))return !1;var t=en(n);return t==we||t==za||typeof n.message=="string"&&typeof n.name=="string"&&!pe(n)}function xp(n){return typeof n=="number"&&$s(n)}function Jn(n){if(!K(n))return !1;var t=en(n);return t==Pe||t==Gi||t==Ga||t==Ya}function ea(n){return typeof n=="number"&&n==R(n)}function ar(n){return typeof n=="number"&&n>-1&&n%1==0&&n<=kn}function K(n){var t=typeof n;return n!=null&&(t=="object"||t=="function")}function Y(n){return n!=null&&typeof n=="object"}var ra=_s?hn(_s):Oc;function Ep(n,t){return n===t||kr(n,t,gi(t))}function yp(n,t,e){return e=typeof e=="function"?e:i,kr(n,t,gi(t),e)}function Sp(n){return ia(n)&&n!=+n}function Op(n){if(hh(n))throw new S(L);return Xs(n)}function Rp(n){return n===null}function bp(n){return n==null}function ia(n){return typeof n=="number"||Y(n)&&en(n)==Jt}function pe(n){if(!Y(n)||en(n)!=qn)return !1;var t=He(n);if(t===null)return !0;var e=F.call(t,"constructor")&&t.constructor;return typeof e=="function"&&e instanceof e&&be.call(e)==yf}var yi=ms?hn(ms):Rc;function Tp(n){return ea(n)&&n>=-kn&&n<=kn}var sa=ws?hn(ws):bc;function or(n){return typeof n=="string"||!O(n)&&Y(n)&&en(n)==Qt}function pn(n){return typeof n=="symbol"||Y(n)&&en(n)==Ae}var Bt=Ps?hn(Ps):Tc;function Lp(n){return n===i}function Dp(n){return Y(n)&&tn(n)==Vt}function Hp(n){return Y(n)&&en(n)==Ja}var Np=ke(ni),$p=ke(function(n,t){return n<=t});function ua(n){if(!n)return [];if(an(n))return or(n)?On(n):un(n);if(ne&&n[ne])return df(n[ne]());var t=tn(n),e=t==yn?qr:t==Sn?Se:Gt;return e(n)}function Xn(n){if(!n)return n===0?n:0;if(n=xn(n),n===ht||n===-ht){var t=n<0?-1:1;return t*Fa}return n===n?n:0}function R(n){var t=Xn(n),e=t%1;return t===t?e?t-e:t:0}function aa(n){return n?vt(R(n),0,Nn):0}function xn(n){if(typeof n=="number")return n;if(pn(n))return _e;if(K(n)){var t=typeof n.valueOf=="function"?n.valueOf():n;n=K(t)?t+"":t;}if(typeof n!="string")return n===0?n:+n;n=ys(n);var e=vo.test(n);return e||mo.test(n)?Qo(n.slice(2),e?2:8):go.test(n)?_e:+n}function oa(n){return Un(n,on(n))}function Up(n){return n?vt(R(n),-kn,kn):n===0?n:0}function W(n){return n==null?"":ln(n)}var Wp=Ft(function(n,t){if(he(t)||an(t)){Un(t,V(t),n);return}for(var e in t)F.call(t,e)&&se(n,e,t[e]);}),fa=Ft(function(n,t){Un(t,on(t),n);}),fr=Ft(function(n,t,e,r){Un(t,on(t),n,r);}),Fp=Ft(function(n,t,e,r){Un(t,V(t),n,r);}),Mp=Yn(Zr);function qp(n,t){var e=Wt(n);return t==null?e:qs(e,t)}var Bp=T(function(n,t){n=M(n);var e=-1,r=t.length,s=r>2?t[2]:i;for(s&&rn(t[0],t[1],s)&&(r=1);++e<r;)for(var o=t[e],f=on(o),c=-1,l=f.length;++c<l;){var v=f[c],_=n[v];(_===i||bn(_,Nt[v])&&!F.call(n,v))&&(n[v]=o[v]);}return n}),Gp=T(function(n){return n.push(i,yu),cn(ca,i,n)});function zp(n,t){return Cs(n,x(t,3),$n)}function Kp(n,t){return Cs(n,x(t,3),Xr)}function Yp(n,t){return n==null?n:Jr(n,x(t,3),on)}function Zp(n,t){return n==null?n:Ys(n,x(t,3),on)}function Jp(n,t){return n&&$n(n,x(t,3))}function Xp(n,t){return n&&Xr(n,x(t,3))}function Qp(n){return n==null?[]:ze(n,V(n))}function Vp(n){return n==null?[]:ze(n,on(n))}function Si(n,t,e){var r=n==null?i:_t(n,t);return r===i?e:r}function kp(n,t){return n!=null&&Ru(n,t,Ac)}function Oi(n,t){return n!=null&&Ru(n,t,Cc)}var jp=Au(function(n,t,e){t!=null&&typeof t.toString!="function"&&(t=Te.call(t)),n[t]=e;},bi(fn)),nd=Au(function(n,t,e){t!=null&&typeof t.toString!="function"&&(t=Te.call(t)),F.call(n,t)?n[t].push(e):n[t]=[e];},x),td=T(ae);function V(n){return an(n)?Fs(n):jr(n)}function on(n){return an(n)?Fs(n,!0):Lc(n)}function ed(n,t){var e={};return t=x(t,3),$n(n,function(r,s,o){zn(e,t(r,s,o),r);}),e}function rd(n,t){var e={};return t=x(t,3),$n(n,function(r,s,o){zn(e,s,t(r,s,o));}),e}var id=Ft(function(n,t,e){Ke(n,t,e);}),ca=Ft(function(n,t,e,r){Ke(n,t,e,r);}),sd=Yn(function(n,t){var e={};if(n==null)return e;var r=!1;t=G(t,function(o){return o=st(o,n),r||(r=o.length>1),o}),Un(n,pi(n),e),r&&(e=An(e,Ln|Fn|xt,jc));for(var s=t.length;s--;)si(e,t[s]);return e});function ud(n,t){return ha(n,ur(x(t)))}var ad=Yn(function(n,t){return n==null?{}:Hc(n,t)});function ha(n,t){if(n==null)return {};var e=G(pi(n),function(r){return [r]});return t=x(t),eu(n,e,function(r,s){return t(r,s[0])})}function od(n,t,e){t=st(t,n);var r=-1,s=t.length;for(s||(s=1,n=i);++r<s;){var o=n==null?i:n[Wn(t[r])];o===i&&(r=s,o=e),n=Jn(o)?o.call(n):o;}return n}function fd(n,t,e){return n==null?n:fe(n,t,e)}function cd(n,t,e,r){return r=typeof r=="function"?r:i,n==null?n:fe(n,t,e,r)}var la=xu(V),pa=xu(on);function hd(n,t,e){var r=O(n),s=r||at(n)||Bt(n);if(t=x(t,4),e==null){var o=n&&n.constructor;s?e=r?new o:[]:K(n)?e=Jn(o)?Wt(He(n)):{}:e={};}return (s?mn:$n)(n,function(f,c,l){return t(e,f,c,l)}),e}function ld(n,t){return n==null?!0:si(n,t)}function pd(n,t,e){return n==null?n:au(n,t,oi(e))}function dd(n,t,e,r){return r=typeof r=="function"?r:i,n==null?n:au(n,t,oi(e),r)}function Gt(n){return n==null?[]:Mr(n,V(n))}function gd(n){return n==null?[]:Mr(n,on(n))}function vd(n,t,e){return e===i&&(e=t,t=i),e!==i&&(e=xn(e),e=e===e?e:0),t!==i&&(t=xn(t),t=t===t?t:0),vt(xn(n),t,e)}function _d(n,t,e){return t=Xn(t),e===i?(e=t,t=0):e=Xn(e),n=xn(n),Ic(n,t,e)}function md(n,t,e){if(e&&typeof e!="boolean"&&rn(n,t,e)&&(t=e=i),e===i&&(typeof t=="boolean"?(e=t,t=i):typeof n=="boolean"&&(e=n,n=i)),n===i&&t===i?(n=0,t=1):(n=Xn(n),t===i?(t=n,n=0):t=Xn(t)),n>t){var r=n;n=t,t=r;}if(e||n%1||t%1){var s=Us();return nn(n+s*(t-n+Xo("1e-"+((s+"").length-1))),t)}return ei(n,t)}var wd=Mt(function(n,t,e){return t=t.toLowerCase(),n+(e?da(t):t)});function da(n){return Ri(W(n).toLowerCase())}function ga(n){return n=W(n),n&&n.replace(Po,ff).replace(Fo,"")}function Pd(n,t,e){n=W(n),t=ln(t);var r=n.length;e=e===i?r:vt(R(e),0,r);var s=e;return e-=t.length,e>=0&&n.slice(e,s)==t}function Ad(n){return n=W(n),n&&ja.test(n)?n.replace(Yi,cf):n}function Cd(n){return n=W(n),n&&so.test(n)?n.replace(xr,"\\$&"):n}var Id=Mt(function(n,t,e){return n+(e?"-":"")+t.toLowerCase()}),xd=Mt(function(n,t,e){return n+(e?" ":"")+t.toLowerCase()}),Ed=mu("toLowerCase");function yd(n,t,e){n=W(n),t=R(t);var r=t?Dt(n):0;if(!t||r>=t)return n;var s=(t-r)/2;return Ve(We(s),e)+n+Ve(Ue(s),e)}function Sd(n,t,e){n=W(n),t=R(t);var r=t?Dt(n):0;return t&&r<t?n+Ve(t-r,e):n}function Od(n,t,e){n=W(n),t=R(t);var r=t?Dt(n):0;return t&&r<t?Ve(t-r,e)+n:n}function Rd(n,t,e){return e||t==null?t=0:t&&(t=+t),$f(W(n).replace(Er,""),t||0)}function bd(n,t,e){return (e?rn(n,t,e):t===i)?t=1:t=R(t),ri(W(n),t)}function Td(){var n=arguments,t=W(n[0]);return n.length<3?t:t.replace(n[1],n[2])}var Ld=Mt(function(n,t,e){return n+(e?"_":"")+t.toLowerCase()});function Dd(n,t,e){return e&&typeof e!="number"&&rn(n,t,e)&&(t=e=i),e=e===i?Nn:e>>>0,e?(n=W(n),n&&(typeof t=="string"||t!=null&&!yi(t))&&(t=ln(t),!t&&Lt(n))?ut(On(n),0,e):n.split(t,e)):[]}var Hd=Mt(function(n,t,e){return n+(e?" ":"")+Ri(t)});function Nd(n,t,e){return n=W(n),e=e==null?0:vt(R(e),0,n.length),t=ln(t),n.slice(e,e+t.length)==t}function $d(n,t,e){var r=a.templateSettings;e&&rn(n,t,e)&&(t=i),n=W(n),t=fr({},t,r,Eu);var s=fr({},t.imports,r.imports,Eu),o=V(s),f=Mr(s,o),c,l,v=0,_=t.interpolate||Ce,m="__p += '",P=Br((t.escape||Ce).source+"|"+_.source+"|"+(_===Zi?po:Ce).source+"|"+(t.evaluate||Ce).source+"|$","g"),I="//# sourceURL="+(F.call(t,"sourceURL")?(t.sourceURL+"").replace(/\s/g," "):"lodash.templateSources["+ ++zo+"]")+`
`;n.replace(P,function(y,H,$,dn,sn,gn){return $||($=dn),m+=n.slice(v,gn).replace(Ao,hf),H&&(c=!0,m+=`' +
__e(`+H+`) +
'`),sn&&(l=!0,m+=`';
`+sn+`;
__p += '`),$&&(m+=`' +
((__t = (`+$+`)) == null ? '' : __t) +
'`),v=gn+y.length,y}),m+=`';
`;var E=F.call(t,"variable")&&t.variable;if(!E)m=`with (obj) {
`+m+`
}
`;else if(ho.test(E))throw new S(En);m=(l?m.replace(Xa,""):m).replace(Qa,"$1").replace(Va,"$1;"),m="function("+(E||"obj")+`) {
`+(E?"":`obj || (obj = {});
`)+"var __t, __p = ''"+(c?", __e = _.escape":"")+(l?`, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
`:`;
`)+m+`return __p
}`;var b=_a(function(){return U(o,I+"return "+m).apply(i,f)});if(b.source=m,Ei(b))throw b;return b}function Ud(n){return W(n).toLowerCase()}function Wd(n){return W(n).toUpperCase()}function Fd(n,t,e){if(n=W(n),n&&(e||t===i))return ys(n);if(!n||!(t=ln(t)))return n;var r=On(n),s=On(t),o=Ss(r,s),f=Os(r,s)+1;return ut(r,o,f).join("")}function Md(n,t,e){if(n=W(n),n&&(e||t===i))return n.slice(0,bs(n)+1);if(!n||!(t=ln(t)))return n;var r=On(n),s=Os(r,On(t))+1;return ut(r,0,s).join("")}function qd(n,t,e){if(n=W(n),n&&(e||t===i))return n.replace(Er,"");if(!n||!(t=ln(t)))return n;var r=On(n),s=Ss(r,On(t));return ut(r,s).join("")}function Bd(n,t){var e=Da,r=Ha;if(K(t)){var s="separator"in t?t.separator:s;e="length"in t?R(t.length):e,r="omission"in t?ln(t.omission):r;}n=W(n);var o=n.length;if(Lt(n)){var f=On(n);o=f.length;}if(e>=o)return n;var c=e-Dt(r);if(c<1)return r;var l=f?ut(f,0,c).join(""):n.slice(0,c);if(s===i)return l+r;if(f&&(c+=l.length-c),yi(s)){if(n.slice(c).search(s)){var v,_=l;for(s.global||(s=Br(s.source,W(Ji.exec(s))+"g")),s.lastIndex=0;v=s.exec(_);)var m=v.index;l=l.slice(0,m===i?c:m);}}else if(n.indexOf(ln(s),c)!=c){var P=l.lastIndexOf(s);P>-1&&(l=l.slice(0,P));}return l+r}function Gd(n){return n=W(n),n&&ka.test(n)?n.replace(Ki,mf):n}var zd=Mt(function(n,t,e){return n+(e?" ":"")+t.toUpperCase()}),Ri=mu("toUpperCase");function va(n,t,e){return n=W(n),t=e?i:t,t===i?pf(n)?Af(n):rf(n):n.match(t)||[]}var _a=T(function(n,t){try{return cn(n,i,t)}catch(e){return Ei(e)?e:new S(e)}}),Kd=Yn(function(n,t){return mn(t,function(e){e=Wn(e),zn(n,e,Ii(n[e],n));}),n});function Yd(n){var t=n==null?0:n.length,e=x();return n=t?G(n,function(r){if(typeof r[1]!="function")throw new wn(D);return [e(r[0]),r[1]]}):[],T(function(r){for(var s=-1;++s<t;){var o=n[s];if(cn(o[0],this,r))return cn(o[1],this,r)}})}function Zd(n){return mc(An(n,Ln))}function bi(n){return function(){return n}}function Jd(n,t){return n==null||n!==n?t:n}var Xd=Pu(),Qd=Pu(!0);function fn(n){return n}function Ti(n){return Qs(typeof n=="function"?n:An(n,Ln))}function Vd(n){return ks(An(n,Ln))}function kd(n,t){return js(n,An(t,Ln))}var jd=T(function(n,t){return function(e){return ae(e,n,t)}}),ng=T(function(n,t){return function(e){return ae(n,e,t)}});function Li(n,t,e){var r=V(t),s=ze(t,r);e==null&&!(K(t)&&(s.length||!r.length))&&(e=t,t=n,n=this,s=ze(t,V(t)));var o=!(K(e)&&"chain"in e)||!!e.chain,f=Jn(n);return mn(s,function(c){var l=t[c];n[c]=l,f&&(n.prototype[c]=function(){var v=this.__chain__;if(o||v){var _=n(this.__wrapped__),m=_.__actions__=un(this.__actions__);return m.push({func:l,args:arguments,thisArg:n}),_.__chain__=v,_}return l.apply(n,nt([this.value()],arguments))});}),n}function tg(){return k._===this&&(k._=Sf),this}function Di(){}function eg(n){return n=R(n),T(function(t){return nu(t,n)})}var rg=ci(G),ig=ci(As),sg=ci(Nr);function ma(n){return _i(n)?$r(Wn(n)):Nc(n)}function ug(n){return function(t){return n==null?i:_t(n,t)}}var ag=Cu(),og=Cu(!0);function Hi(){return []}function Ni(){return !1}function fg(){return {}}function cg(){return ""}function hg(){return !0}function lg(n,t){if(n=R(n),n<1||n>kn)return [];var e=Nn,r=nn(n,Nn);t=x(t),n-=Nn;for(var s=Fr(r,t);++e<n;)t(e);return s}function pg(n){return O(n)?G(n,Wn):pn(n)?[n]:un(Wu(W(n)))}function dg(n){var t=++Ef;return W(n)+t}var gg=Qe(function(n,t){return n+t},0),vg=hi("ceil"),_g=Qe(function(n,t){return n/t},1),mg=hi("floor");function wg(n){return n&&n.length?Ge(n,fn,Qr):i}function Pg(n,t){return n&&n.length?Ge(n,x(t,2),Qr):i}function Ag(n){return xs(n,fn)}function Cg(n,t){return xs(n,x(t,2))}function Ig(n){return n&&n.length?Ge(n,fn,ni):i}function xg(n,t){return n&&n.length?Ge(n,x(t,2),ni):i}var Eg=Qe(function(n,t){return n*t},1),yg=hi("round"),Sg=Qe(function(n,t){return n-t},0);function Og(n){return n&&n.length?Wr(n,fn):0}function Rg(n,t){return n&&n.length?Wr(n,x(t,2)):0}return a.after=Vl,a.ary=Xu,a.assign=Wp,a.assignIn=fa,a.assignInWith=fr,a.assignWith=Fp,a.at=Mp,a.before=Qu,a.bind=Ii,a.bindAll=Kd,a.bindKey=Vu,a.castArray=fp,a.chain=Yu,a.chunk=mh,a.compact=wh,a.concat=Ph,a.cond=Yd,a.conforms=Zd,a.constant=bi,a.countBy=Ol,a.create=qp,a.curry=ku,a.curryRight=ju,a.debounce=na,a.defaults=Bp,a.defaultsDeep=Gp,a.defer=kl,a.delay=jl,a.difference=Ah,a.differenceBy=Ch,a.differenceWith=Ih,a.drop=xh,a.dropRight=Eh,a.dropRightWhile=yh,a.dropWhile=Sh,a.fill=Oh,a.filter=bl,a.flatMap=Dl,a.flatMapDeep=Hl,a.flatMapDepth=Nl,a.flatten=Bu,a.flattenDeep=Rh,a.flattenDepth=bh,a.flip=np,a.flow=Xd,a.flowRight=Qd,a.fromPairs=Th,a.functions=Qp,a.functionsIn=Vp,a.groupBy=$l,a.initial=Dh,a.intersection=Hh,a.intersectionBy=Nh,a.intersectionWith=$h,a.invert=jp,a.invertBy=nd,a.invokeMap=Wl,a.iteratee=Ti,a.keyBy=Fl,a.keys=V,a.keysIn=on,a.map=rr,a.mapKeys=ed,a.mapValues=rd,a.matches=Vd,a.matchesProperty=kd,a.memoize=sr,a.merge=id,a.mergeWith=ca,a.method=jd,a.methodOf=ng,a.mixin=Li,a.negate=ur,a.nthArg=eg,a.omit=sd,a.omitBy=ud,a.once=tp,a.orderBy=Ml,a.over=rg,a.overArgs=ep,a.overEvery=ig,a.overSome=sg,a.partial=xi,a.partialRight=ta,a.partition=ql,a.pick=ad,a.pickBy=ha,a.property=ma,a.propertyOf=ug,a.pull=Mh,a.pullAll=zu,a.pullAllBy=qh,a.pullAllWith=Bh,a.pullAt=Gh,a.range=ag,a.rangeRight=og,a.rearg=rp,a.reject=zl,a.remove=zh,a.rest=ip,a.reverse=Ai,a.sampleSize=Yl,a.set=fd,a.setWith=cd,a.shuffle=Zl,a.slice=Kh,a.sortBy=Ql,a.sortedUniq=kh,a.sortedUniqBy=jh,a.split=Dd,a.spread=sp,a.tail=nl,a.take=tl,a.takeRight=el,a.takeRightWhile=rl,a.takeWhile=il,a.tap=wl,a.throttle=up,a.thru=er,a.toArray=ua,a.toPairs=la,a.toPairsIn=pa,a.toPath=pg,a.toPlainObject=oa,a.transform=hd,a.unary=ap,a.union=sl,a.unionBy=ul,a.unionWith=al,a.uniq=ol,a.uniqBy=fl,a.uniqWith=cl,a.unset=ld,a.unzip=Ci,a.unzipWith=Ku,a.update=pd,a.updateWith=dd,a.values=Gt,a.valuesIn=gd,a.without=hl,a.words=va,a.wrap=op,a.xor=ll,a.xorBy=pl,a.xorWith=dl,a.zip=gl,a.zipObject=vl,a.zipObjectDeep=_l,a.zipWith=ml,a.entries=la,a.entriesIn=pa,a.extend=fa,a.extendWith=fr,Li(a,a),a.add=gg,a.attempt=_a,a.camelCase=wd,a.capitalize=da,a.ceil=vg,a.clamp=vd,a.clone=cp,a.cloneDeep=lp,a.cloneDeepWith=pp,a.cloneWith=hp,a.conformsTo=dp,a.deburr=ga,a.defaultTo=Jd,a.divide=_g,a.endsWith=Pd,a.eq=bn,a.escape=Ad,a.escapeRegExp=Cd,a.every=Rl,a.find=Tl,a.findIndex=Mu,a.findKey=zp,a.findLast=Ll,a.findLastIndex=qu,a.findLastKey=Kp,a.floor=mg,a.forEach=Zu,a.forEachRight=Ju,a.forIn=Yp,a.forInRight=Zp,a.forOwn=Jp,a.forOwnRight=Xp,a.get=Si,a.gt=gp,a.gte=vp,a.has=kp,a.hasIn=Oi,a.head=Gu,a.identity=fn,a.includes=Ul,a.indexOf=Lh,a.inRange=_d,a.invoke=td,a.isArguments=Pt,a.isArray=O,a.isArrayBuffer=_p,a.isArrayLike=an,a.isArrayLikeObject=Z,a.isBoolean=mp,a.isBuffer=at,a.isDate=wp,a.isElement=Pp,a.isEmpty=Ap,a.isEqual=Cp,a.isEqualWith=Ip,a.isError=Ei,a.isFinite=xp,a.isFunction=Jn,a.isInteger=ea,a.isLength=ar,a.isMap=ra,a.isMatch=Ep,a.isMatchWith=yp,a.isNaN=Sp,a.isNative=Op,a.isNil=bp,a.isNull=Rp,a.isNumber=ia,a.isObject=K,a.isObjectLike=Y,a.isPlainObject=pe,a.isRegExp=yi,a.isSafeInteger=Tp,a.isSet=sa,a.isString=or,a.isSymbol=pn,a.isTypedArray=Bt,a.isUndefined=Lp,a.isWeakMap=Dp,a.isWeakSet=Hp,a.join=Uh,a.kebabCase=Id,a.last=In,a.lastIndexOf=Wh,a.lowerCase=xd,a.lowerFirst=Ed,a.lt=Np,a.lte=$p,a.max=wg,a.maxBy=Pg,a.mean=Ag,a.meanBy=Cg,a.min=Ig,a.minBy=xg,a.stubArray=Hi,a.stubFalse=Ni,a.stubObject=fg,a.stubString=cg,a.stubTrue=hg,a.multiply=Eg,a.nth=Fh,a.noConflict=tg,a.noop=Di,a.now=ir,a.pad=yd,a.padEnd=Sd,a.padStart=Od,a.parseInt=Rd,a.random=md,a.reduce=Bl,a.reduceRight=Gl,a.repeat=bd,a.replace=Td,a.result=od,a.round=yg,a.runInContext=h,a.sample=Kl,a.size=Jl,a.snakeCase=Ld,a.some=Xl,a.sortedIndex=Yh,a.sortedIndexBy=Zh,a.sortedIndexOf=Jh,a.sortedLastIndex=Xh,a.sortedLastIndexBy=Qh,a.sortedLastIndexOf=Vh,a.startCase=Hd,a.startsWith=Nd,a.subtract=Sg,a.sum=Og,a.sumBy=Rg,a.template=$d,a.times=lg,a.toFinite=Xn,a.toInteger=R,a.toLength=aa,a.toLower=Ud,a.toNumber=xn,a.toSafeInteger=Up,a.toString=W,a.toUpper=Wd,a.trim=Fd,a.trimEnd=Md,a.trimStart=qd,a.truncate=Bd,a.unescape=Gd,a.uniqueId=dg,a.upperCase=zd,a.upperFirst=Ri,a.each=Zu,a.eachRight=Ju,a.first=Gu,Li(a,function(){var n={};return $n(a,function(t,e){F.call(a.prototype,e)||(n[e]=t);}),n}(),{chain:!1}),a.VERSION=d,mn(["bind","bindKey","curry","curryRight","partial","partialRight"],function(n){a[n].placeholder=a;}),mn(["drop","take"],function(n,t){N.prototype[n]=function(e){e=e===i?1:Q(R(e),0);var r=this.__filtered__&&!t?new N(this):this.clone();return r.__filtered__?r.__takeCount__=nn(e,r.__takeCount__):r.__views__.push({size:nn(e,Nn),type:n+(r.__dir__<0?"Right":"")}),r},N.prototype[n+"Right"]=function(e){return this.reverse()[n](e).reverse()};}),mn(["filter","map","takeWhile"],function(n,t){var e=t+1,r=e==Bi||e==Wa;N.prototype[n]=function(s){var o=this.clone();return o.__iteratees__.push({iteratee:x(s,3),type:e}),o.__filtered__=o.__filtered__||r,o};}),mn(["head","last"],function(n,t){var e="take"+(t?"Right":"");N.prototype[n]=function(){return this[e](1).value()[0]};}),mn(["initial","tail"],function(n,t){var e="drop"+(t?"":"Right");N.prototype[n]=function(){return this.__filtered__?new N(this):this[e](1)};}),N.prototype.compact=function(){return this.filter(fn)},N.prototype.find=function(n){return this.filter(n).head()},N.prototype.findLast=function(n){return this.reverse().find(n)},N.prototype.invokeMap=T(function(n,t){return typeof n=="function"?new N(this):this.map(function(e){return ae(e,n,t)})}),N.prototype.reject=function(n){return this.filter(ur(x(n)))},N.prototype.slice=function(n,t){n=R(n);var e=this;return e.__filtered__&&(n>0||t<0)?new N(e):(n<0?e=e.takeRight(-n):n&&(e=e.drop(n)),t!==i&&(t=R(t),e=t<0?e.dropRight(-t):e.take(t-n)),e)},N.prototype.takeRightWhile=function(n){return this.reverse().takeWhile(n).reverse()},N.prototype.toArray=function(){return this.take(Nn)},$n(N.prototype,function(n,t){var e=/^(?:filter|find|map|reject)|While$/.test(t),r=/^(?:head|last)$/.test(t),s=a[r?"take"+(t=="last"?"Right":""):t],o=r||/^find/.test(t);s&&(a.prototype[t]=function(){var f=this.__wrapped__,c=r?[1]:arguments,l=f instanceof N,v=c[0],_=l||O(f),m=function(H){var $=s.apply(a,nt([H],c));return r&&P?$[0]:$};_&&e&&typeof v=="function"&&v.length!=1&&(l=_=!1);var P=this.__chain__,I=!!this.__actions__.length,E=o&&!P,b=l&&!I;if(!o&&_){f=b?f:new N(this);var y=n.apply(f,c);return y.__actions__.push({func:er,args:[m],thisArg:i}),new Pn(y,P)}return E&&b?n.apply(this,c):(y=this.thru(m),E?r?y.value()[0]:y.value():y)});}),mn(["pop","push","shift","sort","splice","unshift"],function(n){var t=Oe[n],e=/^(?:push|sort|unshift)$/.test(n)?"tap":"thru",r=/^(?:pop|shift)$/.test(n);a.prototype[n]=function(){var s=arguments;if(r&&!this.__chain__){var o=this.value();return t.apply(O(o)?o:[],s)}return this[e](function(f){return t.apply(O(f)?f:[],s)})};}),$n(N.prototype,function(n,t){var e=a[t];if(e){var r=e.name+"";F.call(Ut,r)||(Ut[r]=[]),Ut[r].push({name:t,func:e});}}),Ut[Xe(i,ct).name]=[{name:"wrapper",func:i}],N.prototype.clone=Gf,N.prototype.reverse=zf,N.prototype.value=Kf,a.prototype.at=Pl,a.prototype.chain=Al,a.prototype.commit=Cl,a.prototype.next=Il,a.prototype.plant=El,a.prototype.reverse=yl,a.prototype.toJSON=a.prototype.valueOf=a.prototype.value=Sl,a.prototype.first=a.prototype.head,ne&&(a.prototype[ne]=xl),a},Ht=Cf();lt?((lt.exports=Ht)._=Ht,Tr._=Ht):k._=Ht;}).call(ge);})(Ui,Ui.exports);var Gg=Object.defineProperty,zg=Object.defineProperties,Kg=Object.getOwnPropertyDescriptors,Ea=Object.getOwnPropertySymbols,Yg=Object.prototype.hasOwnProperty,Zg=Object.prototype.propertyIsEnumerable,ya=(A,u,i)=>u in A?Gg(A,u,{enumerable:!0,configurable:!0,writable:!0,value:i}):A[u]=i,cr$1=(A,u)=>{for(var i in u||(u={}))Yg.call(u,i)&&ya(A,i,u[i]);if(Ea)for(var i of Ea(u))Zg.call(u,i)&&ya(A,i,u[i]);return A},Jg=(A,u)=>zg(A,Kg(u));function ft$3(A,u,i){var d;const w=ve$1(A);return ((d=u.rpcMap)==null?void 0:d[w.reference])||`${Bg}?chainId=${w.namespace}:${w.reference}&projectId=${i}`}function Ct$1(A){return A.includes(":")?A.split(":")[1]:A}function Sa(A){return A.map(u=>`${u.split(":")[0]}:${u.split(":")[1]}`)}function Xg(A,u){const i=Object.keys(u.namespaces).filter(w=>w.includes(A));if(!i.length)return [];const d=[];return i.forEach(w=>{const L=u.namespaces[w].accounts;d.push(...L);}),d}function Oa(A={},u={}){const i=Ra(A),d=Ra(u);return Ui.exports.merge(i,d)}function Ra(A){var u,i,d,w;const L={};if(!B$6(A))return L;for(const[D,En]of Object.entries(A)){const zt=oe$3(D)?[D]:En.chains,pr=En.methods||[],It=En.events||[],Ln=En.rpcMap||{},Fn=en(D);L[Fn]=Jg(cr$1(cr$1({},L[Fn]),En),{chains:S$d(zt,(u=L[Fn])==null?void 0:u.chains),methods:S$d(pr,(i=L[Fn])==null?void 0:i.methods),events:S$d(It,(d=L[Fn])==null?void 0:d.events),rpcMap:cr$1(cr$1({},Ln),(w=L[Fn])==null?void 0:w.rpcMap)});}return L}function Qg(A){return A.includes(":")?A.split(":")[2]:A}function Vg(A){const u={};for(const[i,d]of Object.entries(A)){const w=d.methods||[],L=d.events||[],D=d.accounts||[],En=oe$3(i)?[i]:d.chains?d.chains:Sa(d.accounts);u[i]={chains:En,methods:w,events:L,accounts:D};}return u}function Wi(A){return typeof A=="number"?A:A.includes("0x")?parseInt(A,16):(A=A.includes(":")?A.split(":")[1]:A,isNaN(Number(A))?A:Number(A))}const ba={},z$5=A=>ba[A],Fi=(A,u)=>{ba[A]=u;};class kg{constructor(u){this.name="polkadot",this.namespace=u.namespace,this.events=z$5("events"),this.client=z$5("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders();}updateNamespace(u){this.namespace=Object.assign(this.namespace,u);}requestAccounts(){return this.getAccounts()}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const u=this.namespace.chains[0];if(!u)throw new Error("ChainId not found");return u.split(":")[1]}request(u){return this.namespace.methods.includes(u.request.method)?this.client.request(u):this.getHttpProvider().request(u.request)}setDefaultChain(u,i){this.httpProviders[u]||this.setHttpProvider(u,i),this.chainId=u,this.events.emit(Vn.DEFAULT_CHAIN_CHANGED,`${this.name}:${u}`);}getAccounts(){const u=this.namespace.accounts;return u?u.filter(i=>i.split(":")[1]===this.chainId.toString()).map(i=>i.split(":")[2])||[]:[]}createHttpProviders(){const u={};return this.namespace.chains.forEach(i=>{var d;const w=Ct$1(i);u[w]=this.createHttpProvider(w,(d=this.namespace.rpcMap)==null?void 0:d[i]);}),u}getHttpProvider(){const u=`${this.name}:${this.chainId}`,i=this.httpProviders[u];if(typeof i>"u")throw new Error(`JSON-RPC provider for ${u} not found`);return i}setHttpProvider(u,i){const d=this.createHttpProvider(u,i);d&&(this.httpProviders[u]=d);}createHttpProvider(u,i){const d=i||ft$3(u,this.namespace,this.client.core.projectId);if(!d)throw new Error(`No RPC url provided for chainId: ${u}`);return new JsonRpcProvider(new HttpConnection(d,z$5("disableProviderPing")))}}class jg{constructor(u){this.name="eip155",this.namespace=u.namespace,this.events=z$5("events"),this.client=z$5("client"),this.httpProviders=this.createHttpProviders(),this.chainId=parseInt(this.getDefaultChain());}async request(u){switch(u.request.method){case"eth_requestAccounts":return this.getAccounts();case"eth_accounts":return this.getAccounts();case"wallet_switchEthereumChain":return await this.handleSwitchChain(u);case"eth_chainId":return parseInt(this.getDefaultChain())}return this.namespace.methods.includes(u.request.method)?await this.client.request(u):this.getHttpProvider().request(u.request)}updateNamespace(u){this.namespace=Object.assign(this.namespace,u);}setDefaultChain(u,i){this.httpProviders[u]||this.setHttpProvider(parseInt(u),i),this.chainId=parseInt(u),this.events.emit(Vn.DEFAULT_CHAIN_CHANGED,`${this.name}:${u}`);}requestAccounts(){return this.getAccounts()}getDefaultChain(){if(this.chainId)return this.chainId.toString();if(this.namespace.defaultChain)return this.namespace.defaultChain;const u=this.namespace.chains[0];if(!u)throw new Error("ChainId not found");return u.split(":")[1]}createHttpProvider(u,i){const d=i||ft$3(`${this.name}:${u}`,this.namespace,this.client.core.projectId);if(!d)throw new Error(`No RPC url provided for chainId: ${u}`);return new JsonRpcProvider(new HttpConnection(d,z$5("disableProviderPing")))}setHttpProvider(u,i){const d=this.createHttpProvider(u,i);d&&(this.httpProviders[u]=d);}createHttpProviders(){const u={};return this.namespace.chains.forEach(i=>{var d;const w=parseInt(Ct$1(i));u[w]=this.createHttpProvider(w,(d=this.namespace.rpcMap)==null?void 0:d[i]);}),u}getAccounts(){const u=this.namespace.accounts;return u?[...new Set(u.filter(i=>i.split(":")[1]===this.chainId.toString()).map(i=>i.split(":")[2]))]:[]}getHttpProvider(){const u=this.chainId,i=this.httpProviders[u];if(typeof i>"u")throw new Error(`JSON-RPC provider for ${u} not found`);return i}async handleSwitchChain(u){var i,d;let w=u.request.params?(i=u.request.params[0])==null?void 0:i.chainId:"0x0";w=w.startsWith("0x")?w:`0x${w}`;const L=parseInt(w,16);if(this.isChainApproved(L))this.setDefaultChain(`${L}`);else if(this.namespace.methods.includes("wallet_switchEthereumChain"))await this.client.request({topic:u.topic,request:{method:u.request.method,params:[{chainId:w}]},chainId:(d=this.namespace.chains)==null?void 0:d[0]}),this.setDefaultChain(`${L}`);else throw new Error(`Failed to switch to chain 'eip155:${L}'. The chain is not approved or the wallet does not support 'wallet_switchEthereumChain' method.`);return null}isChainApproved(u){return this.namespace.chains.includes(`${this.name}:${u}`)}}class nv{constructor(u){this.name="solana",this.namespace=u.namespace,this.events=z$5("events"),this.client=z$5("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders();}updateNamespace(u){this.namespace=Object.assign(this.namespace,u);}requestAccounts(){return this.getAccounts()}request(u){return this.namespace.methods.includes(u.request.method)?this.client.request(u):this.getHttpProvider().request(u.request)}setDefaultChain(u,i){this.httpProviders[u]||this.setHttpProvider(u,i),this.chainId=u,this.events.emit(Vn.DEFAULT_CHAIN_CHANGED,`${this.name}:${u}`);}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const u=this.namespace.chains[0];if(!u)throw new Error("ChainId not found");return u.split(":")[1]}getAccounts(){const u=this.namespace.accounts;return u?[...new Set(u.filter(i=>i.split(":")[1]===this.chainId.toString()).map(i=>i.split(":")[2]))]:[]}createHttpProviders(){const u={};return this.namespace.chains.forEach(i=>{var d;const w=Ct$1(i);u[w]=this.createHttpProvider(w,(d=this.namespace.rpcMap)==null?void 0:d[i]);}),u}getHttpProvider(){const u=`${this.name}:${this.chainId}`,i=this.httpProviders[u];if(typeof i>"u")throw new Error(`JSON-RPC provider for ${u} not found`);return i}setHttpProvider(u,i){const d=this.createHttpProvider(u,i);d&&(this.httpProviders[u]=d);}createHttpProvider(u,i){const d=i||ft$3(u,this.namespace,this.client.core.projectId);if(!d)throw new Error(`No RPC url provided for chainId: ${u}`);return new JsonRpcProvider(new HttpConnection(d,z$5("disableProviderPing")))}}class tv{constructor(u){this.name="cosmos",this.namespace=u.namespace,this.events=z$5("events"),this.client=z$5("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders();}updateNamespace(u){this.namespace=Object.assign(this.namespace,u);}requestAccounts(){return this.getAccounts()}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const u=this.namespace.chains[0];if(!u)throw new Error("ChainId not found");return u.split(":")[1]}request(u){return this.namespace.methods.includes(u.request.method)?this.client.request(u):this.getHttpProvider().request(u.request)}setDefaultChain(u,i){this.httpProviders[u]||this.setHttpProvider(u,i),this.chainId=u,this.events.emit(Vn.DEFAULT_CHAIN_CHANGED,`${this.name}:${this.chainId}`);}getAccounts(){const u=this.namespace.accounts;return u?[...new Set(u.filter(i=>i.split(":")[1]===this.chainId.toString()).map(i=>i.split(":")[2]))]:[]}createHttpProviders(){const u={};return this.namespace.chains.forEach(i=>{var d;const w=Ct$1(i);u[w]=this.createHttpProvider(w,(d=this.namespace.rpcMap)==null?void 0:d[i]);}),u}getHttpProvider(){const u=`${this.name}:${this.chainId}`,i=this.httpProviders[u];if(typeof i>"u")throw new Error(`JSON-RPC provider for ${u} not found`);return i}setHttpProvider(u,i){const d=this.createHttpProvider(u,i);d&&(this.httpProviders[u]=d);}createHttpProvider(u,i){const d=i||ft$3(u,this.namespace,this.client.core.projectId);if(!d)throw new Error(`No RPC url provided for chainId: ${u}`);return new JsonRpcProvider(new HttpConnection(d,z$5("disableProviderPing")))}}class ev{constructor(u){this.name="cip34",this.namespace=u.namespace,this.events=z$5("events"),this.client=z$5("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders();}updateNamespace(u){this.namespace=Object.assign(this.namespace,u);}requestAccounts(){return this.getAccounts()}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const u=this.namespace.chains[0];if(!u)throw new Error("ChainId not found");return u.split(":")[1]}request(u){return this.namespace.methods.includes(u.request.method)?this.client.request(u):this.getHttpProvider().request(u.request)}setDefaultChain(u,i){this.httpProviders[u]||this.setHttpProvider(u,i),this.chainId=u,this.events.emit(Vn.DEFAULT_CHAIN_CHANGED,`${this.name}:${this.chainId}`);}getAccounts(){const u=this.namespace.accounts;return u?[...new Set(u.filter(i=>i.split(":")[1]===this.chainId.toString()).map(i=>i.split(":")[2]))]:[]}createHttpProviders(){const u={};return this.namespace.chains.forEach(i=>{const d=this.getCardanoRPCUrl(i),w=Ct$1(i);u[w]=this.createHttpProvider(w,d);}),u}getHttpProvider(){const u=`${this.name}:${this.chainId}`,i=this.httpProviders[u];if(typeof i>"u")throw new Error(`JSON-RPC provider for ${u} not found`);return i}getCardanoRPCUrl(u){const i=this.namespace.rpcMap;if(i)return i[u]}setHttpProvider(u,i){const d=this.createHttpProvider(u,i);d&&(this.httpProviders[u]=d);}createHttpProvider(u,i){const d=i||this.getCardanoRPCUrl(u);if(!d)throw new Error(`No RPC url provided for chainId: ${u}`);return new JsonRpcProvider(new HttpConnection(d,z$5("disableProviderPing")))}}class rv{constructor(u){this.name="elrond",this.namespace=u.namespace,this.events=z$5("events"),this.client=z$5("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders();}updateNamespace(u){this.namespace=Object.assign(this.namespace,u);}requestAccounts(){return this.getAccounts()}request(u){return this.namespace.methods.includes(u.request.method)?this.client.request(u):this.getHttpProvider().request(u.request)}setDefaultChain(u,i){this.httpProviders[u]||this.setHttpProvider(u,i),this.chainId=u,this.events.emit(Vn.DEFAULT_CHAIN_CHANGED,`${this.name}:${u}`);}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const u=this.namespace.chains[0];if(!u)throw new Error("ChainId not found");return u.split(":")[1]}getAccounts(){const u=this.namespace.accounts;return u?[...new Set(u.filter(i=>i.split(":")[1]===this.chainId.toString()).map(i=>i.split(":")[2]))]:[]}createHttpProviders(){const u={};return this.namespace.chains.forEach(i=>{var d;const w=Ct$1(i);u[w]=this.createHttpProvider(w,(d=this.namespace.rpcMap)==null?void 0:d[i]);}),u}getHttpProvider(){const u=`${this.name}:${this.chainId}`,i=this.httpProviders[u];if(typeof i>"u")throw new Error(`JSON-RPC provider for ${u} not found`);return i}setHttpProvider(u,i){const d=this.createHttpProvider(u,i);d&&(this.httpProviders[u]=d);}createHttpProvider(u,i){const d=i||ft$3(u,this.namespace,this.client.core.projectId);if(!d)throw new Error(`No RPC url provided for chainId: ${u}`);return new JsonRpcProvider(new HttpConnection(d,z$5("disableProviderPing")))}}class iv{constructor(u){this.name="multiversx",this.namespace=u.namespace,this.events=z$5("events"),this.client=z$5("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders();}updateNamespace(u){this.namespace=Object.assign(this.namespace,u);}requestAccounts(){return this.getAccounts()}request(u){return this.namespace.methods.includes(u.request.method)?this.client.request(u):this.getHttpProvider().request(u.request)}setDefaultChain(u,i){this.httpProviders[u]||this.setHttpProvider(u,i),this.chainId=u,this.events.emit(Vn.DEFAULT_CHAIN_CHANGED,`${this.name}:${u}`);}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const u=this.namespace.chains[0];if(!u)throw new Error("ChainId not found");return u.split(":")[1]}getAccounts(){const u=this.namespace.accounts;return u?[...new Set(u.filter(i=>i.split(":")[1]===this.chainId.toString()).map(i=>i.split(":")[2]))]:[]}createHttpProviders(){const u={};return this.namespace.chains.forEach(i=>{var d;const w=Ct$1(i);u[w]=this.createHttpProvider(w,(d=this.namespace.rpcMap)==null?void 0:d[i]);}),u}getHttpProvider(){const u=`${this.name}:${this.chainId}`,i=this.httpProviders[u];if(typeof i>"u")throw new Error(`JSON-RPC provider for ${u} not found`);return i}setHttpProvider(u,i){const d=this.createHttpProvider(u,i);d&&(this.httpProviders[u]=d);}createHttpProvider(u,i){const d=i||ft$3(u,this.namespace,this.client.core.projectId);if(!d)throw new Error(`No RPC url provided for chainId: ${u}`);return new JsonRpcProvider(new HttpConnection(d,z$5("disableProviderPing")))}}class sv{constructor(u){this.name="near",this.namespace=u.namespace,this.events=z$5("events"),this.client=z$5("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders();}updateNamespace(u){this.namespace=Object.assign(this.namespace,u);}requestAccounts(){return this.getAccounts()}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const u=this.namespace.chains[0];if(!u)throw new Error("ChainId not found");return u.split(":")[1]}request(u){return this.namespace.methods.includes(u.request.method)?this.client.request(u):this.getHttpProvider().request(u.request)}setDefaultChain(u,i){if(this.chainId=u,!this.httpProviders[u]){const d=i||ft$3(`${this.name}:${u}`,this.namespace);if(!d)throw new Error(`No RPC url provided for chainId: ${u}`);this.setHttpProvider(u,d);}this.events.emit(Vn.DEFAULT_CHAIN_CHANGED,`${this.name}:${this.chainId}`);}getAccounts(){const u=this.namespace.accounts;return u?u.filter(i=>i.split(":")[1]===this.chainId.toString()).map(i=>i.split(":")[2])||[]:[]}createHttpProviders(){const u={};return this.namespace.chains.forEach(i=>{var d;u[i]=this.createHttpProvider(i,(d=this.namespace.rpcMap)==null?void 0:d[i]);}),u}getHttpProvider(){const u=`${this.name}:${this.chainId}`,i=this.httpProviders[u];if(typeof i>"u")throw new Error(`JSON-RPC provider for ${u} not found`);return i}setHttpProvider(u,i){const d=this.createHttpProvider(u,i);d&&(this.httpProviders[u]=d);}createHttpProvider(u,i){const d=i||ft$3(u,this.namespace);return typeof d>"u"?void 0:new JsonRpcProvider(new HttpConnection(d,z$5("disableProviderPing")))}}var uv=Object.defineProperty,av=Object.defineProperties,ov=Object.getOwnPropertyDescriptors,Ta=Object.getOwnPropertySymbols,fv=Object.prototype.hasOwnProperty,cv=Object.prototype.propertyIsEnumerable,La=(A,u,i)=>u in A?uv(A,u,{enumerable:!0,configurable:!0,writable:!0,value:i}):A[u]=i,hr$1=(A,u)=>{for(var i in u||(u={}))fv.call(u,i)&&La(A,i,u[i]);if(Ta)for(var i of Ta(u))cv.call(u,i)&&La(A,i,u[i]);return A},Mi=(A,u)=>av(A,ov(u));let lr$1 = class lr{constructor(u){this.events=new EventEmitter$1,this.rpcProviders={},this.shouldAbortPairingAttempt=!1,this.maxPairingAttempts=10,this.disableProviderPing=!1,this.providerOpts=u,this.logger=typeof u?.logger<"u"&&typeof u?.logger!="string"?u.logger:cjs$3.pino(cjs$3.getDefaultLoggerOptions({level:u?.logger||Ia})),this.disableProviderPing=u?.disableProviderPing||!1;}static async init(u){const i=new lr(u);return await i.initialize(),i}async request(u,i,d){const[w,L]=this.validateChain(i);if(!this.session)throw new Error("Please call connect() before request()");return await this.getProvider(w).request({request:hr$1({},u),chainId:`${w}:${L}`,topic:this.session.topic,expiry:d})}sendAsync(u,i,d,w){const L=new Date().getTime();this.request(u,d,w).then(D=>i(null,formatJsonRpcResult(L,D))).catch(D=>i(D,void 0));}async enable(){if(!this.client)throw new Error("Sign Client not initialized");return this.session||await this.connect({namespaces:this.namespaces,optionalNamespaces:this.optionalNamespaces,sessionProperties:this.sessionProperties}),await this.requestAccounts()}async disconnect(){var u;if(!this.session)throw new Error("Please call connect() before enable()");await this.client.disconnect({topic:(u=this.session)==null?void 0:u.topic,reason:U$3("USER_DISCONNECTED")}),await this.cleanup();}async connect(u){if(!this.client)throw new Error("Sign Client not initialized");if(this.setNamespaces(u),await this.cleanupPendingPairings(),!u.skipPairing)return await this.pair(u.pairingTopic)}on(u,i){this.events.on(u,i);}once(u,i){this.events.once(u,i);}removeListener(u,i){this.events.removeListener(u,i);}off(u,i){this.events.off(u,i);}get isWalletConnect(){return !0}async pair(u){this.shouldAbortPairingAttempt=!1;let i=0;do{if(this.shouldAbortPairingAttempt)throw new Error("Pairing aborted");if(i>=this.maxPairingAttempts)throw new Error("Max auto pairing attempts reached");const{uri:d,approval:w}=await this.client.connect({pairingTopic:u,requiredNamespaces:this.namespaces,optionalNamespaces:this.optionalNamespaces,sessionProperties:this.sessionProperties});d&&(this.uri=d,this.events.emit("display_uri",d)),await w().then(L=>{this.session=L;const D=Vg(L.namespaces);this.namespaces=Oa(this.namespaces,D),this.persist("namespaces",this.namespaces);}).catch(L=>{if(L.message!==ae$1)throw L;i++;});}while(!this.session);return this.onConnect(),this.session}setDefaultChain(u,i){try{if(!this.session)return;const[d,w]=this.validateChain(u);this.getProvider(d).setDefaultChain(w,i);}catch(d){if(!/Please call connect/.test(d.message))throw d}}async cleanupPendingPairings(u={}){this.logger.info("Cleaning up inactive pairings...");const i=this.client.pairing.getAll();if(k$8(i)){for(const d of i)u.deletePairings?this.client.core.expirer.set(d.topic,0):await this.client.core.relayer.subscriber.unsubscribe(d.topic);this.logger.info(`Inactive pairings cleared: ${i.length}`);}}abortPairingAttempt(){this.shouldAbortPairingAttempt=!0;}async checkStorage(){if(this.namespaces=await this.getFromStore("namespaces"),this.optionalNamespaces=await this.getFromStore("optionalNamespaces")||{},this.client.session.length){const u=this.client.session.keys.length-1;this.session=this.client.session.get(this.client.session.keys[u]),this.createProviders();}}async initialize(){this.logger.trace("Initialized"),await this.createClient(),await this.checkStorage(),this.registerEventListeners();}async createClient(){this.client=this.providerOpts.client||await Q$3.init({logger:this.providerOpts.logger||Ia,relayUrl:this.providerOpts.relayUrl||Fg,projectId:this.providerOpts.projectId,metadata:this.providerOpts.metadata,storageOptions:this.providerOpts.storageOptions,storage:this.providerOpts.storage,name:this.providerOpts.name}),this.logger.trace("SignClient Initialized");}createProviders(){if(!this.client)throw new Error("Sign Client not initialized");if(!this.session)throw new Error("Session not initialized. Please call connect() before enable()");const u=[...new Set(Object.keys(this.session.namespaces).map(i=>en(i)))];Fi("client",this.client),Fi("events",this.events),Fi("disableProviderPing",this.disableProviderPing),u.forEach(i=>{if(!this.session)return;const d=Xg(i,this.session),w=Sa(d),L=Oa(this.namespaces,this.optionalNamespaces),D=Mi(hr$1({},L[i]),{accounts:d,chains:w});switch(i){case"eip155":this.rpcProviders[i]=new jg({namespace:D});break;case"solana":this.rpcProviders[i]=new nv({namespace:D});break;case"cosmos":this.rpcProviders[i]=new tv({namespace:D});break;case"polkadot":this.rpcProviders[i]=new kg({namespace:D});break;case"cip34":this.rpcProviders[i]=new ev({namespace:D});break;case"elrond":this.rpcProviders[i]=new rv({namespace:D});break;case"multiversx":this.rpcProviders[i]=new iv({namespace:D});break;case"near":this.rpcProviders[i]=new sv({namespace:D});break}});}registerEventListeners(){if(typeof this.client>"u")throw new Error("Sign Client is not initialized");this.client.on("session_ping",u=>{this.events.emit("session_ping",u);}),this.client.on("session_event",u=>{const{params:i}=u,{event:d}=i;if(d.name==="accountsChanged"){const w=d.data;w&&k$8(w)&&this.events.emit("accountsChanged",w.map(Qg));}else if(d.name==="chainChanged"){const w=i.chainId,L=i.event.data,D=en(w),En=Wi(w)!==Wi(L)?`${D}:${Wi(L)}`:w;this.onChainChanged(En);}else this.events.emit(d.name,d.data);this.events.emit("session_event",u);}),this.client.on("session_update",({topic:u,params:i})=>{var d;const{namespaces:w}=i,L=(d=this.client)==null?void 0:d.session.get(u);this.session=Mi(hr$1({},L),{namespaces:w}),this.onSessionUpdate(),this.events.emit("session_update",{topic:u,params:i});}),this.client.on("session_delete",async u=>{await this.cleanup(),this.events.emit("session_delete",u),this.events.emit("disconnect",Mi(hr$1({},U$3("USER_DISCONNECTED")),{data:u.topic}));}),this.on(Vn.DEFAULT_CHAIN_CHANGED,u=>{this.onChainChanged(u,!0);});}getProvider(u){if(!this.rpcProviders[u])throw new Error(`Provider not found: ${u}`);return this.rpcProviders[u]}onSessionUpdate(){Object.keys(this.rpcProviders).forEach(u=>{var i;this.getProvider(u).updateNamespace((i=this.session)==null?void 0:i.namespaces[u]);});}setNamespaces(u){const{namespaces:i,optionalNamespaces:d,sessionProperties:w}=u;i&&Object.keys(i).length&&(this.namespaces=i),d&&Object.keys(d).length&&(this.optionalNamespaces=d),this.sessionProperties=w,this.persist("namespaces",i),this.persist("optionalNamespaces",d);}validateChain(u){const[i,d]=u?.split(":")||["",""];if(!this.namespaces||!Object.keys(this.namespaces).length)return [i,d];if(i&&!Object.keys(this.namespaces||{}).map(D=>en(D)).includes(i))throw new Error(`Namespace '${i}' is not configured. Please call connect() first with namespace config.`);if(i&&d)return [i,d];const w=en(Object.keys(this.namespaces)[0]),L=this.rpcProviders[w].getDefaultChain();return [w,L]}async requestAccounts(){const[u]=this.validateChain();return await this.getProvider(u).requestAccounts()}onChainChanged(u,i=!1){if(!this.namespaces)return;const[d,w]=this.validateChain(u);w&&(i||this.getProvider(d).setDefaultChain(w),this.namespaces[d]?this.namespaces[d].defaultChain=w:this.namespaces[`${d}:${w}`]?this.namespaces[`${d}:${w}`].defaultChain=w:this.namespaces[`${d}:${w}`]={defaultChain:w},this.persist("namespaces",this.namespaces),this.events.emit("chainChanged",w));}onConnect(){this.createProviders(),this.events.emit("connect",{session:this.session});}async cleanup(){this.session=void 0,this.namespaces=void 0,this.optionalNamespaces=void 0,this.sessionProperties=void 0,this.persist("namespaces",void 0),this.persist("optionalNamespaces",void 0),this.persist("sessionProperties",void 0),await this.cleanupPendingPairings({deletePairings:!0});}persist(u,i){this.client.core.storage.setItem(`${xa}/${u}`,i);}async getFromStore(u){return await this.client.core.storage.getItem(`${xa}/${u}`)}};const hv=lr$1;

    const P$6="wc",S$b="ethereum_provider",$$6=`${P$6}@2:${S$b}:`,j$7="https://rpc.walletconnect.com/v1/",u$a=["eth_sendTransaction","personal_sign"],E$6=["eth_accounts","eth_requestAccounts","eth_sendRawTransaction","eth_sign","eth_signTransaction","eth_signTypedData","eth_signTypedData_v3","eth_signTypedData_v4","eth_sendTransaction","personal_sign","wallet_switchEthereumChain","wallet_addEthereumChain","wallet_getPermissions","wallet_requestPermissions","wallet_registerOnboarding","wallet_watchAsset","wallet_scanQRCode"],m$7=["chainChanged","accountsChanged"],_$8=["chainChanged","accountsChanged","message","disconnect","connect"];var N$6=Object.defineProperty,q$4=Object.defineProperties,D$5=Object.getOwnPropertyDescriptors,y$b=Object.getOwnPropertySymbols,U$1=Object.prototype.hasOwnProperty,Q$2=Object.prototype.propertyIsEnumerable,O$2=(a,t,s)=>t in a?N$6(a,t,{enumerable:!0,configurable:!0,writable:!0,value:s}):a[t]=s,p$a=(a,t)=>{for(var s in t||(t={}))U$1.call(t,s)&&O$2(a,s,t[s]);if(y$b)for(var s of y$b(t))Q$2.call(t,s)&&O$2(a,s,t[s]);return a},M$6=(a,t)=>q$4(a,D$5(t));function g$7(a){return Number(a[0].split(":")[1])}function f$d(a){return `0x${a.toString(16)}`}function L$7(a){const{chains:t,optionalChains:s,methods:i,optionalMethods:n,events:e,optionalEvents:h,rpcMap:c}=a;if(!k$8(t))throw new Error("Invalid chains");const o={chains:t,methods:i||u$a,events:e||m$7,rpcMap:p$a({},t.length?{[g$7(t)]:c[g$7(t)]}:{})},r=e?.filter(l=>!m$7.includes(l)),d=i?.filter(l=>!u$a.includes(l));if(!s&&!h&&!n&&!(r!=null&&r.length)&&!(d!=null&&d.length))return {required:t.length?o:void 0};const C=r?.length&&d?.length||!s,I={chains:[...new Set(C?o.chains.concat(s||[]):s)],methods:[...new Set(o.methods.concat(n!=null&&n.length?n:E$6))],events:[...new Set(o.events.concat(h!=null&&h.length?h:_$8))],rpcMap:c};return {required:t.length?o:void 0,optional:s.length?I:void 0}}let v$7 = class v{constructor(){this.events=new EventEmitter$1,this.namespace="eip155",this.accounts=[],this.chainId=1,this.STORAGE_KEY=$$6,this.on=(t,s)=>(this.events.on(t,s),this),this.once=(t,s)=>(this.events.once(t,s),this),this.removeListener=(t,s)=>(this.events.removeListener(t,s),this),this.off=(t,s)=>(this.events.off(t,s),this),this.parseAccount=t=>this.isCompatibleChainId(t)?this.parseAccountId(t).address:t,this.signer={},this.rpc={};}static async init(t){const s=new v;return await s.initialize(t),s}async request(t,s){return await this.signer.request(t,this.formatChainId(this.chainId),s)}sendAsync(t,s,i){this.signer.sendAsync(t,s,this.formatChainId(this.chainId),i);}get connected(){return this.signer.client?this.signer.client.core.relayer.connected:!1}get connecting(){return this.signer.client?this.signer.client.core.relayer.connecting:!1}async enable(){return this.session||await this.connect(),await this.request({method:"eth_requestAccounts"})}async connect(t){if(!this.signer.client)throw new Error("Provider not initialized. Call init() first");this.loadConnectOpts(t);const{required:s,optional:i}=L$7(this.rpc);try{const n=await new Promise(async(h,c)=>{var o;this.rpc.showQrModal&&((o=this.modal)==null||o.subscribeModal(r=>{!r.open&&!this.signer.session&&(this.signer.abortPairingAttempt(),c(new Error("Connection request reset. Please try again.")));})),await this.signer.connect(M$6(p$a({namespaces:p$a({},s&&{[this.namespace]:s})},i&&{optionalNamespaces:{[this.namespace]:i}}),{pairingTopic:t?.pairingTopic})).then(r=>{h(r);}).catch(r=>{c(new Error(r.message));});});if(!n)return;const e=Un(n.namespaces,[this.namespace]);this.setChainIds(this.rpc.chains.length?this.rpc.chains:e),this.setAccounts(e),this.events.emit("connect",{chainId:f$d(this.chainId)});}catch(n){throw this.signer.logger.error(n),n}finally{this.modal&&this.modal.closeModal();}}async disconnect(){this.session&&await this.signer.disconnect(),this.reset();}get isWalletConnect(){return !0}get session(){return this.signer.session}registerEventListeners(){this.signer.on("session_event",t=>{const{params:s}=t,{event:i}=s;i.name==="accountsChanged"?(this.accounts=this.parseAccounts(i.data),this.events.emit("accountsChanged",this.accounts)):i.name==="chainChanged"?this.setChainId(this.formatChainId(i.data)):this.events.emit(i.name,i.data),this.events.emit("session_event",t);}),this.signer.on("chainChanged",t=>{const s=parseInt(t);this.chainId=s,this.events.emit("chainChanged",f$d(this.chainId)),this.persist();}),this.signer.on("session_update",t=>{this.events.emit("session_update",t);}),this.signer.on("session_delete",t=>{this.reset(),this.events.emit("session_delete",t),this.events.emit("disconnect",M$6(p$a({},U$3("USER_DISCONNECTED")),{data:t.topic,name:"USER_DISCONNECTED"}));}),this.signer.on("display_uri",t=>{var s,i;this.rpc.showQrModal&&((s=this.modal)==null||s.closeModal(),(i=this.modal)==null||i.openModal({uri:t})),this.events.emit("display_uri",t);});}switchEthereumChain(t){this.request({method:"wallet_switchEthereumChain",params:[{chainId:t.toString(16)}]});}isCompatibleChainId(t){return typeof t=="string"?t.startsWith(`${this.namespace}:`):!1}formatChainId(t){return `${this.namespace}:${t}`}parseChainId(t){return Number(t.split(":")[1])}setChainIds(t){const s=t.filter(i=>this.isCompatibleChainId(i)).map(i=>this.parseChainId(i));s.length&&(this.chainId=s[0],this.events.emit("chainChanged",f$d(this.chainId)),this.persist());}setChainId(t){if(this.isCompatibleChainId(t)){const s=this.parseChainId(t);this.chainId=s,this.switchEthereumChain(s);}}parseAccountId(t){const[s,i,n]=t.split(":");return {chainId:`${s}:${i}`,address:n}}setAccounts(t){this.accounts=t.filter(s=>this.parseChainId(this.parseAccountId(s).chainId)===this.chainId).map(s=>this.parseAccountId(s).address),this.events.emit("accountsChanged",this.accounts);}getRpcConfig(t){var s,i;const n=(s=t?.chains)!=null?s:[],e=(i=t?.optionalChains)!=null?i:[],h=n.concat(e);if(!h.length)throw new Error("No chains specified in either `chains` or `optionalChains`");const c=n.length?t?.methods||u$a:[],o=n.length?t?.events||m$7:[],r=t?.optionalMethods||[],d=t?.optionalEvents||[],C=t?.rpcMap||this.buildRpcMap(h,t.projectId),I=t?.qrModalOptions||void 0;return {chains:n?.map(l=>this.formatChainId(l)),optionalChains:e.map(l=>this.formatChainId(l)),methods:c,events:o,optionalMethods:r,optionalEvents:d,rpcMap:C,showQrModal:!!(t!=null&&t.showQrModal),qrModalOptions:I,projectId:t.projectId,metadata:t.metadata}}buildRpcMap(t,s){const i={};return t.forEach(n=>{i[n]=this.getRpcUrl(n,s);}),i}async initialize(t){if(this.rpc=this.getRpcConfig(t),this.chainId=this.rpc.chains.length?g$7(this.rpc.chains):g$7(this.rpc.optionalChains),this.signer=await hv.init({projectId:this.rpc.projectId,metadata:this.rpc.metadata,disableProviderPing:t.disableProviderPing,relayUrl:t.relayUrl,storageOptions:t.storageOptions}),this.registerEventListeners(),await this.loadPersistedSession(),this.rpc.showQrModal){let s;try{const{WalletConnectModal:i}=await Promise.resolve().then(function () { return index$2; });s=i;}catch{throw new Error("To use QR modal, please install @walletconnect/modal package")}if(s)try{this.modal=new s(p$a({projectId:this.rpc.projectId},this.rpc.qrModalOptions));}catch(i){throw this.signer.logger.error(i),new Error("Could not generate WalletConnectModal Instance")}}}loadConnectOpts(t){if(!t)return;const{chains:s,optionalChains:i,rpcMap:n}=t;s&&k$8(s)&&(this.rpc.chains=s.map(e=>this.formatChainId(e)),s.forEach(e=>{this.rpc.rpcMap[e]=n?.[e]||this.getRpcUrl(e);})),i&&k$8(i)&&(this.rpc.optionalChains=[],this.rpc.optionalChains=i?.map(e=>this.formatChainId(e)),i.forEach(e=>{this.rpc.rpcMap[e]=n?.[e]||this.getRpcUrl(e);}));}getRpcUrl(t,s){var i;return ((i=this.rpc.rpcMap)==null?void 0:i[t])||`${j$7}?chainId=eip155:${t}&projectId=${s||this.rpc.projectId}`}async loadPersistedSession(){if(!this.session)return;const t=await this.signer.client.core.storage.getItem(`${this.STORAGE_KEY}/chainId`),s=this.session.namespaces[`${this.namespace}:${t}`]?this.session.namespaces[`${this.namespace}:${t}`]:this.session.namespaces[this.namespace];this.setChainIds(t?[this.formatChainId(t)]:s?.accounts),this.setAccounts(s?.accounts);}reset(){this.chainId=1,this.accounts=[];}persist(){this.session&&this.signer.client.core.storage.setItem(`${this.STORAGE_KEY}/chainId`,this.chainId);}parseAccounts(t){return typeof t=="string"||t instanceof String?[this.parseAccount(t)]:t.map(s=>this.parseAccount(s))}};const G$2=v$7;

    var index_es = /*#__PURE__*/Object.freeze({
        __proto__: null,
        EthereumProvider: G$2,
        OPTIONAL_EVENTS: _$8,
        OPTIONAL_METHODS: E$6,
        REQUIRED_EVENTS: m$7,
        REQUIRED_METHODS: u$a,
        default: v$7
    });

    const version$3 = '2.9.5';

    const getContractAddress = (address) => address;
    const getUrl = (url) => url;
    const getVersion$1 = () => `viem@${version$3}`;

    let BaseError$1 = class BaseError extends Error {
        constructor(shortMessage, args = {}) {
            super();
            Object.defineProperty(this, "details", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "docsPath", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "metaMessages", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "shortMessage", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'ViemError'
            });
            Object.defineProperty(this, "version", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: getVersion$1()
            });
            const details = args.cause instanceof BaseError
                ? args.cause.details
                : args.cause?.message
                    ? args.cause.message
                    : args.details;
            const docsPath = args.cause instanceof BaseError
                ? args.cause.docsPath || args.docsPath
                : args.docsPath;
            this.message = [
                shortMessage || 'An error occurred.',
                '',
                ...(args.metaMessages ? [...args.metaMessages, ''] : []),
                ...(docsPath
                    ? [
                        `Docs: https://viem.sh${docsPath}${args.docsSlug ? `#${args.docsSlug}` : ''}`,
                    ]
                    : []),
                ...(details ? [`Details: ${details}`] : []),
                `Version: ${this.version}`,
            ].join('\n');
            if (args.cause)
                this.cause = args.cause;
            this.details = details;
            this.docsPath = docsPath;
            this.metaMessages = args.metaMessages;
            this.shortMessage = shortMessage;
        }
        walk(fn) {
            return walk(this, fn);
        }
    };
    function walk(err, fn) {
        if (fn?.(err))
            return err;
        if (err && typeof err === 'object' && 'cause' in err)
            return walk(err.cause, fn);
        return fn ? null : err;
    }

    class IntegerOutOfRangeError extends BaseError$1 {
        constructor({ max, min, signed, size, value, }) {
            super(`Number "${value}" is not in safe ${size ? `${size * 8}-bit ${signed ? 'signed' : 'unsigned'} ` : ''}integer range ${max ? `(${min} to ${max})` : `(above ${min})`}`);
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'IntegerOutOfRangeError'
            });
        }
    }
    class InvalidBytesBooleanError extends BaseError$1 {
        constructor(bytes) {
            super(`Bytes value "${bytes}" is not a valid boolean. The bytes array must contain a single byte of either a 0 or 1 value.`);
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'InvalidBytesBooleanError'
            });
        }
    }
    class SizeOverflowError extends BaseError$1 {
        constructor({ givenSize, maxSize }) {
            super(`Size cannot exceed ${maxSize} bytes. Given size: ${givenSize} bytes.`);
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'SizeOverflowError'
            });
        }
    }

    class SliceOffsetOutOfBoundsError extends BaseError$1 {
        constructor({ offset, position, size, }) {
            super(`Slice ${position === 'start' ? 'starting' : 'ending'} at offset "${offset}" is out-of-bounds (size: ${size}).`);
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'SliceOffsetOutOfBoundsError'
            });
        }
    }
    class SizeExceedsPaddingSizeError extends BaseError$1 {
        constructor({ size, targetSize, type, }) {
            super(`${type.charAt(0).toUpperCase()}${type
            .slice(1)
            .toLowerCase()} size (${size}) exceeds padding size (${targetSize}).`);
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'SizeExceedsPaddingSizeError'
            });
        }
    }
    class InvalidBytesLengthError extends BaseError$1 {
        constructor({ size, targetSize, type, }) {
            super(`${type.charAt(0).toUpperCase()}${type
            .slice(1)
            .toLowerCase()} is expected to be ${targetSize} ${type} long, but is ${size} ${type} long.`);
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'InvalidBytesLengthError'
            });
        }
    }

    function pad$1(hexOrBytes, { dir, size = 32 } = {}) {
        if (typeof hexOrBytes === 'string')
            return padHex(hexOrBytes, { dir, size });
        return padBytes(hexOrBytes, { dir, size });
    }
    function padHex(hex_, { dir, size = 32 } = {}) {
        if (size === null)
            return hex_;
        const hex = hex_.replace('0x', '');
        if (hex.length > size * 2)
            throw new SizeExceedsPaddingSizeError({
                size: Math.ceil(hex.length / 2),
                targetSize: size,
                type: 'hex',
            });
        return `0x${hex[dir === 'right' ? 'padEnd' : 'padStart'](size * 2, '0')}`;
    }
    function padBytes(bytes, { dir, size = 32 } = {}) {
        if (size === null)
            return bytes;
        if (bytes.length > size)
            throw new SizeExceedsPaddingSizeError({
                size: bytes.length,
                targetSize: size,
                type: 'bytes',
            });
        const paddedBytes = new Uint8Array(size);
        for (let i = 0; i < size; i++) {
            const padEnd = dir === 'right';
            paddedBytes[padEnd ? i : size - i - 1] =
                bytes[padEnd ? i : bytes.length - i - 1];
        }
        return paddedBytes;
    }

    function isHex(value, { strict = true } = {}) {
        if (!value)
            return false;
        if (typeof value !== 'string')
            return false;
        return strict ? /^0x[0-9a-fA-F]*$/.test(value) : value.startsWith('0x');
    }

    /**
     * @description Retrieves the size of the value (in bytes).
     *
     * @param value The value (hex or byte array) to retrieve the size of.
     * @returns The size of the value (in bytes).
     */
    function size$3(value) {
        if (isHex(value, { strict: false }))
            return Math.ceil((value.length - 2) / 2);
        return value.length;
    }

    function trim(hexOrBytes, { dir = 'left' } = {}) {
        let data = typeof hexOrBytes === 'string' ? hexOrBytes.replace('0x', '') : hexOrBytes;
        let sliceLength = 0;
        for (let i = 0; i < data.length - 1; i++) {
            if (data[dir === 'left' ? i : data.length - i - 1].toString() === '0')
                sliceLength++;
            else
                break;
        }
        data =
            dir === 'left'
                ? data.slice(sliceLength)
                : data.slice(0, data.length - sliceLength);
        if (typeof hexOrBytes === 'string') {
            if (data.length === 1 && dir === 'right')
                data = `${data}0`;
            return `0x${data.length % 2 === 1 ? `0${data}` : data}`;
        }
        return data;
    }

    const encoder$1 = /*#__PURE__*/ new TextEncoder();
    /**
     * Encodes a UTF-8 string, hex value, bigint, number or boolean to a byte array.
     *
     * - Docs: https://viem.sh/docs/utilities/toBytes
     * - Example: https://viem.sh/docs/utilities/toBytes#usage
     *
     * @param value Value to encode.
     * @param opts Options.
     * @returns Byte array value.
     *
     * @example
     * import { toBytes } from 'viem'
     * const data = toBytes('Hello world')
     * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])
     *
     * @example
     * import { toBytes } from 'viem'
     * const data = toBytes(420)
     * // Uint8Array([1, 164])
     *
     * @example
     * import { toBytes } from 'viem'
     * const data = toBytes(420, { size: 4 })
     * // Uint8Array([0, 0, 1, 164])
     */
    function toBytes$1(value, opts = {}) {
        if (typeof value === 'number' || typeof value === 'bigint')
            return numberToBytes$1(value, opts);
        if (typeof value === 'boolean')
            return boolToBytes(value, opts);
        if (isHex(value))
            return hexToBytes$1(value, opts);
        return stringToBytes$1(value, opts);
    }
    /**
     * Encodes a boolean into a byte array.
     *
     * - Docs: https://viem.sh/docs/utilities/toBytes#booltobytes
     *
     * @param value Boolean value to encode.
     * @param opts Options.
     * @returns Byte array value.
     *
     * @example
     * import { boolToBytes } from 'viem'
     * const data = boolToBytes(true)
     * // Uint8Array([1])
     *
     * @example
     * import { boolToBytes } from 'viem'
     * const data = boolToBytes(true, { size: 32 })
     * // Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1])
     */
    function boolToBytes(value, opts = {}) {
        const bytes = new Uint8Array(1);
        bytes[0] = Number(value);
        if (typeof opts.size === 'number') {
            assertSize$1(bytes, { size: opts.size });
            return pad$1(bytes, { size: opts.size });
        }
        return bytes;
    }
    // We use very optimized technique to convert hex string to byte array
    const charCodeMap = {
        zero: 48,
        nine: 57,
        A: 65,
        F: 70,
        a: 97,
        f: 102,
    };
    function charCodeToBase16(char) {
        if (char >= charCodeMap.zero && char <= charCodeMap.nine)
            return char - charCodeMap.zero;
        if (char >= charCodeMap.A && char <= charCodeMap.F)
            return char - (charCodeMap.A - 10);
        if (char >= charCodeMap.a && char <= charCodeMap.f)
            return char - (charCodeMap.a - 10);
        return undefined;
    }
    /**
     * Encodes a hex string into a byte array.
     *
     * - Docs: https://viem.sh/docs/utilities/toBytes#hextobytes
     *
     * @param hex Hex string to encode.
     * @param opts Options.
     * @returns Byte array value.
     *
     * @example
     * import { hexToBytes } from 'viem'
     * const data = hexToBytes('0x48656c6c6f20776f726c6421')
     * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])
     *
     * @example
     * import { hexToBytes } from 'viem'
     * const data = hexToBytes('0x48656c6c6f20776f726c6421', { size: 32 })
     * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
     */
    function hexToBytes$1(hex_, opts = {}) {
        let hex = hex_;
        if (opts.size) {
            assertSize$1(hex, { size: opts.size });
            hex = pad$1(hex, { dir: 'right', size: opts.size });
        }
        let hexString = hex.slice(2);
        if (hexString.length % 2)
            hexString = `0${hexString}`;
        const length = hexString.length / 2;
        const bytes = new Uint8Array(length);
        for (let index = 0, j = 0; index < length; index++) {
            const nibbleLeft = charCodeToBase16(hexString.charCodeAt(j++));
            const nibbleRight = charCodeToBase16(hexString.charCodeAt(j++));
            if (nibbleLeft === undefined || nibbleRight === undefined) {
                throw new BaseError$1(`Invalid byte sequence ("${hexString[j - 2]}${hexString[j - 1]}" in "${hexString}").`);
            }
            bytes[index] = nibbleLeft * 16 + nibbleRight;
        }
        return bytes;
    }
    /**
     * Encodes a number into a byte array.
     *
     * - Docs: https://viem.sh/docs/utilities/toBytes#numbertobytes
     *
     * @param value Number to encode.
     * @param opts Options.
     * @returns Byte array value.
     *
     * @example
     * import { numberToBytes } from 'viem'
     * const data = numberToBytes(420)
     * // Uint8Array([1, 164])
     *
     * @example
     * import { numberToBytes } from 'viem'
     * const data = numberToBytes(420, { size: 4 })
     * // Uint8Array([0, 0, 1, 164])
     */
    function numberToBytes$1(value, opts) {
        const hex = numberToHex$1(value, opts);
        return hexToBytes$1(hex);
    }
    /**
     * Encodes a UTF-8 string into a byte array.
     *
     * - Docs: https://viem.sh/docs/utilities/toBytes#stringtobytes
     *
     * @param value String to encode.
     * @param opts Options.
     * @returns Byte array value.
     *
     * @example
     * import { stringToBytes } from 'viem'
     * const data = stringToBytes('Hello world!')
     * // Uint8Array([72, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 33])
     *
     * @example
     * import { stringToBytes } from 'viem'
     * const data = stringToBytes('Hello world!', { size: 32 })
     * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
     */
    function stringToBytes$1(value, opts = {}) {
        const bytes = encoder$1.encode(value);
        if (typeof opts.size === 'number') {
            assertSize$1(bytes, { size: opts.size });
            return pad$1(bytes, { dir: 'right', size: opts.size });
        }
        return bytes;
    }

    function assertSize$1(hexOrBytes, { size }) {
        if (size$3(hexOrBytes) > size)
            throw new SizeOverflowError({
                givenSize: size$3(hexOrBytes),
                maxSize: size,
            });
    }
    /**
     * Decodes a hex value into a bigint.
     *
     * - Docs: https://viem.sh/docs/utilities/fromHex#hextobigint
     *
     * @param hex Hex value to decode.
     * @param opts Options.
     * @returns BigInt value.
     *
     * @example
     * import { hexToBigInt } from 'viem'
     * const data = hexToBigInt('0x1a4', { signed: true })
     * // 420n
     *
     * @example
     * import { hexToBigInt } from 'viem'
     * const data = hexToBigInt('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })
     * // 420n
     */
    function hexToBigInt$1(hex, opts = {}) {
        const { signed } = opts;
        if (opts.size)
            assertSize$1(hex, { size: opts.size });
        const value = BigInt(hex);
        if (!signed)
            return value;
        const size = (hex.length - 2) / 2;
        const max = (1n << (BigInt(size) * 8n - 1n)) - 1n;
        if (value <= max)
            return value;
        return value - BigInt(`0x${'f'.padStart(size * 2, 'f')}`) - 1n;
    }
    /**
     * Decodes a hex string into a number.
     *
     * - Docs: https://viem.sh/docs/utilities/fromHex#hextonumber
     *
     * @param hex Hex value to decode.
     * @param opts Options.
     * @returns Number value.
     *
     * @example
     * import { hexToNumber } from 'viem'
     * const data = hexToNumber('0x1a4')
     * // 420
     *
     * @example
     * import { hexToNumber } from 'viem'
     * const data = hexToBigInt('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })
     * // 420
     */
    function hexToNumber$1(hex, opts = {}) {
        return Number(hexToBigInt$1(hex, opts));
    }
    /**
     * Decodes a hex value into a UTF-8 string.
     *
     * - Docs: https://viem.sh/docs/utilities/fromHex#hextostring
     *
     * @param hex Hex value to decode.
     * @param opts Options.
     * @returns String value.
     *
     * @example
     * import { hexToString } from 'viem'
     * const data = hexToString('0x48656c6c6f20576f726c6421')
     * // 'Hello world!'
     *
     * @example
     * import { hexToString } from 'viem'
     * const data = hexToString('0x48656c6c6f20576f726c64210000000000000000000000000000000000000000', {
     *  size: 32,
     * })
     * // 'Hello world'
     */
    function hexToString(hex, opts = {}) {
        let bytes = hexToBytes$1(hex);
        if (opts.size) {
            assertSize$1(bytes, { size: opts.size });
            bytes = trim(bytes, { dir: 'right' });
        }
        return new TextDecoder().decode(bytes);
    }

    const hexes = /*#__PURE__*/ Array.from({ length: 256 }, (_v, i) => i.toString(16).padStart(2, '0'));
    /**
     * Encodes a string, number, bigint, or ByteArray into a hex string
     *
     * - Docs: https://viem.sh/docs/utilities/toHex
     * - Example: https://viem.sh/docs/utilities/toHex#usage
     *
     * @param value Value to encode.
     * @param opts Options.
     * @returns Hex value.
     *
     * @example
     * import { toHex } from 'viem'
     * const data = toHex('Hello world')
     * // '0x48656c6c6f20776f726c6421'
     *
     * @example
     * import { toHex } from 'viem'
     * const data = toHex(420)
     * // '0x1a4'
     *
     * @example
     * import { toHex } from 'viem'
     * const data = toHex('Hello world', { size: 32 })
     * // '0x48656c6c6f20776f726c64210000000000000000000000000000000000000000'
     */
    function toHex$1(value, opts = {}) {
        if (typeof value === 'number' || typeof value === 'bigint')
            return numberToHex$1(value, opts);
        if (typeof value === 'string') {
            return stringToHex(value, opts);
        }
        if (typeof value === 'boolean')
            return boolToHex(value, opts);
        return bytesToHex$1(value, opts);
    }
    /**
     * Encodes a boolean into a hex string
     *
     * - Docs: https://viem.sh/docs/utilities/toHex#booltohex
     *
     * @param value Value to encode.
     * @param opts Options.
     * @returns Hex value.
     *
     * @example
     * import { boolToHex } from 'viem'
     * const data = boolToHex(true)
     * // '0x1'
     *
     * @example
     * import { boolToHex } from 'viem'
     * const data = boolToHex(false)
     * // '0x0'
     *
     * @example
     * import { boolToHex } from 'viem'
     * const data = boolToHex(true, { size: 32 })
     * // '0x0000000000000000000000000000000000000000000000000000000000000001'
     */
    function boolToHex(value, opts = {}) {
        const hex = `0x${Number(value)}`;
        if (typeof opts.size === 'number') {
            assertSize$1(hex, { size: opts.size });
            return pad$1(hex, { size: opts.size });
        }
        return hex;
    }
    /**
     * Encodes a bytes array into a hex string
     *
     * - Docs: https://viem.sh/docs/utilities/toHex#bytestohex
     *
     * @param value Value to encode.
     * @param opts Options.
     * @returns Hex value.
     *
     * @example
     * import { bytesToHex } from 'viem'
     * const data = bytesToHex(Uint8Array.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])
     * // '0x48656c6c6f20576f726c6421'
     *
     * @example
     * import { bytesToHex } from 'viem'
     * const data = bytesToHex(Uint8Array.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]), { size: 32 })
     * // '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000'
     */
    function bytesToHex$1(value, opts = {}) {
        let string = '';
        for (let i = 0; i < value.length; i++) {
            string += hexes[value[i]];
        }
        const hex = `0x${string}`;
        if (typeof opts.size === 'number') {
            assertSize$1(hex, { size: opts.size });
            return pad$1(hex, { dir: 'right', size: opts.size });
        }
        return hex;
    }
    /**
     * Encodes a number or bigint into a hex string
     *
     * - Docs: https://viem.sh/docs/utilities/toHex#numbertohex
     *
     * @param value Value to encode.
     * @param opts Options.
     * @returns Hex value.
     *
     * @example
     * import { numberToHex } from 'viem'
     * const data = numberToHex(420)
     * // '0x1a4'
     *
     * @example
     * import { numberToHex } from 'viem'
     * const data = numberToHex(420, { size: 32 })
     * // '0x00000000000000000000000000000000000000000000000000000000000001a4'
     */
    function numberToHex$1(value_, opts = {}) {
        const { signed, size } = opts;
        const value = BigInt(value_);
        let maxValue;
        if (size) {
            if (signed)
                maxValue = (1n << (BigInt(size) * 8n - 1n)) - 1n;
            else
                maxValue = 2n ** (BigInt(size) * 8n) - 1n;
        }
        else if (typeof value_ === 'number') {
            maxValue = BigInt(Number.MAX_SAFE_INTEGER);
        }
        const minValue = typeof maxValue === 'bigint' && signed ? -maxValue - 1n : 0;
        if ((maxValue && value > maxValue) || value < minValue) {
            const suffix = typeof value_ === 'bigint' ? 'n' : '';
            throw new IntegerOutOfRangeError({
                max: maxValue ? `${maxValue}${suffix}` : undefined,
                min: `${minValue}${suffix}`,
                signed,
                size,
                value: `${value_}${suffix}`,
            });
        }
        const hex = `0x${(signed && value < 0
        ? (1n << BigInt(size * 8)) + BigInt(value)
        : value).toString(16)}`;
        if (size)
            return pad$1(hex, { size });
        return hex;
    }
    const encoder = /*#__PURE__*/ new TextEncoder();
    /**
     * Encodes a UTF-8 string into a hex string
     *
     * - Docs: https://viem.sh/docs/utilities/toHex#stringtohex
     *
     * @param value Value to encode.
     * @param opts Options.
     * @returns Hex value.
     *
     * @example
     * import { stringToHex } from 'viem'
     * const data = stringToHex('Hello World!')
     * // '0x48656c6c6f20576f726c6421'
     *
     * @example
     * import { stringToHex } from 'viem'
     * const data = stringToHex('Hello World!', { size: 32 })
     * // '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000'
     */
    function stringToHex(value_, opts = {}) {
        const value = encoder.encode(value_);
        return bytesToHex$1(value, opts);
    }

    function formatAbiItem$1(abiItem, { includeName = false } = {}) {
        if (abiItem.type !== 'function' &&
            abiItem.type !== 'event' &&
            abiItem.type !== 'error')
            throw new InvalidDefinitionTypeError(abiItem.type);
        return `${abiItem.name}(${formatAbiParams(abiItem.inputs, { includeName })})`;
    }
    function formatAbiParams(params, { includeName = false } = {}) {
        if (!params)
            return '';
        return params
            .map((param) => formatAbiParam(param, { includeName }))
            .join(includeName ? ', ' : ',');
    }
    function formatAbiParam(param, { includeName }) {
        if (param.type.startsWith('tuple')) {
            return `(${formatAbiParams(param.components, { includeName })})${param.type.slice('tuple'.length)}`;
        }
        return param.type + (includeName && param.name ? ` ${param.name}` : '');
    }

    class AbiDecodingDataSizeTooSmallError extends BaseError$1 {
        constructor({ data, params, size, }) {
            super([`Data size of ${size} bytes is too small for given parameters.`].join('\n'), {
                metaMessages: [
                    `Params: (${formatAbiParams(params, { includeName: true })})`,
                    `Data:   ${data} (${size} bytes)`,
                ],
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'AbiDecodingDataSizeTooSmallError'
            });
            Object.defineProperty(this, "data", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "params", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "size", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            this.data = data;
            this.params = params;
            this.size = size;
        }
    }
    class AbiDecodingZeroDataError extends BaseError$1 {
        constructor() {
            super('Cannot decode zero data ("0x") with ABI parameters.');
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'AbiDecodingZeroDataError'
            });
        }
    }
    class AbiEncodingArrayLengthMismatchError extends BaseError$1 {
        constructor({ expectedLength, givenLength, type, }) {
            super([
                `ABI encoding array length mismatch for type ${type}.`,
                `Expected length: ${expectedLength}`,
                `Given length: ${givenLength}`,
            ].join('\n'));
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'AbiEncodingArrayLengthMismatchError'
            });
        }
    }
    class AbiEncodingBytesSizeMismatchError extends BaseError$1 {
        constructor({ expectedSize, value }) {
            super(`Size of bytes "${value}" (bytes${size$3(value)}) does not match expected size (bytes${expectedSize}).`);
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'AbiEncodingBytesSizeMismatchError'
            });
        }
    }
    class AbiEncodingLengthMismatchError extends BaseError$1 {
        constructor({ expectedLength, givenLength, }) {
            super([
                'ABI encoding params/values length mismatch.',
                `Expected length (params): ${expectedLength}`,
                `Given length (values): ${givenLength}`,
            ].join('\n'));
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'AbiEncodingLengthMismatchError'
            });
        }
    }
    class AbiErrorSignatureNotFoundError extends BaseError$1 {
        constructor(signature, { docsPath }) {
            super([
                `Encoded error signature "${signature}" not found on ABI.`,
                'Make sure you are using the correct ABI and that the error exists on it.',
                `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${signature}.`,
            ].join('\n'), {
                docsPath,
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'AbiErrorSignatureNotFoundError'
            });
            Object.defineProperty(this, "signature", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            this.signature = signature;
        }
    }
    class AbiFunctionNotFoundError extends BaseError$1 {
        constructor(functionName, { docsPath } = {}) {
            super([
                `Function ${functionName ? `"${functionName}" ` : ''}not found on ABI.`,
                'Make sure you are using the correct ABI and that the function exists on it.',
            ].join('\n'), {
                docsPath,
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'AbiFunctionNotFoundError'
            });
        }
    }
    class AbiFunctionOutputsNotFoundError extends BaseError$1 {
        constructor(functionName, { docsPath }) {
            super([
                `Function "${functionName}" does not contain any \`outputs\` on ABI.`,
                'Cannot decode function result without knowing what the parameter types are.',
                'Make sure you are using the correct ABI and that the function exists on it.',
            ].join('\n'), {
                docsPath,
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'AbiFunctionOutputsNotFoundError'
            });
        }
    }
    class AbiItemAmbiguityError extends BaseError$1 {
        constructor(x, y) {
            super('Found ambiguous types in overloaded ABI items.', {
                metaMessages: [
                    `\`${x.type}\` in \`${formatAbiItem$1(x.abiItem)}\`, and`,
                    `\`${y.type}\` in \`${formatAbiItem$1(y.abiItem)}\``,
                    '',
                    'These types encode differently and cannot be distinguished at runtime.',
                    'Remove one of the ambiguous items in the ABI.',
                ],
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'AbiItemAmbiguityError'
            });
        }
    }
    class InvalidAbiEncodingTypeError extends BaseError$1 {
        constructor(type, { docsPath }) {
            super([
                `Type "${type}" is not a valid encoding type.`,
                'Please provide a valid ABI type.',
            ].join('\n'), { docsPath });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'InvalidAbiEncodingType'
            });
        }
    }
    class InvalidAbiDecodingTypeError extends BaseError$1 {
        constructor(type, { docsPath }) {
            super([
                `Type "${type}" is not a valid decoding type.`,
                'Please provide a valid ABI type.',
            ].join('\n'), { docsPath });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'InvalidAbiDecodingType'
            });
        }
    }
    class InvalidArrayError extends BaseError$1 {
        constructor(value) {
            super([`Value "${value}" is not a valid array.`].join('\n'));
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'InvalidArrayError'
            });
        }
    }
    class InvalidDefinitionTypeError extends BaseError$1 {
        constructor(type) {
            super([
                `"${type}" is not a valid definition type.`,
                'Valid types: "function", "event", "error"',
            ].join('\n'));
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'InvalidDefinitionTypeError'
            });
        }
    }

    function concat(values) {
        if (typeof values[0] === 'string')
            return concatHex(values);
        return concatBytes$1(values);
    }
    function concatBytes$1(values) {
        let length = 0;
        for (const arr of values) {
            length += arr.length;
        }
        const result = new Uint8Array(length);
        let offset = 0;
        for (const arr of values) {
            result.set(arr, offset);
            offset += arr.length;
        }
        return result;
    }
    function concatHex(values) {
        return `0x${values.reduce((acc, x) => acc + x.replace('0x', ''), '')}`;
    }

    class InvalidAddressError extends BaseError$1 {
        constructor({ address }) {
            super(`Address "${address}" is invalid.`, {
                metaMessages: [
                    '- Address must be a hex value of 20 bytes (40 hex characters).',
                    '- Address must match its checksum counterpart.',
                ],
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'InvalidAddressError'
            });
        }
    }

    /**
     * Map with a LRU (Least recently used) policy.
     *
     * @link https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU
     */
    class LruMap extends Map {
        constructor(size) {
            super();
            Object.defineProperty(this, "maxSize", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            this.maxSize = size;
        }
        set(key, value) {
            super.set(key, value);
            if (this.maxSize && this.size > this.maxSize)
                this.delete(this.keys().next().value);
            return this;
        }
    }

    function number$2(n) {
        if (!Number.isSafeInteger(n) || n < 0)
            throw new Error(`Wrong positive integer: ${n}`);
    }
    function bytes$1(b, ...lengths) {
        if (!(b instanceof Uint8Array))
            throw new Error('Expected Uint8Array');
        if (lengths.length > 0 && !lengths.includes(b.length))
            throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
    }
    function exists(instance, checkFinished = true) {
        if (instance.destroyed)
            throw new Error('Hash instance has been destroyed');
        if (checkFinished && instance.finished)
            throw new Error('Hash#digest() has already been called');
    }
    function output(out, instance) {
        bytes$1(out);
        const min = instance.outputLen;
        if (out.length < min) {
            throw new Error(`digestInto() expects output buffer of length at least ${min}`);
        }
    }

    const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
    const _32n = /* @__PURE__ */ BigInt(32);
    // We are not using BigUint64Array, because they are extremely slow as per 2022
    function fromBig(n, le = false) {
        if (le)
            return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };
        return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
    }
    function split(lst, le = false) {
        let Ah = new Uint32Array(lst.length);
        let Al = new Uint32Array(lst.length);
        for (let i = 0; i < lst.length; i++) {
            const { h, l } = fromBig(lst[i], le);
            [Ah[i], Al[i]] = [h, l];
        }
        return [Ah, Al];
    }
    // Left rotate for Shift in [1, 32)
    const rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));
    const rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));
    // Left rotate for Shift in (32, 64), NOTE: 32 is special case.
    const rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));
    const rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));

    /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
    // We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.
    // node.js versions earlier than v19 don't declare it in global scope.
    // For node.js, package.json#exports field mapping rewrites import
    // from `crypto` to `cryptoNode`, which imports native module.
    // Makes the utils un-importable in browsers without a bundler.
    // Once node.js 18 is deprecated, we can just drop the import.
    const u8a = (a) => a instanceof Uint8Array;
    const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
    // big-endian hardware is rare. Just in case someone still decides to run hashes:
    // early-throw an error because we don't support BE yet.
    const isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;
    if (!isLE)
        throw new Error('Non little-endian hardware is not supported');
    /**
     * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])
     */
    function utf8ToBytes$1(str) {
        if (typeof str !== 'string')
            throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
        return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809
    }
    /**
     * Normalizes (non-hex) string or Uint8Array to Uint8Array.
     * Warning: when Uint8Array is passed, it would NOT get copied.
     * Keep in mind for future mutable operations.
     */
    function toBytes(data) {
        if (typeof data === 'string')
            data = utf8ToBytes$1(data);
        if (!u8a(data))
            throw new Error(`expected Uint8Array, got ${typeof data}`);
        return data;
    }
    // For runtime check if class implements interface
    let Hash$7 = class Hash {
        // Safe version that clones internal state
        clone() {
            return this._cloneInto();
        }
    };
    function wrapConstructor(hashCons) {
        const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
        const tmp = hashCons();
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = () => hashCons();
        return hashC;
    }

    // SHA3 (keccak) is based on a new design: basically, the internal state is bigger than output size.
    // It's called a sponge function.
    // Various per round constants calculations
    const [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
    const _0n = /* @__PURE__ */ BigInt(0);
    const _1n = /* @__PURE__ */ BigInt(1);
    const _2n = /* @__PURE__ */ BigInt(2);
    const _7n = /* @__PURE__ */ BigInt(7);
    const _256n = /* @__PURE__ */ BigInt(256);
    const _0x71n = /* @__PURE__ */ BigInt(0x71);
    for (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {
        // Pi
        [x, y] = [y, (2 * x + 3 * y) % 5];
        SHA3_PI.push(2 * (5 * y + x));
        // Rotational
        SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);
        // Iota
        let t = _0n;
        for (let j = 0; j < 7; j++) {
            R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;
            if (R & _2n)
                t ^= _1n << ((_1n << /* @__PURE__ */ BigInt(j)) - _1n);
        }
        _SHA3_IOTA.push(t);
    }
    const [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ split(_SHA3_IOTA, true);
    // Left rotation (without 0, 32, 64)
    const rotlH = (h, l, s) => (s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s));
    const rotlL = (h, l, s) => (s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s));
    // Same as keccakf1600, but allows to skip some rounds
    function keccakP(s, rounds = 24) {
        const B = new Uint32Array(5 * 2);
        // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)
        for (let round = 24 - rounds; round < 24; round++) {
            // Theta θ
            for (let x = 0; x < 10; x++)
                B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
            for (let x = 0; x < 10; x += 2) {
                const idx1 = (x + 8) % 10;
                const idx0 = (x + 2) % 10;
                const B0 = B[idx0];
                const B1 = B[idx0 + 1];
                const Th = rotlH(B0, B1, 1) ^ B[idx1];
                const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
                for (let y = 0; y < 50; y += 10) {
                    s[x + y] ^= Th;
                    s[x + y + 1] ^= Tl;
                }
            }
            // Rho (ρ) and Pi (π)
            let curH = s[2];
            let curL = s[3];
            for (let t = 0; t < 24; t++) {
                const shift = SHA3_ROTL[t];
                const Th = rotlH(curH, curL, shift);
                const Tl = rotlL(curH, curL, shift);
                const PI = SHA3_PI[t];
                curH = s[PI];
                curL = s[PI + 1];
                s[PI] = Th;
                s[PI + 1] = Tl;
            }
            // Chi (χ)
            for (let y = 0; y < 50; y += 10) {
                for (let x = 0; x < 10; x++)
                    B[x] = s[y + x];
                for (let x = 0; x < 10; x++)
                    s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
            }
            // Iota (ι)
            s[0] ^= SHA3_IOTA_H[round];
            s[1] ^= SHA3_IOTA_L[round];
        }
        B.fill(0);
    }
    let Keccak$1 = class Keccak extends Hash$7 {
        // NOTE: we accept arguments in bytes instead of bits here.
        constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
            super();
            this.blockLen = blockLen;
            this.suffix = suffix;
            this.outputLen = outputLen;
            this.enableXOF = enableXOF;
            this.rounds = rounds;
            this.pos = 0;
            this.posOut = 0;
            this.finished = false;
            this.destroyed = false;
            // Can be passed from user as dkLen
            number$2(outputLen);
            // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes
            if (0 >= this.blockLen || this.blockLen >= 200)
                throw new Error('Sha3 supports only keccak-f1600 function');
            this.state = new Uint8Array(200);
            this.state32 = u32(this.state);
        }
        keccak() {
            keccakP(this.state32, this.rounds);
            this.posOut = 0;
            this.pos = 0;
        }
        update(data) {
            exists(this);
            const { blockLen, state } = this;
            data = toBytes(data);
            const len = data.length;
            for (let pos = 0; pos < len;) {
                const take = Math.min(blockLen - this.pos, len - pos);
                for (let i = 0; i < take; i++)
                    state[this.pos++] ^= data[pos++];
                if (this.pos === blockLen)
                    this.keccak();
            }
            return this;
        }
        finish() {
            if (this.finished)
                return;
            this.finished = true;
            const { state, suffix, pos, blockLen } = this;
            // Do the padding
            state[pos] ^= suffix;
            if ((suffix & 0x80) !== 0 && pos === blockLen - 1)
                this.keccak();
            state[blockLen - 1] ^= 0x80;
            this.keccak();
        }
        writeInto(out) {
            exists(this, false);
            bytes$1(out);
            this.finish();
            const bufferOut = this.state;
            const { blockLen } = this;
            for (let pos = 0, len = out.length; pos < len;) {
                if (this.posOut >= blockLen)
                    this.keccak();
                const take = Math.min(blockLen - this.posOut, len - pos);
                out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
                this.posOut += take;
                pos += take;
            }
            return out;
        }
        xofInto(out) {
            // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF
            if (!this.enableXOF)
                throw new Error('XOF is not possible for this instance');
            return this.writeInto(out);
        }
        xof(bytes) {
            number$2(bytes);
            return this.xofInto(new Uint8Array(bytes));
        }
        digestInto(out) {
            output(out, this);
            if (this.finished)
                throw new Error('digest() was already called');
            this.writeInto(out);
            this.destroy();
            return out;
        }
        digest() {
            return this.digestInto(new Uint8Array(this.outputLen));
        }
        destroy() {
            this.destroyed = true;
            this.state.fill(0);
        }
        _cloneInto(to) {
            const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
            to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
            to.state32.set(this.state32);
            to.pos = this.pos;
            to.posOut = this.posOut;
            to.finished = this.finished;
            to.rounds = rounds;
            // Suffix can change in cSHAKE
            to.suffix = suffix;
            to.outputLen = outputLen;
            to.enableXOF = enableXOF;
            to.destroyed = this.destroyed;
            return to;
        }
    };
    const gen = (suffix, blockLen, outputLen) => wrapConstructor(() => new Keccak$1(blockLen, suffix, outputLen));
    /**
     * keccak-256 hash function. Different from SHA3-256.
     * @param message - that would be hashed
     */
    const keccak_256 = /* @__PURE__ */ gen(0x01, 136, 256 / 8);

    function keccak256(value, to_) {
        const to = to_ || 'hex';
        const bytes = keccak_256(isHex(value, { strict: false }) ? toBytes$1(value) : value);
        if (to === 'bytes')
            return bytes;
        return toHex$1(bytes);
    }

    function checksumAddress(address_, chainId) {
        const hexAddress = chainId
            ? `${chainId}${address_.toLowerCase()}`
            : address_.substring(2).toLowerCase();
        const hash = keccak256(stringToBytes$1(hexAddress), 'bytes');
        const address = (chainId ? hexAddress.substring(`${chainId}0x`.length) : hexAddress).split('');
        for (let i = 0; i < 40; i += 2) {
            if (hash[i >> 1] >> 4 >= 8 && address[i]) {
                address[i] = address[i].toUpperCase();
            }
            if ((hash[i >> 1] & 0x0f) >= 8 && address[i + 1]) {
                address[i + 1] = address[i + 1].toUpperCase();
            }
        }
        return `0x${address.join('')}`;
    }
    function getAddress(address, chainId) {
        if (!isAddress(address))
            throw new InvalidAddressError({ address });
        return checksumAddress(address, chainId);
    }

    const addressRegex = /^0x[a-fA-F0-9]{40}$/;
    const isAddressCache = /*#__PURE__*/ new LruMap(8192);
    function isAddress(address, { strict = true } = {}) {
        if (isAddressCache.has(address))
            return isAddressCache.get(address);
        const result = (() => {
            if (!addressRegex.test(address))
                return false;
            if (address.toLowerCase() === address)
                return true;
            if (strict)
                return checksumAddress(address) === address;
            return true;
        })();
        isAddressCache.set(address, result);
        return result;
    }

    /**
     * @description Returns a section of the hex or byte array given a start/end bytes offset.
     *
     * @param value The hex or byte array to slice.
     * @param start The start offset (in bytes).
     * @param end The end offset (in bytes).
     */
    function slice(value, start, end, { strict } = {}) {
        if (isHex(value, { strict: false }))
            return sliceHex(value, start, end, {
                strict,
            });
        return sliceBytes(value, start, end, {
            strict,
        });
    }
    function assertStartOffset(value, start) {
        if (typeof start === 'number' && start > 0 && start > size$3(value) - 1)
            throw new SliceOffsetOutOfBoundsError({
                offset: start,
                position: 'start',
                size: size$3(value),
            });
    }
    function assertEndOffset(value, start, end) {
        if (typeof start === 'number' &&
            typeof end === 'number' &&
            size$3(value) !== end - start) {
            throw new SliceOffsetOutOfBoundsError({
                offset: end,
                position: 'end',
                size: size$3(value),
            });
        }
    }
    /**
     * @description Returns a section of the byte array given a start/end bytes offset.
     *
     * @param value The byte array to slice.
     * @param start The start offset (in bytes).
     * @param end The end offset (in bytes).
     */
    function sliceBytes(value_, start, end, { strict } = {}) {
        assertStartOffset(value_, start);
        const value = value_.slice(start, end);
        if (strict)
            assertEndOffset(value, start, end);
        return value;
    }
    /**
     * @description Returns a section of the hex value given a start/end bytes offset.
     *
     * @param value The hex value to slice.
     * @param start The start offset (in bytes).
     * @param end The end offset (in bytes).
     */
    function sliceHex(value_, start, end, { strict } = {}) {
        assertStartOffset(value_, start);
        const value = `0x${value_
        .replace('0x', '')
        .slice((start ?? 0) * 2, (end ?? value_.length) * 2)}`;
        if (strict)
            assertEndOffset(value, start, end);
        return value;
    }

    /**
     * @description Encodes a list of primitive values into an ABI-encoded hex value.
     *
     * - Docs: https://viem.sh/docs/abi/encodeAbiParameters#encodeabiparameters
     *
     *   Generates ABI encoded data using the [ABI specification](https://docs.soliditylang.org/en/latest/abi-spec), given a set of ABI parameters (inputs/outputs) and their corresponding values.
     *
     * @param params - a set of ABI Parameters (params), that can be in the shape of the inputs or outputs attribute of an ABI Item.
     * @param values - a set of values (values) that correspond to the given params.
     * @example
     * ```typescript
     * import { encodeAbiParameters } from 'viem'
     *
     * const encodedData = encodeAbiParameters(
     *   [
     *     { name: 'x', type: 'string' },
     *     { name: 'y', type: 'uint' },
     *     { name: 'z', type: 'bool' }
     *   ],
     *   ['wagmi', 420n, true]
     * )
     * ```
     *
     * You can also pass in Human Readable parameters with the parseAbiParameters utility.
     *
     * @example
     * ```typescript
     * import { encodeAbiParameters, parseAbiParameters } from 'viem'
     *
     * const encodedData = encodeAbiParameters(
     *   parseAbiParameters('string x, uint y, bool z'),
     *   ['wagmi', 420n, true]
     * )
     * ```
     */
    function encodeAbiParameters(params, values) {
        if (params.length !== values.length)
            throw new AbiEncodingLengthMismatchError({
                expectedLength: params.length,
                givenLength: values.length,
            });
        // Prepare the parameters to determine dynamic types to encode.
        const preparedParams = prepareParams({
            params: params,
            values: values,
        });
        const data = encodeParams(preparedParams);
        if (data.length === 0)
            return '0x';
        return data;
    }
    function prepareParams({ params, values, }) {
        const preparedParams = [];
        for (let i = 0; i < params.length; i++) {
            preparedParams.push(prepareParam({ param: params[i], value: values[i] }));
        }
        return preparedParams;
    }
    function prepareParam({ param, value, }) {
        const arrayComponents = getArrayComponents(param.type);
        if (arrayComponents) {
            const [length, type] = arrayComponents;
            return encodeArray(value, { length, param: { ...param, type } });
        }
        if (param.type === 'tuple') {
            return encodeTuple(value, {
                param: param,
            });
        }
        if (param.type === 'address') {
            return encodeAddress(value);
        }
        if (param.type === 'bool') {
            return encodeBool(value);
        }
        if (param.type.startsWith('uint') || param.type.startsWith('int')) {
            const signed = param.type.startsWith('int');
            return encodeNumber(value, { signed });
        }
        if (param.type.startsWith('bytes')) {
            return encodeBytes(value, { param });
        }
        if (param.type === 'string') {
            return encodeString(value);
        }
        throw new InvalidAbiEncodingTypeError(param.type, {
            docsPath: '/docs/contract/encodeAbiParameters',
        });
    }
    function encodeParams(preparedParams) {
        // 1. Compute the size of the static part of the parameters.
        let staticSize = 0;
        for (let i = 0; i < preparedParams.length; i++) {
            const { dynamic, encoded } = preparedParams[i];
            if (dynamic)
                staticSize += 32;
            else
                staticSize += size$3(encoded);
        }
        // 2. Split the parameters into static and dynamic parts.
        const staticParams = [];
        const dynamicParams = [];
        let dynamicSize = 0;
        for (let i = 0; i < preparedParams.length; i++) {
            const { dynamic, encoded } = preparedParams[i];
            if (dynamic) {
                staticParams.push(numberToHex$1(staticSize + dynamicSize, { size: 32 }));
                dynamicParams.push(encoded);
                dynamicSize += size$3(encoded);
            }
            else {
                staticParams.push(encoded);
            }
        }
        // 3. Concatenate static and dynamic parts.
        return concat([...staticParams, ...dynamicParams]);
    }
    function encodeAddress(value) {
        if (!isAddress(value))
            throw new InvalidAddressError({ address: value });
        return { dynamic: false, encoded: padHex(value.toLowerCase()) };
    }
    function encodeArray(value, { length, param, }) {
        const dynamic = length === null;
        if (!Array.isArray(value))
            throw new InvalidArrayError(value);
        if (!dynamic && value.length !== length)
            throw new AbiEncodingArrayLengthMismatchError({
                expectedLength: length,
                givenLength: value.length,
                type: `${param.type}[${length}]`,
            });
        let dynamicChild = false;
        const preparedParams = [];
        for (let i = 0; i < value.length; i++) {
            const preparedParam = prepareParam({ param, value: value[i] });
            if (preparedParam.dynamic)
                dynamicChild = true;
            preparedParams.push(preparedParam);
        }
        if (dynamic || dynamicChild) {
            const data = encodeParams(preparedParams);
            if (dynamic) {
                const length = numberToHex$1(preparedParams.length, { size: 32 });
                return {
                    dynamic: true,
                    encoded: preparedParams.length > 0 ? concat([length, data]) : length,
                };
            }
            if (dynamicChild)
                return { dynamic: true, encoded: data };
        }
        return {
            dynamic: false,
            encoded: concat(preparedParams.map(({ encoded }) => encoded)),
        };
    }
    function encodeBytes(value, { param }) {
        const [, paramSize] = param.type.split('bytes');
        const bytesSize = size$3(value);
        if (!paramSize) {
            let value_ = value;
            // If the size is not divisible by 32 bytes, pad the end
            // with empty bytes to the ceiling 32 bytes.
            if (bytesSize % 32 !== 0)
                value_ = padHex(value_, {
                    dir: 'right',
                    size: Math.ceil((value.length - 2) / 2 / 32) * 32,
                });
            return {
                dynamic: true,
                encoded: concat([padHex(numberToHex$1(bytesSize, { size: 32 })), value_]),
            };
        }
        if (bytesSize !== parseInt(paramSize))
            throw new AbiEncodingBytesSizeMismatchError({
                expectedSize: parseInt(paramSize),
                value,
            });
        return { dynamic: false, encoded: padHex(value, { dir: 'right' }) };
    }
    function encodeBool(value) {
        if (typeof value !== 'boolean')
            throw new BaseError$1(`Invalid boolean value: "${value}" (type: ${typeof value}). Expected: \`true\` or \`false\`.`);
        return { dynamic: false, encoded: padHex(boolToHex(value)) };
    }
    function encodeNumber(value, { signed }) {
        return {
            dynamic: false,
            encoded: numberToHex$1(value, {
                size: 32,
                signed,
            }),
        };
    }
    function encodeString(value) {
        const hexValue = stringToHex(value);
        const partsLength = Math.ceil(size$3(hexValue) / 32);
        const parts = [];
        for (let i = 0; i < partsLength; i++) {
            parts.push(padHex(slice(hexValue, i * 32, (i + 1) * 32), {
                dir: 'right',
            }));
        }
        return {
            dynamic: true,
            encoded: concat([
                padHex(numberToHex$1(size$3(hexValue), { size: 32 })),
                ...parts,
            ]),
        };
    }
    function encodeTuple(value, { param }) {
        let dynamic = false;
        const preparedParams = [];
        for (let i = 0; i < param.components.length; i++) {
            const param_ = param.components[i];
            const index = Array.isArray(value) ? i : param_.name;
            const preparedParam = prepareParam({
                param: param_,
                value: value[index],
            });
            preparedParams.push(preparedParam);
            if (preparedParam.dynamic)
                dynamic = true;
        }
        return {
            dynamic,
            encoded: dynamic
                ? encodeParams(preparedParams)
                : concat(preparedParams.map(({ encoded }) => encoded)),
        };
    }
    function getArrayComponents(type) {
        const matches = type.match(/^(.*)\[(\d+)?\]$/);
        return matches
            ? // Return `null` if the array is dynamic.
                [matches[2] ? Number(matches[2]) : null, matches[1]]
            : undefined;
    }

    function parseAccount(account) {
        if (typeof account === 'string')
            return { address: account, type: 'json-rpc' };
        return account;
    }

    class AccountNotFoundError extends BaseError$1 {
        constructor({ docsPath } = {}) {
            super([
                'Could not find an Account to execute with this Action.',
                'Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the WalletClient.',
            ].join('\n'), {
                docsPath,
                docsSlug: 'account',
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'AccountNotFoundError'
            });
        }
    }

    class ChainDoesNotSupportContract extends BaseError$1 {
        constructor({ blockNumber, chain, contract, }) {
            super(`Chain "${chain.name}" does not support contract "${contract.name}".`, {
                metaMessages: [
                    'This could be due to any of the following:',
                    ...(blockNumber &&
                        contract.blockCreated &&
                        contract.blockCreated > blockNumber
                        ? [
                            `- The contract "${contract.name}" was not deployed until block ${contract.blockCreated} (current block ${blockNumber}).`,
                        ]
                        : [
                            `- The chain does not have the contract "${contract.name}" configured.`,
                        ]),
                ],
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'ChainDoesNotSupportContract'
            });
        }
    }
    class ClientChainNotConfiguredError extends BaseError$1 {
        constructor() {
            super('No chain was provided to the Client.');
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'ClientChainNotConfiguredError'
            });
        }
    }

    const etherUnits = {
        gwei: 9,
        wei: 18,
    };
    const gweiUnits = {
        ether: -9,
        wei: 9,
    };
    const weiUnits = {
        ether: -18,
        gwei: -9,
    };

    /**
     *  Divides a number by a given exponent of base 10 (10exponent), and formats it into a string representation of the number..
     *
     * - Docs: https://viem.sh/docs/utilities/formatUnits
     *
     * @example
     * import { formatUnits } from 'viem'
     *
     * formatUnits(420000000000n, 9)
     * // '420'
     */
    function formatUnits(value, decimals) {
        let display = value.toString();
        const negative = display.startsWith('-');
        if (negative)
            display = display.slice(1);
        display = display.padStart(decimals, '0');
        let [integer, fraction] = [
            display.slice(0, display.length - decimals),
            display.slice(display.length - decimals),
        ];
        fraction = fraction.replace(/(0+)$/, '');
        return `${negative ? '-' : ''}${integer || '0'}${fraction ? `.${fraction}` : ''}`;
    }

    /**
     * Converts numerical wei to a string representation of gwei.
     *
     * - Docs: https://viem.sh/docs/utilities/formatGwei
     *
     * @example
     * import { formatGwei } from 'viem'
     *
     * formatGwei(1000000000n)
     * // '1'
     */
    function formatGwei(wei, unit = 'wei') {
        return formatUnits(wei, gweiUnits[unit]);
    }

    class ExecutionRevertedError extends BaseError$1 {
        constructor({ cause, message, } = {}) {
            const reason = message
                ?.replace('execution reverted: ', '')
                ?.replace('execution reverted', '');
            super(`Execution reverted ${reason ? `with reason: ${reason}` : 'for an unknown reason'}.`, {
                cause,
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'ExecutionRevertedError'
            });
        }
    }
    Object.defineProperty(ExecutionRevertedError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: 3
    });
    Object.defineProperty(ExecutionRevertedError, "nodeMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /execution reverted/
    });
    class FeeCapTooHighError extends BaseError$1 {
        constructor({ cause, maxFeePerGas, } = {}) {
            super(`The fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)} gwei` : ''}) cannot be higher than the maximum allowed value (2^256-1).`, {
                cause,
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'FeeCapTooHigh'
            });
        }
    }
    Object.defineProperty(FeeCapTooHighError, "nodeMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /max fee per gas higher than 2\^256-1|fee cap higher than 2\^256-1/
    });
    class FeeCapTooLowError extends BaseError$1 {
        constructor({ cause, maxFeePerGas, } = {}) {
            super(`The fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)}` : ''} gwei) cannot be lower than the block base fee.`, {
                cause,
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'FeeCapTooLow'
            });
        }
    }
    Object.defineProperty(FeeCapTooLowError, "nodeMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /max fee per gas less than block base fee|fee cap less than block base fee|transaction is outdated/
    });
    class NonceTooHighError extends BaseError$1 {
        constructor({ cause, nonce, } = {}) {
            super(`Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ''}is higher than the next one expected.`, { cause });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'NonceTooHighError'
            });
        }
    }
    Object.defineProperty(NonceTooHighError, "nodeMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /nonce too high/
    });
    class NonceTooLowError extends BaseError$1 {
        constructor({ cause, nonce, } = {}) {
            super([
                `Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ''}is lower than the current nonce of the account.`,
                'Try increasing the nonce or find the latest nonce with `getTransactionCount`.',
            ].join('\n'), { cause });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'NonceTooLowError'
            });
        }
    }
    Object.defineProperty(NonceTooLowError, "nodeMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /nonce too low|transaction already imported|already known/
    });
    class NonceMaxValueError extends BaseError$1 {
        constructor({ cause, nonce, } = {}) {
            super(`Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ''}exceeds the maximum allowed nonce.`, { cause });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'NonceMaxValueError'
            });
        }
    }
    Object.defineProperty(NonceMaxValueError, "nodeMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /nonce has max value/
    });
    class InsufficientFundsError extends BaseError$1 {
        constructor({ cause } = {}) {
            super([
                'The total cost (gas * gas fee + value) of executing this transaction exceeds the balance of the account.',
            ].join('\n'), {
                cause,
                metaMessages: [
                    'This error could arise when the account does not have enough funds to:',
                    ' - pay for the total gas fee,',
                    ' - pay for the value to send.',
                    ' ',
                    'The cost of the transaction is calculated as `gas * gas fee + value`, where:',
                    ' - `gas` is the amount of gas needed for transaction to execute,',
                    ' - `gas fee` is the gas fee,',
                    ' - `value` is the amount of ether to send to the recipient.',
                ],
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'InsufficientFundsError'
            });
        }
    }
    Object.defineProperty(InsufficientFundsError, "nodeMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /insufficient funds/
    });
    class IntrinsicGasTooHighError extends BaseError$1 {
        constructor({ cause, gas, } = {}) {
            super(`The amount of gas ${gas ? `(${gas}) ` : ''}provided for the transaction exceeds the limit allowed for the block.`, {
                cause,
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'IntrinsicGasTooHighError'
            });
        }
    }
    Object.defineProperty(IntrinsicGasTooHighError, "nodeMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /intrinsic gas too high|gas limit reached/
    });
    class IntrinsicGasTooLowError extends BaseError$1 {
        constructor({ cause, gas, } = {}) {
            super(`The amount of gas ${gas ? `(${gas}) ` : ''}provided for the transaction is too low.`, {
                cause,
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'IntrinsicGasTooLowError'
            });
        }
    }
    Object.defineProperty(IntrinsicGasTooLowError, "nodeMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /intrinsic gas too low/
    });
    class TransactionTypeNotSupportedError extends BaseError$1 {
        constructor({ cause }) {
            super('The transaction type is not supported for this chain.', {
                cause,
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'TransactionTypeNotSupportedError'
            });
        }
    }
    Object.defineProperty(TransactionTypeNotSupportedError, "nodeMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /transaction type not valid/
    });
    class TipAboveFeeCapError extends BaseError$1 {
        constructor({ cause, maxPriorityFeePerGas, maxFeePerGas, } = {}) {
            super([
                `The provided tip (\`maxPriorityFeePerGas\`${maxPriorityFeePerGas
                ? ` = ${formatGwei(maxPriorityFeePerGas)} gwei`
                : ''}) cannot be higher than the fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)} gwei` : ''}).`,
            ].join('\n'), {
                cause,
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'TipAboveFeeCapError'
            });
        }
    }
    Object.defineProperty(TipAboveFeeCapError, "nodeMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /max priority fee per gas higher than max fee per gas|tip higher than fee cap/
    });
    class UnknownNodeError extends BaseError$1 {
        constructor({ cause }) {
            super(`An error occurred while executing: ${cause?.shortMessage}`, {
                cause,
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'UnknownNodeError'
            });
        }
    }

    /**
     * Converts numerical wei to a string representation of ether.
     *
     * - Docs: https://viem.sh/docs/utilities/formatEther
     *
     * @example
     * import { formatEther } from 'viem'
     *
     * formatEther(1000000000000000000n)
     * // '1'
     */
    function formatEther(wei, unit = 'wei') {
        return formatUnits(wei, etherUnits[unit]);
    }

    function prettyPrint(args) {
        const entries = Object.entries(args)
            .map(([key, value]) => {
            if (value === undefined || value === false)
                return null;
            return [key, value];
        })
            .filter(Boolean);
        const maxLength = entries.reduce((acc, [key]) => Math.max(acc, key.length), 0);
        return entries
            .map(([key, value]) => `  ${`${key}:`.padEnd(maxLength + 1)}  ${value}`)
            .join('\n');
    }
    class FeeConflictError extends BaseError$1 {
        constructor() {
            super([
                'Cannot specify both a `gasPrice` and a `maxFeePerGas`/`maxPriorityFeePerGas`.',
                'Use `maxFeePerGas`/`maxPriorityFeePerGas` for EIP-1559 compatible networks, and `gasPrice` for others.',
            ].join('\n'));
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'FeeConflictError'
            });
        }
    }

    const stringify$1 = (value, replacer, space) => JSON.stringify(value, (key, value_) => {
        const value = typeof value_ === 'bigint' ? value_.toString() : value_;
        return typeof replacer === 'function' ? replacer(key, value) : value;
    }, space);

    class HttpRequestError extends BaseError$1 {
        constructor({ body, details, headers, status, url, }) {
            super('HTTP request failed.', {
                details,
                metaMessages: [
                    status && `Status: ${status}`,
                    `URL: ${getUrl(url)}`,
                    body && `Request body: ${stringify$1(body)}`,
                ].filter(Boolean),
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'HttpRequestError'
            });
            Object.defineProperty(this, "body", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "headers", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "status", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "url", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            this.body = body;
            this.headers = headers;
            this.status = status;
            this.url = url;
        }
    }
    class RpcRequestError extends BaseError$1 {
        constructor({ body, error, url, }) {
            super('RPC Request failed.', {
                cause: error,
                details: error.message,
                metaMessages: [`URL: ${getUrl(url)}`, `Request body: ${stringify$1(body)}`],
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'RpcRequestError'
            });
            Object.defineProperty(this, "code", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            this.code = error.code;
        }
    }
    class TimeoutError extends BaseError$1 {
        constructor({ body, url, }) {
            super('The request took too long to respond.', {
                details: 'The request timed out.',
                metaMessages: [`URL: ${getUrl(url)}`, `Request body: ${stringify$1(body)}`],
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'TimeoutError'
            });
        }
    }

    const unknownErrorCode = -1;
    class RpcError extends BaseError$1 {
        constructor(cause, { code, docsPath, metaMessages, shortMessage }) {
            super(shortMessage, {
                cause,
                docsPath,
                metaMessages: metaMessages || cause?.metaMessages,
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'RpcError'
            });
            Object.defineProperty(this, "code", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            this.name = cause.name;
            this.code = (cause instanceof RpcRequestError ? cause.code : code ?? unknownErrorCode);
        }
    }
    class ProviderRpcError extends RpcError {
        constructor(cause, options) {
            super(cause, options);
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'ProviderRpcError'
            });
            Object.defineProperty(this, "data", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            this.data = options.data;
        }
    }
    class ParseRpcError extends RpcError {
        constructor(cause) {
            super(cause, {
                code: ParseRpcError.code,
                shortMessage: 'Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text.',
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'ParseRpcError'
            });
        }
    }
    Object.defineProperty(ParseRpcError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: -32700
    });
    class InvalidRequestRpcError extends RpcError {
        constructor(cause) {
            super(cause, {
                code: InvalidRequestRpcError.code,
                shortMessage: 'JSON is not a valid request object.',
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'InvalidRequestRpcError'
            });
        }
    }
    Object.defineProperty(InvalidRequestRpcError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: -32600
    });
    class MethodNotFoundRpcError extends RpcError {
        constructor(cause) {
            super(cause, {
                code: MethodNotFoundRpcError.code,
                shortMessage: 'The method does not exist / is not available.',
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'MethodNotFoundRpcError'
            });
        }
    }
    Object.defineProperty(MethodNotFoundRpcError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: -32601
    });
    class InvalidParamsRpcError extends RpcError {
        constructor(cause) {
            super(cause, {
                code: InvalidParamsRpcError.code,
                shortMessage: [
                    'Invalid parameters were provided to the RPC method.',
                    'Double check you have provided the correct parameters.',
                ].join('\n'),
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'InvalidParamsRpcError'
            });
        }
    }
    Object.defineProperty(InvalidParamsRpcError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: -32602
    });
    class InternalRpcError extends RpcError {
        constructor(cause) {
            super(cause, {
                code: InternalRpcError.code,
                shortMessage: 'An internal error was received.',
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'InternalRpcError'
            });
        }
    }
    Object.defineProperty(InternalRpcError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: -32603
    });
    class InvalidInputRpcError extends RpcError {
        constructor(cause) {
            super(cause, {
                code: InvalidInputRpcError.code,
                shortMessage: [
                    'Missing or invalid parameters.',
                    'Double check you have provided the correct parameters.',
                ].join('\n'),
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'InvalidInputRpcError'
            });
        }
    }
    Object.defineProperty(InvalidInputRpcError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: -32000
    });
    class ResourceNotFoundRpcError extends RpcError {
        constructor(cause) {
            super(cause, {
                code: ResourceNotFoundRpcError.code,
                shortMessage: 'Requested resource not found.',
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'ResourceNotFoundRpcError'
            });
        }
    }
    Object.defineProperty(ResourceNotFoundRpcError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: -32001
    });
    class ResourceUnavailableRpcError extends RpcError {
        constructor(cause) {
            super(cause, {
                code: ResourceUnavailableRpcError.code,
                shortMessage: 'Requested resource not available.',
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'ResourceUnavailableRpcError'
            });
        }
    }
    Object.defineProperty(ResourceUnavailableRpcError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: -32002
    });
    class TransactionRejectedRpcError extends RpcError {
        constructor(cause) {
            super(cause, {
                code: TransactionRejectedRpcError.code,
                shortMessage: 'Transaction creation failed.',
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'TransactionRejectedRpcError'
            });
        }
    }
    Object.defineProperty(TransactionRejectedRpcError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: -32003
    });
    class MethodNotSupportedRpcError extends RpcError {
        constructor(cause) {
            super(cause, {
                code: MethodNotSupportedRpcError.code,
                shortMessage: 'Method is not implemented.',
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'MethodNotSupportedRpcError'
            });
        }
    }
    Object.defineProperty(MethodNotSupportedRpcError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: -32004
    });
    class LimitExceededRpcError extends RpcError {
        constructor(cause) {
            super(cause, {
                code: LimitExceededRpcError.code,
                shortMessage: 'Request exceeds defined limit.',
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'LimitExceededRpcError'
            });
        }
    }
    Object.defineProperty(LimitExceededRpcError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: -32005
    });
    class JsonRpcVersionUnsupportedError extends RpcError {
        constructor(cause) {
            super(cause, {
                code: JsonRpcVersionUnsupportedError.code,
                shortMessage: 'Version of JSON-RPC protocol is not supported.',
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'JsonRpcVersionUnsupportedError'
            });
        }
    }
    Object.defineProperty(JsonRpcVersionUnsupportedError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: -32006
    });
    class UserRejectedRequestError extends ProviderRpcError {
        constructor(cause) {
            super(cause, {
                code: UserRejectedRequestError.code,
                shortMessage: 'User rejected the request.',
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'UserRejectedRequestError'
            });
        }
    }
    Object.defineProperty(UserRejectedRequestError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: 4001
    });
    class UnauthorizedProviderError extends ProviderRpcError {
        constructor(cause) {
            super(cause, {
                code: UnauthorizedProviderError.code,
                shortMessage: 'The requested method and/or account has not been authorized by the user.',
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'UnauthorizedProviderError'
            });
        }
    }
    Object.defineProperty(UnauthorizedProviderError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: 4100
    });
    class UnsupportedProviderMethodError extends ProviderRpcError {
        constructor(cause) {
            super(cause, {
                code: UnsupportedProviderMethodError.code,
                shortMessage: 'The Provider does not support the requested method.',
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'UnsupportedProviderMethodError'
            });
        }
    }
    Object.defineProperty(UnsupportedProviderMethodError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: 4200
    });
    class ProviderDisconnectedError extends ProviderRpcError {
        constructor(cause) {
            super(cause, {
                code: ProviderDisconnectedError.code,
                shortMessage: 'The Provider is disconnected from all chains.',
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'ProviderDisconnectedError'
            });
        }
    }
    Object.defineProperty(ProviderDisconnectedError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: 4900
    });
    class ChainDisconnectedError extends ProviderRpcError {
        constructor(cause) {
            super(cause, {
                code: ChainDisconnectedError.code,
                shortMessage: 'The Provider is not connected to the requested chain.',
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'ChainDisconnectedError'
            });
        }
    }
    Object.defineProperty(ChainDisconnectedError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: 4901
    });
    class SwitchChainError extends ProviderRpcError {
        constructor(cause) {
            super(cause, {
                code: SwitchChainError.code,
                shortMessage: 'An error occurred when attempting to switch chain.',
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'SwitchChainError'
            });
        }
    }
    Object.defineProperty(SwitchChainError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: 4902
    });
    class UnknownRpcError extends RpcError {
        constructor(cause) {
            super(cause, {
                shortMessage: 'An unknown RPC error occurred.',
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'UnknownRpcError'
            });
        }
    }

    function getNodeError(err, args) {
        const message = (err.details || '').toLowerCase();
        const executionRevertedError = err instanceof BaseError$1
            ? err.walk((e) => e.code === ExecutionRevertedError.code)
            : err;
        if (executionRevertedError instanceof BaseError$1) {
            return new ExecutionRevertedError({
                cause: err,
                message: executionRevertedError.details,
            });
        }
        if (ExecutionRevertedError.nodeMessage.test(message))
            return new ExecutionRevertedError({
                cause: err,
                message: err.details,
            });
        if (FeeCapTooHighError.nodeMessage.test(message))
            return new FeeCapTooHighError({
                cause: err,
                maxFeePerGas: args?.maxFeePerGas,
            });
        if (FeeCapTooLowError.nodeMessage.test(message))
            return new FeeCapTooLowError({
                cause: err,
                maxFeePerGas: args?.maxFeePerGas,
            });
        if (NonceTooHighError.nodeMessage.test(message))
            return new NonceTooHighError({ cause: err, nonce: args?.nonce });
        if (NonceTooLowError.nodeMessage.test(message))
            return new NonceTooLowError({ cause: err, nonce: args?.nonce });
        if (NonceMaxValueError.nodeMessage.test(message))
            return new NonceMaxValueError({ cause: err, nonce: args?.nonce });
        if (InsufficientFundsError.nodeMessage.test(message))
            return new InsufficientFundsError({ cause: err });
        if (IntrinsicGasTooHighError.nodeMessage.test(message))
            return new IntrinsicGasTooHighError({ cause: err, gas: args?.gas });
        if (IntrinsicGasTooLowError.nodeMessage.test(message))
            return new IntrinsicGasTooLowError({ cause: err, gas: args?.gas });
        if (TransactionTypeNotSupportedError.nodeMessage.test(message))
            return new TransactionTypeNotSupportedError({ cause: err });
        if (TipAboveFeeCapError.nodeMessage.test(message))
            return new TipAboveFeeCapError({
                cause: err,
                maxFeePerGas: args?.maxFeePerGas,
                maxPriorityFeePerGas: args?.maxPriorityFeePerGas,
            });
        return new UnknownNodeError({
            cause: err,
        });
    }

    /**
     * @description Picks out the keys from `value` that exist in the formatter..
     */
    function extract(value_, { format }) {
        if (!format)
            return {};
        const value = {};
        function extract_(formatted) {
            const keys = Object.keys(formatted);
            for (const key of keys) {
                if (key in value_)
                    value[key] = value_[key];
                if (formatted[key] &&
                    typeof formatted[key] === 'object' &&
                    !Array.isArray(formatted[key]))
                    extract_(formatted[key]);
            }
        }
        const formatted = format(value_ || {});
        extract_(formatted);
        return value;
    }

    const rpcTransactionType = {
        legacy: '0x0',
        eip2930: '0x1',
        eip1559: '0x2',
        eip4844: '0x3',
    };
    function formatTransactionRequest(request) {
        const rpcRequest = { ...request };
        if (typeof request.blobs !== 'undefined' &&
            typeof request.blobs[0] !== 'string')
            rpcRequest.blobs = request.blobs.map((x) => bytesToHex$1(x));
        if (typeof request.gas !== 'undefined')
            rpcRequest.gas = numberToHex$1(request.gas);
        if (typeof request.gasPrice !== 'undefined')
            rpcRequest.gasPrice = numberToHex$1(request.gasPrice);
        if (typeof request.maxFeePerBlobGas !== 'undefined')
            rpcRequest.maxFeePerBlobGas = numberToHex$1(request.maxFeePerBlobGas);
        if (typeof request.maxFeePerGas !== 'undefined')
            rpcRequest.maxFeePerGas = numberToHex$1(request.maxFeePerGas);
        if (typeof request.maxPriorityFeePerGas !== 'undefined')
            rpcRequest.maxPriorityFeePerGas = numberToHex$1(request.maxPriorityFeePerGas);
        if (typeof request.nonce !== 'undefined')
            rpcRequest.nonce = numberToHex$1(request.nonce);
        if (typeof request.type !== 'undefined')
            rpcRequest.type = rpcTransactionType[request.type];
        if (typeof request.value !== 'undefined')
            rpcRequest.value = numberToHex$1(request.value);
        return rpcRequest;
    }

    /**
     * Retrieves and returns an action from the client (if exists), and falls
     * back to the tree-shakable action.
     *
     * Useful for extracting overridden actions from a client (ie. if a consumer
     * wants to override the `sendTransaction` implementation).
     */
    function getAction$1(client, action, 
    // Some minifiers drop `Function.prototype.name`, meaning that `action.name`
    // will not work. For that case, the consumer needs to pass the name explicitly.
    name) {
        return (params) => client[action.name || name]?.(params) ?? action(client, params);
    }

    function assertRequest(args) {
        const { account: account_, gasPrice, maxFeePerGas, maxPriorityFeePerGas, to, } = args;
        const account = account_ ? parseAccount(account_) : undefined;
        if (account && !isAddress(account.address))
            throw new InvalidAddressError({ address: account.address });
        if (to && !isAddress(to))
            throw new InvalidAddressError({ address: to });
        if (typeof gasPrice !== 'undefined' &&
            (typeof maxFeePerGas !== 'undefined' ||
                typeof maxPriorityFeePerGas !== 'undefined'))
            throw new FeeConflictError();
        if (maxFeePerGas && maxFeePerGas > 2n ** 256n - 1n)
            throw new FeeCapTooHighError({ maxFeePerGas });
        if (maxPriorityFeePerGas &&
            maxFeePerGas &&
            maxPriorityFeePerGas > maxFeePerGas)
            throw new TipAboveFeeCapError({ maxFeePerGas, maxPriorityFeePerGas });
    }

    /* [Multicall3](https://github.com/mds1/multicall) */
    const multicall3Abi = [
        {
            inputs: [
                {
                    components: [
                        {
                            name: 'target',
                            type: 'address',
                        },
                        {
                            name: 'allowFailure',
                            type: 'bool',
                        },
                        {
                            name: 'callData',
                            type: 'bytes',
                        },
                    ],
                    name: 'calls',
                    type: 'tuple[]',
                },
            ],
            name: 'aggregate3',
            outputs: [
                {
                    components: [
                        {
                            name: 'success',
                            type: 'bool',
                        },
                        {
                            name: 'returnData',
                            type: 'bytes',
                        },
                    ],
                    name: 'returnData',
                    type: 'tuple[]',
                },
            ],
            stateMutability: 'view',
            type: 'function',
        },
    ];
    const universalResolverErrors = [
        {
            inputs: [],
            name: 'ResolverNotFound',
            type: 'error',
        },
        {
            inputs: [],
            name: 'ResolverWildcardNotSupported',
            type: 'error',
        },
        {
            inputs: [],
            name: 'ResolverNotContract',
            type: 'error',
        },
        {
            inputs: [
                {
                    name: 'returnData',
                    type: 'bytes',
                },
            ],
            name: 'ResolverError',
            type: 'error',
        },
        {
            inputs: [
                {
                    components: [
                        {
                            name: 'status',
                            type: 'uint16',
                        },
                        {
                            name: 'message',
                            type: 'string',
                        },
                    ],
                    name: 'errors',
                    type: 'tuple[]',
                },
            ],
            name: 'HttpError',
            type: 'error',
        },
    ];
    const universalResolverResolveAbi = [
        ...universalResolverErrors,
        {
            name: 'resolve',
            type: 'function',
            stateMutability: 'view',
            inputs: [
                { name: 'name', type: 'bytes' },
                { name: 'data', type: 'bytes' },
            ],
            outputs: [
                { name: '', type: 'bytes' },
                { name: 'address', type: 'address' },
            ],
        },
        {
            name: 'resolve',
            type: 'function',
            stateMutability: 'view',
            inputs: [
                { name: 'name', type: 'bytes' },
                { name: 'data', type: 'bytes' },
                { name: 'gateways', type: 'string[]' },
            ],
            outputs: [
                { name: '', type: 'bytes' },
                { name: 'address', type: 'address' },
            ],
        },
    ];
    const universalResolverReverseAbi = [
        ...universalResolverErrors,
        {
            name: 'reverse',
            type: 'function',
            stateMutability: 'view',
            inputs: [{ type: 'bytes', name: 'reverseName' }],
            outputs: [
                { type: 'string', name: 'resolvedName' },
                { type: 'address', name: 'resolvedAddress' },
                { type: 'address', name: 'reverseResolver' },
                { type: 'address', name: 'resolver' },
            ],
        },
        {
            name: 'reverse',
            type: 'function',
            stateMutability: 'view',
            inputs: [
                { type: 'bytes', name: 'reverseName' },
                { type: 'string[]', name: 'gateways' },
            ],
            outputs: [
                { type: 'string', name: 'resolvedName' },
                { type: 'address', name: 'resolvedAddress' },
                { type: 'address', name: 'reverseResolver' },
                { type: 'address', name: 'resolver' },
            ],
        },
    ];
    const textResolverAbi = [
        {
            name: 'text',
            type: 'function',
            stateMutability: 'view',
            inputs: [
                { name: 'name', type: 'bytes32' },
                { name: 'key', type: 'string' },
            ],
            outputs: [{ name: '', type: 'string' }],
        },
    ];

    class NegativeOffsetError extends BaseError$1 {
        constructor({ offset }) {
            super(`Offset \`${offset}\` cannot be negative.`);
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'NegativeOffsetError'
            });
        }
    }
    class PositionOutOfBoundsError extends BaseError$1 {
        constructor({ length, position }) {
            super(`Position \`${position}\` is out of bounds (\`0 < position < ${length}\`).`);
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'PositionOutOfBoundsError'
            });
        }
    }
    class RecursiveReadLimitExceededError extends BaseError$1 {
        constructor({ count, limit }) {
            super(`Recursive read limit of \`${limit}\` exceeded (recursive read count: \`${count}\`).`);
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'RecursiveReadLimitExceededError'
            });
        }
    }

    const staticCursor = {
        bytes: new Uint8Array(),
        dataView: new DataView(new ArrayBuffer(0)),
        position: 0,
        positionReadCount: new Map(),
        recursiveReadCount: 0,
        recursiveReadLimit: Infinity,
        assertReadLimit() {
            if (this.recursiveReadCount >= this.recursiveReadLimit)
                throw new RecursiveReadLimitExceededError({
                    count: this.recursiveReadCount + 1,
                    limit: this.recursiveReadLimit,
                });
        },
        assertPosition(position) {
            if (position < 0 || position > this.bytes.length - 1)
                throw new PositionOutOfBoundsError({
                    length: this.bytes.length,
                    position,
                });
        },
        decrementPosition(offset) {
            if (offset < 0)
                throw new NegativeOffsetError({ offset });
            const position = this.position - offset;
            this.assertPosition(position);
            this.position = position;
        },
        getReadCount(position) {
            return this.positionReadCount.get(position || this.position) || 0;
        },
        incrementPosition(offset) {
            if (offset < 0)
                throw new NegativeOffsetError({ offset });
            const position = this.position + offset;
            this.assertPosition(position);
            this.position = position;
        },
        inspectByte(position_) {
            const position = position_ ?? this.position;
            this.assertPosition(position);
            return this.bytes[position];
        },
        inspectBytes(length, position_) {
            const position = position_ ?? this.position;
            this.assertPosition(position + length - 1);
            return this.bytes.subarray(position, position + length);
        },
        inspectUint8(position_) {
            const position = position_ ?? this.position;
            this.assertPosition(position);
            return this.bytes[position];
        },
        inspectUint16(position_) {
            const position = position_ ?? this.position;
            this.assertPosition(position + 1);
            return this.dataView.getUint16(position);
        },
        inspectUint24(position_) {
            const position = position_ ?? this.position;
            this.assertPosition(position + 2);
            return ((this.dataView.getUint16(position) << 8) +
                this.dataView.getUint8(position + 2));
        },
        inspectUint32(position_) {
            const position = position_ ?? this.position;
            this.assertPosition(position + 3);
            return this.dataView.getUint32(position);
        },
        pushByte(byte) {
            this.assertPosition(this.position);
            this.bytes[this.position] = byte;
            this.position++;
        },
        pushBytes(bytes) {
            this.assertPosition(this.position + bytes.length - 1);
            this.bytes.set(bytes, this.position);
            this.position += bytes.length;
        },
        pushUint8(value) {
            this.assertPosition(this.position);
            this.bytes[this.position] = value;
            this.position++;
        },
        pushUint16(value) {
            this.assertPosition(this.position + 1);
            this.dataView.setUint16(this.position, value);
            this.position += 2;
        },
        pushUint24(value) {
            this.assertPosition(this.position + 2);
            this.dataView.setUint16(this.position, value >> 8);
            this.dataView.setUint8(this.position + 2, value & ~4294967040);
            this.position += 3;
        },
        pushUint32(value) {
            this.assertPosition(this.position + 3);
            this.dataView.setUint32(this.position, value);
            this.position += 4;
        },
        readByte() {
            this.assertReadLimit();
            this._touch();
            const value = this.inspectByte();
            this.position++;
            return value;
        },
        readBytes(length, size) {
            this.assertReadLimit();
            this._touch();
            const value = this.inspectBytes(length);
            this.position += size ?? length;
            return value;
        },
        readUint8() {
            this.assertReadLimit();
            this._touch();
            const value = this.inspectUint8();
            this.position += 1;
            return value;
        },
        readUint16() {
            this.assertReadLimit();
            this._touch();
            const value = this.inspectUint16();
            this.position += 2;
            return value;
        },
        readUint24() {
            this.assertReadLimit();
            this._touch();
            const value = this.inspectUint24();
            this.position += 3;
            return value;
        },
        readUint32() {
            this.assertReadLimit();
            this._touch();
            const value = this.inspectUint32();
            this.position += 4;
            return value;
        },
        get remaining() {
            return this.bytes.length - this.position;
        },
        setPosition(position) {
            const oldPosition = this.position;
            this.assertPosition(position);
            this.position = position;
            return () => (this.position = oldPosition);
        },
        _touch() {
            if (this.recursiveReadLimit === Infinity)
                return;
            const count = this.getReadCount();
            this.positionReadCount.set(this.position, count + 1);
            if (count > 0)
                this.recursiveReadCount++;
        },
    };
    function createCursor(bytes, { recursiveReadLimit = 8_192 } = {}) {
        const cursor = Object.create(staticCursor);
        cursor.bytes = bytes;
        cursor.dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
        cursor.positionReadCount = new Map();
        cursor.recursiveReadLimit = recursiveReadLimit;
        return cursor;
    }

    /**
     * Decodes a byte array into a bigint.
     *
     * - Docs: https://viem.sh/docs/utilities/fromBytes#bytestobigint
     *
     * @param bytes Byte array to decode.
     * @param opts Options.
     * @returns BigInt value.
     *
     * @example
     * import { bytesToBigInt } from 'viem'
     * const data = bytesToBigInt(new Uint8Array([1, 164]))
     * // 420n
     */
    function bytesToBigInt$1(bytes, opts = {}) {
        if (typeof opts.size !== 'undefined')
            assertSize$1(bytes, { size: opts.size });
        const hex = bytesToHex$1(bytes, opts);
        return hexToBigInt$1(hex, opts);
    }
    /**
     * Decodes a byte array into a boolean.
     *
     * - Docs: https://viem.sh/docs/utilities/fromBytes#bytestobool
     *
     * @param bytes Byte array to decode.
     * @param opts Options.
     * @returns Boolean value.
     *
     * @example
     * import { bytesToBool } from 'viem'
     * const data = bytesToBool(new Uint8Array([1]))
     * // true
     */
    function bytesToBool(bytes_, opts = {}) {
        let bytes = bytes_;
        if (typeof opts.size !== 'undefined') {
            assertSize$1(bytes, { size: opts.size });
            bytes = trim(bytes);
        }
        if (bytes.length > 1 || bytes[0] > 1)
            throw new InvalidBytesBooleanError(bytes);
        return Boolean(bytes[0]);
    }
    /**
     * Decodes a byte array into a number.
     *
     * - Docs: https://viem.sh/docs/utilities/fromBytes#bytestonumber
     *
     * @param bytes Byte array to decode.
     * @param opts Options.
     * @returns Number value.
     *
     * @example
     * import { bytesToNumber } from 'viem'
     * const data = bytesToNumber(new Uint8Array([1, 164]))
     * // 420
     */
    function bytesToNumber$1(bytes, opts = {}) {
        if (typeof opts.size !== 'undefined')
            assertSize$1(bytes, { size: opts.size });
        const hex = bytesToHex$1(bytes, opts);
        return hexToNumber$1(hex, opts);
    }
    /**
     * Decodes a byte array into a UTF-8 string.
     *
     * - Docs: https://viem.sh/docs/utilities/fromBytes#bytestostring
     *
     * @param bytes Byte array to decode.
     * @param opts Options.
     * @returns String value.
     *
     * @example
     * import { bytesToString } from 'viem'
     * const data = bytesToString(new Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))
     * // 'Hello world'
     */
    function bytesToString$1(bytes_, opts = {}) {
        let bytes = bytes_;
        if (typeof opts.size !== 'undefined') {
            assertSize$1(bytes, { size: opts.size });
            bytes = trim(bytes, { dir: 'right' });
        }
        return new TextDecoder().decode(bytes);
    }

    function decodeAbiParameters(params, data) {
        const bytes = typeof data === 'string' ? hexToBytes$1(data) : data;
        const cursor = createCursor(bytes);
        if (size$3(bytes) === 0 && params.length > 0)
            throw new AbiDecodingZeroDataError();
        if (size$3(data) && size$3(data) < 32)
            throw new AbiDecodingDataSizeTooSmallError({
                data: typeof data === 'string' ? data : bytesToHex$1(data),
                params: params,
                size: size$3(data),
            });
        let consumed = 0;
        const values = [];
        for (let i = 0; i < params.length; ++i) {
            const param = params[i];
            cursor.setPosition(consumed);
            const [data, consumed_] = decodeParameter(cursor, param, {
                staticPosition: 0,
            });
            consumed += consumed_;
            values.push(data);
        }
        return values;
    }
    function decodeParameter(cursor, param, { staticPosition }) {
        const arrayComponents = getArrayComponents(param.type);
        if (arrayComponents) {
            const [length, type] = arrayComponents;
            return decodeArray(cursor, { ...param, type }, { length, staticPosition });
        }
        if (param.type === 'tuple')
            return decodeTuple(cursor, param, { staticPosition });
        if (param.type === 'address')
            return decodeAddress(cursor);
        if (param.type === 'bool')
            return decodeBool(cursor);
        if (param.type.startsWith('bytes'))
            return decodeBytes(cursor, param, { staticPosition });
        if (param.type.startsWith('uint') || param.type.startsWith('int'))
            return decodeNumber(cursor, param);
        if (param.type === 'string')
            return decodeString(cursor, { staticPosition });
        throw new InvalidAbiDecodingTypeError(param.type, {
            docsPath: '/docs/contract/decodeAbiParameters',
        });
    }
    ////////////////////////////////////////////////////////////////////
    // Type Decoders
    const sizeOfLength = 32;
    const sizeOfOffset = 32;
    function decodeAddress(cursor) {
        const value = cursor.readBytes(32);
        return [checksumAddress(bytesToHex$1(sliceBytes(value, -20))), 32];
    }
    function decodeArray(cursor, param, { length, staticPosition }) {
        // If the length of the array is not known in advance (dynamic array),
        // this means we will need to wonder off to the pointer and decode.
        if (!length) {
            // Dealing with a dynamic type, so get the offset of the array data.
            const offset = bytesToNumber$1(cursor.readBytes(sizeOfOffset));
            // Start is the static position of current slot + offset.
            const start = staticPosition + offset;
            const startOfData = start + sizeOfLength;
            // Get the length of the array from the offset.
            cursor.setPosition(start);
            const length = bytesToNumber$1(cursor.readBytes(sizeOfLength));
            // Check if the array has any dynamic children.
            const dynamicChild = hasDynamicChild(param);
            let consumed = 0;
            const value = [];
            for (let i = 0; i < length; ++i) {
                // If any of the children is dynamic, then all elements will be offset pointer, thus size of one slot (32 bytes).
                // Otherwise, elements will be the size of their encoding (consumed bytes).
                cursor.setPosition(startOfData + (dynamicChild ? i * 32 : consumed));
                const [data, consumed_] = decodeParameter(cursor, param, {
                    staticPosition: startOfData,
                });
                consumed += consumed_;
                value.push(data);
            }
            // As we have gone wondering, restore to the original position + next slot.
            cursor.setPosition(staticPosition + 32);
            return [value, 32];
        }
        // If the length of the array is known in advance,
        // and the length of an element deeply nested in the array is not known,
        // we need to decode the offset of the array data.
        if (hasDynamicChild(param)) {
            // Dealing with dynamic types, so get the offset of the array data.
            const offset = bytesToNumber$1(cursor.readBytes(sizeOfOffset));
            // Start is the static position of current slot + offset.
            const start = staticPosition + offset;
            const value = [];
            for (let i = 0; i < length; ++i) {
                // Move cursor along to the next slot (next offset pointer).
                cursor.setPosition(start + i * 32);
                const [data] = decodeParameter(cursor, param, {
                    staticPosition: start,
                });
                value.push(data);
            }
            // As we have gone wondering, restore to the original position + next slot.
            cursor.setPosition(staticPosition + 32);
            return [value, 32];
        }
        // If the length of the array is known in advance and the array is deeply static,
        // then we can just decode each element in sequence.
        let consumed = 0;
        const value = [];
        for (let i = 0; i < length; ++i) {
            const [data, consumed_] = decodeParameter(cursor, param, {
                staticPosition: staticPosition + consumed,
            });
            consumed += consumed_;
            value.push(data);
        }
        return [value, consumed];
    }
    function decodeBool(cursor) {
        return [bytesToBool(cursor.readBytes(32), { size: 32 }), 32];
    }
    function decodeBytes(cursor, param, { staticPosition }) {
        const [_, size] = param.type.split('bytes');
        if (!size) {
            // Dealing with dynamic types, so get the offset of the bytes data.
            const offset = bytesToNumber$1(cursor.readBytes(32));
            // Set position of the cursor to start of bytes data.
            cursor.setPosition(staticPosition + offset);
            const length = bytesToNumber$1(cursor.readBytes(32));
            // If there is no length, we have zero data.
            if (length === 0) {
                // As we have gone wondering, restore to the original position + next slot.
                cursor.setPosition(staticPosition + 32);
                return ['0x', 32];
            }
            const data = cursor.readBytes(length);
            // As we have gone wondering, restore to the original position + next slot.
            cursor.setPosition(staticPosition + 32);
            return [bytesToHex$1(data), 32];
        }
        const value = bytesToHex$1(cursor.readBytes(parseInt(size), 32));
        return [value, 32];
    }
    function decodeNumber(cursor, param) {
        const signed = param.type.startsWith('int');
        const size = parseInt(param.type.split('int')[1] || '256');
        const value = cursor.readBytes(32);
        return [
            size > 48
                ? bytesToBigInt$1(value, { signed })
                : bytesToNumber$1(value, { signed }),
            32,
        ];
    }
    function decodeTuple(cursor, param, { staticPosition }) {
        // Tuples can have unnamed components (i.e. they are arrays), so we must
        // determine whether the tuple is named or unnamed. In the case of a named
        // tuple, the value will be an object where each property is the name of the
        // component. In the case of an unnamed tuple, the value will be an array.
        const hasUnnamedChild = param.components.length === 0 || param.components.some(({ name }) => !name);
        // Initialize the value to an object or an array, depending on whether the
        // tuple is named or unnamed.
        const value = hasUnnamedChild ? [] : {};
        let consumed = 0;
        // If the tuple has a dynamic child, we must first decode the offset to the
        // tuple data.
        if (hasDynamicChild(param)) {
            // Dealing with dynamic types, so get the offset of the tuple data.
            const offset = bytesToNumber$1(cursor.readBytes(sizeOfOffset));
            // Start is the static position of referencing slot + offset.
            const start = staticPosition + offset;
            for (let i = 0; i < param.components.length; ++i) {
                const component = param.components[i];
                cursor.setPosition(start + consumed);
                const [data, consumed_] = decodeParameter(cursor, component, {
                    staticPosition: start,
                });
                consumed += consumed_;
                value[hasUnnamedChild ? i : component?.name] = data;
            }
            // As we have gone wondering, restore to the original position + next slot.
            cursor.setPosition(staticPosition + 32);
            return [value, 32];
        }
        // If the tuple has static children, we can just decode each component
        // in sequence.
        for (let i = 0; i < param.components.length; ++i) {
            const component = param.components[i];
            const [data, consumed_] = decodeParameter(cursor, component, {
                staticPosition,
            });
            value[hasUnnamedChild ? i : component?.name] = data;
            consumed += consumed_;
        }
        return [value, consumed];
    }
    function decodeString(cursor, { staticPosition }) {
        // Get offset to start of string data.
        const offset = bytesToNumber$1(cursor.readBytes(32));
        // Start is the static position of current slot + offset.
        const start = staticPosition + offset;
        cursor.setPosition(start);
        const length = bytesToNumber$1(cursor.readBytes(32));
        // If there is no length, we have zero data (empty string).
        if (length === 0) {
            cursor.setPosition(staticPosition + 32);
            return ['', 32];
        }
        const data = cursor.readBytes(length, 32);
        const value = bytesToString$1(trim(data));
        // As we have gone wondering, restore to the original position + next slot.
        cursor.setPosition(staticPosition + 32);
        return [value, 32];
    }
    function hasDynamicChild(param) {
        const { type } = param;
        if (type === 'string')
            return true;
        if (type === 'bytes')
            return true;
        if (type.endsWith('[]'))
            return true;
        if (type === 'tuple')
            return param.components?.some(hasDynamicChild);
        const arrayComponents = getArrayComponents(param.type);
        if (arrayComponents &&
            hasDynamicChild({ ...param, type: arrayComponents[1] }))
            return true;
        return false;
    }

    // TODO: This looks cool. Need to check the performance of `new RegExp` versus defined inline though.
    // https://twitter.com/GabrielVergnaud/status/1622906834343366657
    function execTyped(regex, string) {
        const match = regex.exec(string);
        return match?.groups;
    }

    // https://regexr.com/7f7rv
    const tupleRegex = /^tuple(?<array>(\[(\d*)\])*)$/;
    /**
     * Formats {@link AbiParameter} to human-readable ABI parameter.
     *
     * @param abiParameter - ABI parameter
     * @returns Human-readable ABI parameter
     *
     * @example
     * const result = formatAbiParameter({ type: 'address', name: 'from' })
     * //    ^? const result: 'address from'
     */
    function formatAbiParameter(abiParameter) {
        let type = abiParameter.type;
        if (tupleRegex.test(abiParameter.type) && 'components' in abiParameter) {
            type = '(';
            const length = abiParameter.components.length;
            for (let i = 0; i < length; i++) {
                const component = abiParameter.components[i];
                type += formatAbiParameter(component);
                if (i < length - 1)
                    type += ', ';
            }
            const result = execTyped(tupleRegex, abiParameter.type);
            type += `)${result?.array ?? ''}`;
            return formatAbiParameter({
                ...abiParameter,
                type,
            });
        }
        // Add `indexed` to type if in `abiParameter`
        if ('indexed' in abiParameter && abiParameter.indexed)
            type = `${type} indexed`;
        // Return human-readable ABI parameter
        if (abiParameter.name)
            return `${type} ${abiParameter.name}`;
        return type;
    }

    /**
     * Formats {@link AbiParameter}s to human-readable ABI parameters.
     *
     * @param abiParameters - ABI parameters
     * @returns Human-readable ABI parameters
     *
     * @example
     * const result = formatAbiParameters([
     *   //  ^? const result: 'address from, uint256 tokenId'
     *   { type: 'address', name: 'from' },
     *   { type: 'uint256', name: 'tokenId' },
     * ])
     */
    function formatAbiParameters(abiParameters) {
        let params = '';
        const length = abiParameters.length;
        for (let i = 0; i < length; i++) {
            const abiParameter = abiParameters[i];
            params += formatAbiParameter(abiParameter);
            if (i !== length - 1)
                params += ', ';
        }
        return params;
    }

    /**
     * Formats ABI item (e.g. error, event, function) into human-readable ABI item
     *
     * @param abiItem - ABI item
     * @returns Human-readable ABI item
     */
    function formatAbiItem(abiItem) {
        if (abiItem.type === 'function')
            return `function ${abiItem.name}(${formatAbiParameters(abiItem.inputs)})${abiItem.stateMutability && abiItem.stateMutability !== 'nonpayable'
            ? ` ${abiItem.stateMutability}`
            : ''}${abiItem.outputs.length
            ? ` returns (${formatAbiParameters(abiItem.outputs)})`
            : ''}`;
        else if (abiItem.type === 'event')
            return `event ${abiItem.name}(${formatAbiParameters(abiItem.inputs)})`;
        else if (abiItem.type === 'error')
            return `error ${abiItem.name}(${formatAbiParameters(abiItem.inputs)})`;
        else if (abiItem.type === 'constructor')
            return `constructor(${formatAbiParameters(abiItem.inputs)})${abiItem.stateMutability === 'payable' ? ' payable' : ''}`;
        else if (abiItem.type === 'fallback')
            return 'fallback()';
        return 'receive() external payable';
    }

    const hash$1 = (value) => keccak256(toBytes$1(value));
    function hashSignature(sig) {
        return hash$1(sig);
    }

    function normalizeSignature(signature) {
        let active = true;
        let current = '';
        let level = 0;
        let result = '';
        let valid = false;
        for (let i = 0; i < signature.length; i++) {
            const char = signature[i];
            // If the character is a separator, we want to reactivate.
            if (['(', ')', ','].includes(char))
                active = true;
            // If the character is a "level" token, we want to increment/decrement.
            if (char === '(')
                level++;
            if (char === ')')
                level--;
            // If we aren't active, we don't want to mutate the result.
            if (!active)
                continue;
            // If level === 0, we are at the definition level.
            if (level === 0) {
                if (char === ' ' && ['event', 'function', ''].includes(result))
                    result = '';
                else {
                    result += char;
                    // If we are at the end of the definition, we must be finished.
                    if (char === ')') {
                        valid = true;
                        break;
                    }
                }
                continue;
            }
            // Ignore spaces
            if (char === ' ') {
                // If the previous character is a separator, and the current section isn't empty, we want to deactivate.
                if (signature[i - 1] !== ',' && current !== ',' && current !== ',(') {
                    current = '';
                    active = false;
                }
                continue;
            }
            result += char;
            current += char;
        }
        if (!valid)
            throw new BaseError$1('Unable to normalize signature.');
        return result;
    }

    /**
     * Returns the signature for a given function or event definition.
     *
     * @example
     * const signature = toSignature('function ownerOf(uint256 tokenId)')
     * // 'ownerOf(uint256)'
     *
     * @example
     * const signature_3 = toSignature({
     *   name: 'ownerOf',
     *   type: 'function',
     *   inputs: [{ name: 'tokenId', type: 'uint256' }],
     *   outputs: [],
     *   stateMutability: 'view',
     * })
     * // 'ownerOf(uint256)'
     */
    const toSignature = (def) => {
        const def_ = (() => {
            if (typeof def === 'string')
                return def;
            return formatAbiItem(def);
        })();
        return normalizeSignature(def_);
    };

    /**
     * Returns the hash (of the function/event signature) for a given event or function definition.
     */
    function toSignatureHash(fn) {
        return hashSignature(toSignature(fn));
    }

    /**
     * Returns the event selector for a given event definition.
     *
     * @example
     * const selector = toEventSelector('Transfer(address indexed from, address indexed to, uint256 amount)')
     * // 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef
     */
    const toEventSelector = toSignatureHash;

    /**
     * Returns the function selector for a given function definition.
     *
     * @example
     * const selector = toFunctionSelector('function ownerOf(uint256 tokenId)')
     * // 0x6352211e
     */
    const toFunctionSelector = (fn) => slice(toSignatureHash(fn), 0, 4);

    function getAbiItem(parameters) {
        const { abi, args = [], name } = parameters;
        const isSelector = isHex(name, { strict: false });
        const abiItems = abi.filter((abiItem) => {
            if (isSelector) {
                if (abiItem.type === 'function')
                    return toFunctionSelector(abiItem) === name;
                if (abiItem.type === 'event')
                    return toEventSelector(abiItem) === name;
                return false;
            }
            return 'name' in abiItem && abiItem.name === name;
        });
        if (abiItems.length === 0)
            return undefined;
        if (abiItems.length === 1)
            return abiItems[0];
        let matchedAbiItem = undefined;
        for (const abiItem of abiItems) {
            if (!('inputs' in abiItem))
                continue;
            if (!args || args.length === 0) {
                if (!abiItem.inputs || abiItem.inputs.length === 0)
                    return abiItem;
                continue;
            }
            if (!abiItem.inputs)
                continue;
            if (abiItem.inputs.length === 0)
                continue;
            if (abiItem.inputs.length !== args.length)
                continue;
            const matched = args.every((arg, index) => {
                const abiParameter = 'inputs' in abiItem && abiItem.inputs[index];
                if (!abiParameter)
                    return false;
                return isArgOfType(arg, abiParameter);
            });
            if (matched) {
                // Check for ambiguity against already matched parameters (e.g. `address` vs `bytes20`).
                if (matchedAbiItem &&
                    'inputs' in matchedAbiItem &&
                    matchedAbiItem.inputs) {
                    const ambiguousTypes = getAmbiguousTypes(abiItem.inputs, matchedAbiItem.inputs, args);
                    if (ambiguousTypes)
                        throw new AbiItemAmbiguityError({
                            abiItem,
                            type: ambiguousTypes[0],
                        }, {
                            abiItem: matchedAbiItem,
                            type: ambiguousTypes[1],
                        });
                }
                matchedAbiItem = abiItem;
            }
        }
        if (matchedAbiItem)
            return matchedAbiItem;
        return abiItems[0];
    }
    function isArgOfType(arg, abiParameter) {
        const argType = typeof arg;
        const abiParameterType = abiParameter.type;
        switch (abiParameterType) {
            case 'address':
                return isAddress(arg, { strict: false });
            case 'bool':
                return argType === 'boolean';
            case 'function':
                return argType === 'string';
            case 'string':
                return argType === 'string';
            default: {
                if (abiParameterType === 'tuple' && 'components' in abiParameter)
                    return Object.values(abiParameter.components).every((component, index) => {
                        return isArgOfType(Object.values(arg)[index], component);
                    });
                // `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`
                // https://regexr.com/6v8hp
                if (/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(abiParameterType))
                    return argType === 'number' || argType === 'bigint';
                // `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`
                // https://regexr.com/6va55
                if (/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(abiParameterType))
                    return argType === 'string' || arg instanceof Uint8Array;
                // fixed-length (`<type>[M]`) and dynamic (`<type>[]`) arrays
                // https://regexr.com/6va6i
                if (/[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(abiParameterType)) {
                    return (Array.isArray(arg) &&
                        arg.every((x) => isArgOfType(x, {
                            ...abiParameter,
                            // Pop off `[]` or `[M]` from end of type
                            type: abiParameterType.replace(/(\[[0-9]{0,}\])$/, ''),
                        })));
                }
                return false;
            }
        }
    }
    function getAmbiguousTypes(sourceParameters, targetParameters, args) {
        for (const parameterIndex in sourceParameters) {
            const sourceParameter = sourceParameters[parameterIndex];
            const targetParameter = targetParameters[parameterIndex];
            if (sourceParameter.type === 'tuple' &&
                targetParameter.type === 'tuple' &&
                'components' in sourceParameter &&
                'components' in targetParameter)
                return getAmbiguousTypes(sourceParameter.components, targetParameter.components, args[parameterIndex]);
            const types = [sourceParameter.type, targetParameter.type];
            const ambiguous = (() => {
                if (types.includes('address') && types.includes('bytes20'))
                    return true;
                if (types.includes('address') && types.includes('string'))
                    return isAddress(args[parameterIndex], { strict: false });
                if (types.includes('address') && types.includes('bytes'))
                    return isAddress(args[parameterIndex], { strict: false });
                return false;
            })();
            if (ambiguous)
                return types;
        }
        return;
    }

    const docsPath$1 = '/docs/contract/decodeFunctionResult';
    function decodeFunctionResult(parameters) {
        const { abi, args, functionName, data } = parameters;
        let abiItem = abi[0];
        if (functionName) {
            const item = getAbiItem({ abi, args, name: functionName });
            if (!item)
                throw new AbiFunctionNotFoundError(functionName, { docsPath: docsPath$1 });
            abiItem = item;
        }
        if (abiItem.type !== 'function')
            throw new AbiFunctionNotFoundError(undefined, { docsPath: docsPath$1 });
        if (!abiItem.outputs)
            throw new AbiFunctionOutputsNotFoundError(abiItem.name, { docsPath: docsPath$1 });
        const values = decodeAbiParameters(abiItem.outputs, data);
        if (values && values.length > 1)
            return values;
        if (values && values.length === 1)
            return values[0];
        return undefined;
    }

    const docsPath = '/docs/contract/encodeFunctionData';
    function prepareEncodeFunctionData(parameters) {
        const { abi, args, functionName } = parameters;
        let abiItem = abi[0];
        if (functionName) {
            const item = getAbiItem({
                abi,
                args,
                name: functionName,
            });
            if (!item)
                throw new AbiFunctionNotFoundError(functionName, { docsPath });
            abiItem = item;
        }
        if (abiItem.type !== 'function')
            throw new AbiFunctionNotFoundError(undefined, { docsPath });
        return {
            abi: [abiItem],
            functionName: toFunctionSelector(formatAbiItem$1(abiItem)),
        };
    }

    function encodeFunctionData(parameters) {
        const { args } = parameters;
        const { abi, functionName } = (() => {
            if (parameters.abi.length === 1 &&
                parameters.functionName?.startsWith('0x'))
                return parameters;
            return prepareEncodeFunctionData(parameters);
        })();
        const abiItem = abi[0];
        const signature = functionName;
        const data = 'inputs' in abiItem && abiItem.inputs
            ? encodeAbiParameters(abiItem.inputs, args ?? [])
            : undefined;
        return concatHex([signature, data ?? '0x']);
    }

    function getChainContractAddress({ blockNumber, chain, contract: name, }) {
        const contract = chain?.contracts?.[name];
        if (!contract)
            throw new ChainDoesNotSupportContract({
                chain,
                contract: { name },
            });
        if (blockNumber &&
            contract.blockCreated &&
            contract.blockCreated > blockNumber)
            throw new ChainDoesNotSupportContract({
                blockNumber,
                chain,
                contract: {
                    name,
                    blockCreated: contract.blockCreated,
                },
            });
        return contract.address;
    }

    // https://docs.soliditylang.org/en/v0.8.16/control-structures.html#panic-via-assert-and-error-via-require
    const panicReasons = {
        1: 'An `assert` condition failed.',
        17: 'Arithmetic operation resulted in underflow or overflow.',
        18: 'Division or modulo by zero (e.g. `5 / 0` or `23 % 0`).',
        33: 'Attempted to convert to an invalid type.',
        34: 'Attempted to access a storage byte array that is incorrectly encoded.',
        49: 'Performed `.pop()` on an empty array',
        50: 'Array index is out of bounds.',
        65: 'Allocated too much memory or created an array which is too large.',
        81: 'Attempted to call a zero-initialized variable of internal function type.',
    };
    const solidityError = {
        inputs: [
            {
                name: 'message',
                type: 'string',
            },
        ],
        name: 'Error',
        type: 'error',
    };
    const solidityPanic = {
        inputs: [
            {
                name: 'reason',
                type: 'uint256',
            },
        ],
        name: 'Panic',
        type: 'error',
    };

    function decodeErrorResult(parameters) {
        const { abi, data } = parameters;
        const signature = slice(data, 0, 4);
        if (signature === '0x')
            throw new AbiDecodingZeroDataError();
        const abi_ = [...(abi || []), solidityError, solidityPanic];
        const abiItem = abi_.find((x) => x.type === 'error' && signature === toFunctionSelector(formatAbiItem$1(x)));
        if (!abiItem)
            throw new AbiErrorSignatureNotFoundError(signature, {
                docsPath: '/docs/contract/decodeErrorResult',
            });
        return {
            abiItem,
            args: 'inputs' in abiItem && abiItem.inputs && abiItem.inputs.length > 0
                ? decodeAbiParameters(abiItem.inputs, slice(data, 4))
                : undefined,
            errorName: abiItem.name,
        };
    }

    function formatAbiItemWithArgs({ abiItem, args, includeFunctionName = true, includeName = false, }) {
        if (!('name' in abiItem))
            return;
        if (!('inputs' in abiItem))
            return;
        if (!abiItem.inputs)
            return;
        return `${includeFunctionName ? abiItem.name : ''}(${abiItem.inputs
        .map((input, i) => `${includeName && input.name ? `${input.name}: ` : ''}${typeof args[i] === 'object' ? stringify$1(args[i]) : args[i]}`)
        .join(', ')})`;
    }

    class AccountStateConflictError extends BaseError$1 {
        constructor({ address }) {
            super(`State for account "${address}" is set multiple times.`);
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'AccountStateConflictError'
            });
        }
    }
    class StateAssignmentConflictError extends BaseError$1 {
        constructor() {
            super('state and stateDiff are set on the same account.');
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'StateAssignmentConflictError'
            });
        }
    }
    function prettyStateMapping(stateMapping) {
        return stateMapping.reduce((pretty, { slot, value }) => {
            return `${pretty}        ${slot}: ${value}\n`;
        }, '');
    }
    function prettyStateOverride(stateOverride) {
        return stateOverride
            .reduce((pretty, { address, ...state }) => {
            let val = `${pretty}    ${address}:\n`;
            if (state.nonce)
                val += `      nonce: ${state.nonce}\n`;
            if (state.balance)
                val += `      balance: ${state.balance}\n`;
            if (state.code)
                val += `      code: ${state.code}\n`;
            if (state.state) {
                val += '      state:\n';
                val += prettyStateMapping(state.state);
            }
            if (state.stateDiff) {
                val += '      stateDiff:\n';
                val += prettyStateMapping(state.stateDiff);
            }
            return val;
        }, '  State Override:\n')
            .slice(0, -1);
    }

    class CallExecutionError extends BaseError$1 {
        constructor(cause, { account: account_, docsPath, chain, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, stateOverride, }) {
            const account = account_ ? parseAccount(account_) : undefined;
            let prettyArgs = prettyPrint({
                from: account?.address,
                to,
                value: typeof value !== 'undefined' &&
                    `${formatEther(value)} ${chain?.nativeCurrency?.symbol || 'ETH'}`,
                data,
                gas,
                gasPrice: typeof gasPrice !== 'undefined' && `${formatGwei(gasPrice)} gwei`,
                maxFeePerGas: typeof maxFeePerGas !== 'undefined' &&
                    `${formatGwei(maxFeePerGas)} gwei`,
                maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== 'undefined' &&
                    `${formatGwei(maxPriorityFeePerGas)} gwei`,
                nonce,
            });
            if (stateOverride) {
                prettyArgs += `\n${prettyStateOverride(stateOverride)}`;
            }
            super(cause.shortMessage, {
                cause,
                docsPath,
                metaMessages: [
                    ...(cause.metaMessages ? [...cause.metaMessages, ' '] : []),
                    'Raw Call Arguments:',
                    prettyArgs,
                ].filter(Boolean),
            });
            Object.defineProperty(this, "cause", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'CallExecutionError'
            });
            this.cause = cause;
        }
    }
    class ContractFunctionExecutionError extends BaseError$1 {
        constructor(cause, { abi, args, contractAddress, docsPath, functionName, sender, }) {
            const abiItem = getAbiItem({ abi, args, name: functionName });
            const formattedArgs = abiItem
                ? formatAbiItemWithArgs({
                    abiItem,
                    args,
                    includeFunctionName: false,
                    includeName: false,
                })
                : undefined;
            const functionWithParams = abiItem
                ? formatAbiItem$1(abiItem, { includeName: true })
                : undefined;
            const prettyArgs = prettyPrint({
                address: contractAddress && getContractAddress(contractAddress),
                function: functionWithParams,
                args: formattedArgs &&
                    formattedArgs !== '()' &&
                    `${[...Array(functionName?.length ?? 0).keys()]
                    .map(() => ' ')
                    .join('')}${formattedArgs}`,
                sender,
            });
            super(cause.shortMessage ||
                `An unknown error occurred while executing the contract function "${functionName}".`, {
                cause,
                docsPath,
                metaMessages: [
                    ...(cause.metaMessages ? [...cause.metaMessages, ' '] : []),
                    'Contract Call:',
                    prettyArgs,
                ].filter(Boolean),
            });
            Object.defineProperty(this, "abi", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "args", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "cause", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "contractAddress", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "formattedArgs", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "functionName", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "sender", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'ContractFunctionExecutionError'
            });
            this.abi = abi;
            this.args = args;
            this.cause = cause;
            this.contractAddress = contractAddress;
            this.functionName = functionName;
            this.sender = sender;
        }
    }
    class ContractFunctionRevertedError extends BaseError$1 {
        constructor({ abi, data, functionName, message, }) {
            let cause;
            let decodedData = undefined;
            let metaMessages;
            let reason;
            if (data && data !== '0x') {
                try {
                    decodedData = decodeErrorResult({ abi, data });
                    const { abiItem, errorName, args: errorArgs } = decodedData;
                    if (errorName === 'Error') {
                        reason = errorArgs[0];
                    }
                    else if (errorName === 'Panic') {
                        const [firstArg] = errorArgs;
                        reason = panicReasons[firstArg];
                    }
                    else {
                        const errorWithParams = abiItem
                            ? formatAbiItem$1(abiItem, { includeName: true })
                            : undefined;
                        const formattedArgs = abiItem && errorArgs
                            ? formatAbiItemWithArgs({
                                abiItem,
                                args: errorArgs,
                                includeFunctionName: false,
                                includeName: false,
                            })
                            : undefined;
                        metaMessages = [
                            errorWithParams ? `Error: ${errorWithParams}` : '',
                            formattedArgs && formattedArgs !== '()'
                                ? `       ${[...Array(errorName?.length ?? 0).keys()]
                                .map(() => ' ')
                                .join('')}${formattedArgs}`
                                : '',
                        ];
                    }
                }
                catch (err) {
                    cause = err;
                }
            }
            else if (message)
                reason = message;
            let signature;
            if (cause instanceof AbiErrorSignatureNotFoundError) {
                signature = cause.signature;
                metaMessages = [
                    `Unable to decode signature "${signature}" as it was not found on the provided ABI.`,
                    'Make sure you are using the correct ABI and that the error exists on it.',
                    `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${signature}.`,
                ];
            }
            super((reason && reason !== 'execution reverted') || signature
                ? [
                    `The contract function "${functionName}" reverted with the following ${signature ? 'signature' : 'reason'}:`,
                    reason || signature,
                ].join('\n')
                : `The contract function "${functionName}" reverted.`, {
                cause,
                metaMessages,
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'ContractFunctionRevertedError'
            });
            Object.defineProperty(this, "data", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "reason", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "signature", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            this.data = decodedData;
            this.reason = reason;
            this.signature = signature;
        }
    }
    class ContractFunctionZeroDataError extends BaseError$1 {
        constructor({ functionName }) {
            super(`The contract function "${functionName}" returned no data ("0x").`, {
                metaMessages: [
                    'This could be due to any of the following:',
                    `  - The contract does not have the function "${functionName}",`,
                    '  - The parameters passed to the contract function may be invalid, or',
                    '  - The address is not a contract.',
                ],
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'ContractFunctionZeroDataError'
            });
        }
    }
    class RawContractError extends BaseError$1 {
        constructor({ data, message, }) {
            super(message || '');
            Object.defineProperty(this, "code", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 3
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'RawContractError'
            });
            Object.defineProperty(this, "data", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            this.data = data;
        }
    }

    /*
     * @description Checks if error is a valid null result UniversalResolver error
     */
    function isNullUniversalResolverError(err, callType) {
        if (!(err instanceof BaseError$1))
            return false;
        const cause = err.walk((e) => e instanceof ContractFunctionRevertedError);
        if (!(cause instanceof ContractFunctionRevertedError))
            return false;
        if (cause.data?.errorName === 'ResolverNotFound')
            return true;
        if (cause.data?.errorName === 'ResolverWildcardNotSupported')
            return true;
        if (cause.data?.errorName === 'ResolverNotContract')
            return true;
        if (cause.data?.errorName === 'ResolverError')
            return true;
        if (cause.data?.errorName === 'HttpError')
            return true;
        // Backwards compatibility for older UniversalResolver contracts
        if (cause.reason?.includes('Wildcard on non-extended resolvers is not supported'))
            return true;
        // No primary name set for address.
        if (callType === 'reverse' && cause.reason === panicReasons[50])
            return true;
        return false;
    }

    function encodedLabelToLabelhash(label) {
        if (label.length !== 66)
            return null;
        if (label.indexOf('[') !== 0)
            return null;
        if (label.indexOf(']') !== 65)
            return null;
        const hash = `0x${label.slice(1, 65)}`;
        if (!isHex(hash))
            return null;
        return hash;
    }

    /**
     * @description Hashes ENS name
     *
     * - Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `namehash`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize) function for this.
     *
     * @example
     * namehash('wevm.eth')
     * '0xf246651c1b9a6b141d19c2604e9a58f567973833990f830d882534a747801359'
     *
     * @link https://eips.ethereum.org/EIPS/eip-137
     */
    function namehash(name) {
        let result = new Uint8Array(32).fill(0);
        if (!name)
            return bytesToHex$1(result);
        const labels = name.split('.');
        // Iterate in reverse order building up hash
        for (let i = labels.length - 1; i >= 0; i -= 1) {
            const hashFromEncodedLabel = encodedLabelToLabelhash(labels[i]);
            const hashed = hashFromEncodedLabel
                ? toBytes$1(hashFromEncodedLabel)
                : keccak256(stringToBytes$1(labels[i]), 'bytes');
            result = keccak256(concat([result, hashed]), 'bytes');
        }
        return bytesToHex$1(result);
    }

    function encodeLabelhash(hash) {
        return `[${hash.slice(2)}]`;
    }

    /**
     * @description Hashes ENS label
     *
     * - Since ENS labels prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS labels](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `labelhash`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize) function for this.
     *
     * @example
     * labelhash('eth')
     * '0x4f5b812789fc606be1b3b16908db13fc7a9adf7ca72641f84d75b47069d3d7f0'
     */
    function labelhash(label) {
        const result = new Uint8Array(32).fill(0);
        if (!label)
            return bytesToHex$1(result);
        return encodedLabelToLabelhash(label) || keccak256(stringToBytes$1(label));
    }

    /*
     * @description Encodes a DNS packet into a ByteArray containing a UDP payload.
     */
    function packetToBytes(packet) {
        // strip leading and trailing `.`
        const value = packet.replace(/^\.|\.$/gm, '');
        if (value.length === 0)
            return new Uint8Array(1);
        const bytes = new Uint8Array(stringToBytes$1(value).byteLength + 2);
        let offset = 0;
        const list = value.split('.');
        for (let i = 0; i < list.length; i++) {
            let encoded = stringToBytes$1(list[i]);
            // if the length is > 255, make the encoded label value a labelhash
            // this is compatible with the universal resolver
            if (encoded.byteLength > 255)
                encoded = stringToBytes$1(encodeLabelhash(labelhash(list[i])));
            bytes[offset] = encoded.length;
            bytes.set(encoded, offset + 1);
            offset += encoded.length + 1;
        }
        if (bytes.byteLength !== offset + 1)
            return bytes.slice(0, offset + 1);
        return bytes;
    }

    const EXECUTION_REVERTED_ERROR_CODE = 3;
    function getContractError(err, { abi, address, args, docsPath, functionName, sender, }) {
        const { code, data, message, shortMessage } = (err instanceof RawContractError
            ? err
            : err instanceof BaseError$1
                ? err.walk((err) => 'data' in err) || err.walk()
                : {});
        const cause = (() => {
            if (err instanceof AbiDecodingZeroDataError)
                return new ContractFunctionZeroDataError({ functionName });
            if ([EXECUTION_REVERTED_ERROR_CODE, InternalRpcError.code].includes(code) &&
                (data || message || shortMessage)) {
                return new ContractFunctionRevertedError({
                    abi,
                    data: typeof data === 'object' ? data.data : data,
                    functionName,
                    message: shortMessage ?? message,
                });
            }
            return err;
        })();
        return new ContractFunctionExecutionError(cause, {
            abi,
            args,
            contractAddress: address,
            docsPath,
            functionName,
            sender,
        });
    }

    const aggregate3Signature = '0x82ad56cb';

    function getCallError(err, { docsPath, ...args }) {
        const cause = (() => {
            const cause = getNodeError(err, args);
            if (cause instanceof UnknownNodeError)
                return err;
            return cause;
        })();
        return new CallExecutionError(cause, {
            docsPath,
            ...args,
        });
    }

    const schedulerCache = /*#__PURE__*/ new Map();
    function createBatchScheduler({ fn, id, shouldSplitBatch, wait = 0, sort, }) {
        const exec = async () => {
            const scheduler = getScheduler();
            flush();
            const args = scheduler.map(({ args }) => args);
            if (args.length === 0)
                return;
            fn(args)
                .then((data) => {
                if (sort && Array.isArray(data))
                    data.sort(sort);
                for (let i = 0; i < scheduler.length; i++) {
                    const { pendingPromise } = scheduler[i];
                    pendingPromise.resolve?.([data[i], data]);
                }
            })
                .catch((err) => {
                for (let i = 0; i < scheduler.length; i++) {
                    const { pendingPromise } = scheduler[i];
                    pendingPromise.reject?.(err);
                }
            });
        };
        const flush = () => schedulerCache.delete(id);
        const getBatchedArgs = () => getScheduler().map(({ args }) => args);
        const getScheduler = () => schedulerCache.get(id) || [];
        const setScheduler = (item) => schedulerCache.set(id, [...getScheduler(), item]);
        return {
            flush,
            async schedule(args) {
                const pendingPromise = {};
                const promise = new Promise((resolve, reject) => {
                    pendingPromise.resolve = resolve;
                    pendingPromise.reject = reject;
                });
                const split = shouldSplitBatch?.([...getBatchedArgs(), args]);
                if (split)
                    exec();
                const hasActiveScheduler = getScheduler().length > 0;
                if (hasActiveScheduler) {
                    setScheduler({ args, pendingPromise });
                    return promise;
                }
                setScheduler({ args, pendingPromise });
                setTimeout(exec, wait);
                return promise;
            },
        };
    }

    /**
     * Executes a new message call immediately without submitting a transaction to the network.
     *
     * - Docs: https://viem.sh/docs/actions/public/call
     * - JSON-RPC Methods: [`eth_call`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_call)
     *
     * @param client - Client to use
     * @param parameters - {@link CallParameters}
     * @returns The call data. {@link CallReturnType}
     *
     * @example
     * import { createPublicClient, http } from 'viem'
     * import { mainnet } from 'viem/chains'
     * import { call } from 'viem/public'
     *
     * const client = createPublicClient({
     *   chain: mainnet,
     *   transport: http(),
     * })
     * const data = await call(client, {
     *   account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
     *   data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
     *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
     * })
     */
    async function call$1(client, args) {
        const { account: account_ = client.account, batch = Boolean(client.batch?.multicall), blockNumber, blockTag = 'latest', accessList, blobs, data, gas, gasPrice, maxFeePerBlobGas, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, stateOverride, ...rest } = args;
        const account = account_ ? parseAccount(account_) : undefined;
        try {
            assertRequest(args);
            const blockNumberHex = blockNumber ? numberToHex$1(blockNumber) : undefined;
            const block = blockNumberHex || blockTag;
            const rpcStateOverride = parseStateOverride(stateOverride);
            const chainFormat = client.chain?.formatters?.transactionRequest?.format;
            const format = chainFormat || formatTransactionRequest;
            const request = format({
                // Pick out extra data that might exist on the chain's transaction request type.
                ...extract(rest, { format: chainFormat }),
                from: account?.address,
                accessList,
                blobs,
                data,
                gas,
                gasPrice,
                maxFeePerBlobGas,
                maxFeePerGas,
                maxPriorityFeePerGas,
                nonce,
                to,
                value,
            });
            if (batch && shouldPerformMulticall({ request }) && !rpcStateOverride) {
                try {
                    return await scheduleMulticall(client, {
                        ...request,
                        blockNumber,
                        blockTag,
                    });
                }
                catch (err) {
                    if (!(err instanceof ClientChainNotConfiguredError) &&
                        !(err instanceof ChainDoesNotSupportContract))
                        throw err;
                }
            }
            const response = await client.request({
                method: 'eth_call',
                params: rpcStateOverride
                    ? [
                        request,
                        block,
                        rpcStateOverride,
                    ]
                    : [request, block],
            });
            if (response === '0x')
                return { data: undefined };
            return { data: response };
        }
        catch (err) {
            const data = getRevertErrorData(err);
            const { offchainLookup, offchainLookupSignature } = await Promise.resolve().then(function () { return ccip; });
            if (client.ccipRead !== false &&
                data?.slice(0, 10) === offchainLookupSignature &&
                to)
                return { data: await offchainLookup(client, { data, to }) };
            throw getCallError(err, {
                ...args,
                account,
                chain: client.chain,
            });
        }
    }
    // We only want to perform a scheduled multicall if:
    // - The request has calldata,
    // - The request has a target address,
    // - The target address is not already the aggregate3 signature,
    // - The request has no other properties (`nonce`, `gas`, etc cannot be sent with a multicall).
    function shouldPerformMulticall({ request }) {
        const { data, to, ...request_ } = request;
        if (!data)
            return false;
        if (data.startsWith(aggregate3Signature))
            return false;
        if (!to)
            return false;
        if (Object.values(request_).filter((x) => typeof x !== 'undefined').length > 0)
            return false;
        return true;
    }
    async function scheduleMulticall(client, args) {
        const { batchSize = 1024, wait = 0 } = typeof client.batch?.multicall === 'object' ? client.batch.multicall : {};
        const { blockNumber, blockTag = 'latest', data, multicallAddress: multicallAddress_, to, } = args;
        let multicallAddress = multicallAddress_;
        if (!multicallAddress) {
            if (!client.chain)
                throw new ClientChainNotConfiguredError();
            multicallAddress = getChainContractAddress({
                blockNumber,
                chain: client.chain,
                contract: 'multicall3',
            });
        }
        const blockNumberHex = blockNumber ? numberToHex$1(blockNumber) : undefined;
        const block = blockNumberHex || blockTag;
        const { schedule } = createBatchScheduler({
            id: `${client.uid}.${block}`,
            wait,
            shouldSplitBatch(args) {
                const size = args.reduce((size, { data }) => size + (data.length - 2), 0);
                return size > batchSize * 2;
            },
            fn: async (requests) => {
                const calls = requests.map((request) => ({
                    allowFailure: true,
                    callData: request.data,
                    target: request.to,
                }));
                const calldata = encodeFunctionData({
                    abi: multicall3Abi,
                    args: [calls],
                    functionName: 'aggregate3',
                });
                const data = await client.request({
                    method: 'eth_call',
                    params: [
                        {
                            data: calldata,
                            to: multicallAddress,
                        },
                        block,
                    ],
                });
                return decodeFunctionResult({
                    abi: multicall3Abi,
                    args: [calls],
                    functionName: 'aggregate3',
                    data: data || '0x',
                });
            },
        });
        const [{ returnData, success }] = await schedule({ data, to });
        if (!success)
            throw new RawContractError({ data: returnData });
        if (returnData === '0x')
            return { data: undefined };
        return { data: returnData };
    }
    function getRevertErrorData(err) {
        if (!(err instanceof BaseError$1))
            return undefined;
        const error = err.walk();
        return typeof error?.data === 'object' ? error.data?.data : error.data;
    }
    function parseStateMapping(stateMapping) {
        if (!stateMapping || stateMapping.length === 0)
            return undefined;
        return stateMapping.reduce((acc, { slot, value }) => {
            if (slot.length !== 66)
                throw new InvalidBytesLengthError({
                    size: slot.length,
                    targetSize: 66,
                    type: 'hex',
                });
            if (value.length !== 66)
                throw new InvalidBytesLengthError({
                    size: value.length,
                    targetSize: 66,
                    type: 'hex',
                });
            acc[slot] = value;
            return acc;
        }, {});
    }
    function parseAccountStateOverride(args) {
        const { balance, nonce, state, stateDiff, code } = args;
        const rpcAccountStateOverride = {};
        if (code !== undefined) {
            rpcAccountStateOverride.code = code;
        }
        if (balance !== undefined) {
            rpcAccountStateOverride.balance = numberToHex$1(balance, { size: 32 });
        }
        if (nonce !== undefined) {
            rpcAccountStateOverride.nonce = numberToHex$1(nonce, { size: 8 });
        }
        if (state !== undefined) {
            rpcAccountStateOverride.state = parseStateMapping(state);
        }
        if (stateDiff !== undefined) {
            if (rpcAccountStateOverride.state)
                throw new StateAssignmentConflictError();
            rpcAccountStateOverride.stateDiff = parseStateMapping(stateDiff);
        }
        return rpcAccountStateOverride;
    }
    function parseStateOverride(args) {
        if (!args)
            return undefined;
        const rpcStateOverride = {};
        for (const { address, ...accountState } of args) {
            if (!isAddress(address, { strict: false }))
                throw new InvalidAddressError({ address });
            if (rpcStateOverride[address])
                throw new AccountStateConflictError({ address: address });
            rpcStateOverride[address] = parseAccountStateOverride(accountState);
        }
        return rpcStateOverride;
    }

    /**
     * Calls a read-only function on a contract, and returns the response.
     *
     * - Docs: https://viem.sh/docs/contract/readContract
     * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/contracts/reading-contracts
     *
     * A "read-only" function (constant function) on a Solidity contract is denoted by a `view` or `pure` keyword. They can only read the state of the contract, and cannot make any changes to it. Since read-only methods do not change the state of the contract, they do not require any gas to be executed, and can be called by any user without the need to pay for gas.
     *
     * Internally, uses a [Public Client](https://viem.sh/docs/clients/public) to call the [`call` action](https://viem.sh/docs/actions/public/call) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData).
     *
     * @param client - Client to use
     * @param parameters - {@link ReadContractParameters}
     * @returns The response from the contract. Type is inferred. {@link ReadContractReturnType}
     *
     * @example
     * import { createPublicClient, http, parseAbi } from 'viem'
     * import { mainnet } from 'viem/chains'
     * import { readContract } from 'viem/contract'
     *
     * const client = createPublicClient({
     *   chain: mainnet,
     *   transport: http(),
     * })
     * const result = await readContract(client, {
     *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
     *   abi: parseAbi(['function balanceOf(address) view returns (uint256)']),
     *   functionName: 'balanceOf',
     *   args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'],
     * })
     * // 424122n
     */
    async function readContract$1(client, parameters) {
        const { abi, address, args, functionName, ...rest } = parameters;
        const calldata = encodeFunctionData({
            abi,
            args,
            functionName,
        });
        try {
            const { data } = await getAction$1(client, call$1, 'call')({
                ...rest,
                data: calldata,
                to: address,
            });
            return decodeFunctionResult({
                abi,
                args,
                functionName,
                data: data || '0x',
            });
        }
        catch (error) {
            throw getContractError(error, {
                abi,
                address,
                args,
                docsPath: '/docs/contract/readContract',
                functionName,
            });
        }
    }

    class EnsAvatarInvalidMetadataError extends BaseError$1 {
        constructor({ data }) {
            super('Unable to extract image from metadata. The metadata may be malformed or invalid.', {
                metaMessages: [
                    '- Metadata must be a JSON object with at least an `image`, `image_url` or `image_data` property.',
                    '',
                    `Provided data: ${JSON.stringify(data)}`,
                ],
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'EnsAvatarInvalidMetadataError'
            });
        }
    }
    class EnsAvatarInvalidNftUriError extends BaseError$1 {
        constructor({ reason }) {
            super(`ENS NFT avatar URI is invalid. ${reason}`);
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'EnsAvatarInvalidNftUriError'
            });
        }
    }
    class EnsAvatarUriResolutionError extends BaseError$1 {
        constructor({ uri }) {
            super(`Unable to resolve ENS avatar URI "${uri}". The URI may be malformed, invalid, or does not respond with a valid image.`);
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'EnsAvatarUriResolutionError'
            });
        }
    }
    class EnsAvatarUnsupportedNamespaceError extends BaseError$1 {
        constructor({ namespace }) {
            super(`ENS NFT avatar namespace "${namespace}" is not supported. Must be "erc721" or "erc1155".`);
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'EnsAvatarUnsupportedNamespaceError'
            });
        }
    }

    const networkRegex = /(?<protocol>https?:\/\/[^\/]*|ipfs:\/|ipns:\/|ar:\/)?(?<root>\/)?(?<subpath>ipfs\/|ipns\/)?(?<target>[\w\-.]+)(?<subtarget>\/.*)?/;
    const ipfsHashRegex = /^(Qm[1-9A-HJ-NP-Za-km-z]{44,}|b[A-Za-z2-7]{58,}|B[A-Z2-7]{58,}|z[1-9A-HJ-NP-Za-km-z]{48,}|F[0-9A-F]{50,})(\/(?<target>[\w\-.]+))?(?<subtarget>\/.*)?$/;
    const base64Regex = /^data:([a-zA-Z\-/+]*);base64,([^"].*)/;
    const dataURIRegex = /^data:([a-zA-Z\-/+]*)?(;[a-zA-Z0-9].*?)?(,)/;
    async function isImageUri(uri) {
        try {
            const res = await fetch(uri, { method: 'HEAD' });
            // retrieve content type header to check if content is image
            if (res.status === 200) {
                const contentType = res.headers.get('content-type');
                return contentType?.startsWith('image/');
            }
            return false;
        }
        catch (error) {
            // if error is not cors related then fail
            if (typeof error === 'object' && typeof error.response !== 'undefined') {
                return false;
            }
            // fail in NodeJS, since the error is not cors but any other network issue
            // biome-ignore lint/suspicious/noPrototypeBuiltins:
            if (!globalThis.hasOwnProperty('Image'))
                return false;
            // in case of cors, use image api to validate if given url is an actual image
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = () => {
                    resolve(true);
                };
                img.onerror = () => {
                    resolve(false);
                };
                img.src = uri;
            });
        }
    }
    function getGateway(custom, defaultGateway) {
        if (!custom)
            return defaultGateway;
        if (custom.endsWith('/'))
            return custom.slice(0, -1);
        return custom;
    }
    function resolveAvatarUri({ uri, gatewayUrls, }) {
        const isEncoded = base64Regex.test(uri);
        if (isEncoded)
            return { uri, isOnChain: true, isEncoded };
        const ipfsGateway = getGateway(gatewayUrls?.ipfs, 'https://ipfs.io');
        const arweaveGateway = getGateway(gatewayUrls?.arweave, 'https://arweave.net');
        const networkRegexMatch = uri.match(networkRegex);
        const { protocol, subpath, target, subtarget = '', } = networkRegexMatch?.groups || {};
        const isIPNS = protocol === 'ipns:/' || subpath === 'ipns/';
        const isIPFS = protocol === 'ipfs:/' || subpath === 'ipfs/' || ipfsHashRegex.test(uri);
        if (uri.startsWith('http') && !isIPNS && !isIPFS) {
            let replacedUri = uri;
            if (gatewayUrls?.arweave)
                replacedUri = uri.replace(/https:\/\/arweave.net/g, gatewayUrls?.arweave);
            return { uri: replacedUri, isOnChain: false, isEncoded: false };
        }
        if ((isIPNS || isIPFS) && target) {
            return {
                uri: `${ipfsGateway}/${isIPNS ? 'ipns' : 'ipfs'}/${target}${subtarget}`,
                isOnChain: false,
                isEncoded: false,
            };
        }
        if (protocol === 'ar:/' && target) {
            return {
                uri: `${arweaveGateway}/${target}${subtarget || ''}`,
                isOnChain: false,
                isEncoded: false,
            };
        }
        let parsedUri = uri.replace(dataURIRegex, '');
        if (parsedUri.startsWith('<svg')) {
            // if svg, base64 encode
            parsedUri = `data:image/svg+xml;base64,${btoa(parsedUri)}`;
        }
        if (parsedUri.startsWith('data:') || parsedUri.startsWith('{')) {
            return {
                uri: parsedUri,
                isOnChain: true,
                isEncoded: false,
            };
        }
        throw new EnsAvatarUriResolutionError({ uri });
    }
    function getJsonImage(data) {
        // validation check for json data, must include one of theses properties
        if (typeof data !== 'object' ||
            (!('image' in data) && !('image_url' in data) && !('image_data' in data))) {
            throw new EnsAvatarInvalidMetadataError({ data });
        }
        return data.image || data.image_url || data.image_data;
    }
    async function getMetadataAvatarUri({ gatewayUrls, uri, }) {
        try {
            const res = await fetch(uri).then((res) => res.json());
            const image = await parseAvatarUri({
                gatewayUrls,
                uri: getJsonImage(res),
            });
            return image;
        }
        catch {
            throw new EnsAvatarUriResolutionError({ uri });
        }
    }
    async function parseAvatarUri({ gatewayUrls, uri, }) {
        const { uri: resolvedURI, isOnChain } = resolveAvatarUri({ uri, gatewayUrls });
        if (isOnChain)
            return resolvedURI;
        // check if resolvedURI is an image, if it is return the url
        const isImage = await isImageUri(resolvedURI);
        if (isImage)
            return resolvedURI;
        throw new EnsAvatarUriResolutionError({ uri });
    }
    function parseNftUri(uri_) {
        let uri = uri_;
        // parse valid nft spec (CAIP-22/CAIP-29)
        // @see: https://github.com/ChainAgnostic/CAIPs/tree/master/CAIPs
        if (uri.startsWith('did:nft:')) {
            // convert DID to CAIP
            uri = uri.replace('did:nft:', '').replace(/_/g, '/');
        }
        const [reference, asset_namespace, tokenID] = uri.split('/');
        const [eip_namespace, chainID] = reference.split(':');
        const [erc_namespace, contractAddress] = asset_namespace.split(':');
        if (!eip_namespace || eip_namespace.toLowerCase() !== 'eip155')
            throw new EnsAvatarInvalidNftUriError({ reason: 'Only EIP-155 supported' });
        if (!chainID)
            throw new EnsAvatarInvalidNftUriError({ reason: 'Chain ID not found' });
        if (!contractAddress)
            throw new EnsAvatarInvalidNftUriError({
                reason: 'Contract address not found',
            });
        if (!tokenID)
            throw new EnsAvatarInvalidNftUriError({ reason: 'Token ID not found' });
        if (!erc_namespace)
            throw new EnsAvatarInvalidNftUriError({ reason: 'ERC namespace not found' });
        return {
            chainID: parseInt(chainID),
            namespace: erc_namespace.toLowerCase(),
            contractAddress: contractAddress,
            tokenID,
        };
    }
    async function getNftTokenUri(client, { nft }) {
        if (nft.namespace === 'erc721') {
            return readContract$1(client, {
                address: nft.contractAddress,
                abi: [
                    {
                        name: 'tokenURI',
                        type: 'function',
                        stateMutability: 'view',
                        inputs: [{ name: 'tokenId', type: 'uint256' }],
                        outputs: [{ name: '', type: 'string' }],
                    },
                ],
                functionName: 'tokenURI',
                args: [BigInt(nft.tokenID)],
            });
        }
        if (nft.namespace === 'erc1155') {
            return readContract$1(client, {
                address: nft.contractAddress,
                abi: [
                    {
                        name: 'uri',
                        type: 'function',
                        stateMutability: 'view',
                        inputs: [{ name: '_id', type: 'uint256' }],
                        outputs: [{ name: '', type: 'string' }],
                    },
                ],
                functionName: 'uri',
                args: [BigInt(nft.tokenID)],
            });
        }
        throw new EnsAvatarUnsupportedNamespaceError({ namespace: nft.namespace });
    }

    async function parseAvatarRecord(client, { gatewayUrls, record, }) {
        if (/eip155:/i.test(record))
            return parseNftAvatarUri(client, { gatewayUrls, record });
        return parseAvatarUri({ uri: record, gatewayUrls });
    }
    async function parseNftAvatarUri(client, { gatewayUrls, record, }) {
        // parse NFT URI into properties
        const nft = parseNftUri(record);
        // fetch tokenURI from the NFT contract
        const nftUri = await getNftTokenUri(client, { nft });
        // resolve the URI from the fetched tokenURI
        const { uri: resolvedNftUri, isOnChain, isEncoded, } = resolveAvatarUri({ uri: nftUri, gatewayUrls });
        // if the resolved URI is on chain, return the data
        if (isOnChain &&
            (resolvedNftUri.includes('data:application/json;base64,') ||
                resolvedNftUri.startsWith('{'))) {
            const encodedJson = isEncoded
                ? // if it is encoded, decode it
                    atob(resolvedNftUri.replace('data:application/json;base64,', ''))
                : // if it isn't encoded assume it is a JSON string, but it could be anything (it will error if it is)
                    resolvedNftUri;
            const decoded = JSON.parse(encodedJson);
            return parseAvatarUri({ uri: getJsonImage(decoded), gatewayUrls });
        }
        let uriTokenId = nft.tokenID;
        if (nft.namespace === 'erc1155')
            uriTokenId = uriTokenId.replace('0x', '').padStart(64, '0');
        return getMetadataAvatarUri({
            gatewayUrls,
            uri: resolvedNftUri.replace(/(?:0x)?{id}/, uriTokenId),
        });
    }

    /**
     * Gets a text record for specified ENS name.
     *
     * - Docs: https://viem.sh/docs/ens/actions/getEnsResolver
     * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens
     *
     * Calls `resolve(bytes, bytes)` on ENS Universal Resolver Contract.
     *
     * Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize) function for this.
     *
     * @param client - Client to use
     * @param parameters - {@link GetEnsTextParameters}
     * @returns Address for ENS resolver. {@link GetEnsTextReturnType}
     *
     * @example
     * import { createPublicClient, http } from 'viem'
     * import { mainnet } from 'viem/chains'
     * import { getEnsText, normalize } from 'viem/ens'
     *
     * const client = createPublicClient({
     *   chain: mainnet,
     *   transport: http(),
     * })
     * const twitterRecord = await getEnsText(client, {
     *   name: normalize('wevm.eth'),
     *   key: 'com.twitter',
     * })
     * // 'wagmi_sh'
     */
    async function getEnsText(client, { blockNumber, blockTag, name, key, gatewayUrls, strict, universalResolverAddress: universalResolverAddress_, }) {
        let universalResolverAddress = universalResolverAddress_;
        if (!universalResolverAddress) {
            if (!client.chain)
                throw new Error('client chain not configured. universalResolverAddress is required.');
            universalResolverAddress = getChainContractAddress({
                blockNumber,
                chain: client.chain,
                contract: 'ensUniversalResolver',
            });
        }
        try {
            const readContractParameters = {
                address: universalResolverAddress,
                abi: universalResolverResolveAbi,
                functionName: 'resolve',
                args: [
                    toHex$1(packetToBytes(name)),
                    encodeFunctionData({
                        abi: textResolverAbi,
                        functionName: 'text',
                        args: [namehash(name), key],
                    }),
                ],
                blockNumber,
                blockTag,
            };
            const readContractAction = getAction$1(client, readContract$1, 'readContract');
            const res = gatewayUrls
                ? await readContractAction({
                    ...readContractParameters,
                    args: [...readContractParameters.args, gatewayUrls],
                })
                : await readContractAction(readContractParameters);
            if (res[0] === '0x')
                return null;
            const record = decodeFunctionResult({
                abi: textResolverAbi,
                functionName: 'text',
                data: res[0],
            });
            return record === '' ? null : record;
        }
        catch (err) {
            if (strict)
                throw err;
            if (isNullUniversalResolverError(err, 'resolve'))
                return null;
            throw err;
        }
    }

    /**
     * Gets the avatar of an ENS name.
     *
     * - Docs: https://viem.sh/docs/ens/actions/getEnsAvatar
     * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens
     *
     * Calls [`getEnsText`](https://viem.sh/docs/ens/actions/getEnsText) with `key` set to `'avatar'`.
     *
     * Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize) function for this.
     *
     * @param client - Client to use
     * @param parameters - {@link GetEnsAvatarParameters}
     * @returns Avatar URI or `null` if not found. {@link GetEnsAvatarReturnType}
     *
     * @example
     * import { createPublicClient, http } from 'viem'
     * import { mainnet } from 'viem/chains'
     * import { getEnsAvatar, normalize } from 'viem/ens'
     *
     * const client = createPublicClient({
     *   chain: mainnet,
     *   transport: http(),
     * })
     * const ensAvatar = await getEnsAvatar(client, {
     *   name: normalize('wevm.eth'),
     * })
     * // 'https://ipfs.io/ipfs/Qma8mnp6xV3J2cRNf3mTth5C8nV11CAnceVinc3y8jSbio'
     */
    async function getEnsAvatar$1(client, { blockNumber, blockTag, assetGatewayUrls, name, gatewayUrls, strict, universalResolverAddress, }) {
        const record = await getAction$1(client, getEnsText, 'getEnsText')({
            blockNumber,
            blockTag,
            key: 'avatar',
            name,
            universalResolverAddress,
            gatewayUrls,
            strict,
        });
        if (!record)
            return null;
        try {
            return await parseAvatarRecord(client, {
                record,
                gatewayUrls: assetGatewayUrls,
            });
        }
        catch {
            return null;
        }
    }

    /**
     * Gets primary name for specified address.
     *
     * - Docs: https://viem.sh/docs/ens/actions/getEnsName
     * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens
     *
     * Calls `reverse(bytes)` on ENS Universal Resolver Contract to "reverse resolve" the address to the primary ENS name.
     *
     * @param client - Client to use
     * @param parameters - {@link GetEnsNameParameters}
     * @returns Name or `null` if not found. {@link GetEnsNameReturnType}
     *
     * @example
     * import { createPublicClient, http } from 'viem'
     * import { mainnet } from 'viem/chains'
     * import { getEnsName } from 'viem/ens'
     *
     * const client = createPublicClient({
     *   chain: mainnet,
     *   transport: http(),
     * })
     * const ensName = await getEnsName(client, {
     *   address: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
     * })
     * // 'wevm.eth'
     */
    async function getEnsName$1(client, { address, blockNumber, blockTag, gatewayUrls, strict, universalResolverAddress: universalResolverAddress_, }) {
        let universalResolverAddress = universalResolverAddress_;
        if (!universalResolverAddress) {
            if (!client.chain)
                throw new Error('client chain not configured. universalResolverAddress is required.');
            universalResolverAddress = getChainContractAddress({
                blockNumber,
                chain: client.chain,
                contract: 'ensUniversalResolver',
            });
        }
        const reverseNode = `${address.toLowerCase().substring(2)}.addr.reverse`;
        try {
            const readContractParameters = {
                address: universalResolverAddress,
                abi: universalResolverReverseAbi,
                functionName: 'reverse',
                args: [toHex$1(packetToBytes(reverseNode))],
                blockNumber,
                blockTag,
            };
            const readContractAction = getAction$1(client, readContract$1, 'readContract');
            const [name, resolvedAddress] = gatewayUrls
                ? await readContractAction({
                    ...readContractParameters,
                    args: [...readContractParameters.args, gatewayUrls],
                })
                : await readContractAction(readContractParameters);
            if (address.toLowerCase() !== resolvedAddress.toLowerCase())
                return null;
            return name;
        }
        catch (err) {
            if (strict)
                throw err;
            if (isNullUniversalResolverError(err, 'reverse'))
                return null;
            throw err;
        }
    }

    /**
     * Returns the balance of an address in wei.
     *
     * - Docs: https://viem.sh/docs/actions/public/getBalance
     * - JSON-RPC Methods: [`eth_getBalance`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getbalance)
     *
     * You can convert the balance to ether units with [`formatEther`](https://viem.sh/docs/utilities/formatEther).
     *
     * ```ts
     * const balance = await getBalance(client, {
     *   address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
     *   blockTag: 'safe'
     * })
     * const balanceAsEther = formatEther(balance)
     * // "6.942"
     * ```
     *
     * @param client - Client to use
     * @param parameters - {@link GetBalanceParameters}
     * @returns The balance of the address in wei. {@link GetBalanceReturnType}
     *
     * @example
     * import { createPublicClient, http } from 'viem'
     * import { mainnet } from 'viem/chains'
     * import { getBalance } from 'viem/public'
     *
     * const client = createPublicClient({
     *   chain: mainnet,
     *   transport: http(),
     * })
     * const balance = await getBalance(client, {
     *   address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
     * })
     * // 10000000000000000000000n (wei)
     */
    async function getBalance$1(client, { address, blockNumber, blockTag = 'latest' }) {
        const blockNumberHex = blockNumber ? numberToHex$1(blockNumber) : undefined;
        const balance = await client.request({
            method: 'eth_getBalance',
            params: [address, blockNumberHex || blockTag],
        });
        return BigInt(balance);
    }

    async function wait(time) {
        return new Promise((res) => setTimeout(res, time));
    }

    const size$2 = 256;
    let index$8 = size$2;
    let buffer$1;
    function uid$1(length = 11) {
        if (!buffer$1 || index$8 + length > size$2 * 2) {
            buffer$1 = '';
            index$8 = 0;
            for (let i = 0; i < size$2; i++) {
                buffer$1 += ((256 + Math.random() * 256) | 0).toString(16).substring(1);
            }
        }
        return buffer$1.substring(index$8, index$8++ + length);
    }

    function createClient(parameters) {
        const { batch, cacheTime = parameters.pollingInterval ?? 4_000, ccipRead, key = 'base', name = 'Base Client', pollingInterval = 4_000, type = 'base', } = parameters;
        const chain = parameters.chain;
        const account = parameters.account
            ? parseAccount(parameters.account)
            : undefined;
        const { config, request, value } = parameters.transport({
            chain,
            pollingInterval,
        });
        const transport = { ...config, ...value };
        const client = {
            account,
            batch,
            cacheTime,
            ccipRead,
            chain,
            key,
            name,
            pollingInterval,
            request,
            transport,
            type,
            uid: uid$1(),
        };
        function extend(base) {
            return (extendFn) => {
                const extended = extendFn(base);
                for (const key in client)
                    delete extended[key];
                const combined = { ...base, ...extended };
                return Object.assign(combined, { extend: extend(combined) });
            };
        }
        return Object.assign(client, { extend: extend(client) });
    }

    function withRetry(fn, { delay: delay_ = 100, retryCount = 2, shouldRetry = () => true, } = {}) {
        return new Promise((resolve, reject) => {
            const attemptRetry = async ({ count = 0 } = {}) => {
                const retry = async ({ error }) => {
                    const delay = typeof delay_ === 'function' ? delay_({ count, error }) : delay_;
                    if (delay)
                        await wait(delay);
                    attemptRetry({ count: count + 1 });
                };
                try {
                    const data = await fn();
                    resolve(data);
                }
                catch (err) {
                    if (count < retryCount &&
                        (await shouldRetry({ count, error: err })))
                        return retry({ error: err });
                    reject(err);
                }
            };
            attemptRetry();
        });
    }

    function buildRequest(request, options = {}) {
        return async (args, overrideOptions = {}) => {
            const { retryDelay = 150, retryCount = 3 } = {
                ...options,
                ...overrideOptions,
            };
            return withRetry(async () => {
                try {
                    return await request(args);
                }
                catch (err_) {
                    const err = err_;
                    switch (err.code) {
                        // -32700
                        case ParseRpcError.code:
                            throw new ParseRpcError(err);
                        // -32600
                        case InvalidRequestRpcError.code:
                            throw new InvalidRequestRpcError(err);
                        // -32601
                        case MethodNotFoundRpcError.code:
                            throw new MethodNotFoundRpcError(err);
                        // -32602
                        case InvalidParamsRpcError.code:
                            throw new InvalidParamsRpcError(err);
                        // -32603
                        case InternalRpcError.code:
                            throw new InternalRpcError(err);
                        // -32000
                        case InvalidInputRpcError.code:
                            throw new InvalidInputRpcError(err);
                        // -32001
                        case ResourceNotFoundRpcError.code:
                            throw new ResourceNotFoundRpcError(err);
                        // -32002
                        case ResourceUnavailableRpcError.code:
                            throw new ResourceUnavailableRpcError(err);
                        // -32003
                        case TransactionRejectedRpcError.code:
                            throw new TransactionRejectedRpcError(err);
                        // -32004
                        case MethodNotSupportedRpcError.code:
                            throw new MethodNotSupportedRpcError(err);
                        // -32005
                        case LimitExceededRpcError.code:
                            throw new LimitExceededRpcError(err);
                        // -32006
                        case JsonRpcVersionUnsupportedError.code:
                            throw new JsonRpcVersionUnsupportedError(err);
                        // 4001
                        case UserRejectedRequestError.code:
                            throw new UserRejectedRequestError(err);
                        // 4100
                        case UnauthorizedProviderError.code:
                            throw new UnauthorizedProviderError(err);
                        // 4200
                        case UnsupportedProviderMethodError.code:
                            throw new UnsupportedProviderMethodError(err);
                        // 4900
                        case ProviderDisconnectedError.code:
                            throw new ProviderDisconnectedError(err);
                        // 4901
                        case ChainDisconnectedError.code:
                            throw new ChainDisconnectedError(err);
                        // 4902
                        case SwitchChainError.code:
                            throw new SwitchChainError(err);
                        // CAIP-25: User Rejected Error
                        // https://docs.walletconnect.com/2.0/specs/clients/sign/error-codes#rejected-caip-25
                        case 5000:
                            throw new UserRejectedRequestError(err);
                        default:
                            if (err_ instanceof BaseError$1)
                                throw err_;
                            throw new UnknownRpcError(err);
                    }
                }
            }, {
                delay: ({ count, error }) => {
                    // If we find a Retry-After header, let's retry after the given time.
                    if (error && error instanceof HttpRequestError) {
                        const retryAfter = error?.headers?.get('Retry-After');
                        if (retryAfter?.match(/\d/))
                            return parseInt(retryAfter) * 1000;
                    }
                    // Otherwise, let's retry with an exponential backoff.
                    return ~~(1 << count) * retryDelay;
                },
                retryCount,
                shouldRetry: ({ error }) => shouldRetry(error),
            });
        };
    }
    function shouldRetry(error) {
        if ('code' in error && typeof error.code === 'number') {
            if (error.code === -1)
                return true; // Unknown error
            if (error.code === LimitExceededRpcError.code)
                return true;
            if (error.code === InternalRpcError.code)
                return true;
            return false;
        }
        if (error instanceof HttpRequestError && error.status) {
            // Forbidden
            if (error.status === 403)
                return true;
            // Request Timeout
            if (error.status === 408)
                return true;
            // Request Entity Too Large
            if (error.status === 413)
                return true;
            // Too Many Requests
            if (error.status === 429)
                return true;
            // Internal Server Error
            if (error.status === 500)
                return true;
            // Bad Gateway
            if (error.status === 502)
                return true;
            // Service Unavailable
            if (error.status === 503)
                return true;
            // Gateway Timeout
            if (error.status === 504)
                return true;
            return false;
        }
        return true;
    }

    /**
     * @description Creates an transport intended to be used with a client.
     */
    function createTransport({ key, name, request, retryCount = 3, retryDelay = 150, timeout, type, }, value) {
        return {
            config: { key, name, request, retryCount, retryDelay, timeout, type },
            request: buildRequest(request, { retryCount, retryDelay }),
            value,
        };
    }

    /**
     * @description Creates a custom transport given an EIP-1193 compliant `request` attribute.
     */
    function custom$1(provider, config = {}) {
        const { key = 'custom', name = 'Custom Provider', retryDelay } = config;
        return ({ retryCount: defaultRetryCount }) => createTransport({
            key,
            name,
            request: provider.request.bind(provider),
            retryCount: config.retryCount ?? defaultRetryCount,
            retryDelay,
            type: 'custom',
        });
    }

    class UrlRequiredError extends BaseError$1 {
        constructor() {
            super('No URL was provided to the Transport. Please provide a valid RPC URL to the Transport.', {
                docsPath: '/docs/clients/intro',
            });
        }
    }

    function withTimeout$2(fn, { errorInstance = new Error('timed out'), timeout, signal, }) {
        return new Promise((resolve, reject) => {
            (async () => {
                let timeoutId;
                try {
                    const controller = new AbortController();
                    if (timeout > 0) {
                        timeoutId = setTimeout(() => {
                            if (signal) {
                                controller.abort();
                            }
                            else {
                                reject(errorInstance);
                            }
                        }, timeout);
                    }
                    resolve(await fn({ signal: controller?.signal || null }));
                }
                catch (err) {
                    if (err.name === 'AbortError')
                        reject(errorInstance);
                    reject(err);
                }
                finally {
                    clearTimeout(timeoutId);
                }
            })();
        });
    }

    function createIdStore() {
        return {
            current: 0,
            take() {
                return this.current++;
            },
            reset() {
                this.current = 0;
            },
        };
    }
    const idCache = /*#__PURE__*/ createIdStore();

    function getHttpRpcClient(url, options = {}) {
        return {
            async request(params) {
                const { body, fetchOptions = {}, onResponse = options.onResponse, timeout = options.timeout ?? 10_000, } = params;
                const { headers, method, signal: signal_, } = { ...options.fetchOptions, ...fetchOptions };
                try {
                    const response = await withTimeout$2(async ({ signal }) => {
                        const response = await fetch(url, {
                            ...fetchOptions,
                            body: Array.isArray(body)
                                ? stringify$1(body.map((body) => ({
                                    jsonrpc: '2.0',
                                    id: body.id ?? idCache.take(),
                                    ...body,
                                })))
                                : stringify$1({
                                    jsonrpc: '2.0',
                                    id: body.id ?? idCache.take(),
                                    ...body,
                                }),
                            headers: {
                                ...headers,
                                'Content-Type': 'application/json',
                            },
                            method: method || 'POST',
                            signal: signal_ || (timeout > 0 ? signal : null),
                        });
                        return response;
                    }, {
                        errorInstance: new TimeoutError({ body, url }),
                        timeout,
                        signal: true,
                    });
                    if (onResponse)
                        await onResponse(response);
                    let data;
                    if (response.headers.get('Content-Type')?.startsWith('application/json')) {
                        data = await response.json();
                    }
                    else {
                        data = await response.text();
                    }
                    if (!response.ok) {
                        throw new HttpRequestError({
                            body,
                            details: stringify$1(data.error) || response.statusText,
                            headers: response.headers,
                            status: response.status,
                            url,
                        });
                    }
                    return data;
                }
                catch (err) {
                    if (err instanceof HttpRequestError)
                        throw err;
                    if (err instanceof TimeoutError)
                        throw err;
                    throw new HttpRequestError({
                        body,
                        details: err.message,
                        url,
                    });
                }
            },
        };
    }

    /**
     * @description Creates a HTTP transport that connects to a JSON-RPC API.
     */
    function http(
    /** URL of the JSON-RPC API. Defaults to the chain's public RPC URL. */
    url, config = {}) {
        const { batch, fetchOptions, key = 'http', name = 'HTTP JSON-RPC', onFetchResponse, retryDelay, } = config;
        return ({ chain, retryCount: retryCount_, timeout: timeout_ }) => {
            const { batchSize = 1000, wait = 0 } = typeof batch === 'object' ? batch : {};
            const retryCount = config.retryCount ?? retryCount_;
            const timeout = timeout_ ?? config.timeout ?? 10_000;
            const url_ = url || chain?.rpcUrls.default.http[0];
            if (!url_)
                throw new UrlRequiredError();
            const rpcClient = getHttpRpcClient(url_, {
                fetchOptions,
                onResponse: onFetchResponse,
                timeout,
            });
            return createTransport({
                key,
                name,
                async request({ method, params }) {
                    const body = { method, params };
                    const { schedule } = createBatchScheduler({
                        id: `${url}`,
                        wait,
                        shouldSplitBatch(requests) {
                            return requests.length > batchSize;
                        },
                        fn: (body) => rpcClient.request({
                            body,
                        }),
                        sort: (a, b) => a.id - b.id,
                    });
                    const fn = async (body) => batch
                        ? schedule(body)
                        : [
                            await rpcClient.request({
                                body,
                            }),
                        ];
                    const [{ error, result }] = await fn(body);
                    if (error)
                        throw new RpcRequestError({
                            body,
                            error,
                            url: url_,
                        });
                    return result;
                },
                retryCount,
                retryDelay,
                timeout,
                type: 'http',
            }, {
                fetchOptions,
                url: url_,
            });
        };
    }

    class OffchainLookupError extends BaseError$1 {
        constructor({ callbackSelector, cause, data, extraData, sender, urls, }) {
            super(cause.shortMessage ||
                'An error occurred while fetching for an offchain result.', {
                cause,
                metaMessages: [
                    ...(cause.metaMessages || []),
                    cause.metaMessages?.length ? '' : [],
                    'Offchain Gateway Call:',
                    urls && [
                        '  Gateway URL(s):',
                        ...urls.map((url) => `    ${getUrl(url)}`),
                    ],
                    `  Sender: ${sender}`,
                    `  Data: ${data}`,
                    `  Callback selector: ${callbackSelector}`,
                    `  Extra data: ${extraData}`,
                ].flat(),
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'OffchainLookupError'
            });
        }
    }
    class OffchainLookupResponseMalformedError extends BaseError$1 {
        constructor({ result, url }) {
            super('Offchain gateway response is malformed. Response data must be a hex value.', {
                metaMessages: [
                    `Gateway URL: ${getUrl(url)}`,
                    `Response: ${stringify$1(result)}`,
                ],
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'OffchainLookupResponseMalformedError'
            });
        }
    }
    class OffchainLookupSenderMismatchError extends BaseError$1 {
        constructor({ sender, to }) {
            super('Reverted sender address does not match target contract address (`to`).', {
                metaMessages: [
                    `Contract address: ${to}`,
                    `OffchainLookup sender address: ${sender}`,
                ],
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'OffchainLookupSenderMismatchError'
            });
        }
    }

    function isAddressEqual(a, b) {
        if (!isAddress(a, { strict: false }))
            throw new InvalidAddressError({ address: a });
        if (!isAddress(b, { strict: false }))
            throw new InvalidAddressError({ address: b });
        return a.toLowerCase() === b.toLowerCase();
    }

    const offchainLookupSignature = '0x556f1830';
    const offchainLookupAbiItem = {
        name: 'OffchainLookup',
        type: 'error',
        inputs: [
            {
                name: 'sender',
                type: 'address',
            },
            {
                name: 'urls',
                type: 'string[]',
            },
            {
                name: 'callData',
                type: 'bytes',
            },
            {
                name: 'callbackFunction',
                type: 'bytes4',
            },
            {
                name: 'extraData',
                type: 'bytes',
            },
        ],
    };
    async function offchainLookup(client, { blockNumber, blockTag, data, to, }) {
        const { args } = decodeErrorResult({
            data,
            abi: [offchainLookupAbiItem],
        });
        const [sender, urls, callData, callbackSelector, extraData] = args;
        const { ccipRead } = client;
        const ccipRequest_ = ccipRead && typeof ccipRead?.request === 'function'
            ? ccipRead.request
            : ccipRequest;
        try {
            if (!isAddressEqual(to, sender))
                throw new OffchainLookupSenderMismatchError({ sender, to });
            const result = await ccipRequest_({ data: callData, sender, urls });
            const { data: data_ } = await call$1(client, {
                blockNumber,
                blockTag,
                data: concat([
                    callbackSelector,
                    encodeAbiParameters([{ type: 'bytes' }, { type: 'bytes' }], [result, extraData]),
                ]),
                to,
            });
            return data_;
        }
        catch (err) {
            throw new OffchainLookupError({
                callbackSelector,
                cause: err,
                data,
                extraData,
                sender,
                urls,
            });
        }
    }
    async function ccipRequest({ data, sender, urls, }) {
        let error = new Error('An unknown error occurred.');
        for (let i = 0; i < urls.length; i++) {
            const url = urls[i];
            const method = url.includes('{data}') ? 'GET' : 'POST';
            const body = method === 'POST' ? { data, sender } : undefined;
            try {
                const response = await fetch(url.replace('{sender}', sender).replace('{data}', data), {
                    body: JSON.stringify(body),
                    method,
                });
                let result;
                if (response.headers.get('Content-Type')?.startsWith('application/json')) {
                    result = (await response.json()).data;
                }
                else {
                    result = (await response.text());
                }
                if (!response.ok) {
                    error = new HttpRequestError({
                        body,
                        details: result?.error
                            ? stringify$1(result.error)
                            : response.statusText,
                        headers: response.headers,
                        status: response.status,
                        url,
                    });
                    continue;
                }
                if (!isHex(result)) {
                    error = new OffchainLookupResponseMalformedError({
                        result,
                        url,
                    });
                    continue;
                }
                return result;
            }
            catch (err) {
                error = new HttpRequestError({
                    body,
                    details: err.message,
                    url,
                });
            }
        }
        throw error;
    }

    var ccip = /*#__PURE__*/Object.freeze({
        __proto__: null,
        ccipRequest: ccipRequest,
        offchainLookup: offchainLookup,
        offchainLookupAbiItem: offchainLookupAbiItem,
        offchainLookupSignature: offchainLookupSignature
    });

    function defineChain(chain) {
        return {
            formatters: undefined,
            fees: undefined,
            serializers: undefined,
            ...chain,
        };
    }

    /**
     * Similar to [`readContract`](https://viem.sh/docs/contract/readContract), but batches up multiple functions on a contract in a single RPC call via the [`multicall3` contract](https://github.com/mds1/multicall).
     *
     * - Docs: https://viem.sh/docs/contract/multicall
     *
     * @param client - Client to use
     * @param parameters - {@link MulticallParameters}
     * @returns An array of results with accompanying status. {@link MulticallReturnType}
     *
     * @example
     * import { createPublicClient, http, parseAbi } from 'viem'
     * import { mainnet } from 'viem/chains'
     * import { multicall } from 'viem/contract'
     *
     * const client = createPublicClient({
     *   chain: mainnet,
     *   transport: http(),
     * })
     * const abi = parseAbi([
     *   'function balanceOf(address) view returns (uint256)',
     *   'function totalSupply() view returns (uint256)',
     * ])
     * const results = await multicall(client, {
     *   contracts: [
     *     {
     *       address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
     *       abi,
     *       functionName: 'balanceOf',
     *       args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'],
     *     },
     *     {
     *       address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
     *       abi,
     *       functionName: 'totalSupply',
     *     },
     *   ],
     * })
     * // [{ result: 424122n, status: 'success' }, { result: 1000000n, status: 'success' }]
     */
    async function multicall$1(client, parameters) {
        const { allowFailure = true, batchSize: batchSize_, blockNumber, blockTag, multicallAddress: multicallAddress_, stateOverride, } = parameters;
        const contracts = parameters.contracts;
        const batchSize = batchSize_ ??
            ((typeof client.batch?.multicall === 'object' &&
                client.batch.multicall.batchSize) ||
                1_024);
        let multicallAddress = multicallAddress_;
        if (!multicallAddress) {
            if (!client.chain)
                throw new Error('client chain not configured. multicallAddress is required.');
            multicallAddress = getChainContractAddress({
                blockNumber,
                chain: client.chain,
                contract: 'multicall3',
            });
        }
        const chunkedCalls = [[]];
        let currentChunk = 0;
        let currentChunkSize = 0;
        for (let i = 0; i < contracts.length; i++) {
            const { abi, address, args, functionName } = contracts[i];
            try {
                const callData = encodeFunctionData({ abi, args, functionName });
                currentChunkSize += (callData.length - 2) / 2;
                // Check to see if we need to create a new chunk.
                if (
                // Check if batching is enabled.
                batchSize > 0 &&
                    // Check if the current size of the batch exceeds the size limit.
                    currentChunkSize > batchSize &&
                    // Check if the current chunk is not already empty.
                    chunkedCalls[currentChunk].length > 0) {
                    currentChunk++;
                    currentChunkSize = (callData.length - 2) / 2;
                    chunkedCalls[currentChunk] = [];
                }
                chunkedCalls[currentChunk] = [
                    ...chunkedCalls[currentChunk],
                    {
                        allowFailure: true,
                        callData,
                        target: address,
                    },
                ];
            }
            catch (err) {
                const error = getContractError(err, {
                    abi,
                    address,
                    args,
                    docsPath: '/docs/contract/multicall',
                    functionName,
                });
                if (!allowFailure)
                    throw error;
                chunkedCalls[currentChunk] = [
                    ...chunkedCalls[currentChunk],
                    {
                        allowFailure: true,
                        callData: '0x',
                        target: address,
                    },
                ];
            }
        }
        const aggregate3Results = await Promise.allSettled(chunkedCalls.map((calls) => getAction$1(client, readContract$1, 'readContract')({
            abi: multicall3Abi,
            address: multicallAddress,
            args: [calls],
            blockNumber,
            blockTag,
            functionName: 'aggregate3',
            stateOverride,
        })));
        const results = [];
        for (let i = 0; i < aggregate3Results.length; i++) {
            const result = aggregate3Results[i];
            // If an error occurred in a `readContract` invocation (ie. network error),
            // then append the failure reason to each contract result.
            if (result.status === 'rejected') {
                if (!allowFailure)
                    throw result.reason;
                for (let j = 0; j < chunkedCalls[i].length; j++) {
                    results.push({
                        status: 'failure',
                        error: result.reason,
                        result: undefined,
                    });
                }
                continue;
            }
            // If the `readContract` call was successful, then decode the results.
            const aggregate3Result = result.value;
            for (let j = 0; j < aggregate3Result.length; j++) {
                // Extract the response from `readContract`
                const { returnData, success } = aggregate3Result[j];
                // Extract the request call data from the original call.
                const { callData } = chunkedCalls[i][j];
                // Extract the contract config for this call from the `contracts` argument
                // for decoding.
                const { abi, address, functionName, args } = contracts[results.length];
                try {
                    if (callData === '0x')
                        throw new AbiDecodingZeroDataError();
                    if (!success)
                        throw new RawContractError({ data: returnData });
                    const result = decodeFunctionResult({
                        abi,
                        args,
                        data: returnData,
                        functionName,
                    });
                    results.push(allowFailure ? { result, status: 'success' } : result);
                }
                catch (err) {
                    const error = getContractError(err, {
                        abi,
                        address,
                        args,
                        docsPath: '/docs/contract/multicall',
                        functionName,
                    });
                    if (!allowFailure)
                        throw error;
                    results.push({ error, result: undefined, status: 'failure' });
                }
            }
        }
        if (results.length !== contracts.length)
            throw new BaseError$1('multicall results mismatch');
        return results;
    }

    /**
     * Calculates an Ethereum-specific signature in [EIP-191 format](https://eips.ethereum.org/EIPS/eip-191): `keccak256("\x19Ethereum Signed Message:\n" + len(message) + message))`.
     *
     * - Docs: https://viem.sh/docs/actions/wallet/signMessage
     * - JSON-RPC Methods:
     *   - JSON-RPC Accounts: [`personal_sign`](https://docs.metamask.io/guide/signing-data#personal-sign)
     *   - Local Accounts: Signs locally. No JSON-RPC request.
     *
     * With the calculated signature, you can:
     * - use [`verifyMessage`](https://viem.sh/docs/utilities/verifyMessage) to verify the signature,
     * - use [`recoverMessageAddress`](https://viem.sh/docs/utilities/recoverMessageAddress) to recover the signing address from a signature.
     *
     * @param client - Client to use
     * @param parameters - {@link SignMessageParameters}
     * @returns The signed message. {@link SignMessageReturnType}
     *
     * @example
     * import { createWalletClient, custom } from 'viem'
     * import { mainnet } from 'viem/chains'
     * import { signMessage } from 'viem/wallet'
     *
     * const client = createWalletClient({
     *   chain: mainnet,
     *   transport: custom(window.ethereum),
     * })
     * const signature = await signMessage(client, {
     *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
     *   message: 'hello world',
     * })
     *
     * @example
     * // Account Hoisting
     * import { createWalletClient, custom } from 'viem'
     * import { privateKeyToAccount } from 'viem/accounts'
     * import { mainnet } from 'viem/chains'
     * import { signMessage } from 'viem/wallet'
     *
     * const client = createWalletClient({
     *   account: privateKeyToAccount('0x…'),
     *   chain: mainnet,
     *   transport: custom(window.ethereum),
     * })
     * const signature = await signMessage(client, {
     *   message: 'hello world',
     * })
     */
    async function signMessage$1(client, { account: account_ = client.account, message, }) {
        if (!account_)
            throw new AccountNotFoundError({
                docsPath: '/docs/actions/wallet/signMessage',
            });
        const account = parseAccount(account_);
        if (account.type === 'local')
            return account.signMessage({ message });
        const message_ = (() => {
            if (typeof message === 'string')
                return stringToHex(message);
            if (message.raw instanceof Uint8Array)
                return toHex$1(message.raw);
            return message.raw;
        })();
        return client.request({
            method: 'personal_sign',
            params: [message_, account.address],
        }, { retryCount: 0 });
    }

    /**
     * Announces an EIP-1193 Provider.
     */
    /**
     * Watches for EIP-1193 Providers to be announced.
     */
    function requestProviders(listener) {
        const handler = (event) => listener(event.detail);
        window.addEventListener('eip6963:announceProvider', handler);
        window.dispatchEvent(new CustomEvent('eip6963:requestProvider'));
        return () => window.removeEventListener('eip6963:announceProvider', handler);
    }

    function createStore$1() {
        const listeners = new Set();
        let providerDetails = [];
        const request = () => requestProviders((providerDetail) => {
            if (providerDetails.some(({ info }) => info.uuid === providerDetail.info.uuid))
                return;
            providerDetails = [...providerDetails, providerDetail];
            listeners.forEach((listener) => listener(providerDetails, { added: [providerDetail] }));
        });
        let unwatch = request();
        return {
            _listeners() {
                return listeners;
            },
            clear() {
                listeners.forEach((listener) => listener([], { removed: [...providerDetails] }));
                providerDetails = [];
            },
            destroy() {
                this.clear();
                listeners.clear();
                unwatch();
            },
            findProvider({ rdns }) {
                return providerDetails.find((providerDetail) => providerDetail.info.rdns === rdns);
            },
            getProviders() {
                return providerDetails;
            },
            reset() {
                this.clear();
                unwatch();
                unwatch = request();
            },
            subscribe(listener, { emitImmediately } = {}) {
                listeners.add(listener);
                if (emitImmediately)
                    listener(providerDetails, { added: providerDetails });
                return () => listeners.delete(listener);
            },
        };
    }

    const subscribeWithSelectorImpl = (fn) => (set, get, api) => {
      const origSubscribe = api.subscribe;
      api.subscribe = (selector, optListener, options) => {
        let listener = selector;
        if (optListener) {
          const equalityFn = (options == null ? void 0 : options.equalityFn) || Object.is;
          let currentSlice = selector(api.getState());
          listener = (state) => {
            const nextSlice = selector(state);
            if (!equalityFn(currentSlice, nextSlice)) {
              const previousSlice = currentSlice;
              optListener(currentSlice = nextSlice, previousSlice);
            }
          };
          if (options == null ? void 0 : options.fireImmediately) {
            optListener(currentSlice, currentSlice);
          }
        }
        return origSubscribe(listener);
      };
      const initialState = fn(set, get, api);
      return initialState;
    };
    const subscribeWithSelector = subscribeWithSelectorImpl;

    function createJSONStorage(getStorage, options) {
      let storage;
      try {
        storage = getStorage();
      } catch (e) {
        return;
      }
      const persistStorage = {
        getItem: (name) => {
          var _a;
          const parse = (str2) => {
            if (str2 === null) {
              return null;
            }
            return JSON.parse(str2, options == null ? void 0 : options.reviver);
          };
          const str = (_a = storage.getItem(name)) != null ? _a : null;
          if (str instanceof Promise) {
            return str.then(parse);
          }
          return parse(str);
        },
        setItem: (name, newValue) => storage.setItem(
          name,
          JSON.stringify(newValue, options == null ? void 0 : options.replacer)
        ),
        removeItem: (name) => storage.removeItem(name)
      };
      return persistStorage;
    }
    const toThenable = (fn) => (input) => {
      try {
        const result = fn(input);
        if (result instanceof Promise) {
          return result;
        }
        return {
          then(onFulfilled) {
            return toThenable(onFulfilled)(result);
          },
          catch(_onRejected) {
            return this;
          }
        };
      } catch (e) {
        return {
          then(_onFulfilled) {
            return this;
          },
          catch(onRejected) {
            return toThenable(onRejected)(e);
          }
        };
      }
    };
    const oldImpl = (config, baseOptions) => (set, get, api) => {
      let options = {
        getStorage: () => localStorage,
        serialize: JSON.stringify,
        deserialize: JSON.parse,
        partialize: (state) => state,
        version: 0,
        merge: (persistedState, currentState) => ({
          ...currentState,
          ...persistedState
        }),
        ...baseOptions
      };
      let hasHydrated = false;
      const hydrationListeners = /* @__PURE__ */ new Set();
      const finishHydrationListeners = /* @__PURE__ */ new Set();
      let storage;
      try {
        storage = options.getStorage();
      } catch (e) {
      }
      if (!storage) {
        return config(
          (...args) => {
            console.warn(
              `[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`
            );
            set(...args);
          },
          get,
          api
        );
      }
      const thenableSerialize = toThenable(options.serialize);
      const setItem = () => {
        const state = options.partialize({ ...get() });
        let errorInSync;
        const thenable = thenableSerialize({ state, version: options.version }).then(
          (serializedValue) => storage.setItem(options.name, serializedValue)
        ).catch((e) => {
          errorInSync = e;
        });
        if (errorInSync) {
          throw errorInSync;
        }
        return thenable;
      };
      const savedSetState = api.setState;
      api.setState = (state, replace) => {
        savedSetState(state, replace);
        void setItem();
      };
      const configResult = config(
        (...args) => {
          set(...args);
          void setItem();
        },
        get,
        api
      );
      let stateFromStorage;
      const hydrate = () => {
        var _a;
        if (!storage)
          return;
        hasHydrated = false;
        hydrationListeners.forEach((cb) => cb(get()));
        const postRehydrationCallback = ((_a = options.onRehydrateStorage) == null ? void 0 : _a.call(options, get())) || void 0;
        return toThenable(storage.getItem.bind(storage))(options.name).then((storageValue) => {
          if (storageValue) {
            return options.deserialize(storageValue);
          }
        }).then((deserializedStorageValue) => {
          if (deserializedStorageValue) {
            if (typeof deserializedStorageValue.version === "number" && deserializedStorageValue.version !== options.version) {
              if (options.migrate) {
                return options.migrate(
                  deserializedStorageValue.state,
                  deserializedStorageValue.version
                );
              }
              console.error(
                `State loaded from storage couldn't be migrated since no migrate function was provided`
              );
            } else {
              return deserializedStorageValue.state;
            }
          }
        }).then((migratedState) => {
          var _a2;
          stateFromStorage = options.merge(
            migratedState,
            (_a2 = get()) != null ? _a2 : configResult
          );
          set(stateFromStorage, true);
          return setItem();
        }).then(() => {
          postRehydrationCallback == null ? void 0 : postRehydrationCallback(stateFromStorage, void 0);
          hasHydrated = true;
          finishHydrationListeners.forEach((cb) => cb(stateFromStorage));
        }).catch((e) => {
          postRehydrationCallback == null ? void 0 : postRehydrationCallback(void 0, e);
        });
      };
      api.persist = {
        setOptions: (newOptions) => {
          options = {
            ...options,
            ...newOptions
          };
          if (newOptions.getStorage) {
            storage = newOptions.getStorage();
          }
        },
        clearStorage: () => {
          storage == null ? void 0 : storage.removeItem(options.name);
        },
        getOptions: () => options,
        rehydrate: () => hydrate(),
        hasHydrated: () => hasHydrated,
        onHydrate: (cb) => {
          hydrationListeners.add(cb);
          return () => {
            hydrationListeners.delete(cb);
          };
        },
        onFinishHydration: (cb) => {
          finishHydrationListeners.add(cb);
          return () => {
            finishHydrationListeners.delete(cb);
          };
        }
      };
      hydrate();
      return stateFromStorage || configResult;
    };
    const newImpl = (config, baseOptions) => (set, get, api) => {
      let options = {
        storage: createJSONStorage(() => localStorage),
        partialize: (state) => state,
        version: 0,
        merge: (persistedState, currentState) => ({
          ...currentState,
          ...persistedState
        }),
        ...baseOptions
      };
      let hasHydrated = false;
      const hydrationListeners = /* @__PURE__ */ new Set();
      const finishHydrationListeners = /* @__PURE__ */ new Set();
      let storage = options.storage;
      if (!storage) {
        return config(
          (...args) => {
            console.warn(
              `[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`
            );
            set(...args);
          },
          get,
          api
        );
      }
      const setItem = () => {
        const state = options.partialize({ ...get() });
        return storage.setItem(options.name, {
          state,
          version: options.version
        });
      };
      const savedSetState = api.setState;
      api.setState = (state, replace) => {
        savedSetState(state, replace);
        void setItem();
      };
      const configResult = config(
        (...args) => {
          set(...args);
          void setItem();
        },
        get,
        api
      );
      let stateFromStorage;
      const hydrate = () => {
        var _a, _b;
        if (!storage)
          return;
        hasHydrated = false;
        hydrationListeners.forEach((cb) => {
          var _a2;
          return cb((_a2 = get()) != null ? _a2 : configResult);
        });
        const postRehydrationCallback = ((_b = options.onRehydrateStorage) == null ? void 0 : _b.call(options, (_a = get()) != null ? _a : configResult)) || void 0;
        return toThenable(storage.getItem.bind(storage))(options.name).then((deserializedStorageValue) => {
          if (deserializedStorageValue) {
            if (typeof deserializedStorageValue.version === "number" && deserializedStorageValue.version !== options.version) {
              if (options.migrate) {
                return options.migrate(
                  deserializedStorageValue.state,
                  deserializedStorageValue.version
                );
              }
              console.error(
                `State loaded from storage couldn't be migrated since no migrate function was provided`
              );
            } else {
              return deserializedStorageValue.state;
            }
          }
        }).then((migratedState) => {
          var _a2;
          stateFromStorage = options.merge(
            migratedState,
            (_a2 = get()) != null ? _a2 : configResult
          );
          set(stateFromStorage, true);
          return setItem();
        }).then(() => {
          postRehydrationCallback == null ? void 0 : postRehydrationCallback(stateFromStorage, void 0);
          stateFromStorage = get();
          hasHydrated = true;
          finishHydrationListeners.forEach((cb) => cb(stateFromStorage));
        }).catch((e) => {
          postRehydrationCallback == null ? void 0 : postRehydrationCallback(void 0, e);
        });
      };
      api.persist = {
        setOptions: (newOptions) => {
          options = {
            ...options,
            ...newOptions
          };
          if (newOptions.storage) {
            storage = newOptions.storage;
          }
        },
        clearStorage: () => {
          storage == null ? void 0 : storage.removeItem(options.name);
        },
        getOptions: () => options,
        rehydrate: () => hydrate(),
        hasHydrated: () => hasHydrated,
        onHydrate: (cb) => {
          hydrationListeners.add(cb);
          return () => {
            hydrationListeners.delete(cb);
          };
        },
        onFinishHydration: (cb) => {
          finishHydrationListeners.add(cb);
          return () => {
            finishHydrationListeners.delete(cb);
          };
        }
      };
      if (!options.skipHydration) {
        hydrate();
      }
      return stateFromStorage || configResult;
    };
    const persistImpl = (config, baseOptions) => {
      if ("getStorage" in baseOptions || "serialize" in baseOptions || "deserialize" in baseOptions) {
        if ((undefined ? undefined.MODE : void 0) !== "production") {
          console.warn(
            "[DEPRECATED] `getStorage`, `serialize` and `deserialize` options are deprecated. Use `storage` option instead."
          );
        }
        return oldImpl(config, baseOptions);
      }
      return newImpl(config, baseOptions);
    };
    const persist = persistImpl;

    const createStoreImpl = (createState) => {
      let state;
      const listeners = /* @__PURE__ */ new Set();
      const setState = (partial, replace) => {
        const nextState = typeof partial === "function" ? partial(state) : partial;
        if (!Object.is(nextState, state)) {
          const previousState = state;
          state = (replace != null ? replace : typeof nextState !== "object") ? nextState : Object.assign({}, state, nextState);
          listeners.forEach((listener) => listener(state, previousState));
        }
      };
      const getState = () => state;
      const subscribe = (listener) => {
        listeners.add(listener);
        return () => listeners.delete(listener);
      };
      const destroy = () => {
        if ((undefined ? undefined.MODE : void 0) !== "production") {
          console.warn(
            "[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."
          );
        }
        listeners.clear();
      };
      const api = { setState, getState, subscribe, destroy };
      state = createState(setState, getState, api);
      return api;
    };
    const createStore = (createState) => createState ? createStoreImpl(createState) : createStoreImpl;

    var eventemitter3 = {exports: {}};

    (function (module) {

    	var has = Object.prototype.hasOwnProperty
    	  , prefix = '~';

    	/**
    	 * Constructor to create a storage for our `EE` objects.
    	 * An `Events` instance is a plain object whose properties are event names.
    	 *
    	 * @constructor
    	 * @private
    	 */
    	function Events() {}

    	//
    	// We try to not inherit from `Object.prototype`. In some engines creating an
    	// instance in this way is faster than calling `Object.create(null)` directly.
    	// If `Object.create(null)` is not supported we prefix the event names with a
    	// character to make sure that the built-in object properties are not
    	// overridden or used as an attack vector.
    	//
    	if (Object.create) {
    	  Events.prototype = Object.create(null);

    	  //
    	  // This hack is needed because the `__proto__` property is still inherited in
    	  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
    	  //
    	  if (!new Events().__proto__) prefix = false;
    	}

    	/**
    	 * Representation of a single event listener.
    	 *
    	 * @param {Function} fn The listener function.
    	 * @param {*} context The context to invoke the listener with.
    	 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
    	 * @constructor
    	 * @private
    	 */
    	function EE(fn, context, once) {
    	  this.fn = fn;
    	  this.context = context;
    	  this.once = once || false;
    	}

    	/**
    	 * Add a listener for a given event.
    	 *
    	 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
    	 * @param {(String|Symbol)} event The event name.
    	 * @param {Function} fn The listener function.
    	 * @param {*} context The context to invoke the listener with.
    	 * @param {Boolean} once Specify if the listener is a one-time listener.
    	 * @returns {EventEmitter}
    	 * @private
    	 */
    	function addListener(emitter, event, fn, context, once) {
    	  if (typeof fn !== 'function') {
    	    throw new TypeError('The listener must be a function');
    	  }

    	  var listener = new EE(fn, context || emitter, once)
    	    , evt = prefix ? prefix + event : event;

    	  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
    	  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
    	  else emitter._events[evt] = [emitter._events[evt], listener];

    	  return emitter;
    	}

    	/**
    	 * Clear event by name.
    	 *
    	 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
    	 * @param {(String|Symbol)} evt The Event name.
    	 * @private
    	 */
    	function clearEvent(emitter, evt) {
    	  if (--emitter._eventsCount === 0) emitter._events = new Events();
    	  else delete emitter._events[evt];
    	}

    	/**
    	 * Minimal `EventEmitter` interface that is molded against the Node.js
    	 * `EventEmitter` interface.
    	 *
    	 * @constructor
    	 * @public
    	 */
    	function EventEmitter() {
    	  this._events = new Events();
    	  this._eventsCount = 0;
    	}

    	/**
    	 * Return an array listing the events for which the emitter has registered
    	 * listeners.
    	 *
    	 * @returns {Array}
    	 * @public
    	 */
    	EventEmitter.prototype.eventNames = function eventNames() {
    	  var names = []
    	    , events
    	    , name;

    	  if (this._eventsCount === 0) return names;

    	  for (name in (events = this._events)) {
    	    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
    	  }

    	  if (Object.getOwnPropertySymbols) {
    	    return names.concat(Object.getOwnPropertySymbols(events));
    	  }

    	  return names;
    	};

    	/**
    	 * Return the listeners registered for a given event.
    	 *
    	 * @param {(String|Symbol)} event The event name.
    	 * @returns {Array} The registered listeners.
    	 * @public
    	 */
    	EventEmitter.prototype.listeners = function listeners(event) {
    	  var evt = prefix ? prefix + event : event
    	    , handlers = this._events[evt];

    	  if (!handlers) return [];
    	  if (handlers.fn) return [handlers.fn];

    	  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
    	    ee[i] = handlers[i].fn;
    	  }

    	  return ee;
    	};

    	/**
    	 * Return the number of listeners listening to a given event.
    	 *
    	 * @param {(String|Symbol)} event The event name.
    	 * @returns {Number} The number of listeners.
    	 * @public
    	 */
    	EventEmitter.prototype.listenerCount = function listenerCount(event) {
    	  var evt = prefix ? prefix + event : event
    	    , listeners = this._events[evt];

    	  if (!listeners) return 0;
    	  if (listeners.fn) return 1;
    	  return listeners.length;
    	};

    	/**
    	 * Calls each of the listeners registered for a given event.
    	 *
    	 * @param {(String|Symbol)} event The event name.
    	 * @returns {Boolean} `true` if the event had listeners, else `false`.
    	 * @public
    	 */
    	EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
    	  var evt = prefix ? prefix + event : event;

    	  if (!this._events[evt]) return false;

    	  var listeners = this._events[evt]
    	    , len = arguments.length
    	    , args
    	    , i;

    	  if (listeners.fn) {
    	    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

    	    switch (len) {
    	      case 1: return listeners.fn.call(listeners.context), true;
    	      case 2: return listeners.fn.call(listeners.context, a1), true;
    	      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
    	      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
    	      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
    	      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
    	    }

    	    for (i = 1, args = new Array(len -1); i < len; i++) {
    	      args[i - 1] = arguments[i];
    	    }

    	    listeners.fn.apply(listeners.context, args);
    	  } else {
    	    var length = listeners.length
    	      , j;

    	    for (i = 0; i < length; i++) {
    	      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

    	      switch (len) {
    	        case 1: listeners[i].fn.call(listeners[i].context); break;
    	        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
    	        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
    	        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;
    	        default:
    	          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
    	            args[j - 1] = arguments[j];
    	          }

    	          listeners[i].fn.apply(listeners[i].context, args);
    	      }
    	    }
    	  }

    	  return true;
    	};

    	/**
    	 * Add a listener for a given event.
    	 *
    	 * @param {(String|Symbol)} event The event name.
    	 * @param {Function} fn The listener function.
    	 * @param {*} [context=this] The context to invoke the listener with.
    	 * @returns {EventEmitter} `this`.
    	 * @public
    	 */
    	EventEmitter.prototype.on = function on(event, fn, context) {
    	  return addListener(this, event, fn, context, false);
    	};

    	/**
    	 * Add a one-time listener for a given event.
    	 *
    	 * @param {(String|Symbol)} event The event name.
    	 * @param {Function} fn The listener function.
    	 * @param {*} [context=this] The context to invoke the listener with.
    	 * @returns {EventEmitter} `this`.
    	 * @public
    	 */
    	EventEmitter.prototype.once = function once(event, fn, context) {
    	  return addListener(this, event, fn, context, true);
    	};

    	/**
    	 * Remove the listeners of a given event.
    	 *
    	 * @param {(String|Symbol)} event The event name.
    	 * @param {Function} fn Only remove the listeners that match this function.
    	 * @param {*} context Only remove the listeners that have this context.
    	 * @param {Boolean} once Only remove one-time listeners.
    	 * @returns {EventEmitter} `this`.
    	 * @public
    	 */
    	EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
    	  var evt = prefix ? prefix + event : event;

    	  if (!this._events[evt]) return this;
    	  if (!fn) {
    	    clearEvent(this, evt);
    	    return this;
    	  }

    	  var listeners = this._events[evt];

    	  if (listeners.fn) {
    	    if (
    	      listeners.fn === fn &&
    	      (!once || listeners.once) &&
    	      (!context || listeners.context === context)
    	    ) {
    	      clearEvent(this, evt);
    	    }
    	  } else {
    	    for (var i = 0, events = [], length = listeners.length; i < length; i++) {
    	      if (
    	        listeners[i].fn !== fn ||
    	        (once && !listeners[i].once) ||
    	        (context && listeners[i].context !== context)
    	      ) {
    	        events.push(listeners[i]);
    	      }
    	    }

    	    //
    	    // Reset the array, or remove it completely if we have no more listeners.
    	    //
    	    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
    	    else clearEvent(this, evt);
    	  }

    	  return this;
    	};

    	/**
    	 * Remove all listeners, or those of the specified event.
    	 *
    	 * @param {(String|Symbol)} [event] The event name.
    	 * @returns {EventEmitter} `this`.
    	 * @public
    	 */
    	EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
    	  var evt;

    	  if (event) {
    	    evt = prefix ? prefix + event : event;
    	    if (this._events[evt]) clearEvent(this, evt);
    	  } else {
    	    this._events = new Events();
    	    this._eventsCount = 0;
    	  }

    	  return this;
    	};

    	//
    	// Alias methods names because people roll like that.
    	//
    	EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
    	EventEmitter.prototype.addListener = EventEmitter.prototype.on;

    	//
    	// Expose the prefix.
    	//
    	EventEmitter.prefixed = prefix;

    	//
    	// Allow `EventEmitter` to be imported as module namespace.
    	//
    	EventEmitter.EventEmitter = EventEmitter;

    	//
    	// Expose the module.
    	//
    	{
    	  module.exports = EventEmitter;
    	} 
    } (eventemitter3));

    var eventemitter3Exports = eventemitter3.exports;
    var EventEmitter = /*@__PURE__*/getDefaultExportFromCjs(eventemitter3Exports);

    var __classPrivateFieldGet$2 = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _Emitter_emitter;
    class Emitter {
        constructor(uid) {
            Object.defineProperty(this, "uid", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: uid
            });
            _Emitter_emitter.set(this, new EventEmitter());
        }
        on(eventName, fn) {
            __classPrivateFieldGet$2(this, _Emitter_emitter, "f").on(eventName, fn);
        }
        once(eventName, fn) {
            __classPrivateFieldGet$2(this, _Emitter_emitter, "f").once(eventName, fn);
        }
        off(eventName, fn) {
            __classPrivateFieldGet$2(this, _Emitter_emitter, "f").off(eventName, fn);
        }
        emit(eventName, ...params) {
            const data = params[0];
            __classPrivateFieldGet$2(this, _Emitter_emitter, "f").emit(eventName, { uid: this.uid, ...data });
        }
        listenerCount(eventName) {
            return __classPrivateFieldGet$2(this, _Emitter_emitter, "f").listenerCount(eventName);
        }
    }
    _Emitter_emitter = new WeakMap();
    function createEmitter(uid) {
        return new Emitter(uid);
    }

    function deserialize(value, reviver) {
        return JSON.parse(value, (key, value_) => {
            let value = value_;
            if (value?.__type === 'bigint')
                value = BigInt(value.value);
            if (value?.__type === 'Map')
                value = new Map(value.value);
            return reviver?.(key, value) ?? value;
        });
    }

    /**
     * Get the reference key for the circular value
     *
     * @param keys the keys to build the reference key from
     * @param cutoff the maximum number of keys to include
     * @returns the reference key
     */
    function getReferenceKey(keys, cutoff) {
        return keys.slice(0, cutoff).join('.') || '.';
    }
    /**
     * Faster `Array.prototype.indexOf` implementation build for slicing / splicing
     *
     * @param array the array to match the value in
     * @param value the value to match
     * @returns the matching index, or -1
     */
    function getCutoff(array, value) {
        const { length } = array;
        for (let index = 0; index < length; ++index) {
            if (array[index] === value) {
                return index + 1;
            }
        }
        return 0;
    }
    /**
     * Create a replacer method that handles circular values
     *
     * @param [replacer] a custom replacer to use for non-circular values
     * @param [circularReplacer] a custom replacer to use for circular methods
     * @returns the value to stringify
     */
    function createReplacer(replacer, circularReplacer) {
        const hasReplacer = typeof replacer === 'function';
        const hasCircularReplacer = typeof circularReplacer === 'function';
        const cache = [];
        const keys = [];
        return function replace(key, value) {
            if (typeof value === 'object') {
                if (cache.length) {
                    const thisCutoff = getCutoff(cache, this);
                    if (thisCutoff === 0) {
                        cache[cache.length] = this;
                    }
                    else {
                        cache.splice(thisCutoff);
                        keys.splice(thisCutoff);
                    }
                    keys[keys.length] = key;
                    const valueCutoff = getCutoff(cache, value);
                    if (valueCutoff !== 0) {
                        return hasCircularReplacer
                            ? circularReplacer.call(this, key, value, getReferenceKey(keys, valueCutoff))
                            : `[ref=${getReferenceKey(keys, valueCutoff)}]`;
                    }
                }
                else {
                    cache[0] = value;
                    keys[0] = key;
                }
            }
            return hasReplacer ? replacer.call(this, key, value) : value;
        };
    }
    /**
     * Stringifier that handles circular values
     *
     * Forked from https://github.com/planttheidea/fast-stringify
     *
     * @param value to stringify
     * @param [replacer] a custom replacer function for handling standard values
     * @param [indent] the number of spaces to indent the output by
     * @param [circularReplacer] a custom replacer function for handling circular values
     * @returns the stringified output
     */
    function serialize$1(value, replacer, indent, circularReplacer) {
        return JSON.stringify(value, createReplacer((key, value_) => {
            let value = value_;
            if (typeof value === 'bigint')
                value = { __type: 'bigint', value: value_.toString() };
            if (value instanceof Map)
                value = { __type: 'Map', value: Array.from(value_.entries()) };
            return replacer?.(key, value) ?? value;
        }, circularReplacer), indent ?? undefined);
    }

    function createStorage(parameters) {
        const { deserialize: deserialize$1 = deserialize, key: prefix = 'wagmi', serialize = serialize$1, storage = noopStorage, } = parameters;
        function unwrap(value) {
            if (value instanceof Promise)
                return value.then((x) => x).catch(() => null);
            return value;
        }
        return {
            ...storage,
            key: prefix,
            async getItem(key, defaultValue) {
                const value = storage.getItem(`${prefix}.${key}`);
                const unwrapped = await unwrap(value);
                if (unwrapped)
                    return deserialize$1(unwrapped) ?? null;
                return (defaultValue ?? null);
            },
            async setItem(key, value) {
                const storageKey = `${prefix}.${key}`;
                if (value === null)
                    await unwrap(storage.removeItem(storageKey));
                else
                    await unwrap(storage.setItem(storageKey, serialize(value)));
            },
            async removeItem(key) {
                await unwrap(storage.removeItem(`${prefix}.${key}`));
            },
        };
    }
    const noopStorage = {
        getItem: () => null,
        setItem: () => { },
        removeItem: () => { },
    };

    function createConnector(createConnectorFn) {
        return createConnectorFn;
    }

    const version$2 = '2.6.13';

    const getVersion = () => `@wagmi/core@${version$2}`;

    var __classPrivateFieldGet$1 = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _BaseError_instances, _BaseError_walk;
    class BaseError extends Error {
        get docsBaseUrl() {
            return 'https://wagmi.sh/core';
        }
        get version() {
            return getVersion();
        }
        constructor(shortMessage, options = {}) {
            super();
            _BaseError_instances.add(this);
            Object.defineProperty(this, "details", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "docsPath", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "metaMessages", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "shortMessage", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'WagmiCoreError'
            });
            const details = options.cause instanceof BaseError
                ? options.cause.details
                : options.cause?.message
                    ? options.cause.message
                    : options.details;
            const docsPath = options.cause instanceof BaseError
                ? options.cause.docsPath || options.docsPath
                : options.docsPath;
            this.message = [
                shortMessage || 'An error occurred.',
                '',
                ...(options.metaMessages ? [...options.metaMessages, ''] : []),
                ...(docsPath
                    ? [
                        `Docs: ${this.docsBaseUrl}${docsPath}.html${options.docsSlug ? `#${options.docsSlug}` : ''}`,
                    ]
                    : []),
                ...(details ? [`Details: ${details}`] : []),
                `Version: ${this.version}`,
            ].join('\n');
            if (options.cause)
                this.cause = options.cause;
            this.details = details;
            this.docsPath = docsPath;
            this.metaMessages = options.metaMessages;
            this.shortMessage = shortMessage;
        }
        walk(fn) {
            return __classPrivateFieldGet$1(this, _BaseError_instances, "m", _BaseError_walk).call(this, this, fn);
        }
    }
    _BaseError_instances = new WeakSet(), _BaseError_walk = function _BaseError_walk(err, fn) {
        if (fn?.(err))
            return err;
        if (err.cause)
            return __classPrivateFieldGet$1(this, _BaseError_instances, "m", _BaseError_walk).call(this, err.cause, fn);
        return err;
    };

    class ChainNotConfiguredError extends BaseError {
        constructor() {
            super('Chain not configured.');
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'ChainNotConfiguredError'
            });
        }
    }
    class ConnectorAlreadyConnectedError extends BaseError {
        constructor() {
            super('Connector already connected.');
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'ConnectorAlreadyConnectedError'
            });
        }
    }
    class ConnectorNotConnectedError extends BaseError {
        constructor() {
            super('Connector not connected.');
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'ConnectorNotConnectedError'
            });
        }
    }
    class ConnectorAccountNotFoundError extends BaseError {
        constructor({ address, connector, }) {
            super(`Account "${address}" not found for connector "${connector.name}".`);
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'ConnectorAccountNotFoundError'
            });
        }
    }

    class ProviderNotFoundError extends BaseError {
        constructor() {
            super('Provider not found.');
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'ProviderNotFoundError'
            });
        }
    }
    class SwitchChainNotSupportedError extends BaseError {
        constructor({ connector }) {
            super(`"${connector.name}" does not support programmatic chain switching.`);
            Object.defineProperty(this, "name", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 'SwitchChainNotSupportedError'
            });
        }
    }

    const targetMap = {
        coinbaseWallet: {
            id: 'coinbaseWallet',
            name: 'Coinbase Wallet',
            provider(window) {
                if (window?.coinbaseWalletExtension)
                    return window.coinbaseWalletExtension;
                return findProvider(window, 'isCoinbaseWallet');
            },
        },
        metaMask: {
            id: 'metaMask',
            name: 'MetaMask',
            provider(window) {
                return findProvider(window, (provider) => {
                    if (!provider.isMetaMask)
                        return false;
                    // Brave tries to make itself look like MetaMask
                    // Could also try RPC `web3_clientVersion` if following is unreliable
                    if (provider.isBraveWallet && !provider._events && !provider._state)
                        return false;
                    // Other wallets that try to look like MetaMask
                    const flags = [
                        'isApexWallet',
                        'isAvalanche',
                        'isBitKeep',
                        'isBlockWallet',
                        'isKuCoinWallet',
                        'isMathWallet',
                        'isOkxWallet',
                        'isOKExWallet',
                        'isOneInchIOSWallet',
                        'isOneInchAndroidWallet',
                        'isOpera',
                        'isPortal',
                        'isRabby',
                        'isTokenPocket',
                        'isTokenary',
                        'isZerion',
                    ];
                    for (const flag of flags)
                        if (provider[flag])
                            return false;
                    return true;
                });
            },
        },
        phantom: {
            id: 'phantom',
            name: 'Phantom',
            provider(window) {
                if (window?.phantom?.ethereum)
                    return window.phantom?.ethereum;
                return findProvider(window, 'isPhantom');
            },
        },
    };
    injected.type = 'injected';
    function injected(parameters = {}) {
        const { shimDisconnect = true, unstable_shimAsyncInject } = parameters;
        function getTarget() {
            const target = parameters.target;
            if (typeof target === 'function') {
                const result = target();
                if (result)
                    return result;
            }
            if (typeof target === 'object')
                return target;
            if (typeof target === 'string')
                return {
                    ...(targetMap[target] ?? {
                        id: target,
                        name: `${target[0].toUpperCase()}${target.slice(1)}`,
                        provider: `is${target[0].toUpperCase()}${target.slice(1)}`,
                    }),
                };
            return {
                id: 'injected',
                name: 'Injected',
                provider(window) {
                    return window?.ethereum;
                },
            };
        }
        return createConnector((config) => ({
            get icon() {
                return getTarget().icon;
            },
            get id() {
                return getTarget().id;
            },
            get name() {
                return getTarget().name;
            },
            type: injected.type,
            async setup() {
                const provider = await this.getProvider();
                // Only start listening for events if `target` is set, otherwise `injected()` will also receive events
                if (provider && parameters.target)
                    provider.on('connect', this.onConnect.bind(this));
            },
            async connect({ chainId, isReconnecting } = {}) {
                const provider = await this.getProvider();
                if (!provider)
                    throw new ProviderNotFoundError();
                let accounts = null;
                if (!isReconnecting) {
                    accounts = await this.getAccounts().catch(() => null);
                    // Attempt to show another prompt for selecting account if already connected and `shimDisconnect` flag is enabled
                    const isAuthorized = shimDisconnect && !!accounts?.length;
                    if (isAuthorized)
                        try {
                            const permissions = await provider.request({
                                method: 'wallet_requestPermissions',
                                params: [{ eth_accounts: {} }],
                            });
                            accounts = permissions[0]?.caveats?.[0]?.value?.map((x) => getAddress(x));
                        }
                        catch (err) {
                            const error = err;
                            // Not all injected providers support `wallet_requestPermissions` (e.g. MetaMask iOS).
                            // Only bubble up error if user rejects request
                            if (error.code === UserRejectedRequestError.code)
                                throw new UserRejectedRequestError(error);
                            // Or prompt is already open
                            if (error.code === ResourceUnavailableRpcError.code)
                                throw error;
                        }
                }
                try {
                    if (!accounts?.length) {
                        const requestedAccounts = await provider.request({
                            method: 'eth_requestAccounts',
                        });
                        accounts = requestedAccounts.map((x) => getAddress(x));
                    }
                    provider.removeListener('connect', this.onConnect.bind(this));
                    provider.on('accountsChanged', this.onAccountsChanged.bind(this));
                    provider.on('chainChanged', this.onChainChanged);
                    provider.on('disconnect', this.onDisconnect.bind(this));
                    // Switch to chain if provided
                    let currentChainId = await this.getChainId();
                    if (chainId && currentChainId !== chainId) {
                        const chain = await this.switchChain({ chainId }).catch((error) => {
                            if (error.code === UserRejectedRequestError.code)
                                throw error;
                            return { id: currentChainId };
                        });
                        currentChainId = chain?.id ?? currentChainId;
                    }
                    if (shimDisconnect) {
                        // Remove disconnected shim if it exists
                        await config.storage?.removeItem(`${this.id}.disconnected`);
                        // Add connected shim if no target exists
                        if (!parameters.target)
                            await config.storage?.setItem('injected.connected', true);
                    }
                    return { accounts, chainId: currentChainId };
                }
                catch (err) {
                    const error = err;
                    if (error.code === UserRejectedRequestError.code)
                        throw new UserRejectedRequestError(error);
                    if (error.code === ResourceUnavailableRpcError.code)
                        throw new ResourceUnavailableRpcError(error);
                    throw error;
                }
            },
            async disconnect() {
                const provider = await this.getProvider();
                if (!provider)
                    throw new ProviderNotFoundError();
                provider.removeListener('accountsChanged', this.onAccountsChanged.bind(this));
                provider.removeListener('chainChanged', this.onChainChanged);
                provider.removeListener('disconnect', this.onDisconnect.bind(this));
                provider.on('connect', this.onConnect.bind(this));
                // Add shim signalling connector is disconnected
                if (shimDisconnect) {
                    await config.storage?.setItem(`${this.id}.disconnected`, true);
                    if (!parameters.target)
                        await config.storage?.removeItem('injected.connected');
                }
            },
            async getAccounts() {
                const provider = await this.getProvider();
                if (!provider)
                    throw new ProviderNotFoundError();
                const accounts = await provider.request({ method: 'eth_accounts' });
                return accounts.map((x) => getAddress(x));
            },
            async getChainId() {
                const provider = await this.getProvider();
                if (!provider)
                    throw new ProviderNotFoundError();
                const hexChainId = await provider.request({ method: 'eth_chainId' });
                return Number(hexChainId);
            },
            async getProvider() {
                if (typeof window === 'undefined')
                    return undefined;
                let provider;
                const target = getTarget();
                if (typeof target.provider === 'function')
                    provider = target.provider(window);
                else if (typeof target.provider === 'string')
                    provider = findProvider(window, target.provider);
                else
                    provider = target.provider;
                // Some wallets do not conform to EIP-1193 (e.g. Trust Wallet)
                // https://github.com/wevm/wagmi/issues/3526#issuecomment-1912683002
                if (provider && !provider.removeListener) {
                    // Try using `off` handler if it exists, otherwise noop
                    if ('off' in provider && typeof provider.off === 'function')
                        provider.removeListener =
                            provider.off;
                    else
                        provider.removeListener = () => { };
                }
                return provider;
            },
            async isAuthorized() {
                try {
                    const isDisconnected = shimDisconnect &&
                        // If shim exists in storage, connector is disconnected
                        (await config.storage?.getItem(`${this.id}.disconnected`));
                    if (isDisconnected)
                        return false;
                    // Don't allow injected connector to connect if no target is set and it hasn't already connected
                    // (e.g. flag in storage is not set). This prevents a targetless injected connector from connecting
                    // automatically whenever there is a targeted connector configured.
                    if (!parameters.target) {
                        const connected = await config.storage?.getItem('injected.connected');
                        if (!connected)
                            return false;
                    }
                    const provider = await this.getProvider();
                    if (!provider) {
                        if (unstable_shimAsyncInject !== undefined &&
                            unstable_shimAsyncInject !== false) {
                            // If no provider is found, check for async injection
                            // https://github.com/wevm/references/issues/167
                            // https://github.com/MetaMask/detect-provider
                            const handleEthereum = async () => {
                                if (typeof window !== 'undefined')
                                    window.removeEventListener('ethereum#initialized', handleEthereum);
                                const provider = await this.getProvider();
                                return !!provider;
                            };
                            const timeout = typeof unstable_shimAsyncInject === 'number'
                                ? unstable_shimAsyncInject
                                : 1_000;
                            const res = await Promise.race([
                                ...(typeof window !== 'undefined'
                                    ? [
                                        new Promise((resolve) => window.addEventListener('ethereum#initialized', () => resolve(handleEthereum()), { once: true })),
                                    ]
                                    : []),
                                new Promise((resolve) => setTimeout(() => resolve(handleEthereum()), timeout)),
                            ]);
                            if (res)
                                return true;
                        }
                        throw new ProviderNotFoundError();
                    }
                    // We are applying a retry & timeout strategy here as some injected wallets (e.g. MetaMask) fail to
                    // immediately resolve a JSON-RPC request on page load.
                    const accounts = await withRetry(() => withTimeout$2(() => this.getAccounts(), {
                        timeout: 100,
                    }));
                    return !!accounts.length;
                }
                catch {
                    return false;
                }
            },
            async switchChain({ chainId }) {
                const provider = await this.getProvider();
                if (!provider)
                    throw new ProviderNotFoundError();
                const chain = config.chains.find((x) => x.id === chainId);
                if (!chain)
                    throw new SwitchChainError(new ChainNotConfiguredError());
                try {
                    await Promise.all([
                        provider.request({
                            method: 'wallet_switchEthereumChain',
                            params: [{ chainId: numberToHex$1(chainId) }],
                        }),
                        new Promise((resolve) => config.emitter.once('change', ({ chainId: currentChainId }) => {
                            if (currentChainId === chainId)
                                resolve();
                        })),
                    ]);
                    return chain;
                }
                catch (err) {
                    const error = err;
                    // Indicates chain is not added to provider
                    if (error.code === 4902 ||
                        // Unwrapping for MetaMask Mobile
                        // https://github.com/MetaMask/metamask-mobile/issues/2944#issuecomment-976988719
                        error
                            ?.data?.originalError?.code === 4902) {
                        try {
                            const { default: blockExplorer, ...blockExplorers } = chain.blockExplorers ?? {};
                            let blockExplorerUrls;
                            if (blockExplorer)
                                blockExplorerUrls = [
                                    blockExplorer.url,
                                    ...Object.values(blockExplorers).map((x) => x.url),
                                ];
                            await provider.request({
                                method: 'wallet_addEthereumChain',
                                params: [
                                    {
                                        chainId: numberToHex$1(chainId),
                                        chainName: chain.name,
                                        nativeCurrency: chain.nativeCurrency,
                                        rpcUrls: [chain.rpcUrls.default?.http[0] ?? ''],
                                        blockExplorerUrls,
                                    },
                                ],
                            });
                            const currentChainId = await this.getChainId();
                            if (currentChainId !== chainId)
                                throw new UserRejectedRequestError(new Error('User rejected switch after adding network.'));
                            return chain;
                        }
                        catch (error) {
                            throw new UserRejectedRequestError(error);
                        }
                    }
                    if (error.code === UserRejectedRequestError.code)
                        throw new UserRejectedRequestError(error);
                    throw new SwitchChainError(error);
                }
            },
            async onAccountsChanged(accounts) {
                // Disconnect if there are no accounts
                if (accounts.length === 0)
                    this.onDisconnect();
                // Connect if emitter is listening for connect event (e.g. is disconnected and connects through wallet interface)
                else if (config.emitter.listenerCount('connect')) {
                    const chainId = (await this.getChainId()).toString();
                    this.onConnect({ chainId });
                    // Remove disconnected shim if it exists
                    if (shimDisconnect)
                        await config.storage?.removeItem(`${this.id}.disconnected`);
                }
                // Regular change event
                else
                    config.emitter.emit('change', {
                        accounts: accounts.map((x) => getAddress(x)),
                    });
            },
            onChainChanged(chain) {
                const chainId = Number(chain);
                config.emitter.emit('change', { chainId });
            },
            async onConnect(connectInfo) {
                const accounts = await this.getAccounts();
                if (accounts.length === 0)
                    return;
                const chainId = Number(connectInfo.chainId);
                config.emitter.emit('connect', { accounts, chainId });
                const provider = await this.getProvider();
                if (provider) {
                    provider.removeListener('connect', this.onConnect.bind(this));
                    provider.on('accountsChanged', this.onAccountsChanged.bind(this));
                    provider.on('chainChanged', this.onChainChanged);
                    provider.on('disconnect', this.onDisconnect.bind(this));
                }
            },
            async onDisconnect(error) {
                const provider = await this.getProvider();
                // If MetaMask emits a `code: 1013` error, wait for reconnection before disconnecting
                // https://github.com/MetaMask/providers/pull/120
                if (error && error.code === 1013) {
                    if (provider && !!(await this.getAccounts()).length)
                        return;
                }
                // No need to remove `${this.id}.disconnected` from storage because `onDisconnect` is typically
                // only called when the wallet is disconnected through the wallet's interface, meaning the wallet
                // actually disconnected and we don't need to simulate it.
                config.emitter.emit('disconnect');
                if (provider) {
                    provider.removeListener('accountsChanged', this.onAccountsChanged.bind(this));
                    provider.removeListener('chainChanged', this.onChainChanged);
                    provider.removeListener('disconnect', this.onDisconnect.bind(this));
                    provider.on('connect', this.onConnect.bind(this));
                }
            },
        }));
    }
    function findProvider(window, select) {
        function isProvider(provider) {
            if (typeof select === 'function')
                return select(provider);
            if (typeof select === 'string')
                return provider[select];
            return true;
        }
        const ethereum = window.ethereum;
        if (ethereum?.providers)
            return ethereum.providers.find((provider) => isProvider(provider));
        if (ethereum && isProvider(ethereum))
            return ethereum;
        return undefined;
    }

    const size$1 = 256;
    let index$7 = size$1;
    let buffer;
    function uid(length = 11) {
        if (!buffer || index$7 + length > size$1 * 2) {
            buffer = '';
            index$7 = 0;
            for (let i = 0; i < size$1; i++) {
                buffer += ((256 + Math.random() * 256) | 0).toString(16).substring(1);
            }
        }
        return buffer.substring(index$7, index$7++ + length);
    }

    function createConfig(parameters) {
        const { multiInjectedProviderDiscovery = true, storage = createStorage({
            storage: typeof window !== 'undefined' && window.localStorage
                ? window.localStorage
                : noopStorage,
        }), syncConnectedChain = true, ssr, ...rest } = parameters;
        /////////////////////////////////////////////////////////////////////////////////////////////////
        // Set up connectors, clients, etc.
        /////////////////////////////////////////////////////////////////////////////////////////////////
        const mipd = typeof window !== 'undefined' && multiInjectedProviderDiscovery
            ? createStore$1()
            : undefined;
        const chains = createStore(() => rest.chains);
        const connectors = createStore(() => [
            ...(rest.connectors ?? []),
            ...(!ssr
                ? mipd?.getProviders().map(providerDetailToConnector) ?? []
                : []),
        ].map(setup));
        function setup(connectorFn) {
            // Set up emitter with uid and add to connector so they are "linked" together.
            const emitter = createEmitter(uid());
            const connector = {
                ...connectorFn({ emitter, chains: chains.getState(), storage }),
                emitter,
                uid: emitter.uid,
            };
            // Start listening for `connect` events on connector setup
            // This allows connectors to "connect" themselves without user interaction (e.g. MetaMask's "Manually connect to current site")
            emitter.on('connect', connect);
            connector.setup?.();
            return connector;
        }
        function providerDetailToConnector(providerDetail) {
            const { info } = providerDetail;
            const provider = providerDetail.provider;
            return injected({ target: { ...info, id: info.rdns, provider } });
        }
        const clients = new Map();
        function getClient(config = {}) {
            const chainId = config.chainId ?? store.getState().chainId;
            const chain = chains.getState().find((x) => x.id === chainId);
            // chainId specified and not configured
            if (config.chainId && !chain)
                throw new ChainNotConfiguredError();
            {
                const client = clients.get(store.getState().chainId);
                if (client && !chain)
                    return client;
                else if (!chain)
                    throw new ChainNotConfiguredError();
            }
            // If a memoized client exists for a chain id, use that.
            {
                const client = clients.get(chainId);
                if (client)
                    return client;
            }
            let client;
            if (rest.client)
                client = rest.client({ chain });
            else {
                const chainId = chain.id;
                const chainIds = chains.getState().map((x) => x.id);
                // Grab all properties off `rest` and resolve for use in `createClient`
                const properties = {};
                const entries = Object.entries(rest);
                for (const [key, value] of entries) {
                    if (key === 'chains' ||
                        key === 'client' ||
                        key === 'connectors' ||
                        key === 'transports')
                        continue;
                    else {
                        if (typeof value === 'object') {
                            // check if value is chainId-specific since some values can be objects
                            // e.g. { batch: { multicall: { batchSize: 1024 } } }
                            if (chainId in value)
                                properties[key] = value[chainId];
                            else {
                                // check if value is chainId-specific, but does not have value for current chainId
                                const hasChainSpecificValue = chainIds.some((x) => x in value);
                                if (hasChainSpecificValue)
                                    continue;
                                properties[key] = value;
                            }
                        }
                        else
                            properties[key] = value;
                    }
                }
                client = createClient({
                    ...properties,
                    chain,
                    batch: properties.batch ?? { multicall: true },
                    transport: (parameters) => rest.transports[chainId]({ ...parameters, connectors }),
                });
            }
            clients.set(chainId, client);
            return client;
        }
        /////////////////////////////////////////////////////////////////////////////////////////////////
        // Create store
        /////////////////////////////////////////////////////////////////////////////////////////////////
        function getInitialState() {
            return {
                chainId: chains.getState()[0].id,
                connections: new Map(),
                current: undefined,
                status: 'disconnected',
            };
        }
        let currentVersion;
        const prefix = '0.0.0-canary-';
        if (version$2.startsWith(prefix))
            currentVersion = parseInt(version$2.replace(prefix, ''));
        else
            currentVersion = parseInt(version$2.split('.')[0] ?? '0');
        const store = createStore(subscribeWithSelector(
        // only use persist middleware if storage exists
        storage
            ? persist(getInitialState, {
                migrate(persistedState, version) {
                    if (version === currentVersion)
                        return persistedState;
                    const initialState = getInitialState();
                    const chainId = persistedState &&
                        typeof persistedState === 'object' &&
                        'chainId' in persistedState &&
                        typeof persistedState.chainId === 'number'
                        ? persistedState.chainId
                        : initialState.chainId;
                    return { ...initialState, chainId };
                },
                name: 'store',
                partialize(state) {
                    // Only persist "critical" store properties to preserve storage size.
                    return {
                        connections: {
                            __type: 'Map',
                            value: Array.from(state.connections.entries()).map(([key, connection]) => {
                                const { id, name, type, uid } = connection.connector;
                                const connector = { id, name, type, uid };
                                return [key, { ...connection, connector }];
                            }),
                        },
                        chainId: state.chainId,
                        current: state.current,
                    };
                },
                skipHydration: ssr,
                storage: storage,
                version: currentVersion,
            })
            : getInitialState));
        /////////////////////////////////////////////////////////////////////////////////////////////////
        // Subscribe to changes
        /////////////////////////////////////////////////////////////////////////////////////////////////
        // Update default chain when connector chain changes
        if (syncConnectedChain)
            store.subscribe(({ connections, current }) => current ? connections.get(current)?.chainId : undefined, (chainId) => {
                // If chain is not configured, then don't switch over to it.
                const isChainConfigured = chains
                    .getState()
                    .some((x) => x.id === chainId);
                if (!isChainConfigured)
                    return;
                return store.setState((x) => ({
                    ...x,
                    chainId: chainId ?? x.chainId,
                }));
            });
        // EIP-6963 subscribe for new wallet providers
        mipd?.subscribe((providerDetails) => {
            const currentConnectorIds = new Map();
            for (const connector of connectors.getState()) {
                currentConnectorIds.set(connector.id, true);
            }
            const newConnectors = [];
            for (const providerDetail of providerDetails) {
                const connector = setup(providerDetailToConnector(providerDetail));
                if (currentConnectorIds.has(connector.id))
                    continue;
                newConnectors.push(connector);
            }
            if (parameters.storage && !store.persist.hasHydrated())
                return;
            connectors.setState((x) => [...x, ...newConnectors], true);
        });
        /////////////////////////////////////////////////////////////////////////////////////////////////
        // Emitter listeners
        /////////////////////////////////////////////////////////////////////////////////////////////////
        function change(data) {
            store.setState((x) => {
                const connection = x.connections.get(data.uid);
                if (!connection)
                    return x;
                return {
                    ...x,
                    connections: new Map(x.connections).set(data.uid, {
                        accounts: data.accounts ??
                            connection.accounts,
                        chainId: data.chainId ?? connection.chainId,
                        connector: connection.connector,
                    }),
                };
            });
        }
        function connect(data) {
            // Disable handling if reconnecting/connecting
            if (store.getState().status === 'connecting' ||
                store.getState().status === 'reconnecting')
                return;
            store.setState((x) => {
                const connector = connectors.getState().find((x) => x.uid === data.uid);
                if (!connector)
                    return x;
                return {
                    ...x,
                    connections: new Map(x.connections).set(data.uid, {
                        accounts: data.accounts,
                        chainId: data.chainId,
                        connector: connector,
                    }),
                    current: data.uid,
                    status: 'connected',
                };
            });
        }
        function disconnect(data) {
            store.setState((x) => {
                const connection = x.connections.get(data.uid);
                if (connection) {
                    connection.connector.emitter.off('change', change);
                    connection.connector.emitter.off('disconnect', disconnect);
                    connection.connector.emitter.on('connect', connect);
                }
                x.connections.delete(data.uid);
                if (x.connections.size === 0)
                    return {
                        ...x,
                        connections: new Map(),
                        current: undefined,
                        status: 'disconnected',
                    };
                const nextConnection = x.connections.values().next().value;
                return {
                    ...x,
                    connections: new Map(x.connections),
                    current: nextConnection.connector.uid,
                };
            });
        }
        return {
            get chains() {
                return chains.getState();
            },
            get connectors() {
                return connectors.getState();
            },
            storage,
            getClient,
            get state() {
                return store.getState();
            },
            setState(value) {
                let newState;
                if (typeof value === 'function')
                    newState = value(store.getState());
                else
                    newState = value;
                // Reset state if it got set to something not matching the base state
                const initialState = getInitialState();
                if (typeof newState !== 'object')
                    newState = initialState;
                const isCorrupt = Object.keys(initialState).some((x) => !(x in newState));
                if (isCorrupt)
                    newState = initialState;
                store.setState(newState, true);
            },
            subscribe(selector, listener, options) {
                return store.subscribe(selector, listener, options
                    ? { ...options, fireImmediately: options.emitImmediately }
                    : undefined);
            },
            _internal: {
                mipd,
                store,
                ssr: Boolean(ssr),
                syncConnectedChain,
                transports: rest.transports,
                chains: {
                    setState(value) {
                        const nextChains = (typeof value === 'function' ? value(chains.getState()) : value);
                        if (nextChains.length === 0)
                            return;
                        return chains.setState(nextChains, true);
                    },
                    subscribe(listener) {
                        return chains.subscribe(listener);
                    },
                },
                connectors: {
                    providerDetailToConnector,
                    setup,
                    setState(value) {
                        return connectors.setState(typeof value === 'function' ? value(connectors.getState()) : value, true);
                    },
                    subscribe(listener) {
                        return connectors.subscribe(listener);
                    },
                },
                events: { change, connect, disconnect },
            },
        };
    }

    /**
     * Retrieves and returns an action from the client (if exists), and falls
     * back to the tree-shakable action.
     *
     * Useful for extracting overridden actions from a client (ie. if a consumer
     * wants to override the `sendTransaction` implementation).
     */
    function getAction(client, actionFn, 
    // Some minifiers drop `Function.prototype.name`, or replace it with short letters,
    // meaning that `actionFn.name` will not always work. For that case, the consumer
    // needs to pass the name explicitly.
    name) {
        const action_implicit = client[actionFn.name];
        if (typeof action_implicit === 'function')
            return action_implicit;
        const action_explicit = client[name];
        if (typeof action_explicit === 'function')
            return action_explicit;
        return (params) => actionFn(client, params);
    }

    /** https://wagmi.sh/core/api/actions/connect */
    async function connect(config, parameters) {
        // "Register" connector if not already created
        let connector;
        if (typeof parameters.connector === 'function') {
            connector = config._internal.connectors.setup(parameters.connector);
        }
        else
            connector = parameters.connector;
        // Check if connector is already connected
        if (connector.uid === config.state.current)
            throw new ConnectorAlreadyConnectedError();
        try {
            config.setState((x) => ({ ...x, status: 'connecting' }));
            connector.emitter.emit('message', { type: 'connecting' });
            const data = await connector.connect({ chainId: parameters.chainId });
            const accounts = data.accounts;
            connector.emitter.off('connect', config._internal.events.connect);
            connector.emitter.on('change', config._internal.events.change);
            connector.emitter.on('disconnect', config._internal.events.disconnect);
            await config.storage?.setItem('recentConnectorId', connector.id);
            config.setState((x) => ({
                ...x,
                connections: new Map(x.connections).set(connector.uid, {
                    accounts,
                    chainId: data.chainId,
                    connector: connector,
                }),
                current: connector.uid,
                status: 'connected',
            }));
            return { accounts, chainId: data.chainId };
        }
        catch (error) {
            config.setState((x) => ({
                ...x,
                // Keep existing connector connected in case of error
                status: x.current ? 'connected' : 'disconnected',
            }));
            throw error;
        }
    }

    /** https://wagmi.sh/core/api/actions/disconnect */
    async function disconnect(config, parameters = {}) {
        let connector;
        if (parameters.connector)
            connector = parameters.connector;
        else {
            const { connections, current } = config.state;
            const connection = connections.get(current);
            connector = connection?.connector;
        }
        const connections = config.state.connections;
        if (connector) {
            await connector.disconnect();
            connector.emitter.off('change', config._internal.events.change);
            connector.emitter.off('disconnect', config._internal.events.disconnect);
            connector.emitter.on('connect', config._internal.events.connect);
            connections.delete(connector.uid);
        }
        config.setState((x) => {
            // if no connections exist, move to disconnected state
            if (connections.size === 0)
                return {
                    ...x,
                    connections: new Map(),
                    current: undefined,
                    status: 'disconnected',
                };
            // switch over to another connection
            const nextConnection = connections.values().next().value;
            return {
                ...x,
                connections: new Map(connections),
                current: nextConnection.connector.uid,
            };
        });
        // Set recent connector if exists
        {
            const current = config.state.current;
            if (!current)
                return;
            const connector = config.state.connections.get(current)?.connector;
            if (!connector)
                return;
            await config.storage?.setItem('recentConnectorId', connector.id);
        }
    }

    /** https://wagmi.sh/core/api/actions/getConnectorClient */
    async function getConnectorClient(config, parameters = {}) {
        // Get connection
        let connection;
        if (parameters.connector) {
            const { connector } = parameters;
            const [accounts, chainId] = await Promise.all([
                connector.getAccounts(),
                connector.getChainId(),
            ]);
            connection = {
                accounts: accounts,
                chainId,
                connector,
            };
        }
        else
            connection = config.state.connections.get(config.state.current);
        if (!connection)
            throw new ConnectorNotConnectedError();
        const chainId = parameters.chainId ?? connection.chainId;
        const connector = connection.connector;
        if (connector.getClient)
            return connector.getClient({ chainId: chainId });
        // Default using `custom` transport
        const account = parseAccount(parameters.account ?? connection.accounts[0]);
        account.address = getAddress(account.address); // TODO: Checksum address as part of `parseAccount`?
        const chain = config.chains.find((chain) => chain.id === chainId);
        const provider = (await connection.connector.getProvider({ chainId }));
        // if account was provided, check that it exists on the connector
        if (parameters.account && !connection.accounts.includes(account.address))
            throw new ConnectorAccountNotFoundError({
                address: account.address,
                connector,
            });
        return createClient({
            account,
            chain,
            name: 'Connector Client',
            transport: (opts) => custom$1(provider)({ ...opts, retryCount: 0 }),
        });
    }

    function getUnit(unit) {
        if (typeof unit === 'number')
            return unit;
        if (unit === 'wei')
            return 0;
        return Math.abs(weiUnits[unit]);
    }

    /** https://wagmi.sh/core/api/actions/getAccount */
    function getAccount(config) {
        const uid = config.state.current;
        const connection = config.state.connections.get(uid);
        const addresses = connection?.accounts;
        const address = addresses?.[0];
        const chain = config.chains.find((chain) => chain.id === connection?.chainId);
        const status = config.state.status;
        switch (status) {
            case 'connected':
                return {
                    address: address,
                    addresses: addresses,
                    chain,
                    chainId: connection?.chainId,
                    connector: connection?.connector,
                    isConnected: true,
                    isConnecting: false,
                    isDisconnected: false,
                    isReconnecting: false,
                    status,
                };
            case 'reconnecting':
                return {
                    address,
                    addresses,
                    chain,
                    chainId: connection?.chainId,
                    connector: connection?.connector,
                    isConnected: !!address,
                    isConnecting: false,
                    isDisconnected: false,
                    isReconnecting: true,
                    status,
                };
            case 'connecting':
                return {
                    address,
                    addresses,
                    chain,
                    chainId: connection?.chainId,
                    connector: connection?.connector,
                    isConnected: false,
                    isConnecting: true,
                    isDisconnected: false,
                    isReconnecting: false,
                    status,
                };
            case 'disconnected':
                return {
                    address: undefined,
                    addresses: undefined,
                    chain: undefined,
                    chainId: undefined,
                    connector: undefined,
                    isConnected: false,
                    isConnecting: false,
                    isDisconnected: true,
                    isReconnecting: false,
                    status,
                };
        }
    }

    async function multicall(config, parameters) {
        const { allowFailure = true, chainId, contracts, ...rest } = parameters;
        const client = config.getClient({ chainId });
        const action = getAction(client, multicall$1, 'multicall');
        return action({
            allowFailure,
            contracts,
            ...rest,
        });
    }

    /** https://wagmi.sh/core/api/actions/readContract */
    function readContract(config, parameters) {
        const { chainId, ...rest } = parameters;
        const client = config.getClient({ chainId });
        const action = getAction(client, readContract$1, 'readContract');
        return action(rest);
    }

    async function readContracts(config, parameters) {
        const { allowFailure = true, blockNumber, blockTag, ...rest } = parameters;
        const contracts = parameters.contracts;
        try {
            const contractsByChainId = contracts.reduce((contracts, contract, index) => {
                const chainId = contract.chainId ?? config.state.chainId;
                return {
                    ...contracts,
                    [chainId]: [...(contracts[chainId] || []), { contract, index }],
                };
            }, {});
            const promises = () => Object.entries(contractsByChainId).map(([chainId, contracts]) => multicall(config, {
                ...rest,
                allowFailure,
                blockNumber,
                blockTag,
                chainId: parseInt(chainId),
                contracts: contracts.map(({ contract }) => contract),
            }));
            const multicallResults = (await Promise.all(promises())).flat();
            // Reorder the contract results back to the order they were
            // provided in.
            const resultIndexes = Object.values(contractsByChainId).flatMap((contracts) => contracts.map(({ index }) => index));
            return multicallResults.reduce((results, result, index) => {
                if (results)
                    results[resultIndexes[index]] = result;
                return results;
            }, []);
        }
        catch (error) {
            if (error instanceof ContractFunctionExecutionError)
                throw error;
            const promises = () => contracts.map((contract) => readContract(config, { ...contract, blockNumber, blockTag }));
            if (allowFailure)
                return (await Promise.allSettled(promises())).map((result) => {
                    if (result.status === 'fulfilled')
                        return { result: result.value, status: 'success' };
                    return { error: result.reason, result: undefined, status: 'failure' };
                });
            return (await Promise.all(promises()));
        }
    }

    /** https://wagmi.sh/core/api/actions/getBalance */
    async function getBalance(config, parameters) {
        const { address, blockNumber, blockTag, chainId, token: tokenAddress, unit = 'ether', } = parameters;
        if (tokenAddress) {
            try {
                return getTokenBalance(config, {
                    balanceAddress: address,
                    chainId,
                    symbolType: 'string',
                    tokenAddress,
                });
            }
            catch (error) {
                // In the chance that there is an error upon decoding the contract result,
                // it could be likely that the contract data is represented as bytes32 instead
                // of a string.
                if (error instanceof ContractFunctionExecutionError) {
                    const balance = await getTokenBalance(config, {
                        balanceAddress: address,
                        chainId,
                        symbolType: 'bytes32',
                        tokenAddress,
                    });
                    const symbol = hexToString(trim(balance.symbol, { dir: 'right' }));
                    return { ...balance, symbol };
                }
                throw error;
            }
        }
        const client = config.getClient({ chainId });
        const action = getAction(client, getBalance$1, 'getBalance');
        const value = await action(blockNumber ? { address, blockNumber } : { address, blockTag });
        const chain = config.chains.find((x) => x.id === chainId) ?? client.chain;
        return {
            decimals: chain.nativeCurrency.decimals,
            formatted: formatUnits(value, getUnit(unit)),
            symbol: chain.nativeCurrency.symbol,
            value,
        };
    }
    async function getTokenBalance(config, parameters) {
        const { balanceAddress, chainId, symbolType, tokenAddress, unit } = parameters;
        const contract = {
            abi: [
                {
                    type: 'function',
                    name: 'balanceOf',
                    stateMutability: 'view',
                    inputs: [{ type: 'address' }],
                    outputs: [{ type: 'uint256' }],
                },
                {
                    type: 'function',
                    name: 'decimals',
                    stateMutability: 'view',
                    inputs: [],
                    outputs: [{ type: 'uint8' }],
                },
                {
                    type: 'function',
                    name: 'symbol',
                    stateMutability: 'view',
                    inputs: [],
                    outputs: [{ type: symbolType }],
                },
            ],
            address: tokenAddress,
        };
        const [value, decimals, symbol] = await readContracts(config, {
            allowFailure: false,
            contracts: [
                {
                    ...contract,
                    functionName: 'balanceOf',
                    args: [balanceAddress],
                    chainId,
                },
                { ...contract, functionName: 'decimals', chainId },
                { ...contract, functionName: 'symbol', chainId },
            ],
        });
        const formatted = formatUnits(value ?? '0', getUnit(unit ?? decimals));
        return { decimals, formatted, symbol, value };
    }

    /** Forked from https://github.com/epoberezkin/fast-deep-equal */
    function deepEqual(a, b) {
        if (a === b)
            return true;
        if (a && b && typeof a === 'object' && typeof b === 'object') {
            if (a.constructor !== b.constructor)
                return false;
            let length;
            let i;
            if (Array.isArray(a) && Array.isArray(b)) {
                length = a.length;
                if (length !== b.length)
                    return false;
                for (i = length; i-- !== 0;)
                    if (!deepEqual(a[i], b[i]))
                        return false;
                return true;
            }
            if (a.valueOf !== Object.prototype.valueOf)
                return a.valueOf() === b.valueOf();
            if (a.toString !== Object.prototype.toString)
                return a.toString() === b.toString();
            const keys = Object.keys(a);
            length = keys.length;
            if (length !== Object.keys(b).length)
                return false;
            for (i = length; i-- !== 0;)
                if (!Object.prototype.hasOwnProperty.call(b, keys[i]))
                    return false;
            for (i = length; i-- !== 0;) {
                const key = keys[i];
                if (key && !deepEqual(a[key], b[key]))
                    return false;
            }
            return true;
        }
        // true if both NaN, false otherwise
        // biome-ignore lint/suspicious/noSelfCompare: <explanation>
        return a !== a && b !== b;
    }

    /** https://wagmi.sh/core/api/actions/getEnsAvatar */
    function getEnsAvatar(config, parameters) {
        const { chainId, ...rest } = parameters;
        const client = config.getClient({ chainId });
        const action = getAction(client, getEnsAvatar$1, 'getEnsAvatar');
        return action(rest);
    }

    /** https://wagmi.sh/core/api/actions/getEnsName */
    function getEnsName(config, parameters) {
        const { chainId, ...rest } = parameters;
        const client = config.getClient({ chainId });
        const action = getAction(client, getEnsName$1, 'getEnsName');
        return action(rest);
    }

    let isReconnecting = false;
    /** https://wagmi.sh/core/api/actions/reconnect */
    async function reconnect(config, parameters = {}) {
        // If already reconnecting, do nothing
        if (isReconnecting)
            return [];
        isReconnecting = true;
        config.setState((x) => ({
            ...x,
            status: x.current ? 'reconnecting' : 'connecting',
        }));
        const connectors = [];
        if (parameters.connectors?.length) {
            for (const connector_ of parameters.connectors) {
                let connector;
                // "Register" connector if not already created
                if (typeof connector_ === 'function')
                    connector = config._internal.connectors.setup(connector_);
                else
                    connector = connector_;
                connectors.push(connector);
            }
        }
        else
            connectors.push(...config.connectors);
        // Try recently-used connectors first
        let recentConnectorId;
        try {
            recentConnectorId = await config.storage?.getItem('recentConnectorId');
        }
        catch { }
        const scores = {};
        for (const [, connection] of config.state.connections) {
            scores[connection.connector.id] = 1;
        }
        if (recentConnectorId)
            scores[recentConnectorId] = 0;
        const sorted = Object.keys(scores).length > 0
            ? // .toSorted()
                [...connectors].sort((a, b) => (scores[a.id] ?? 10) - (scores[b.id] ?? 10))
            : connectors;
        // Iterate through each connector and try to connect
        let connected = false;
        const connections = [];
        const providers = [];
        for (const connector of sorted) {
            const provider_ = await connector.getProvider();
            if (!provider_)
                continue;
            // If we already have an instance of this connector's provider,
            // then we have already checked it (ie. injected connectors can
            // share the same `window.ethereum` instance, so we don't want to
            // connect to it again).
            if (providers.some((provider) => provider === provider_))
                continue;
            const isAuthorized = await connector.isAuthorized();
            if (!isAuthorized)
                continue;
            const data = await connector
                .connect({ isReconnecting: true })
                .catch(() => null);
            if (!data)
                continue;
            connector.emitter.off('connect', config._internal.events.connect);
            connector.emitter.on('change', config._internal.events.change);
            connector.emitter.on('disconnect', config._internal.events.disconnect);
            config.setState((x) => {
                const connections = new Map(connected ? x.connections : new Map()).set(connector.uid, { accounts: data.accounts, chainId: data.chainId, connector });
                return {
                    ...x,
                    current: connected ? x.current : connector.uid,
                    connections,
                };
            });
            connections.push({
                accounts: data.accounts,
                chainId: data.chainId,
                connector,
            });
            providers.push(provider_);
            connected = true;
        }
        // Prevent overwriting connected status from race condition
        if (config.state.status === 'reconnecting' ||
            config.state.status === 'connecting') {
            // If connecting didn't succeed, set to disconnected
            if (!connected)
                config.setState((x) => ({
                    ...x,
                    connections: new Map(),
                    current: undefined,
                    status: 'disconnected',
                }));
            else
                config.setState((x) => ({ ...x, status: 'connected' }));
        }
        isReconnecting = false;
        return connections;
    }

    /** https://wagmi.sh/core/api/actions/signMessage */
    async function signMessage(config, parameters) {
        const { account, connector, ...rest } = parameters;
        let client;
        if (typeof account === 'object' && account.type === 'local')
            client = config.getClient();
        else
            client = await getConnectorClient(config, { account, connector });
        const action = getAction(client, signMessage$1, 'signMessage');
        return action({
            ...rest,
            ...(account ? { account } : {}),
        });
    }

    /** https://wagmi.sh/core/api/actions/switchChain */
    async function switchChain(config, parameters) {
        const { chainId } = parameters;
        const connection = config.state.connections.get(parameters.connector?.uid ?? config.state.current);
        if (connection) {
            const connector = connection.connector;
            if (!connector.switchChain)
                throw new SwitchChainNotSupportedError({ connector });
            const chain = await connector.switchChain({ chainId });
            return chain;
        }
        const chain = config.chains.find((x) => x.id === chainId);
        if (!chain)
            throw new ChainNotConfiguredError();
        config.setState((x) => ({ ...x, chainId }));
        return chain;
    }

    /** https://wagmi.sh/core/api/actions/watchAccount */
    function watchAccount(config, parameters) {
        const { onChange } = parameters;
        return config.subscribe(() => getAccount(config), onChange, {
            equalityFn(a, b) {
                const { connector: aConnector, ...aRest } = a;
                const { connector: bConnector, ...bRest } = b;
                return (deepEqual(aRest, bRest) &&
                    // check connector separately
                    aConnector?.id === bConnector?.id &&
                    aConnector?.uid === bConnector?.uid);
            },
        });
    }

    /** https://wagmi.sh/core/api/actions/watchConnectors */
    function watchConnectors(config, parameters) {
        const { onChange } = parameters;
        return config._internal.connectors.subscribe((connectors, prevConnectors) => {
            onChange(Object.values(connectors), prevConnectors);
        });
    }

    /** @deprecated use `Number` instead */
    function normalizeChainId(chainId) {
        if (typeof chainId === 'string')
            return Number.parseInt(chainId, chainId.trim().substring(0, 2) === '0x' ? 16 : 10);
        if (typeof chainId === 'bigint')
            return Number(chainId);
        if (typeof chainId === 'number')
            return chainId;
        throw new Error(`Cannot normalize chainId "${chainId}" of type "${typeof chainId}"`);
    }

    const arbitrum = /*#__PURE__*/ defineChain({
        id: 42_161,
        name: 'Arbitrum One',
        nativeCurrency: { name: 'Ether', symbol: 'ETH', decimals: 18 },
        rpcUrls: {
            default: {
                http: ['https://arb1.arbitrum.io/rpc'],
            },
        },
        blockExplorers: {
            default: {
                name: 'Arbiscan',
                url: 'https://arbiscan.io',
                apiUrl: 'https://api.arbiscan.io/api',
            },
        },
        contracts: {
            multicall3: {
                address: '0xca11bde05977b3631167028862be2a173976ca11',
                blockCreated: 7654707,
            },
        },
    });

    const mainnet = /*#__PURE__*/ defineChain({
        id: 1,
        name: 'Ethereum',
        nativeCurrency: { name: 'Ether', symbol: 'ETH', decimals: 18 },
        rpcUrls: {
            default: {
                http: ['https://cloudflare-eth.com'],
            },
        },
        blockExplorers: {
            default: {
                name: 'Etherscan',
                url: 'https://etherscan.io',
                apiUrl: 'https://api.etherscan.io/api',
            },
        },
        contracts: {
            ensRegistry: {
                address: '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e',
            },
            ensUniversalResolver: {
                address: '0xce01f8eee7E479C928F8919abD53E553a36CeF67',
                blockCreated: 19_258_213,
            },
            multicall3: {
                address: '0xca11bde05977b3631167028862be2a173976ca11',
                blockCreated: 14_353_601,
            },
        },
    });

    const t$g=Symbol();const s$h=Object.getPrototypeOf,c$h=new WeakMap,l$c=e=>e&&(c$h.has(e)?c$h.get(e):s$h(e)===Object.prototype||s$h(e)===Array.prototype),y$a=e=>l$c(e)&&e[t$g]||null,h$f=(e,t=!0)=>{c$h.set(e,t);};

    const isObject$2 = (x) => typeof x === "object" && x !== null;
    const proxyStateMap = /* @__PURE__ */ new WeakMap();
    const refSet = /* @__PURE__ */ new WeakSet();
    const buildProxyFunction = (objectIs = Object.is, newProxy = (target, handler) => new Proxy(target, handler), canProxy = (x) => isObject$2(x) && !refSet.has(x) && (Array.isArray(x) || !(Symbol.iterator in x)) && !(x instanceof WeakMap) && !(x instanceof WeakSet) && !(x instanceof Error) && !(x instanceof Number) && !(x instanceof Date) && !(x instanceof String) && !(x instanceof RegExp) && !(x instanceof ArrayBuffer), defaultHandlePromise = (promise) => {
      switch (promise.status) {
        case "fulfilled":
          return promise.value;
        case "rejected":
          throw promise.reason;
        default:
          throw promise;
      }
    }, snapCache = /* @__PURE__ */ new WeakMap(), createSnapshot = (target, version, handlePromise = defaultHandlePromise) => {
      const cache = snapCache.get(target);
      if ((cache == null ? void 0 : cache[0]) === version) {
        return cache[1];
      }
      const snap = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));
      h$f(snap, true);
      snapCache.set(target, [version, snap]);
      Reflect.ownKeys(target).forEach((key) => {
        if (Object.getOwnPropertyDescriptor(snap, key)) {
          return;
        }
        const value = Reflect.get(target, key);
        const desc = {
          value,
          enumerable: true,
          // This is intentional to avoid copying with proxy-compare.
          // It's still non-writable, so it avoids assigning a value.
          configurable: true
        };
        if (refSet.has(value)) {
          h$f(value, false);
        } else if (value instanceof Promise) {
          delete desc.value;
          desc.get = () => handlePromise(value);
        } else if (proxyStateMap.has(value)) {
          const [target2, ensureVersion] = proxyStateMap.get(
            value
          );
          desc.value = createSnapshot(
            target2,
            ensureVersion(),
            handlePromise
          );
        }
        Object.defineProperty(snap, key, desc);
      });
      return Object.preventExtensions(snap);
    }, proxyCache = /* @__PURE__ */ new WeakMap(), versionHolder = [1, 1], proxyFunction = (initialObject) => {
      if (!isObject$2(initialObject)) {
        throw new Error("object required");
      }
      const found = proxyCache.get(initialObject);
      if (found) {
        return found;
      }
      let version = versionHolder[0];
      const listeners = /* @__PURE__ */ new Set();
      const notifyUpdate = (op, nextVersion = ++versionHolder[0]) => {
        if (version !== nextVersion) {
          version = nextVersion;
          listeners.forEach((listener) => listener(op, nextVersion));
        }
      };
      let checkVersion = versionHolder[1];
      const ensureVersion = (nextCheckVersion = ++versionHolder[1]) => {
        if (checkVersion !== nextCheckVersion && !listeners.size) {
          checkVersion = nextCheckVersion;
          propProxyStates.forEach(([propProxyState]) => {
            const propVersion = propProxyState[1](nextCheckVersion);
            if (propVersion > version) {
              version = propVersion;
            }
          });
        }
        return version;
      };
      const createPropListener = (prop) => (op, nextVersion) => {
        const newOp = [...op];
        newOp[1] = [prop, ...newOp[1]];
        notifyUpdate(newOp, nextVersion);
      };
      const propProxyStates = /* @__PURE__ */ new Map();
      const addPropListener = (prop, propProxyState) => {
        if ((undefined ? undefined.MODE : void 0) !== "production" && propProxyStates.has(prop)) {
          throw new Error("prop listener already exists");
        }
        if (listeners.size) {
          const remove = propProxyState[3](createPropListener(prop));
          propProxyStates.set(prop, [propProxyState, remove]);
        } else {
          propProxyStates.set(prop, [propProxyState]);
        }
      };
      const removePropListener = (prop) => {
        var _a;
        const entry = propProxyStates.get(prop);
        if (entry) {
          propProxyStates.delete(prop);
          (_a = entry[1]) == null ? void 0 : _a.call(entry);
        }
      };
      const addListener = (listener) => {
        listeners.add(listener);
        if (listeners.size === 1) {
          propProxyStates.forEach(([propProxyState, prevRemove], prop) => {
            if ((undefined ? undefined.MODE : void 0) !== "production" && prevRemove) {
              throw new Error("remove already exists");
            }
            const remove = propProxyState[3](createPropListener(prop));
            propProxyStates.set(prop, [propProxyState, remove]);
          });
        }
        const removeListener = () => {
          listeners.delete(listener);
          if (listeners.size === 0) {
            propProxyStates.forEach(([propProxyState, remove], prop) => {
              if (remove) {
                remove();
                propProxyStates.set(prop, [propProxyState]);
              }
            });
          }
        };
        return removeListener;
      };
      const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));
      const handler = {
        deleteProperty(target, prop) {
          const prevValue = Reflect.get(target, prop);
          removePropListener(prop);
          const deleted = Reflect.deleteProperty(target, prop);
          if (deleted) {
            notifyUpdate(["delete", [prop], prevValue]);
          }
          return deleted;
        },
        set(target, prop, value, receiver) {
          const hasPrevValue = Reflect.has(target, prop);
          const prevValue = Reflect.get(target, prop, receiver);
          if (hasPrevValue && (objectIs(prevValue, value) || proxyCache.has(value) && objectIs(prevValue, proxyCache.get(value)))) {
            return true;
          }
          removePropListener(prop);
          if (isObject$2(value)) {
            value = y$a(value) || value;
          }
          let nextValue = value;
          if (value instanceof Promise) {
            value.then((v) => {
              value.status = "fulfilled";
              value.value = v;
              notifyUpdate(["resolve", [prop], v]);
            }).catch((e) => {
              value.status = "rejected";
              value.reason = e;
              notifyUpdate(["reject", [prop], e]);
            });
          } else {
            if (!proxyStateMap.has(value) && canProxy(value)) {
              nextValue = proxyFunction(value);
            }
            const childProxyState = !refSet.has(nextValue) && proxyStateMap.get(nextValue);
            if (childProxyState) {
              addPropListener(prop, childProxyState);
            }
          }
          Reflect.set(target, prop, nextValue, receiver);
          notifyUpdate(["set", [prop], value, prevValue]);
          return true;
        }
      };
      const proxyObject = newProxy(baseObject, handler);
      proxyCache.set(initialObject, proxyObject);
      const proxyState = [
        baseObject,
        ensureVersion,
        createSnapshot,
        addListener
      ];
      proxyStateMap.set(proxyObject, proxyState);
      Reflect.ownKeys(initialObject).forEach((key) => {
        const desc = Object.getOwnPropertyDescriptor(
          initialObject,
          key
        );
        if ("value" in desc) {
          proxyObject[key] = initialObject[key];
          delete desc.value;
          delete desc.writable;
        }
        Object.defineProperty(baseObject, key, desc);
      });
      return proxyObject;
    }) => [
      // public functions
      proxyFunction,
      // shared state
      proxyStateMap,
      refSet,
      // internal things
      objectIs,
      newProxy,
      canProxy,
      defaultHandlePromise,
      snapCache,
      createSnapshot,
      proxyCache,
      versionHolder
    ];
    const [defaultProxyFunction] = buildProxyFunction();
    function proxy(initialObject = {}) {
      return defaultProxyFunction(initialObject);
    }
    function subscribe(proxyObject, callback, notifyInSync) {
      const proxyState = proxyStateMap.get(proxyObject);
      if ((undefined ? undefined.MODE : void 0) !== "production" && !proxyState) {
        console.warn("Please use proxy object");
      }
      let promise;
      const ops = [];
      const addListener = proxyState[3];
      let isListenerActive = false;
      const listener = (op) => {
        ops.push(op);
        if (notifyInSync) {
          callback(ops.splice(0));
          return;
        }
        if (!promise) {
          promise = Promise.resolve().then(() => {
            promise = void 0;
            if (isListenerActive) {
              callback(ops.splice(0));
            }
          });
        }
      };
      const removeListener = addListener(listener);
      isListenerActive = true;
      return () => {
        isListenerActive = false;
        removeListener();
      };
    }
    function snapshot(proxyObject, handlePromise) {
      const proxyState = proxyStateMap.get(proxyObject);
      if ((undefined ? undefined.MODE : void 0) !== "production" && !proxyState) {
        console.warn("Please use proxy object");
      }
      const [target, ensureVersion, createSnapshot] = proxyState;
      return createSnapshot(target, ensureVersion(), handlePromise);
    }
    function ref(obj) {
      refSet.add(obj);
      return obj;
    }

    function subscribeKey(proxyObject, key, callback, notifyInSync) {
      let prevValue = proxyObject[key];
      return subscribe(
        proxyObject,
        () => {
          const nextValue = proxyObject[key];
          if (!Object.is(prevValue, nextValue)) {
            callback(prevValue = nextValue);
          }
        },
        notifyInSync
      );
    }

    const SECURE_SITE = 'https://secure.walletconnect.com';
    const ONRAMP_PROVIDERS = [
        {
            label: 'Coinbase',
            name: 'coinbase',
            feeRange: '1-2%',
            url: ''
        }
    ];
    const ConstantsUtil$2 = {
        FOUR_MINUTES_MS: 240000,
        TEN_SEC_MS: 10000,
        ONE_SEC_MS: 1000,
        SECURE_SITE,
        SECURE_SITE_DASHBOARD: `${SECURE_SITE}/dashboard`,
        SECURE_SITE_FAVICON: `${SECURE_SITE}/images/favicon.png`,
        RESTRICTED_TIMEZONES: [
            'ASIA/SHANGHAI',
            'ASIA/URUMQI',
            'ASIA/CHONGQING',
            'ASIA/HARBIN',
            'ASIA/KASHGAR',
            'ASIA/MACAU',
            'ASIA/HONG_KONG',
            'ASIA/MACAO',
            'ASIA/BEIJING',
            'ASIA/HARBIN'
        ],
        CONNECTOR_RDNS_MAP: {
            coinbaseWallet: 'com.coinbase.wallet'
        },
        WC_COINBASE_PAY_SDK_CHAINS: [
            'ethereum',
            'arbitrum',
            'polygon',
            'avalanche-c-chain',
            'optimism',
            'celo',
            'base'
        ],
        WC_COINBASE_PAY_SDK_FALLBACK_CHAIN: 'ethereum',
        WC_COINBASE_PAY_SDK_CHAIN_NAME_MAP: {
            Ethereum: 'ethereum',
            'Arbitrum One': 'arbitrum',
            Polygon: 'polygon',
            Avalanche: 'avalanche-c-chain',
            'OP Mainnet': 'optimism',
            Celo: 'celo',
            Base: 'base'
        },
        WC_COINBASE_ONRAMP_APP_ID: 'bf18c88d-495a-463b-b249-0b9d3656cf5e'
    };

    const CoreHelperUtil = {
        isMobile() {
            if (typeof window !== 'undefined') {
                return Boolean(window.matchMedia('(pointer:coarse)').matches ||
                    /Android|webOS|iPhone|iPad|iPod|BlackBerry|Opera Mini/u.test(navigator.userAgent));
            }
            return false;
        },
        checkCaipNetwork(network, networkName = '') {
            return network?.id.toLocaleLowerCase().includes(networkName.toLowerCase());
        },
        isAndroid() {
            const ua = window.navigator.userAgent.toLowerCase();
            return CoreHelperUtil.isMobile() && ua.includes('android');
        },
        isIos() {
            const ua = window.navigator.userAgent.toLowerCase();
            return CoreHelperUtil.isMobile() && (ua.includes('iphone') || ua.includes('ipad'));
        },
        isClient() {
            return typeof window !== 'undefined';
        },
        isPairingExpired(expiry) {
            return expiry ? expiry - Date.now() <= ConstantsUtil$2.TEN_SEC_MS : true;
        },
        isAllowedRetry(lastRetry) {
            return Date.now() - lastRetry >= ConstantsUtil$2.ONE_SEC_MS;
        },
        copyToClopboard(text) {
            navigator.clipboard.writeText(text);
        },
        getPairingExpiry() {
            return Date.now() + ConstantsUtil$2.FOUR_MINUTES_MS;
        },
        getPlainAddress(caipAddress) {
            return caipAddress.split(':')[2];
        },
        async wait(milliseconds) {
            return new Promise(resolve => {
                setTimeout(resolve, milliseconds);
            });
        },
        debounce(func, timeout = 500) {
            let timer = undefined;
            return (...args) => {
                function next() {
                    func(...args);
                }
                if (timer) {
                    clearTimeout(timer);
                }
                timer = setTimeout(next, timeout);
            };
        },
        isHttpUrl(url) {
            return url.startsWith('http://') || url.startsWith('https://');
        },
        formatNativeUrl(appUrl, wcUri) {
            if (CoreHelperUtil.isHttpUrl(appUrl)) {
                return this.formatUniversalUrl(appUrl, wcUri);
            }
            let safeAppUrl = appUrl;
            if (!safeAppUrl.includes('://')) {
                safeAppUrl = appUrl.replaceAll('/', '').replaceAll(':', '');
                safeAppUrl = `${safeAppUrl}://`;
            }
            if (!safeAppUrl.endsWith('/')) {
                safeAppUrl = `${safeAppUrl}/`;
            }
            const encodedWcUrl = encodeURIComponent(wcUri);
            return {
                redirect: `${safeAppUrl}wc?uri=${encodedWcUrl}`,
                href: safeAppUrl
            };
        },
        formatUniversalUrl(appUrl, wcUri) {
            if (!CoreHelperUtil.isHttpUrl(appUrl)) {
                return this.formatNativeUrl(appUrl, wcUri);
            }
            let safeAppUrl = appUrl;
            if (!safeAppUrl.endsWith('/')) {
                safeAppUrl = `${safeAppUrl}/`;
            }
            const encodedWcUrl = encodeURIComponent(wcUri);
            return {
                redirect: `${safeAppUrl}wc?uri=${encodedWcUrl}`,
                href: safeAppUrl
            };
        },
        openHref(href, target, features) {
            window.open(href, target, features || 'noreferrer noopener');
        },
        async preloadImage(src) {
            const imagePromise = new Promise((resolve, reject) => {
                const image = new Image();
                image.onload = resolve;
                image.onerror = reject;
                image.crossOrigin = 'anonymous';
                image.src = src;
            });
            return Promise.race([imagePromise, CoreHelperUtil.wait(2000)]);
        },
        formatBalance(balance, symbol) {
            let formattedBalance = undefined;
            if (balance === '0') {
                formattedBalance = '0.000';
            }
            else if (typeof balance === 'string') {
                const number = Number(balance);
                if (number) {
                    formattedBalance = number.toString().match(/^-?\d+(?:\.\d{0,3})?/u)?.[0];
                }
            }
            return formattedBalance ? `${formattedBalance} ${symbol ?? ''}` : `0.000 ${symbol ?? ''}`;
        },
        formatBalance2(balance, symbol) {
            let formattedBalance = undefined;
            if (balance === '0') {
                formattedBalance = '0';
            }
            else if (typeof balance === 'string') {
                const number = Number(balance);
                if (number) {
                    formattedBalance = number.toString().match(/^-?\d+(?:\.\d{0,3})?/u)?.[0];
                }
            }
            return {
                value: formattedBalance ?? '0',
                rest: formattedBalance === '0' ? '000' : '',
                symbol
            };
        },
        isRestrictedRegion() {
            try {
                const { timeZone } = new Intl.DateTimeFormat().resolvedOptions();
                const capTimeZone = timeZone.toUpperCase();
                return ConstantsUtil$2.RESTRICTED_TIMEZONES.includes(capTimeZone);
            }
            catch {
                return false;
            }
        },
        getApiUrl() {
            return CoreHelperUtil.isRestrictedRegion()
                ? 'https://api.web3modal.org'
                : 'https://api.web3modal.com';
        },
        getBlockchainApiUrl() {
            return CoreHelperUtil.isRestrictedRegion()
                ? 'https://rpc.walletconnect.org'
                : 'https://rpc.walletconnect.com';
        },
        getAnalyticsUrl() {
            return CoreHelperUtil.isRestrictedRegion()
                ? 'https://pulse.walletconnect.org'
                : 'https://pulse.walletconnect.com';
        },
        getUUID() {
            if (crypto?.randomUUID) {
                return crypto.randomUUID();
            }
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/gu, c => {
                const r = (Math.random() * 16) | 0;
                const v = c === 'x' ? r : (r & 0x3) | 0x8;
                return v.toString(16);
            });
        },
        parseError(error) {
            if (typeof error === 'string') {
                return error;
            }
            else if (typeof error?.issues?.[0]?.message === 'string') {
                return error.issues[0].message;
            }
            else if (error instanceof Error) {
                return error.message;
            }
            return 'Unknown error';
        },
        sortRequestedNetworks(approvedIds, requestedNetworks = []) {
            const approvedIndexMap = {};
            if (requestedNetworks && approvedIds) {
                approvedIds.forEach((id, index) => {
                    approvedIndexMap[id] = index;
                });
                requestedNetworks.sort((a, b) => {
                    const indexA = approvedIndexMap[a.id];
                    const indexB = approvedIndexMap[b.id];
                    if (indexA !== undefined && indexB !== undefined) {
                        return indexA - indexB;
                    }
                    else if (indexA !== undefined) {
                        return -1;
                    }
                    else if (indexB !== undefined) {
                        return 1;
                    }
                    return 0;
                });
            }
            return requestedNetworks;
        },
        calculateBalance(array) {
            let sum = 0;
            for (const item of array) {
                sum += item.value;
            }
            return sum;
        },
        formatTokenBalance(number) {
            const roundedNumber = number.toFixed(2);
            const [dollars, pennies] = roundedNumber.split('.');
            return { dollars, pennies };
        },
        isAddress(address) {
            if (!/^(?:0x)?[0-9a-f]{40}$/iu.test(address)) {
                return false;
            }
            else if (/^(?:0x)?[0-9a-f]{40}$/iu.test(address) || /^(?:0x)?[0-9A-F]{40}$/iu.test(address)) {
                return true;
            }
            return false;
        }
    };

    class FetchUtil {
        constructor({ baseUrl }) {
            this.baseUrl = baseUrl;
        }
        async get({ headers, signal, ...args }) {
            const url = this.createUrl(args);
            const response = await fetch(url, { method: 'GET', headers, signal, cache: 'no-cache' });
            return response.json();
        }
        async getBlob({ headers, signal, ...args }) {
            const url = this.createUrl(args);
            const response = await fetch(url, { method: 'GET', headers, signal });
            return response.blob();
        }
        async post({ body, headers, signal, ...args }) {
            const url = this.createUrl(args);
            const response = await fetch(url, {
                method: 'POST',
                headers,
                body: body ? JSON.stringify(body) : undefined,
                signal
            });
            return response.json();
        }
        async put({ body, headers, signal, ...args }) {
            const url = this.createUrl(args);
            const response = await fetch(url, {
                method: 'PUT',
                headers,
                body: body ? JSON.stringify(body) : undefined,
                signal
            });
            return response.json();
        }
        async delete({ body, headers, signal, ...args }) {
            const url = this.createUrl(args);
            const response = await fetch(url, {
                method: 'DELETE',
                headers,
                body: body ? JSON.stringify(body) : undefined,
                signal
            });
            return response.json();
        }
        createUrl({ path, params }) {
            const url = new URL(path, this.baseUrl);
            if (params) {
                Object.entries(params).forEach(([key, value]) => {
                    if (value) {
                        url.searchParams.append(key, value);
                    }
                });
            }
            return url;
        }
    }

    const state$h = proxy({
        projectId: '',
        sdkType: 'w3m',
        sdkVersion: 'html-wagmi-undefined'
    });
    const OptionsController = {
        state: state$h,
        subscribeKey(key, callback) {
            return subscribeKey(state$h, key, callback);
        },
        setProjectId(projectId) {
            state$h.projectId = projectId;
        },
        setAllWallets(allWallets) {
            state$h.allWallets = allWallets;
        },
        setIncludeWalletIds(includeWalletIds) {
            state$h.includeWalletIds = includeWalletIds;
        },
        setExcludeWalletIds(excludeWalletIds) {
            state$h.excludeWalletIds = excludeWalletIds;
        },
        setFeaturedWalletIds(featuredWalletIds) {
            state$h.featuredWalletIds = featuredWalletIds;
        },
        setTokens(tokens) {
            state$h.tokens = tokens;
        },
        setTermsConditionsUrl(termsConditionsUrl) {
            state$h.termsConditionsUrl = termsConditionsUrl;
        },
        setPrivacyPolicyUrl(privacyPolicyUrl) {
            state$h.privacyPolicyUrl = privacyPolicyUrl;
        },
        setCustomWallets(customWallets) {
            state$h.customWallets = customWallets;
        },
        setIsSiweEnabled(isSiweEnabled) {
            state$h.isSiweEnabled = isSiweEnabled;
        },
        setEnableAnalytics(enableAnalytics) {
            state$h.enableAnalytics = enableAnalytics;
        },
        setSdkVersion(sdkVersion) {
            state$h.sdkVersion = sdkVersion;
        },
        setMetadata(metadata) {
            state$h.metadata = metadata;
        },
        setOnrampEnabled(enableOnramp) {
            state$h.enableOnramp = enableOnramp;
        },
        setWalletFeaturesEnabled(enableWalletFeatures) {
            state$h.enableWalletFeatures = enableWalletFeatures;
        }
    };

    const DEFAULT_OPTIONS = {
        purchaseCurrencies: [
            {
                id: '2b92315d-eab7-5bef-84fa-089a131333f5',
                name: 'USD Coin',
                symbol: 'USDC',
                networks: [
                    {
                        name: 'ethereum-mainnet',
                        display_name: 'Ethereum',
                        chain_id: '1',
                        contract_address: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48'
                    },
                    {
                        name: 'polygon-mainnet',
                        display_name: 'Polygon',
                        chain_id: '137',
                        contract_address: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174'
                    }
                ]
            },
            {
                id: '2b92315d-eab7-5bef-84fa-089a131333f5',
                name: 'Ether',
                symbol: 'ETH',
                networks: [
                    {
                        name: 'ethereum-mainnet',
                        display_name: 'Ethereum',
                        chain_id: '1',
                        contract_address: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48'
                    },
                    {
                        name: 'polygon-mainnet',
                        display_name: 'Polygon',
                        chain_id: '137',
                        contract_address: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174'
                    }
                ]
            }
        ],
        paymentCurrencies: [
            {
                id: 'USD',
                payment_method_limits: [
                    {
                        id: 'card',
                        min: '10.00',
                        max: '7500.00'
                    },
                    {
                        id: 'ach_bank_account',
                        min: '10.00',
                        max: '25000.00'
                    }
                ]
            },
            {
                id: 'EUR',
                payment_method_limits: [
                    {
                        id: 'card',
                        min: '10.00',
                        max: '7500.00'
                    },
                    {
                        id: 'ach_bank_account',
                        min: '10.00',
                        max: '25000.00'
                    }
                ]
            }
        ]
    };
    const baseUrl$2 = CoreHelperUtil.getBlockchainApiUrl();
    const api$3 = new FetchUtil({ baseUrl: baseUrl$2 });
    const BlockchainApiController = {
        fetchIdentity({ caipChainId, address }) {
            return api$3.get({
                path: `/v1/identity/${address}`,
                params: {
                    chainId: caipChainId,
                    projectId: OptionsController.state.projectId
                }
            });
        },
        fetchTransactions({ account, projectId, cursor, onramp, signal }) {
            const queryParams = cursor ? { cursor } : {};
            return api$3.get({
                path: `/v1/account/${account}/history?projectId=${projectId}${onramp ? `&onramp=${onramp}` : ''}`,
                params: queryParams,
                signal
            });
        },
        async getBalance(address) {
            return api$3.get({
                path: `/v1/account/${address}/balance`,
                params: {
                    currency: 'usd',
                    projectId: OptionsController.state.projectId
                }
            });
        },
        async generateOnRampURL({ destinationWallets, partnerUserId, defaultNetwork, purchaseAmount, paymentAmount }) {
            const response = await api$3.post({
                path: `/v1/generators/onrampurl?projectId=${OptionsController.state.projectId}`,
                body: {
                    destinationWallets,
                    defaultNetwork,
                    partnerUserId,
                    defaultExperience: 'buy',
                    presetCryptoAmount: purchaseAmount,
                    presetFiatAmount: paymentAmount
                }
            });
            return response.url;
        },
        async getOnrampOptions() {
            try {
                const response = await api$3.get({
                    path: `/v1/onramp/options?projectId=${OptionsController.state.projectId}`
                });
                return response;
            }
            catch (e) {
                return DEFAULT_OPTIONS;
            }
        },
        async getOnrampQuote({ purchaseCurrency, paymentCurrency, amount, network }) {
            try {
                const response = await api$3.post({
                    path: `/v1/onramp/quote?projectId=${OptionsController.state.projectId}`,
                    body: {
                        purchaseCurrency,
                        paymentCurrency,
                        amount,
                        network
                    }
                });
                return response;
            }
            catch (e) {
                return {
                    coinbaseFee: { amount, currency: paymentCurrency.id },
                    networkFee: { amount, currency: paymentCurrency.id },
                    paymentSubtotal: { amount, currency: paymentCurrency.id },
                    paymentTotal: { amount, currency: paymentCurrency.id },
                    purchaseAmount: { amount, currency: paymentCurrency.id },
                    quoteId: 'mocked-quote-id'
                };
            }
        }
    };

    const state$g = proxy({
        message: '',
        variant: 'success',
        open: false
    });
    const SnackController = {
        state: state$g,
        subscribeKey(key, callback) {
            return subscribeKey(state$g, key, callback);
        },
        showSuccess(message) {
            state$g.message = message;
            state$g.variant = 'success';
            state$g.open = true;
        },
        showError(message) {
            const errorMessage = CoreHelperUtil.parseError(message);
            state$g.message = errorMessage;
            state$g.variant = 'error';
            state$g.open = true;
        },
        hide() {
            state$g.open = false;
        }
    };

    const state$f = proxy({
        isConnected: false,
        currentTab: 0,
        tokenBalance: [],
        smartAccountDeployed: false
    });
    const AccountController = {
        state: state$f,
        subscribe(callback) {
            return subscribe(state$f, () => callback(state$f));
        },
        subscribeKey(key, callback) {
            return subscribeKey(state$f, key, callback);
        },
        setIsConnected(isConnected) {
            state$f.isConnected = isConnected;
        },
        setCaipAddress(caipAddress) {
            state$f.caipAddress = caipAddress;
            state$f.address = caipAddress ? CoreHelperUtil.getPlainAddress(caipAddress) : undefined;
        },
        setBalance(balance, balanceSymbol) {
            state$f.balance = balance;
            state$f.balanceSymbol = balanceSymbol;
        },
        setProfileName(profileName) {
            state$f.profileName = profileName;
        },
        setProfileImage(profileImage) {
            state$f.profileImage = profileImage;
        },
        setAddressExplorerUrl(explorerUrl) {
            state$f.addressExplorerUrl = explorerUrl;
        },
        setSmartAccountDeployed(isDeployed) {
            state$f.smartAccountDeployed = isDeployed;
        },
        setCurrentTab(currentTab) {
            state$f.currentTab = currentTab;
        },
        setTokenBalance(tokenBalance) {
            if (tokenBalance) {
                state$f.tokenBalance = ref(tokenBalance);
            }
        },
        async fetchTokenBalance() {
            try {
                if (state$f.address) {
                    const response = await BlockchainApiController.getBalance(state$f.address);
                    this.setTokenBalance(response.balances);
                }
            }
            catch (error) {
                SnackController.showError('Failed to fetch token balance');
            }
        },
        resetAccount() {
            state$f.isConnected = false;
            state$f.smartAccountDeployed = false;
            state$f.currentTab = 0;
            state$f.caipAddress = undefined;
            state$f.address = undefined;
            state$f.balance = undefined;
            state$f.balanceSymbol = undefined;
            state$f.profileName = undefined;
            state$f.profileImage = undefined;
            state$f.addressExplorerUrl = undefined;
            state$f.tokenBalance = [];
        }
    };

    const WC_DEEPLINK = 'WALLETCONNECT_DEEPLINK_CHOICE';
    const W3M_RECENT = '@w3m/recent';
    const W3M_CONNECTED_WALLET_IMAGE_URL = '@w3m/connected_wallet_image_url';
    const W3M_CONNECTED_CONNECTOR = '@w3m/connected_connector';
    const StorageUtil = {
        setWalletConnectDeepLink({ href, name }) {
            try {
                localStorage.setItem(WC_DEEPLINK, JSON.stringify({ href, name }));
            }
            catch {
                console.info('Unable to set WalletConnect deep link');
            }
        },
        getWalletConnectDeepLink() {
            try {
                const deepLink = localStorage.getItem(WC_DEEPLINK);
                if (deepLink) {
                    return JSON.parse(deepLink);
                }
            }
            catch {
                console.info('Unable to get WalletConnect deep link');
            }
            return undefined;
        },
        deleteWalletConnectDeepLink() {
            try {
                localStorage.removeItem(WC_DEEPLINK);
            }
            catch {
                console.info('Unable to delete WalletConnect deep link');
            }
        },
        setWeb3ModalRecent(wallet) {
            try {
                const recentWallets = StorageUtil.getRecentWallets();
                const exists = recentWallets.find(w => w.id === wallet.id);
                if (!exists) {
                    recentWallets.unshift(wallet);
                    if (recentWallets.length > 2) {
                        recentWallets.pop();
                    }
                    localStorage.setItem(W3M_RECENT, JSON.stringify(recentWallets));
                }
            }
            catch {
                console.info('Unable to set Web3Modal recent');
            }
        },
        getRecentWallets() {
            try {
                const recent = localStorage.getItem(W3M_RECENT);
                return recent ? JSON.parse(recent) : [];
            }
            catch {
                console.info('Unable to get Web3Modal recent');
            }
            return [];
        },
        setConnectedWalletImageUrl(imageUrl) {
            try {
                localStorage.setItem(W3M_CONNECTED_WALLET_IMAGE_URL, imageUrl);
            }
            catch {
                console.info('Unable to set Connected Wallet Image Url');
            }
        },
        getConnectedWalletImageUrl() {
            try {
                return localStorage.getItem(W3M_CONNECTED_WALLET_IMAGE_URL);
            }
            catch {
                console.info('Unable to set Connected Wallet Image Url');
            }
            return undefined;
        },
        setConnectedConnector(connectorType) {
            try {
                localStorage.setItem(W3M_CONNECTED_CONNECTOR, connectorType);
            }
            catch {
                console.info('Unable to set Connected Connector');
            }
        },
        getConnectedConnector() {
            try {
                return localStorage.getItem(W3M_CONNECTED_CONNECTOR);
            }
            catch {
                console.info('Unable to get Connected Connector');
            }
            return undefined;
        }
    };

    const state$e = proxy({
        walletImages: {},
        networkImages: {},
        connectorImages: {},
        tokenImages: {},
        currencyImages: {}
    });
    const AssetController = {
        state: state$e,
        subscribeNetworkImages(callback) {
            return subscribe(state$e.networkImages, () => callback(state$e.networkImages));
        },
        subscribeKey(key, callback) {
            return subscribeKey(state$e, key, callback);
        },
        subscribe(callback) {
            return subscribe(state$e, () => callback(state$e));
        },
        setWalletImage(key, value) {
            state$e.walletImages[key] = value;
        },
        setNetworkImage(key, value) {
            state$e.networkImages[key] = value;
        },
        setConnectorImage(key, value) {
            state$e.connectorImages[key] = value;
        },
        setTokenImage(key, value) {
            state$e.tokenImages[key] = value;
        },
        setCurrencyImage(key, value) {
            state$e.currencyImages[key] = value;
        }
    };

    const state$d = proxy({
        themeMode: 'dark',
        themeVariables: {}
    });
    const ThemeController = {
        state: state$d,
        subscribe(callback) {
            return subscribe(state$d, () => callback(state$d));
        },
        setThemeMode(themeMode) {
            state$d.themeMode = themeMode;
            try {
                const emailConnector = ConnectorController.getEmailConnector();
                if (emailConnector) {
                    emailConnector.provider.syncTheme({
                        themeMode: ThemeController.getSnapshot().themeMode
                    });
                }
            }
            catch {
                console.info('Unable to sync theme to email connector');
            }
        },
        setThemeVariables(themeVariables) {
            state$d.themeVariables = { ...state$d.themeVariables, ...themeVariables };
            try {
                const emailConnector = ConnectorController.getEmailConnector();
                if (emailConnector) {
                    emailConnector.provider.syncTheme({
                        themeVariables: ThemeController.getSnapshot().themeVariables
                    });
                }
            }
            catch {
                console.info('Unable to sync theme to email connector');
            }
        },
        getSnapshot() {
            return snapshot(state$d);
        }
    };

    const state$c = proxy({
        connectors: []
    });
    const ConnectorController = {
        state: state$c,
        subscribeKey(key, callback) {
            return subscribeKey(state$c, key, callback);
        },
        setConnectors(connectors) {
            state$c.connectors = connectors.map(c => ref(c));
        },
        addConnector(connector) {
            state$c.connectors.push(ref(connector));
            if (connector.id === 'w3mEmail') {
                const emailConnector = connector;
                const optionsState = snapshot(OptionsController.state);
                emailConnector?.provider?.syncDappData?.({
                    metadata: optionsState.metadata,
                    sdkVersion: optionsState.sdkVersion,
                    projectId: optionsState.projectId
                });
                emailConnector.provider.syncTheme({
                    themeMode: ThemeController.getSnapshot().themeMode,
                    themeVariables: ThemeController.getSnapshot().themeVariables
                });
            }
        },
        getEmailConnector() {
            return state$c.connectors.find(c => c.type === 'EMAIL');
        },
        getAnnouncedConnectorRdns() {
            return state$c.connectors.filter(c => c.type === 'ANNOUNCED').map(c => c.info?.rdns);
        },
        getConnectors() {
            return state$c.connectors;
        },
        getConnector(id, rdns) {
            return state$c.connectors.find(c => c.explorerId === id || c.info?.rdns === rdns);
        }
    };

    const state$b = proxy({
        open: false,
        selectedNetworkId: undefined
    });
    const PublicStateController = {
        state: state$b,
        subscribe(callback) {
            return subscribe(state$b, () => callback(state$b));
        },
        set(newState) {
            Object.assign(state$b, { ...state$b, ...newState });
        }
    };

    const baseUrl$1 = CoreHelperUtil.getAnalyticsUrl();
    const api$2 = new FetchUtil({ baseUrl: baseUrl$1 });
    const excluded = ['MODAL_CREATED'];
    const state$a = proxy({
        timestamp: Date.now(),
        data: {
            type: 'track',
            event: 'MODAL_CREATED'
        }
    });
    const EventsController = {
        state: state$a,
        subscribe(callback) {
            return subscribe(state$a, () => callback(state$a));
        },
        _getApiHeaders() {
            const { projectId, sdkType, sdkVersion } = OptionsController.state;
            return {
                'x-project-id': projectId,
                'x-sdk-type': sdkType,
                'x-sdk-version': sdkVersion
            };
        },
        async _sendAnalyticsEvent(payload) {
            try {
                if (excluded.includes(payload.data.event) || typeof window === 'undefined') {
                    return;
                }
                await api$2.post({
                    path: '/e',
                    headers: EventsController._getApiHeaders(),
                    body: {
                        eventId: CoreHelperUtil.getUUID(),
                        url: window.location.href,
                        domain: window.location.hostname,
                        timestamp: payload.timestamp,
                        props: payload.data
                    }
                });
            }
            catch {
            }
        },
        sendEvent(data) {
            state$a.timestamp = Date.now();
            state$a.data = data;
            if (OptionsController.state.enableAnalytics) {
                EventsController._sendAnalyticsEvent(state$a);
            }
        }
    };

    const state$9 = proxy({
        supportsAllNetworks: true,
        isDefaultCaipNetwork: false
    });
    const NetworkController = {
        state: state$9,
        subscribeKey(key, callback) {
            return subscribeKey(state$9, key, callback);
        },
        _getClient() {
            if (!state$9._client) {
                throw new Error('NetworkController client not set');
            }
            return state$9._client;
        },
        setClient(client) {
            state$9._client = ref(client);
        },
        setCaipNetwork(caipNetwork) {
            state$9.caipNetwork = caipNetwork;
            PublicStateController.set({ selectedNetworkId: caipNetwork?.id });
            if (!this.state.allowUnsupportedChain) {
                this.checkIfSupportedNetwork();
            }
        },
        setDefaultCaipNetwork(caipNetwork) {
            state$9.caipNetwork = caipNetwork;
            PublicStateController.set({ selectedNetworkId: caipNetwork?.id });
            state$9.isDefaultCaipNetwork = true;
        },
        setRequestedCaipNetworks(requestedNetworks) {
            state$9.requestedCaipNetworks = requestedNetworks;
        },
        setAllowUnsupportedChain(allowUnsupportedChain) {
            state$9.allowUnsupportedChain = allowUnsupportedChain;
        },
        getRequestedCaipNetworks() {
            const { approvedCaipNetworkIds, requestedCaipNetworks } = state$9;
            const approvedIds = approvedCaipNetworkIds;
            const requestedNetworks = requestedCaipNetworks;
            return CoreHelperUtil.sortRequestedNetworks(approvedIds, requestedNetworks);
        },
        async getApprovedCaipNetworksData() {
            const data = await this._getClient().getApprovedCaipNetworksData();
            state$9.supportsAllNetworks = data.supportsAllNetworks;
            state$9.approvedCaipNetworkIds = data.approvedCaipNetworkIds;
        },
        async switchActiveNetwork(network) {
            await this._getClient().switchCaipNetwork(network);
            state$9.caipNetwork = network;
            if (network) {
                EventsController.sendEvent({
                    type: 'track',
                    event: 'SWITCH_NETWORK',
                    properties: { network: network.id }
                });
            }
        },
        checkIfSupportedNetwork() {
            state$9.isUnsupportedChain = !state$9.requestedCaipNetworks?.some(network => network.id === state$9.caipNetwork?.id);
            if (state$9.isUnsupportedChain) {
                this.showUnsupportedChainUI();
            }
        },
        resetNetwork() {
            if (!state$9.isDefaultCaipNetwork) {
                state$9.caipNetwork = undefined;
            }
            state$9.approvedCaipNetworkIds = undefined;
            state$9.supportsAllNetworks = true;
        },
        showUnsupportedChainUI() {
            setTimeout(() => {
                ModalController.open({ view: 'UnsupportedChain' });
            }, 300);
        }
    };

    const baseUrl = CoreHelperUtil.getApiUrl();
    const api$1 = new FetchUtil({ baseUrl });
    const entries = '40';
    const recommendedEntries = '4';
    const state$8 = proxy({
        page: 1,
        count: 0,
        featured: [],
        recommended: [],
        wallets: [],
        search: [],
        isAnalyticsEnabled: false
    });
    const ApiController = {
        state: state$8,
        subscribeKey(key, callback) {
            return subscribeKey(state$8, key, callback);
        },
        _getApiHeaders() {
            const { projectId, sdkType, sdkVersion } = OptionsController.state;
            return {
                'x-project-id': projectId,
                'x-sdk-type': sdkType,
                'x-sdk-version': sdkVersion
            };
        },
        async _fetchWalletImage(imageId) {
            const imageUrl = `${api$1.baseUrl}/getWalletImage/${imageId}`;
            const blob = await api$1.getBlob({ path: imageUrl, headers: ApiController._getApiHeaders() });
            AssetController.setWalletImage(imageId, URL.createObjectURL(blob));
        },
        async _fetchNetworkImage(imageId) {
            const imageUrl = `${api$1.baseUrl}/public/getAssetImage/${imageId}`;
            const blob = await api$1.getBlob({ path: imageUrl, headers: ApiController._getApiHeaders() });
            AssetController.setNetworkImage(imageId, URL.createObjectURL(blob));
        },
        async _fetchConnectorImage(imageId) {
            const imageUrl = `${api$1.baseUrl}/public/getAssetImage/${imageId}`;
            const blob = await api$1.getBlob({ path: imageUrl, headers: ApiController._getApiHeaders() });
            AssetController.setConnectorImage(imageId, URL.createObjectURL(blob));
        },
        async _fetchCurrencyImage(countryCode) {
            const imageUrl = `${api$1.baseUrl}/public/getCurrencyImage/${countryCode}`;
            const blob = await api$1.getBlob({ path: imageUrl, headers: ApiController._getApiHeaders() });
            AssetController.setCurrencyImage(countryCode, URL.createObjectURL(blob));
        },
        async _fetchTokenImage(symbol) {
            const imageUrl = `${api$1.baseUrl}/public/getTokenImage/${symbol}`;
            const blob = await api$1.getBlob({ path: imageUrl, headers: ApiController._getApiHeaders() });
            AssetController.setTokenImage(symbol, URL.createObjectURL(blob));
        },
        async fetchNetworkImages() {
            const { requestedCaipNetworks } = NetworkController.state;
            const ids = requestedCaipNetworks?.map(({ imageId }) => imageId).filter(Boolean);
            if (ids) {
                await Promise.allSettled(ids.map(id => ApiController._fetchNetworkImage(id)));
            }
        },
        async fetchConnectorImages() {
            const { connectors } = ConnectorController.state;
            const ids = connectors.map(({ imageId }) => imageId).filter(Boolean);
            await Promise.allSettled(ids.map(id => ApiController._fetchConnectorImage(id)));
        },
        async fetchCurrencyImages(currencies = []) {
            await Promise.allSettled(currencies.map(currency => ApiController._fetchCurrencyImage(currency)));
        },
        async fetchTokenImages(tokens = []) {
            await Promise.allSettled(tokens.map(token => ApiController._fetchTokenImage(token)));
        },
        async fetchFeaturedWallets() {
            const { featuredWalletIds } = OptionsController.state;
            if (featuredWalletIds?.length) {
                const { data } = await api$1.get({
                    path: '/getWallets',
                    headers: ApiController._getApiHeaders(),
                    params: {
                        page: '1',
                        entries: featuredWalletIds?.length
                            ? String(featuredWalletIds.length)
                            : recommendedEntries,
                        include: featuredWalletIds?.join(',')
                    }
                });
                data.sort((a, b) => featuredWalletIds.indexOf(a.id) - featuredWalletIds.indexOf(b.id));
                const images = data.map(d => d.image_id).filter(Boolean);
                await Promise.allSettled(images.map(id => ApiController._fetchWalletImage(id)));
                state$8.featured = data;
            }
        },
        async fetchRecommendedWallets() {
            const { includeWalletIds, excludeWalletIds, featuredWalletIds } = OptionsController.state;
            const exclude = [...(excludeWalletIds ?? []), ...(featuredWalletIds ?? [])].filter(Boolean);
            const { data, count } = await api$1.get({
                path: '/getWallets',
                headers: ApiController._getApiHeaders(),
                params: {
                    page: '1',
                    chains: NetworkController.state.caipNetwork?.id,
                    entries: recommendedEntries,
                    include: includeWalletIds?.join(','),
                    exclude: exclude?.join(',')
                }
            });
            const recent = StorageUtil.getRecentWallets();
            const recommendedImages = data.map(d => d.image_id).filter(Boolean);
            const recentImages = recent.map(r => r.image_id).filter(Boolean);
            await Promise.allSettled([...recommendedImages, ...recentImages].map(id => ApiController._fetchWalletImage(id)));
            state$8.recommended = data;
            state$8.count = count ?? 0;
        },
        async fetchWallets({ page }) {
            const { includeWalletIds, excludeWalletIds, featuredWalletIds } = OptionsController.state;
            const exclude = [
                ...state$8.recommended.map(({ id }) => id),
                ...(excludeWalletIds ?? []),
                ...(featuredWalletIds ?? [])
            ].filter(Boolean);
            const { data, count } = await api$1.get({
                path: '/getWallets',
                headers: ApiController._getApiHeaders(),
                params: {
                    page: String(page),
                    entries,
                    chains: NetworkController.state.caipNetwork?.id,
                    include: includeWalletIds?.join(','),
                    exclude: exclude.join(',')
                }
            });
            const images = data.map(w => w.image_id).filter(Boolean);
            await Promise.allSettled([
                ...images.map(id => ApiController._fetchWalletImage(id)),
                CoreHelperUtil.wait(300)
            ]);
            state$8.wallets = [...state$8.wallets, ...data];
            state$8.count = count > state$8.count ? count : state$8.count;
            state$8.page = page;
        },
        async searchWallet({ search }) {
            const { includeWalletIds, excludeWalletIds } = OptionsController.state;
            state$8.search = [];
            const { data } = await api$1.get({
                path: '/getWallets',
                headers: ApiController._getApiHeaders(),
                params: {
                    page: '1',
                    entries: '100',
                    search,
                    chains: NetworkController.state.caipNetwork?.id,
                    include: includeWalletIds?.join(','),
                    exclude: excludeWalletIds?.join(',')
                }
            });
            const images = data.map(w => w.image_id).filter(Boolean);
            await Promise.allSettled([
                ...images.map(id => ApiController._fetchWalletImage(id)),
                CoreHelperUtil.wait(300)
            ]);
            state$8.search = data;
        },
        async reFetchWallets() {
            state$8.page = 1;
            state$8.wallets = [];
            await ApiController.fetchFeaturedWallets();
            await ApiController.fetchRecommendedWallets();
        },
        prefetch() {
            const promises = [
                ApiController.fetchFeaturedWallets(),
                ApiController.fetchRecommendedWallets(),
                ApiController.fetchNetworkImages(),
                ApiController.fetchConnectorImages()
            ];
            if (OptionsController.state.enableAnalytics === undefined) {
                promises.push(ApiController.fetchAnalyticsConfig());
            }
            state$8.prefetchPromise = Promise.race([Promise.allSettled(promises), CoreHelperUtil.wait(3000)]);
        },
        async fetchAnalyticsConfig() {
            const { isAnalyticsEnabled } = await api$1.get({
                path: '/getAnalyticsConfig',
                headers: ApiController._getApiHeaders()
            });
            OptionsController.setEnableAnalytics(isAnalyticsEnabled);
        }
    };

    const state$7 = proxy({
        view: 'Connect',
        history: ['Connect']
    });
    const RouterController = {
        state: state$7,
        subscribeKey(key, callback) {
            return subscribeKey(state$7, key, callback);
        },
        push(view, data) {
            if (view !== state$7.view) {
                state$7.view = view;
                state$7.history.push(view);
                state$7.data = data;
            }
        },
        reset(view) {
            state$7.view = view;
            state$7.history = [view];
        },
        replace(view, data) {
            if (state$7.history.length > 1 && state$7.history.at(-1) !== view) {
                state$7.view = view;
                state$7.history[state$7.history.length - 1] = view;
                state$7.data = data;
            }
        },
        goBack() {
            if (state$7.history.length > 1) {
                state$7.history.pop();
                const [last] = state$7.history.slice(-1);
                if (last) {
                    state$7.view = last;
                }
            }
        },
        goBackToIndex(historyIndex) {
            if (state$7.history.length > 1) {
                state$7.history = state$7.history.slice(0, historyIndex + 1);
                const [last] = state$7.history.slice(-1);
                if (last) {
                    state$7.view = last;
                }
            }
        }
    };

    const state$6 = proxy({
        loading: false,
        open: false
    });
    const ModalController = {
        state: state$6,
        subscribe(callback) {
            return subscribe(state$6, () => callback(state$6));
        },
        subscribeKey(key, callback) {
            return subscribeKey(state$6, key, callback);
        },
        async open(options) {
            await ApiController.state.prefetchPromise;
            const connected = AccountController.state.isConnected;
            if (options?.view) {
                RouterController.reset(options.view);
            }
            else if (connected) {
                RouterController.reset('Account');
            }
            else {
                RouterController.reset('Connect');
            }
            state$6.open = true;
            PublicStateController.set({ open: true });
            EventsController.sendEvent({
                type: 'track',
                event: 'MODAL_OPEN',
                properties: { connected }
            });
        },
        close() {
            const connected = AccountController.state.isConnected;
            state$6.open = false;
            PublicStateController.set({ open: false });
            EventsController.sendEvent({
                type: 'track',
                event: 'MODAL_CLOSE',
                properties: { connected }
            });
        },
        setLoading(loading) {
            state$6.loading = loading;
        }
    };

    const USDC_CURRENCY_DEFAULT = {
        id: '2b92315d-eab7-5bef-84fa-089a131333f5',
        name: 'USD Coin',
        symbol: 'USDC',
        networks: [
            {
                name: 'ethereum-mainnet',
                display_name: 'Ethereum',
                chain_id: '1',
                contract_address: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48'
            },
            {
                name: 'polygon-mainnet',
                display_name: 'Polygon',
                chain_id: '137',
                contract_address: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174'
            }
        ]
    };
    const USD_CURRENCY_DEFAULT = {
        id: 'USD',
        payment_method_limits: [
            {
                id: 'card',
                min: '10.00',
                max: '7500.00'
            },
            {
                id: 'ach_bank_account',
                min: '10.00',
                max: '25000.00'
            }
        ]
    };
    const defaultState = {
        providers: ONRAMP_PROVIDERS,
        selectedProvider: null,
        error: null,
        purchaseCurrency: USDC_CURRENCY_DEFAULT,
        paymentCurrency: USD_CURRENCY_DEFAULT,
        purchaseCurrencies: [USDC_CURRENCY_DEFAULT],
        paymentCurrencies: [],
        quotesLoading: false
    };
    const state$5 = proxy(defaultState);
    const OnRampController = {
        state: state$5,
        subscribe(callback) {
            return subscribe(state$5, () => callback(state$5));
        },
        subscribeKey(key, callback) {
            return subscribeKey(state$5, key, callback);
        },
        setSelectedProvider(provider) {
            state$5.selectedProvider = provider;
        },
        setPurchaseCurrency(currency) {
            state$5.purchaseCurrency = currency;
        },
        setPaymentCurrency(currency) {
            state$5.paymentCurrency = currency;
        },
        setPurchaseAmount(amount) {
            this.state.purchaseAmount = amount;
        },
        setPaymentAmount(amount) {
            this.state.paymentAmount = amount;
        },
        async getAvailableCurrencies() {
            const options = await BlockchainApiController.getOnrampOptions();
            state$5.purchaseCurrencies = options.purchaseCurrencies;
            state$5.paymentCurrencies = options.paymentCurrencies;
            state$5.paymentCurrency = options.paymentCurrencies[0] || USD_CURRENCY_DEFAULT;
            state$5.purchaseCurrency = options.purchaseCurrencies[0] || USDC_CURRENCY_DEFAULT;
            await ApiController.fetchCurrencyImages(options.paymentCurrencies.map(currency => currency.id));
            await ApiController.fetchTokenImages(options.purchaseCurrencies.map(currency => currency.symbol));
        },
        async getQuote() {
            state$5.quotesLoading = true;
            try {
                const quote = await BlockchainApiController.getOnrampQuote({
                    purchaseCurrency: state$5.purchaseCurrency,
                    paymentCurrency: state$5.paymentCurrency,
                    amount: state$5.paymentAmount?.toString() || '0',
                    network: state$5.purchaseCurrency?.symbol
                });
                state$5.quotesLoading = false;
                state$5.purchaseAmount = Number(quote.purchaseAmount.amount);
                return quote;
            }
            catch (error) {
                state$5.error = error.message;
                state$5.quotesLoading = false;
                return null;
            }
            finally {
                state$5.quotesLoading = false;
            }
        },
        resetState() {
            state$5.providers = ONRAMP_PROVIDERS;
            state$5.selectedProvider = null;
            state$5.error = null;
            state$5.purchaseCurrency = USDC_CURRENCY_DEFAULT;
            state$5.paymentCurrency = USD_CURRENCY_DEFAULT;
            state$5.purchaseCurrencies = [USDC_CURRENCY_DEFAULT];
            state$5.paymentCurrencies = [];
            state$5.paymentAmount = undefined;
            state$5.purchaseAmount = undefined;
            state$5.quotesLoading = false;
        }
    };

    const state$4 = proxy({
        transactions: [],
        coinbaseTransactions: {},
        transactionsByYear: {},
        loading: false,
        empty: false,
        next: undefined
    });
    const TransactionsController = {
        state: state$4,
        subscribe(callback) {
            return subscribe(state$4, () => callback(state$4));
        },
        async fetchTransactions(accountAddress, onramp) {
            const { projectId } = OptionsController.state;
            if (!projectId || !accountAddress) {
                throw new Error("Transactions can't be fetched without a projectId and an accountAddress");
            }
            state$4.loading = true;
            try {
                const response = await BlockchainApiController.fetchTransactions({
                    account: accountAddress,
                    projectId,
                    cursor: state$4.next,
                    onramp
                });
                const nonSpamTransactions = this.filterSpamTransactions(response.data);
                const filteredTransactions = [...state$4.transactions, ...nonSpamTransactions];
                state$4.loading = false;
                if (onramp === 'coinbase') {
                    state$4.coinbaseTransactions = this.groupTransactionsByYearAndMonth(state$4.coinbaseTransactions, response.data);
                }
                else {
                    state$4.transactions = filteredTransactions;
                    state$4.transactionsByYear = this.groupTransactionsByYearAndMonth(state$4.transactionsByYear, nonSpamTransactions);
                }
                state$4.empty = filteredTransactions.length === 0;
                state$4.next = response.next ? response.next : undefined;
            }
            catch (error) {
                EventsController.sendEvent({
                    type: 'track',
                    event: 'ERROR_FETCH_TRANSACTIONS',
                    properties: {
                        address: accountAddress,
                        projectId,
                        cursor: state$4.next
                    }
                });
                SnackController.showError('Failed to fetch transactions');
                state$4.loading = false;
                state$4.empty = true;
                state$4.next = undefined;
            }
        },
        groupTransactionsByYearAndMonth(transactionsMap = {}, transactions = []) {
            const grouped = transactionsMap;
            transactions.forEach(transaction => {
                const year = new Date(transaction.metadata.minedAt).getFullYear();
                const month = new Date(transaction.metadata.minedAt).getMonth();
                const yearTransactions = grouped[year] ?? {};
                const monthTransactions = yearTransactions[month] ?? [];
                const newMonthTransactions = monthTransactions.filter(tx => tx.id !== transaction.id);
                grouped[year] = {
                    ...yearTransactions,
                    [month]: [...newMonthTransactions, transaction].sort((a, b) => new Date(b.metadata.minedAt).getTime() - new Date(a.metadata.minedAt).getTime())
                };
            });
            return grouped;
        },
        filterSpamTransactions(transactions) {
            return transactions.filter(transaction => {
                const isAllSpam = transaction.transfers.every(transfer => transfer.nft_info?.flags.is_spam === true);
                return !isAllSpam;
            });
        },
        clearCursor() {
            state$4.next = undefined;
        },
        resetTransactions() {
            state$4.transactions = [];
            state$4.transactionsByYear = {};
            state$4.loading = false;
            state$4.empty = false;
            state$4.next = undefined;
        }
    };

    const state$3 = proxy({
        wcError: false,
        buffering: false
    });
    const ConnectionController = {
        state: state$3,
        subscribeKey(key, callback) {
            return subscribeKey(state$3, key, callback);
        },
        _getClient() {
            if (!state$3._client) {
                throw new Error('ConnectionController client not set');
            }
            return state$3._client;
        },
        setClient(client) {
            state$3._client = ref(client);
        },
        connectWalletConnect() {
            state$3.wcPromise = this._getClient().connectWalletConnect(uri => {
                state$3.wcUri = uri;
                state$3.wcPairingExpiry = CoreHelperUtil.getPairingExpiry();
            });
            StorageUtil.setConnectedConnector('WALLET_CONNECT');
        },
        async connectExternal(options) {
            await this._getClient().connectExternal?.(options);
            StorageUtil.setConnectedConnector(options.type);
        },
        async signMessage(message) {
            return this._getClient().signMessage(message);
        },
        checkInstalled(ids) {
            return this._getClient().checkInstalled?.(ids);
        },
        resetWcConnection() {
            state$3.wcUri = undefined;
            state$3.wcPairingExpiry = undefined;
            state$3.wcPromise = undefined;
            state$3.wcLinking = undefined;
            state$3.recentWallet = undefined;
            TransactionsController.resetTransactions();
            StorageUtil.deleteWalletConnectDeepLink();
        },
        setWcLinking(wcLinking) {
            state$3.wcLinking = wcLinking;
        },
        setWcError(wcError) {
            state$3.wcError = wcError;
            state$3.buffering = false;
        },
        setRecentWallet(wallet) {
            state$3.recentWallet = wallet;
        },
        setBuffering(buffering) {
            state$3.buffering = buffering;
        },
        async disconnect() {
            await this._getClient().disconnect();
            this.resetWcConnection();
        }
    };

    const state$2 = proxy({});
    const SendController = {
        state: state$2,
        subscribe(callback) {
            return subscribe(state$2, () => callback(state$2));
        },
        subscribeKey(key, callback) {
            return subscribeKey(state$2, key, callback);
        },
        setToken(token) {
            if (token) {
                state$2.token = ref(token);
            }
        },
        setTokenAmount(sendTokenAmount) {
            state$2.sendTokenAmount = sendTokenAmount;
        },
        setReceiverAddress(receiverAddress) {
            state$2.receiverAddress = receiverAddress;
        },
        setReceiverProfileImageUrl(receiverProfileImageUrl) {
            state$2.receiverProfileImageUrl = receiverProfileImageUrl;
        },
        setReceiverProfileName(receiverProfileName) {
            state$2.receiverProfileName = receiverProfileName;
        },
        resetSend() {
            state$2.token = undefined;
            state$2.sendTokenAmount = undefined;
            state$2.receiverAddress = undefined;
            state$2.receiverProfileImageUrl = undefined;
            state$2.receiverProfileName = undefined;
        }
    };

    const AssetUtil = {
        getWalletImage(wallet) {
            if (wallet?.image_url) {
                return wallet?.image_url;
            }
            if (wallet?.image_id) {
                return AssetController.state.walletImages[wallet.image_id];
            }
            return undefined;
        },
        getNetworkImage(network) {
            if (network?.imageUrl) {
                return network?.imageUrl;
            }
            if (network?.imageId) {
                return AssetController.state.networkImages[network.imageId];
            }
            return undefined;
        },
        getConnectorImage(connector) {
            if (connector?.imageUrl) {
                return connector.imageUrl;
            }
            if (connector?.imageId) {
                return AssetController.state.connectorImages[connector.imageId];
            }
            return undefined;
        }
    };

    const RouterUtil = {
        goBackOrCloseModal() {
            if (RouterController.state.history.length > 1) {
                RouterController.goBack();
            }
            else {
                ModalController.close();
            }
        },
        navigateAfterNetworkSwitch() {
            const { history } = RouterController.state;
            const networkSelectIndex = history.findIndex(name => name === 'Networks');
            if (networkSelectIndex >= 1) {
                RouterController.goBackToIndex(networkSelectIndex - 1);
            }
            else {
                ModalController.close();
            }
        }
    };

    /**
     * @license
     * Copyright 2019 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */
    const t$f=globalThis,e$l=t$f.ShadowRoot&&(void 0===t$f.ShadyCSS||t$f.ShadyCSS.nativeShadow)&&"adoptedStyleSheets"in Document.prototype&&"replace"in CSSStyleSheet.prototype,s$g=Symbol(),o$p=new WeakMap;let n$m = class n{constructor(t,e,o){if(this._$cssResult$=!0,o!==s$g)throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");this.cssText=t,this.t=e;}get styleSheet(){let t=this.o;const s=this.t;if(e$l&&void 0===t){const e=void 0!==s&&1===s.length;e&&(t=o$p.get(s)),void 0===t&&((this.o=t=new CSSStyleSheet).replaceSync(this.cssText),e&&o$p.set(s,t));}return t}toString(){return this.cssText}};const r$q=t=>new n$m("string"==typeof t?t:t+"",void 0,s$g),i$h=(t,...e)=>{const o=1===t.length?t[0]:e.reduce(((e,s,o)=>e+(t=>{if(!0===t._$cssResult$)return t.cssText;if("number"==typeof t)return t;throw Error("Value passed to 'css' function must be a 'css' function result: "+t+". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.")})(s)+t[o+1]),t[0]);return new n$m(o,t,s$g)},S$a=(s,o)=>{if(e$l)s.adoptedStyleSheets=o.map((t=>t instanceof CSSStyleSheet?t:t.styleSheet));else for(const e of o){const o=document.createElement("style"),n=t$f.litNonce;void 0!==n&&o.setAttribute("nonce",n),o.textContent=e.cssText,s.appendChild(o);}},c$g=e$l?t=>t:t=>t instanceof CSSStyleSheet?(t=>{let e="";for(const s of t.cssRules)e+=s.cssText;return r$q(e)})(t):t;

    /**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */const{is:i$g,defineProperty:e$k,getOwnPropertyDescriptor:r$p,getOwnPropertyNames:h$e,getOwnPropertySymbols:o$o,getPrototypeOf:n$l}=Object,a$a=globalThis,c$f=a$a.trustedTypes,l$b=c$f?c$f.emptyScript:"",p$9=a$a.reactiveElementPolyfillSupport,d$b=(t,s)=>t,u$9={toAttribute(t,s){switch(s){case Boolean:t=t?l$b:null;break;case Object:case Array:t=null==t?t:JSON.stringify(t);}return t},fromAttribute(t,s){let i=t;switch(s){case Boolean:i=null!==t;break;case Number:i=null===t?null:Number(t);break;case Object:case Array:try{i=JSON.parse(t);}catch(t){i=null;}}return i}},f$c=(t,s)=>!i$g(t,s),y$9={attribute:!0,type:String,converter:u$9,reflect:!1,hasChanged:f$c};Symbol.metadata??=Symbol("metadata"),a$a.litPropertyMetadata??=new WeakMap;let b$6 = class b extends HTMLElement{static addInitializer(t){this._$Ei(),(this.l??=[]).push(t);}static get observedAttributes(){return this.finalize(),this._$Eh&&[...this._$Eh.keys()]}static createProperty(t,s=y$9){if(s.state&&(s.attribute=!1),this._$Ei(),this.elementProperties.set(t,s),!s.noAccessor){const i=Symbol(),r=this.getPropertyDescriptor(t,i,s);void 0!==r&&e$k(this.prototype,t,r);}}static getPropertyDescriptor(t,s,i){const{get:e,set:h}=r$p(this.prototype,t)??{get(){return this[s]},set(t){this[s]=t;}};return {get(){return e?.call(this)},set(s){const r=e?.call(this);h.call(this,s),this.requestUpdate(t,r,i);},configurable:!0,enumerable:!0}}static getPropertyOptions(t){return this.elementProperties.get(t)??y$9}static _$Ei(){if(this.hasOwnProperty(d$b("elementProperties")))return;const t=n$l(this);t.finalize(),void 0!==t.l&&(this.l=[...t.l]),this.elementProperties=new Map(t.elementProperties);}static finalize(){if(this.hasOwnProperty(d$b("finalized")))return;if(this.finalized=!0,this._$Ei(),this.hasOwnProperty(d$b("properties"))){const t=this.properties,s=[...h$e(t),...o$o(t)];for(const i of s)this.createProperty(i,t[i]);}const t=this[Symbol.metadata];if(null!==t){const s=litPropertyMetadata.get(t);if(void 0!==s)for(const[t,i]of s)this.elementProperties.set(t,i);}this._$Eh=new Map;for(const[t,s]of this.elementProperties){const i=this._$Eu(t,s);void 0!==i&&this._$Eh.set(i,t);}this.elementStyles=this.finalizeStyles(this.styles);}static finalizeStyles(s){const i=[];if(Array.isArray(s)){const e=new Set(s.flat(1/0).reverse());for(const s of e)i.unshift(c$g(s));}else void 0!==s&&i.push(c$g(s));return i}static _$Eu(t,s){const i=s.attribute;return !1===i?void 0:"string"==typeof i?i:"string"==typeof t?t.toLowerCase():void 0}constructor(){super(),this._$Ep=void 0,this.isUpdatePending=!1,this.hasUpdated=!1,this._$Em=null,this._$Ev();}_$Ev(){this._$ES=new Promise((t=>this.enableUpdating=t)),this._$AL=new Map,this._$E_(),this.requestUpdate(),this.constructor.l?.forEach((t=>t(this)));}addController(t){(this._$EO??=new Set).add(t),void 0!==this.renderRoot&&this.isConnected&&t.hostConnected?.();}removeController(t){this._$EO?.delete(t);}_$E_(){const t=new Map,s=this.constructor.elementProperties;for(const i of s.keys())this.hasOwnProperty(i)&&(t.set(i,this[i]),delete this[i]);t.size>0&&(this._$Ep=t);}createRenderRoot(){const t=this.shadowRoot??this.attachShadow(this.constructor.shadowRootOptions);return S$a(t,this.constructor.elementStyles),t}connectedCallback(){this.renderRoot??=this.createRenderRoot(),this.enableUpdating(!0),this._$EO?.forEach((t=>t.hostConnected?.()));}enableUpdating(t){}disconnectedCallback(){this._$EO?.forEach((t=>t.hostDisconnected?.()));}attributeChangedCallback(t,s,i){this._$AK(t,i);}_$EC(t,s){const i=this.constructor.elementProperties.get(t),e=this.constructor._$Eu(t,i);if(void 0!==e&&!0===i.reflect){const r=(void 0!==i.converter?.toAttribute?i.converter:u$9).toAttribute(s,i.type);this._$Em=t,null==r?this.removeAttribute(e):this.setAttribute(e,r),this._$Em=null;}}_$AK(t,s){const i=this.constructor,e=i._$Eh.get(t);if(void 0!==e&&this._$Em!==e){const t=i.getPropertyOptions(e),r="function"==typeof t.converter?{fromAttribute:t.converter}:void 0!==t.converter?.fromAttribute?t.converter:u$9;this._$Em=e,this[e]=r.fromAttribute(s,t.type),this._$Em=null;}}requestUpdate(t,s,i){if(void 0!==t){if(i??=this.constructor.getPropertyOptions(t),!(i.hasChanged??f$c)(this[t],s))return;this.P(t,s,i);}!1===this.isUpdatePending&&(this._$ES=this._$ET());}P(t,s,i){this._$AL.has(t)||this._$AL.set(t,s),!0===i.reflect&&this._$Em!==t&&(this._$Ej??=new Set).add(t);}async _$ET(){this.isUpdatePending=!0;try{await this._$ES;}catch(t){Promise.reject(t);}const t=this.scheduleUpdate();return null!=t&&await t,!this.isUpdatePending}scheduleUpdate(){return this.performUpdate()}performUpdate(){if(!this.isUpdatePending)return;if(!this.hasUpdated){if(this.renderRoot??=this.createRenderRoot(),this._$Ep){for(const[t,s]of this._$Ep)this[t]=s;this._$Ep=void 0;}const t=this.constructor.elementProperties;if(t.size>0)for(const[s,i]of t)!0!==i.wrapped||this._$AL.has(s)||void 0===this[s]||this.P(s,this[s],i);}let t=!1;const s=this._$AL;try{t=this.shouldUpdate(s),t?(this.willUpdate(s),this._$EO?.forEach((t=>t.hostUpdate?.())),this.update(s)):this._$EU();}catch(s){throw t=!1,this._$EU(),s}t&&this._$AE(s);}willUpdate(t){}_$AE(t){this._$EO?.forEach((t=>t.hostUpdated?.())),this.hasUpdated||(this.hasUpdated=!0,this.firstUpdated(t)),this.updated(t);}_$EU(){this._$AL=new Map,this.isUpdatePending=!1;}get updateComplete(){return this.getUpdateComplete()}getUpdateComplete(){return this._$ES}shouldUpdate(t){return !0}update(t){this._$Ej&&=this._$Ej.forEach((t=>this._$EC(t,this[t]))),this._$EU();}updated(t){}firstUpdated(t){}};b$6.elementStyles=[],b$6.shadowRootOptions={mode:"open"},b$6[d$b("elementProperties")]=new Map,b$6[d$b("finalized")]=new Map,p$9?.({ReactiveElement:b$6}),(a$a.reactiveElementVersions??=[]).push("2.0.4");

    /**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */
    const t$e=globalThis,i$f=t$e.trustedTypes,s$f=i$f?i$f.createPolicy("lit-html",{createHTML:t=>t}):void 0,e$j="$lit$",h$d=`lit$${(Math.random()+"").slice(9)}$`,o$n="?"+h$d,n$k=`<${o$n}>`,r$o=document,l$a=()=>r$o.createComment(""),c$e=t=>null===t||"object"!=typeof t&&"function"!=typeof t,a$9=Array.isArray,u$8=t=>a$9(t)||"function"==typeof t?.[Symbol.iterator],d$a="[ \t\n\f\r]",f$b=/<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g,v$6=/-->/g,_$7=/>/g,m$6=RegExp(`>|${d$a}(?:([^\\s"'>=/]+)(${d$a}*=${d$a}*(?:[^ \t\n\f\r"'\`<>=]|("|')|))|$)`,"g"),p$8=/'/g,g$6=/"/g,$$5=/^(?:script|style|textarea|title)$/i,y$8=t=>(i,...s)=>({_$litType$:t,strings:i,values:s}),x$5=y$8(1),b$5=y$8(2),w$6=Symbol.for("lit-noChange"),T$7=Symbol.for("lit-nothing"),A$6=new WeakMap,E$5=r$o.createTreeWalker(r$o,129);function C$6(t,i){if(!Array.isArray(t)||!t.hasOwnProperty("raw"))throw Error("invalid template strings array");return void 0!==s$f?s$f.createHTML(i):i}const P$5=(t,i)=>{const s=t.length-1,o=[];let r,l=2===i?"<svg>":"",c=f$b;for(let i=0;i<s;i++){const s=t[i];let a,u,d=-1,y=0;for(;y<s.length&&(c.lastIndex=y,u=c.exec(s),null!==u);)y=c.lastIndex,c===f$b?"!--"===u[1]?c=v$6:void 0!==u[1]?c=_$7:void 0!==u[2]?($$5.test(u[2])&&(r=RegExp("</"+u[2],"g")),c=m$6):void 0!==u[3]&&(c=m$6):c===m$6?">"===u[0]?(c=r??f$b,d=-1):void 0===u[1]?d=-2:(d=c.lastIndex-u[2].length,a=u[1],c=void 0===u[3]?m$6:'"'===u[3]?g$6:p$8):c===g$6||c===p$8?c=m$6:c===v$6||c===_$7?c=f$b:(c=m$6,r=void 0);const x=c===m$6&&t[i+1].startsWith("/>")?" ":"";l+=c===f$b?s+n$k:d>=0?(o.push(a),s.slice(0,d)+e$j+s.slice(d)+h$d+x):s+h$d+(-2===d?i:x);}return [C$6(t,l+(t[s]||"<?>")+(2===i?"</svg>":"")),o]};let V$5 = class V{constructor({strings:t,_$litType$:s},n){let r;this.parts=[];let c=0,a=0;const u=t.length-1,d=this.parts,[f,v]=P$5(t,s);if(this.el=V.createElement(f,n),E$5.currentNode=this.el.content,2===s){const t=this.el.content.firstChild;t.replaceWith(...t.childNodes);}for(;null!==(r=E$5.nextNode())&&d.length<u;){if(1===r.nodeType){if(r.hasAttributes())for(const t of r.getAttributeNames())if(t.endsWith(e$j)){const i=v[a++],s=r.getAttribute(t).split(h$d),e=/([.?@])?(.*)/.exec(i);d.push({type:1,index:c,name:e[2],strings:s,ctor:"."===e[1]?k$6:"?"===e[1]?H$5:"@"===e[1]?I$5:R$4}),r.removeAttribute(t);}else t.startsWith(h$d)&&(d.push({type:6,index:c}),r.removeAttribute(t));if($$5.test(r.tagName)){const t=r.textContent.split(h$d),s=t.length-1;if(s>0){r.textContent=i$f?i$f.emptyScript:"";for(let i=0;i<s;i++)r.append(t[i],l$a()),E$5.nextNode(),d.push({type:2,index:++c});r.append(t[s],l$a());}}}else if(8===r.nodeType)if(r.data===o$n)d.push({type:2,index:c});else {let t=-1;for(;-1!==(t=r.data.indexOf(h$d,t+1));)d.push({type:7,index:c}),t+=h$d.length-1;}c++;}}static createElement(t,i){const s=r$o.createElement("template");return s.innerHTML=t,s}};function N$5(t,i,s=t,e){if(i===w$6)return i;let h=void 0!==e?s._$Co?.[e]:s._$Cl;const o=c$e(i)?void 0:i._$litDirective$;return h?.constructor!==o&&(h?._$AO?.(!1),void 0===o?h=void 0:(h=new o(t),h._$AT(t,s,e)),void 0!==e?(s._$Co??=[])[e]=h:s._$Cl=h),void 0!==h&&(i=N$5(t,h._$AS(t,i.values),h,e)),i}let S$9 = class S{constructor(t,i){this._$AV=[],this._$AN=void 0,this._$AD=t,this._$AM=i;}get parentNode(){return this._$AM.parentNode}get _$AU(){return this._$AM._$AU}u(t){const{el:{content:i},parts:s}=this._$AD,e=(t?.creationScope??r$o).importNode(i,!0);E$5.currentNode=e;let h=E$5.nextNode(),o=0,n=0,l=s[0];for(;void 0!==l;){if(o===l.index){let i;2===l.type?i=new M$5(h,h.nextSibling,this,t):1===l.type?i=new l.ctor(h,l.name,l.strings,this,t):6===l.type&&(i=new L$6(h,this,t)),this._$AV.push(i),l=s[++n];}o!==l?.index&&(h=E$5.nextNode(),o++);}return E$5.currentNode=r$o,e}p(t){let i=0;for(const s of this._$AV)void 0!==s&&(void 0!==s.strings?(s._$AI(t,s,i),i+=s.strings.length-2):s._$AI(t[i])),i++;}};let M$5 = class M{get _$AU(){return this._$AM?._$AU??this._$Cv}constructor(t,i,s,e){this.type=2,this._$AH=T$7,this._$AN=void 0,this._$AA=t,this._$AB=i,this._$AM=s,this.options=e,this._$Cv=e?.isConnected??!0;}get parentNode(){let t=this._$AA.parentNode;const i=this._$AM;return void 0!==i&&11===t?.nodeType&&(t=i.parentNode),t}get startNode(){return this._$AA}get endNode(){return this._$AB}_$AI(t,i=this){t=N$5(this,t,i),c$e(t)?t===T$7||null==t||""===t?(this._$AH!==T$7&&this._$AR(),this._$AH=T$7):t!==this._$AH&&t!==w$6&&this._(t):void 0!==t._$litType$?this.$(t):void 0!==t.nodeType?this.T(t):u$8(t)?this.k(t):this._(t);}S(t){return this._$AA.parentNode.insertBefore(t,this._$AB)}T(t){this._$AH!==t&&(this._$AR(),this._$AH=this.S(t));}_(t){this._$AH!==T$7&&c$e(this._$AH)?this._$AA.nextSibling.data=t:this.T(r$o.createTextNode(t)),this._$AH=t;}$(t){const{values:i,_$litType$:s}=t,e="number"==typeof s?this._$AC(t):(void 0===s.el&&(s.el=V$5.createElement(C$6(s.h,s.h[0]),this.options)),s);if(this._$AH?._$AD===e)this._$AH.p(i);else {const t=new S$9(e,this),s=t.u(this.options);t.p(i),this.T(s),this._$AH=t;}}_$AC(t){let i=A$6.get(t.strings);return void 0===i&&A$6.set(t.strings,i=new V$5(t)),i}k(t){a$9(this._$AH)||(this._$AH=[],this._$AR());const i=this._$AH;let s,e=0;for(const h of t)e===i.length?i.push(s=new M(this.S(l$a()),this.S(l$a()),this,this.options)):s=i[e],s._$AI(h),e++;e<i.length&&(this._$AR(s&&s._$AB.nextSibling,e),i.length=e);}_$AR(t=this._$AA.nextSibling,i){for(this._$AP?.(!1,!0,i);t&&t!==this._$AB;){const i=t.nextSibling;t.remove(),t=i;}}setConnected(t){void 0===this._$AM&&(this._$Cv=t,this._$AP?.(t));}};let R$4 = class R{get tagName(){return this.element.tagName}get _$AU(){return this._$AM._$AU}constructor(t,i,s,e,h){this.type=1,this._$AH=T$7,this._$AN=void 0,this.element=t,this.name=i,this._$AM=e,this.options=h,s.length>2||""!==s[0]||""!==s[1]?(this._$AH=Array(s.length-1).fill(new String),this.strings=s):this._$AH=T$7;}_$AI(t,i=this,s,e){const h=this.strings;let o=!1;if(void 0===h)t=N$5(this,t,i,0),o=!c$e(t)||t!==this._$AH&&t!==w$6,o&&(this._$AH=t);else {const e=t;let n,r;for(t=h[0],n=0;n<h.length-1;n++)r=N$5(this,e[s+n],i,n),r===w$6&&(r=this._$AH[n]),o||=!c$e(r)||r!==this._$AH[n],r===T$7?t=T$7:t!==T$7&&(t+=(r??"")+h[n+1]),this._$AH[n]=r;}o&&!e&&this.j(t);}j(t){t===T$7?this.element.removeAttribute(this.name):this.element.setAttribute(this.name,t??"");}};let k$6 = class k extends R$4{constructor(){super(...arguments),this.type=3;}j(t){this.element[this.name]=t===T$7?void 0:t;}};let H$5 = class H extends R$4{constructor(){super(...arguments),this.type=4;}j(t){this.element.toggleAttribute(this.name,!!t&&t!==T$7);}};let I$5 = class I extends R$4{constructor(t,i,s,e,h){super(t,i,s,e,h),this.type=5;}_$AI(t,i=this){if((t=N$5(this,t,i,0)??T$7)===w$6)return;const s=this._$AH,e=t===T$7&&s!==T$7||t.capture!==s.capture||t.once!==s.once||t.passive!==s.passive,h=t!==T$7&&(s===T$7||e);e&&this.element.removeEventListener(this.name,this,s),h&&this.element.addEventListener(this.name,this,t),this._$AH=t;}handleEvent(t){"function"==typeof this._$AH?this._$AH.call(this.options?.host??this.element,t):this._$AH.handleEvent(t);}};let L$6 = class L{constructor(t,i,s){this.element=t,this.type=6,this._$AN=void 0,this._$AM=i,this.options=s;}get _$AU(){return this._$AM._$AU}_$AI(t){N$5(this,t);}};const Z$5=t$e.litHtmlPolyfillSupport;Z$5?.(V$5,M$5),(t$e.litHtmlVersions??=[]).push("3.1.2");const j$6=(t,i,s)=>{const e=s?.renderBefore??i;let h=e._$litPart$;if(void 0===h){const t=s?.renderBefore??null;e._$litPart$=h=new M$5(i.insertBefore(l$a(),t),t,void 0,s??{});}return h._$AI(t),h};

    /**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */let s$e = class s extends b$6{constructor(){super(...arguments),this.renderOptions={host:this},this._$Do=void 0;}createRenderRoot(){const t=super.createRenderRoot();return this.renderOptions.renderBefore??=t.firstChild,t}update(t){const i=this.render();this.hasUpdated||(this.renderOptions.isConnected=this.isConnected),super.update(t),this._$Do=j$6(i,this.renderRoot,this.renderOptions);}connectedCallback(){super.connectedCallback(),this._$Do?.setConnected(!0);}disconnectedCallback(){super.disconnectedCallback(),this._$Do?.setConnected(!1);}render(){return w$6}};s$e._$litElement$=!0,s$e[("finalized")]=!0,globalThis.litElementHydrateSupport?.({LitElement:s$e});const r$n=globalThis.litElementPolyfillSupport;r$n?.({LitElement:s$e});(globalThis.litElementVersions??=[]).push("4.0.4");

    let themeTag = undefined;
    let darkModeTag = undefined;
    let lightModeTag = undefined;
    function initializeTheming(themeVariables, themeMode) {
        themeTag = document.createElement('style');
        darkModeTag = document.createElement('style');
        lightModeTag = document.createElement('style');
        themeTag.textContent = createRootStyles(themeVariables).core.cssText;
        darkModeTag.textContent = createRootStyles(themeVariables).dark.cssText;
        lightModeTag.textContent = createRootStyles(themeVariables).light.cssText;
        document.head.appendChild(themeTag);
        document.head.appendChild(darkModeTag);
        document.head.appendChild(lightModeTag);
        setColorTheme(themeMode);
    }
    function setColorTheme(themeMode) {
        if (darkModeTag && lightModeTag) {
            if (themeMode === 'light') {
                darkModeTag.removeAttribute('media');
                lightModeTag.media = 'enabled';
            }
            else {
                lightModeTag.removeAttribute('media');
                darkModeTag.media = 'enabled';
            }
        }
    }
    function setThemeVariables(themeVariables) {
        if (themeTag && darkModeTag && lightModeTag) {
            themeTag.textContent = createRootStyles(themeVariables).core.cssText;
            darkModeTag.textContent = createRootStyles(themeVariables).dark.cssText;
            lightModeTag.textContent = createRootStyles(themeVariables).light.cssText;
        }
    }
    function createRootStyles(themeVariables) {
        return {
            core: i$h `
      @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
      :root {
        --w3m-color-mix-strength: ${r$q(themeVariables?.['--w3m-color-mix-strength']
            ? `${themeVariables['--w3m-color-mix-strength']}%`
            : '0%')};
        --w3m-font-family: ${r$q(themeVariables?.['--w3m-font-family'] ||
            'Inter, Segoe UI, Roboto, Oxygen, Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue, sans-serif;')};
        --w3m-font-size-master: ${r$q(themeVariables?.['--w3m-font-size-master'] || '10px')};
        --w3m-border-radius-master: ${r$q(themeVariables?.['--w3m-border-radius-master'] || '4px')};
        --w3m-z-index: ${r$q(themeVariables?.['--w3m-z-index'] || 100)};

        --wui-font-family: var(--w3m-font-family);

        --wui-font-size-mini: calc(var(--w3m-font-size-master) * 0.8);
        --wui-font-size-micro: var(--w3m-font-size-master);
        --wui-font-size-tiny: calc(var(--w3m-font-size-master) * 1.2);
        --wui-font-size-small: calc(var(--w3m-font-size-master) * 1.4);
        --wui-font-size-paragraph: calc(var(--w3m-font-size-master) * 1.6);
        --wui-font-size-medium: calc(var(--w3m-font-size-master) * 1.8);
        --wui-font-size-large: calc(var(--w3m-font-size-master) * 2);
        --wui-font-size-medium-title: calc(var(--w3m-font-size-master) * 2.4);
        --wui-font-size-2xl: calc(var(--w3m-font-size-master) * 4);

        --wui-border-radius-5xs: var(--w3m-border-radius-master);
        --wui-border-radius-4xs: calc(var(--w3m-border-radius-master) * 1.5);
        --wui-border-radius-3xs: calc(var(--w3m-border-radius-master) * 2);
        --wui-border-radius-xxs: calc(var(--w3m-border-radius-master) * 3);
        --wui-border-radius-xs: calc(var(--w3m-border-radius-master) * 4);
        --wui-border-radius-s: calc(var(--w3m-border-radius-master) * 5);
        --wui-border-radius-m: calc(var(--w3m-border-radius-master) * 7);
        --wui-border-radius-l: calc(var(--w3m-border-radius-master) * 9);
        --wui-border-radius-3xl: calc(var(--w3m-border-radius-master) * 20);

        --wui-font-weight-light: 400;
        --wui-font-weight-regular: 500;
        --wui-font-weight-medium: 600;
        --wui-font-weight-bold: 700;

        --wui-letter-spacing-2xl: -1.6px;
        --wui-letter-spacing-medium-title: -0.96px;
        --wui-letter-spacing-large: -0.8px;
        --wui-letter-spacing-medium: -0.72px;
        --wui-letter-spacing-paragraph: -0.64px;
        --wui-letter-spacing-small: -0.56px;
        --wui-letter-spacing-tiny: -0.48px;
        --wui-letter-spacing-micro: -0.2px;
        --wui-letter-spacing-mini: -0.16px;

        --wui-spacing-0: 0px;
        --wui-spacing-4xs: 2px;
        --wui-spacing-3xs: 4px;
        --wui-spacing-xxs: 6px;
        --wui-spacing-2xs: 7px;
        --wui-spacing-xs: 8px;
        --wui-spacing-1xs: 10px;
        --wui-spacing-s: 12px;
        --wui-spacing-m: 14px;
        --wui-spacing-l: 16px;
        --wui-spacing-2l: 18px;
        --wui-spacing-xl: 20px;
        --wui-spacing-xxl: 24px;
        --wui-spacing-2xl: 32px;
        --wui-spacing-3xl: 40px;
        --wui-spacing-4xl: 90px;

        --wui-icon-box-size-xxs: 14px;
        --wui-icon-box-size-xs: 20px;
        --wui-icon-box-size-sm: 24px;
        --wui-icon-box-size-md: 32px;
        --wui-icon-box-size-lg: 40px;
        --wui-icon-box-size-xl: 64px;

        --wui-icon-size-inherit: inherit;
        --wui-icon-size-xxs: 10px;
        --wui-icon-size-xs: 12px;
        --wui-icon-size-sm: 14px;
        --wui-icon-size-md: 16px;
        --wui-icon-size-mdl: 18px;
        --wui-icon-size-lg: 20px;
        --wui-icon-size-xl: 24px;

        --wui-wallet-image-size-inherit: inherit;
        --wui-wallet-image-size-sm: 40px;
        --wui-wallet-image-size-md: 56px;
        --wui-wallet-image-size-lg: 80px;

        --wui-visual-size-size-inherit: inherit;
        --wui-visual-size-sm: 40px;
        --wui-visual-size-md: 55px;
        --wui-visual-size-lg: 80px;

        --wui-box-size-md: 100px;
        --wui-box-size-lg: 120px;

        --wui-ease-out-power-2: cubic-bezier(0, 0, 0.22, 1);
        --wui-ease-out-power-1: cubic-bezier(0, 0, 0.55, 1);

        --wui-ease-in-power-3: cubic-bezier(0.66, 0, 1, 1);
        --wui-ease-in-power-2: cubic-bezier(0.45, 0, 1, 1);
        --wui-ease-in-power-1: cubic-bezier(0.3, 0, 1, 1);

        --wui-ease-inout-power-1: cubic-bezier(0.45, 0, 0.55, 1);

        --wui-duration-lg: 200ms;
        --wui-duration-md: 125ms;
        --wui-duration-sm: 75ms;

        --wui-path-network-sm: path(
          'M15.4 2.1a5.21 5.21 0 0 1 5.2 0l11.61 6.7a5.21 5.21 0 0 1 2.61 4.52v13.4c0 1.87-1 3.59-2.6 4.52l-11.61 6.7c-1.62.93-3.6.93-5.22 0l-11.6-6.7a5.21 5.21 0 0 1-2.61-4.51v-13.4c0-1.87 1-3.6 2.6-4.52L15.4 2.1Z'
        );

        --wui-path-network-md: path(
          'M43.4605 10.7248L28.0485 1.61089C25.5438 0.129705 22.4562 0.129705 19.9515 1.61088L4.53951 10.7248C2.03626 12.2051 0.5 14.9365 0.5 17.886V36.1139C0.5 39.0635 2.03626 41.7949 4.53951 43.2752L19.9515 52.3891C22.4562 53.8703 25.5438 53.8703 28.0485 52.3891L43.4605 43.2752C45.9637 41.7949 47.5 39.0635 47.5 36.114V17.8861C47.5 14.9365 45.9637 12.2051 43.4605 10.7248Z'
        );

        --wui-path-network-lg: path(
          'M78.3244 18.926L50.1808 2.45078C45.7376 -0.150261 40.2624 -0.150262 35.8192 2.45078L7.6756 18.926C3.23322 21.5266 0.5 26.3301 0.5 31.5248V64.4752C0.5 69.6699 3.23322 74.4734 7.6756 77.074L35.8192 93.5492C40.2624 96.1503 45.7376 96.1503 50.1808 93.5492L78.3244 77.074C82.7668 74.4734 85.5 69.6699 85.5 64.4752V31.5248C85.5 26.3301 82.7668 21.5266 78.3244 18.926Z'
        );

        --wui-width-network-sm: 36px;
        --wui-width-network-md: 48px;
        --wui-width-network-lg: 86px;

        --wui-height-network-sm: 40px;
        --wui-height-network-md: 54px;
        --wui-height-network-lg: 96px;

        --wui-icon-size-network-xs: 12px;
        --wui-icon-size-network-sm: 16px;
        --wui-icon-size-network-md: 24px;
        --wui-icon-size-network-lg: 42px;

        --wui-color-inherit: inherit;

        --wui-color-inverse-100: #fff;
        --wui-color-inverse-000: #000;

        --wui-cover: rgba(20, 20, 20, 0.8);

        --wui-color-modal-bg: var(--wui-color-modal-bg-base);

        --wui-color-blue-100: var(--wui-color-blue-base-100);

        --wui-color-accent-100: var(--wui-color-accent-base-100);
        --wui-color-accent-090: var(--wui-color-accent-base-090);
        --wui-color-accent-080: var(--wui-color-accent-base-080);

        --wui-accent-glass-090: var(--wui-accent-glass-base-090);
        --wui-accent-glass-080: var(--wui-accent-glass-base-080);
        --wui-accent-glass-020: var(--wui-accent-glass-base-020);
        --wui-accent-glass-015: var(--wui-accent-glass-base-015);
        --wui-accent-glass-010: var(--wui-accent-glass-base-010);
        --wui-accent-glass-005: var(--wui-accent-glass-base-005);
        --wui-accent-glass-002: var(--wui-accent-glass-base-002);

        --wui-color-fg-100: var(--wui-color-fg-base-100);
        --wui-color-fg-125: var(--wui-color-fg-base-125);
        --wui-color-fg-150: var(--wui-color-fg-base-150);
        --wui-color-fg-175: var(--wui-color-fg-base-175);
        --wui-color-fg-200: var(--wui-color-fg-base-200);
        --wui-color-fg-225: var(--wui-color-fg-base-225);
        --wui-color-fg-250: var(--wui-color-fg-base-250);
        --wui-color-fg-275: var(--wui-color-fg-base-275);
        --wui-color-fg-300: var(--wui-color-fg-base-300);

        --wui-color-bg-100: var(--wui-color-bg-base-100);
        --wui-color-bg-125: var(--wui-color-bg-base-125);
        --wui-color-bg-150: var(--wui-color-bg-base-150);
        --wui-color-bg-175: var(--wui-color-bg-base-175);
        --wui-color-bg-200: var(--wui-color-bg-base-200);
        --wui-color-bg-225: var(--wui-color-bg-base-225);
        --wui-color-bg-250: var(--wui-color-bg-base-250);
        --wui-color-bg-275: var(--wui-color-bg-base-275);
        --wui-color-bg-300: var(--wui-color-bg-base-300);

        --wui-color-success-100: var(--wui-color-success-base-100);
        --wui-color-error-100: var(--wui-color-error-base-100);

        --wui-icon-box-bg-error-100: var(--wui-icon-box-bg-error-base-100);
        --wui-icon-box-bg-blue-100: var(--wui-icon-box-bg-blue-base-100);
        --wui-icon-box-bg-success-100: var(--wui-icon-box-bg-success-base-100);
        --wui-icon-box-bg-inverse-100: var(--wui-icon-box-bg-inverse-base-100);

        --wui-all-wallets-bg-100: var(--wui-all-wallets-bg-base-100);

        --wui-avatar-border: var(--wui-avatar-border-base);

        --wui-thumbnail-border: var(--wui-thumbnail-border-base);

        --wui-box-shadow-blue: rgba(71, 161, 255, 0.16);
      }

      @supports (background: color-mix(in srgb, white 50%, black)) {
        :root {
          --wui-color-modal-bg: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-modal-bg-base)
          );

          --wui-box-shadow-blue: color-mix(in srgb, var(--wui-color-accent-100) 16%, transparent);

          --wui-color-accent-090: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 90%,
            var(--w3m-default)
          );
          --wui-color-accent-080: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 80%,
            var(--w3m-default)
          );

          --wui-color-accent-090: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 90%,
            transparent
          );
          --wui-color-accent-080: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 80%,
            transparent
          );

          --wui-accent-glass-090: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 90%,
            transparent
          );
          --wui-accent-glass-080: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 80%,
            transparent
          );
          --wui-accent-glass-020: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 20%,
            transparent
          );
          --wui-accent-glass-015: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 15%,
            transparent
          );
          --wui-accent-glass-010: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 10%,
            transparent
          );
          --wui-accent-glass-005: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 5%,
            transparent
          );
          --wui-color-accent-002: color-mix(
            in srgb,
            var(--wui-color-accent-base-100) 2%,
            transparent
          );

          --wui-color-fg-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-base-100)
          );
          --wui-color-fg-125: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-base-125)
          );
          --wui-color-fg-150: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-base-150)
          );
          --wui-color-fg-175: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-base-175)
          );
          --wui-color-fg-200: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-base-200)
          );
          --wui-color-fg-225: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-base-225)
          );
          --wui-color-fg-250: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-base-250)
          );
          --wui-color-fg-275: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-base-275)
          );
          --wui-color-fg-300: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-fg-base-300)
          );

          --wui-color-bg-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-base-100)
          );
          --wui-color-bg-125: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-base-125)
          );
          --wui-color-bg-150: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-base-150)
          );
          --wui-color-bg-175: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-base-175)
          );
          --wui-color-bg-200: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-base-200)
          );
          --wui-color-bg-225: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-base-225)
          );
          --wui-color-bg-250: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-base-250)
          );
          --wui-color-bg-275: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-base-275)
          );
          --wui-color-bg-300: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-bg-base-300)
          );

          --wui-color-success-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-success-base-100)
          );
          --wui-color-error-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-color-error-base-100)
          );

          --wui-icon-box-bg-error-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-error-base-100)
          );
          --wui-icon-box-bg-accent-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-blue-base-100)
          );
          --wui-icon-box-bg-success-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-success-base-100)
          );
          --wui-icon-box-bg-inverse-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-icon-box-bg-inverse-base-100)
          );

          --wui-all-wallets-bg-100: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-all-wallets-bg-base-100)
          );

          --wui-avatar-border: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-avatar-border-base)
          );

          --wui-thumbnail-border: color-mix(
            in srgb,
            var(--w3m-color-mix) var(--w3m-color-mix-strength),
            var(--wui-thumbnail-border-base)
          );
        }
      }
    `,
            light: i$h `
      :root {
        --w3m-color-mix: ${r$q(themeVariables?.['--w3m-color-mix'] || '#fff')};
        --w3m-accent: ${r$q(themeVariables?.['--w3m-accent'] || '#47a1ff')};
        --w3m-default: #fff;

        --wui-color-modal-bg-base: #191a1a;

        --wui-color-blue-base-100: #47a1ff;

        --wui-color-accent-base-100: var(--w3m-accent);
        --wui-color-accent-base-090: #59aaff;
        --wui-color-accent-base-080: #6cb4ff;

        --wui-accent-glass-base-090: rgba(71, 161, 255, 0.9);
        --wui-accent-glass-base-080: rgba(71, 161, 255, 0.8);
        --wui-accent-glass-base-020: rgba(71, 161, 255, 0.2);
        --wui-accent-glass-base-015: rgba(71, 161, 255, 0.15);
        --wui-accent-glass-base-010: rgba(71, 161, 255, 0.1);
        --wui-accent-glass-base-005: rgba(71, 161, 255, 0.05);
        --wui-accent-glass-base-002: rgba(71, 161, 255, 0.02);

        --wui-color-fg-base-100: #e4e7e7;
        --wui-color-fg-base-125: #d0d5d5;
        --wui-color-fg-base-150: #a8b1b1;
        --wui-color-fg-base-175: #a8b0b0;
        --wui-color-fg-base-200: #949e9e;
        --wui-color-fg-base-225: #868f8f;
        --wui-color-fg-base-250: #788080;
        --wui-color-fg-base-275: #788181;
        --wui-color-fg-base-300: #6e7777;

        --wui-color-bg-base-100: #141414;
        --wui-color-bg-base-125: #191a1a;
        --wui-color-bg-base-150: #1e1f1f;
        --wui-color-bg-base-175: #222525;
        --wui-color-bg-base-200: #272a2a;
        --wui-color-bg-base-225: #2c3030;
        --wui-color-bg-base-250: #313535;
        --wui-color-bg-base-275: #363b3b;
        --wui-color-bg-base-300: #3b4040;

        --wui-color-success-base-100: #26d962;
        --wui-color-error-base-100: #f25a67;

        --wui-success-glass-001: rgba(38, 217, 98, 0.01);
        --wui-success-glass-002: rgba(38, 217, 98, 0.02);
        --wui-success-glass-005: rgba(38, 217, 98, 0.05);
        --wui-success-glass-010: rgba(38, 217, 98, 0.1);
        --wui-success-glass-015: rgba(38, 217, 98, 0.15);
        --wui-success-glass-020: rgba(38, 217, 98, 0.2);
        --wui-success-glass-025: rgba(38, 217, 98, 0.25);
        --wui-success-glass-030: rgba(38, 217, 98, 0.3);
        --wui-success-glass-060: rgba(38, 217, 98, 0.6);
        --wui-success-glass-080: rgba(38, 217, 98, 0.8);

        --wui-error-glass-001: rgba(242, 90, 103, 0.01);
        --wui-error-glass-002: rgba(242, 90, 103, 0.02);
        --wui-error-glass-005: rgba(242, 90, 103, 0.05);
        --wui-error-glass-010: rgba(242, 90, 103, 0.1);
        --wui-error-glass-015: rgba(242, 90, 103, 0.15);
        --wui-error-glass-020: rgba(242, 90, 103, 0.2);
        --wui-error-glass-025: rgba(242, 90, 103, 0.25);
        --wui-error-glass-030: rgba(242, 90, 103, 0.3);
        --wui-error-glass-060: rgba(242, 90, 103, 0.6);
        --wui-error-glass-080: rgba(242, 90, 103, 0.8);

        --wui-icon-box-bg-error-base-100: #3c2426;
        --wui-icon-box-bg-blue-base-100: #20303f;
        --wui-icon-box-bg-success-base-100: #1f3a28;
        --wui-icon-box-bg-inverse-base-100: #243240;

        --wui-all-wallets-bg-base-100: #222b35;

        --wui-avatar-border-base: #252525;

        --wui-thumbnail-border-base: #252525;

        --wui-gray-glass-001: rgba(255, 255, 255, 0.01);
        --wui-gray-glass-002: rgba(255, 255, 255, 0.02);
        --wui-gray-glass-005: rgba(255, 255, 255, 0.05);
        --wui-gray-glass-010: rgba(255, 255, 255, 0.1);
        --wui-gray-glass-015: rgba(255, 255, 255, 0.15);
        --wui-gray-glass-020: rgba(255, 255, 255, 0.2);
        --wui-gray-glass-025: rgba(255, 255, 255, 0.25);
        --wui-gray-glass-030: rgba(255, 255, 255, 0.3);
        --wui-gray-glass-060: rgba(255, 255, 255, 0.6);
        --wui-gray-glass-080: rgba(255, 255, 255, 0.8);
        --wui-gray-glass-090: rgba(255, 255, 255, 0.9);
      }
    `,
            dark: i$h `
      :root {
        --w3m-color-mix: ${r$q(themeVariables?.['--w3m-color-mix'] || '#000')};
        --w3m-accent: ${r$q(themeVariables?.['--w3m-accent'] || '#3396ff')};
        --w3m-default: #000;

        --wui-color-modal-bg-base: #fff;

        --wui-color-blue-base-100: #3396ff;

        --wui-color-accent-base-100: var(--w3m-accent);
        --wui-color-accent-base-090: #2d7dd2;
        --wui-color-accent-base-080: #2978cc;

        --wui-accent-glass-base-090: rgba(51, 150, 255, 0.9);
        --wui-accent-glass-base-080: rgba(51, 150, 255, 0.8);
        --wui-accent-glass-base-020: rgba(51, 150, 255, 0.2);
        --wui-accent-glass-base-015: rgba(51, 150, 255, 0.15);
        --wui-accent-glass-base-010: rgba(51, 150, 255, 0.1);
        --wui-accent-glass-base-005: rgba(51, 150, 255, 0.05);
        --wui-accent-glass-base-002: rgba(51, 150, 255, 0.02);

        --wui-color-fg-base-100: #141414;
        --wui-color-fg-base-125: #2d3131;
        --wui-color-fg-base-150: #474d4d;
        --wui-color-fg-base-175: #636d6d;
        --wui-color-fg-base-200: #798686;
        --wui-color-fg-base-225: #828f8f;
        --wui-color-fg-base-250: #8b9797;
        --wui-color-fg-base-275: #95a0a0;
        --wui-color-fg-base-300: #9ea9a9;

        --wui-color-bg-base-100: #ffffff;
        --wui-color-bg-base-125: #f5fafa;
        --wui-color-bg-base-150: #f3f8f8;
        --wui-color-bg-base-175: #eef4f4;
        --wui-color-bg-base-200: #eaf1f1;
        --wui-color-bg-base-225: #e5eded;
        --wui-color-bg-base-250: #e1e9e9;
        --wui-color-bg-base-275: #dce7e7;
        --wui-color-bg-base-300: #d8e3e3;

        --wui-color-success-base-100: #26b562;
        --wui-color-error-base-100: #f05142;

        --wui-success-glass-001: rgba(38, 181, 98, 0.01);
        --wui-success-glass-002: rgba(38, 181, 98, 0.02);
        --wui-success-glass-005: rgba(38, 181, 98, 0.05);
        --wui-success-glass-010: rgba(38, 181, 98, 0.1);
        --wui-success-glass-015: rgba(38, 181, 98, 0.15);
        --wui-success-glass-020: rgba(38, 181, 98, 0.2);
        --wui-success-glass-025: rgba(38, 181, 98, 0.25);
        --wui-success-glass-030: rgba(38, 181, 98, 0.3);
        --wui-success-glass-060: rgba(38, 181, 98, 0.6);
        --wui-success-glass-080: rgba(38, 181, 98, 0.8);

        --wui-error-glass-001: rgba(240, 81, 66, 0.01);
        --wui-error-glass-002: rgba(240, 81, 66, 0.02);
        --wui-error-glass-005: rgba(240, 81, 66, 0.05);
        --wui-error-glass-010: rgba(240, 81, 66, 0.1);
        --wui-error-glass-015: rgba(240, 81, 66, 0.15);
        --wui-error-glass-020: rgba(240, 81, 66, 0.2);
        --wui-error-glass-025: rgba(240, 81, 66, 0.25);
        --wui-error-glass-030: rgba(240, 81, 66, 0.3);
        --wui-error-glass-060: rgba(240, 81, 66, 0.6);
        --wui-error-glass-080: rgba(240, 81, 66, 0.8);

        --wui-icon-box-bg-error-base-100: #f4dfdd;
        --wui-icon-box-bg-blue-base-100: #d9ecfb;
        --wui-icon-box-bg-success-base-100: #daf0e4;
        --wui-icon-box-bg-inverse-base-100: #dcecfc;

        --wui-all-wallets-bg-base-100: #e8f1fa;

        --wui-avatar-border-base: #f3f4f4;

        --wui-thumbnail-border-base: #eaefef;

        --wui-gray-glass-001: rgba(0, 0, 0, 0.01);
        --wui-gray-glass-002: rgba(0, 0, 0, 0.02);
        --wui-gray-glass-005: rgba(0, 0, 0, 0.05);
        --wui-gray-glass-010: rgba(0, 0, 0, 0.1);
        --wui-gray-glass-015: rgba(0, 0, 0, 0.15);
        --wui-gray-glass-020: rgba(0, 0, 0, 0.2);
        --wui-gray-glass-025: rgba(0, 0, 0, 0.25);
        --wui-gray-glass-030: rgba(0, 0, 0, 0.3);
        --wui-gray-glass-060: rgba(0, 0, 0, 0.6);
        --wui-gray-glass-080: rgba(0, 0, 0, 0.8);
        --wui-gray-glass-090: rgba(0, 0, 0, 0.9);
      }
    `
        };
    }
    const resetStyles = i$h `
  *,
  *::after,
  *::before,
  :host {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    font-style: normal;
    text-rendering: optimizeSpeed;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    -webkit-tap-highlight-color: transparent;
    font-family: var(--wui-font-family);
    backface-visibility: hidden;
  }
`;
    const elementStyles = i$h `
  button,
  a {
    cursor: pointer;
    display: flex;
    justify-content: center;
    align-items: center;
    position: relative;
    transition: all var(--wui-ease-out-power-1) var(--wui-duration-lg);
    outline: none;
    border: 1px solid transparent;
    column-gap: var(--wui-spacing-3xs);
    background-color: transparent;
    text-decoration: none;
  }

  @media (hover: hover) and (pointer: fine) {
    button:hover:enabled {
      background-color: var(--wui-gray-glass-005);
    }

    button:active:enabled {
      transition: all var(--wui-ease-out-power-2) var(--wui-duration-sm);
      background-color: var(--wui-gray-glass-010);
    }

    button[data-variant='fill']:hover:enabled {
      background-color: var(--wui-color-accent-090);
    }

    button[data-variant='accentBg']:hover:enabled {
      background: var(--wui-accent-glass-015);
    }

    button[data-variant='accentBg']:active:enabled {
      background: var(--wui-accent-glass-020);
    }
  }

  button:disabled {
    cursor: not-allowed;
    background-color: var(--wui-gray-glass-005);
  }

  button[data-variant='shade']:disabled,
  button[data-variant='accent']:disabled,
  button[data-variant='accentBg']:disabled {
    background-color: var(--wui-gray-glass-010);
    color: var(--wui-gray-glass-015);
    filter: grayscale(1);
  }

  button:disabled > wui-wallet-image,
  button:disabled > wui-all-wallets-image,
  button:disabled > wui-network-image,
  button:disabled > wui-image,
  button:disabled > wui-icon-box,
  button:disabled > wui-transaction-visual,
  button:disabled > wui-logo {
    filter: grayscale(1);
  }

  button:focus-visible,
  a:focus-visible {
    border: 1px solid var(--wui-color-accent-100);
    background-color: var(--wui-gray-glass-005);
    -webkit-box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
    -moz-box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
    box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
  }

  button[data-variant='fill']:focus-visible {
    background-color: var(--wui-color-accent-090);
  }

  button[data-variant='fill'] {
    color: var(--wui-color-inverse-100);
    background-color: var(--wui-color-accent-100);
  }

  button[data-variant='fill']:disabled {
    color: var(--wui-gray-glass-015);
    background-color: var(--wui-gray-glass-015);
  }

  button[data-variant='fill']:disabled > wui-icon {
    color: var(--wui-gray-glass-015);
  }

  button[data-variant='shade'] {
    color: var(--wui-color-fg-200);
  }

  button[data-variant='accent'],
  button[data-variant='accentBg'] {
    color: var(--wui-color-accent-100);
  }

  button[data-variant='accentBg'] {
    background: var(--wui-accent-glass-010);
    border: 1px solid var(--wui-accent-glass-010);
  }

  button[data-variant='fullWidth'] {
    width: 100%;
    border-radius: var(--wui-border-radius-xs);
    height: 56px;
    border: none;
    background-color: var(--wui-gray-glass-002);
    color: var(--wui-color-fg-200);
    gap: var(--wui-spacing-xs);
  }

  button:active:enabled {
    background-color: var(--wui-gray-glass-010);
  }

  button[data-variant='fill']:active:enabled {
    background-color: var(--wui-color-accent-080);
    border: 1px solid var(--wui-gray-glass-010);
  }

  input {
    border: none;
    outline: none;
    appearance: none;
  }
`;
    const colorStyles = i$h `
  .wui-color-inherit {
    color: var(--wui-color-inherit);
  }

  .wui-color-accent-100 {
    color: var(--wui-color-accent-100);
  }

  .wui-color-error-100 {
    color: var(--wui-color-error-100);
  }

  .wui-color-success-100 {
    color: var(--wui-color-success-100);
  }

  .wui-color-inverse-100 {
    color: var(--wui-color-inverse-100);
  }

  .wui-color-inverse-000 {
    color: var(--wui-color-inverse-000);
  }

  .wui-color-fg-100 {
    color: var(--wui-color-fg-100);
  }

  .wui-color-fg-200 {
    color: var(--wui-color-fg-200);
  }

  .wui-color-fg-300 {
    color: var(--wui-color-fg-300);
  }

  .wui-bg-color-inherit {
    background-color: var(--wui-color-inherit);
  }

  .wui-bg-color-blue-100 {
    background-color: var(--wui-color-accent-100);
  }

  .wui-bg-color-error-100 {
    background-color: var(--wui-color-error-100);
  }

  .wui-bg-color-success-100 {
    background-color: var(--wui-color-success-100);
  }

  .wui-bg-color-inverse-100 {
    background-color: var(--wui-color-inverse-100);
  }

  .wui-bg-color-inverse-000 {
    background-color: var(--wui-color-inverse-000);
  }

  .wui-bg-color-fg-100 {
    background-color: var(--wui-color-fg-100);
  }

  .wui-bg-color-fg-200 {
    background-color: var(--wui-color-fg-200);
  }

  .wui-bg-color-fg-300 {
    background-color: var(--wui-color-fg-300);
  }
`;

    function standardCustomElement(tagName, descriptor) {
        const { kind, elements } = descriptor;
        return {
            kind,
            elements,
            finisher(clazz) {
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, clazz);
                }
            }
        };
    }
    function legacyCustomElement(tagName, clazz) {
        if (!customElements.get(tagName)) {
            customElements.define(tagName, clazz);
        }
        return clazz;
    }
    function customElement(tagName) {
        return function create(classOrDescriptor) {
            return typeof classOrDescriptor === 'function'
                ? legacyCustomElement(tagName, classOrDescriptor)
                : standardCustomElement(tagName, classOrDescriptor);
        };
    }

    var styles$1J = i$h `
  :host {
    display: block;
    border-radius: clamp(0px, var(--wui-border-radius-l), 44px);
    box-shadow: 0 0 0 1px var(--wui-gray-glass-005);
    background-color: var(--wui-color-modal-bg);
    overflow: hidden;
  }
`;

    var __decorate$26 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let WuiCard = class WuiCard extends s$e {
        render() {
            return x$5 `<slot></slot>`;
        }
    };
    WuiCard.styles = [resetStyles, styles$1J];
    WuiCard = __decorate$26([
        customElement('wui-card')
    ], WuiCard);

    /**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */const o$m={attribute:!0,type:String,converter:u$9,reflect:!1,hasChanged:f$c},r$m=(t=o$m,e,r)=>{const{kind:n,metadata:i}=r;let s=globalThis.litPropertyMetadata.get(i);if(void 0===s&&globalThis.litPropertyMetadata.set(i,s=new Map),s.set(r.name,t),"accessor"===n){const{name:o}=r;return {set(r){const n=e.get.call(this);e.set.call(this,r),this.requestUpdate(o,n,t);},init(e){return void 0!==e&&this.P(o,void 0,t),e}}}if("setter"===n){const{name:o}=r;return function(r){const n=this[o];e.call(this,r),this.requestUpdate(o,n,t);}}throw Error("Unsupported decorator location: "+n)};function n$j(t){return (e,o)=>"object"==typeof o?r$m(t,e,o):((t,e,o)=>{const r=e.hasOwnProperty(o);return e.constructor.createProperty(o,r?{...t,wrapped:!0}:t),r?Object.getOwnPropertyDescriptor(e,o):void 0})(t,e,o)}

    /**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */function r$l(r){return n$j({...r,state:!0,attribute:!1})}

    var styles$1I = i$h `
  :host {
    display: flex;
    aspect-ratio: 1 / 1;
    color: var(--local-color);
    width: var(--local-width);
  }

  svg {
    width: inherit;
    height: inherit;
    object-fit: contain;
    object-position: center;
  }
`;

    const allWalletsSvg = b$5 `<svg fill="none" viewBox="0 0 24 24">
  <path
    style="fill: var(--wui-color-accent-100);"
    d="M10.2 6.6a3.6 3.6 0 1 1-7.2 0 3.6 3.6 0 0 1 7.2 0ZM21 6.6a3.6 3.6 0 1 1-7.2 0 3.6 3.6 0 0 1 7.2 0ZM10.2 17.4a3.6 3.6 0 1 1-7.2 0 3.6 3.6 0 0 1 7.2 0ZM21 17.4a3.6 3.6 0 1 1-7.2 0 3.6 3.6 0 0 1 7.2 0Z"
  />
</svg>`;

    const arrowBottomCircleSvg = b$5 `<svg
  fill="none"
  viewBox="0 0 21 20"
>
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M10.5 2.42908C6.31875 2.42908 2.92859 5.81989 2.92859 10.0034C2.92859 14.1869 6.31875 17.5777 10.5 17.5777C14.6813 17.5777 18.0714 14.1869 18.0714 10.0034C18.0714 5.81989 14.6813 2.42908 10.5 2.42908ZM0.928589 10.0034C0.928589 4.71596 5.21355 0.429077 10.5 0.429077C15.7865 0.429077 20.0714 4.71596 20.0714 10.0034C20.0714 15.2908 15.7865 19.5777 10.5 19.5777C5.21355 19.5777 0.928589 15.2908 0.928589 10.0034ZM10.5 5.75003C11.0523 5.75003 11.5 6.19774 11.5 6.75003L11.5 10.8343L12.7929 9.54137C13.1834 9.15085 13.8166 9.15085 14.2071 9.54137C14.5976 9.9319 14.5976 10.5651 14.2071 10.9556L11.2071 13.9556C10.8166 14.3461 10.1834 14.3461 9.79291 13.9556L6.79291 10.9556C6.40239 10.5651 6.40239 9.9319 6.79291 9.54137C7.18343 9.15085 7.8166 9.15085 8.20712 9.54137L9.50002 10.8343L9.50002 6.75003C9.50002 6.19774 9.94773 5.75003 10.5 5.75003Z"
    clip-rule="evenodd"
  /></svg
>`;

    const appStoreSvg = b$5 `
<svg width="36" height="36">
  <path
    d="M28.724 0H7.271A7.269 7.269 0 0 0 0 7.272v21.46A7.268 7.268 0 0 0 7.271 36H28.73A7.272 7.272 0 0 0 36 28.728V7.272A7.275 7.275 0 0 0 28.724 0Z"
    fill="url(#a)"
  />
  <path
    d="m17.845 8.271.729-1.26a1.64 1.64 0 1 1 2.843 1.638l-7.023 12.159h5.08c1.646 0 2.569 1.935 1.853 3.276H6.434a1.632 1.632 0 0 1-1.638-1.638c0-.909.73-1.638 1.638-1.638h4.176l5.345-9.265-1.67-2.898a1.642 1.642 0 0 1 2.844-1.638l.716 1.264Zm-6.317 17.5-1.575 2.732a1.64 1.64 0 1 1-2.844-1.638l1.17-2.025c1.323-.41 2.398-.095 3.249.931Zm13.56-4.954h4.262c.909 0 1.638.729 1.638 1.638 0 .909-.73 1.638-1.638 1.638h-2.367l1.597 2.772c.45.788.185 1.782-.602 2.241a1.642 1.642 0 0 1-2.241-.603c-2.69-4.666-4.711-8.159-6.052-10.485-1.372-2.367-.391-4.743.576-5.549 1.075 1.846 2.682 4.631 4.828 8.348Z"
    fill="#fff"
  />
  <defs>
    <linearGradient id="a" x1="18" y1="0" x2="18" y2="36" gradientUnits="userSpaceOnUse">
      <stop stop-color="#18BFFB" />
      <stop offset="1" stop-color="#2072F3" />
    </linearGradient>
  </defs>
</svg>`;

    const appleSvg = b$5 `<svg fill="none" viewBox="0 0 40 40">
  <g clip-path="url(#a)">
    <g clip-path="url(#b)">
      <circle cx="20" cy="19.89" r="20" fill="#000" />
      <g clip-path="url(#c)">
        <path
          fill="#fff"
          d="M28.77 23.3c-.69 1.99-2.75 5.52-4.87 5.56-1.4.03-1.86-.84-3.46-.84-1.61 0-2.12.81-3.45.86-2.25.1-5.72-5.1-5.72-9.62 0-4.15 2.9-6.2 5.42-6.25 1.36-.02 2.64.92 3.47.92.83 0 2.38-1.13 4.02-.97.68.03 2.6.28 3.84 2.08-3.27 2.14-2.76 6.61.75 8.25ZM24.2 7.88c-2.47.1-4.49 2.69-4.2 4.84 2.28.17 4.47-2.39 4.2-4.84Z"
        />
      </g>
    </g>
  </g>
  <defs>
    <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
    <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
    <clipPath id="c"><path fill="#fff" d="M8 7.89h24v24H8z" /></clipPath>
  </defs>
</svg>`;

    const arrowBottomSvg = b$5 `<svg fill="none" viewBox="0 0 14 15">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M7 1.99a1 1 0 0 1 1 1v7.58l2.46-2.46a1 1 0 0 1 1.41 1.42L7.7 13.69a1 1 0 0 1-1.41 0L2.12 9.53A1 1 0 0 1 3.54 8.1L6 10.57V3a1 1 0 0 1 1-1Z"
    clip-rule="evenodd"
  />
</svg>`;

    const arrowLeftSvg = b$5 `<svg fill="none" viewBox="0 0 14 15">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M13 7.99a1 1 0 0 1-1 1H4.4l2.46 2.46a1 1 0 1 1-1.41 1.41L1.29 8.7a1 1 0 0 1 0-1.41L5.46 3.1a1 1 0 0 1 1.41 1.42L4.41 6.99H12a1 1 0 0 1 1 1Z"
    clip-rule="evenodd"
  />
</svg>`;

    const arrowRightSvg = b$5 `<svg fill="none" viewBox="0 0 14 15">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M1 7.99a1 1 0 0 1 1-1h7.58L7.12 4.53A1 1 0 1 1 8.54 3.1l4.16 4.17a1 1 0 0 1 0 1.41l-4.16 4.17a1 1 0 1 1-1.42-1.41l2.46-2.46H2a1 1 0 0 1-1-1Z"
    clip-rule="evenodd"
  />
</svg>`;

    const arrowTopSvg = b$5 `<svg fill="none" viewBox="0 0 14 15">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M7 13.99a1 1 0 0 1-1-1V5.4L3.54 7.86a1 1 0 0 1-1.42-1.41L6.3 2.28a1 1 0 0 1 1.41 0l4.17 4.17a1 1 0 1 1-1.41 1.41L8 5.4v7.59a1 1 0 0 1-1 1Z"
    clip-rule="evenodd"
  />
</svg>`;

    const browserSvg$1 = b$5 `<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M4 6.4a1 1 0 0 1-.46.89 6.98 6.98 0 0 0 .38 6.18A7 7 0 0 0 16.46 7.3a1 1 0 0 1-.47-.92 7 7 0 0 0-12 .03Zm-2.02-.5a9 9 0 1 1 16.03 8.2A9 9 0 0 1 1.98 5.9Z"
    clip-rule="evenodd"
  />
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M6.03 8.63c-1.46-.3-2.72-.75-3.6-1.35l-.02-.01-.14-.11a1 1 0 0 1 1.2-1.6l.1.08c.6.4 1.52.74 2.69 1 .16-.99.39-1.88.67-2.65.3-.79.68-1.5 1.15-2.02A2.58 2.58 0 0 1 9.99 1c.8 0 1.45.44 1.92.97.47.52.84 1.23 1.14 2.02.29.77.52 1.66.68 2.64a8 8 0 0 0 2.7-1l.26-.18h.48a1 1 0 0 1 .12 2c-.86.51-2.01.91-3.34 1.18a22.24 22.24 0 0 1-.03 3.19c1.45.29 2.7.73 3.58 1.31a1 1 0 0 1-1.1 1.68c-.6-.4-1.56-.76-2.75-1-.15.8-.36 1.55-.6 2.2-.3.79-.67 1.5-1.14 2.02-.47.53-1.12.97-1.92.97-.8 0-1.45-.44-1.91-.97a6.51 6.51 0 0 1-1.15-2.02c-.24-.65-.44-1.4-.6-2.2-1.18.24-2.13.6-2.73.99a1 1 0 1 1-1.1-1.67c.88-.58 2.12-1.03 3.57-1.31a22.03 22.03 0 0 1-.04-3.2Zm2.2-1.7c.15-.86.34-1.61.58-2.24.24-.65.51-1.12.76-1.4.25-.28.4-.29.42-.29.03 0 .17.01.42.3.25.27.52.74.77 1.4.23.62.43 1.37.57 2.22a19.96 19.96 0 0 1-3.52 0Zm-.18 4.6a20.1 20.1 0 0 1-.03-2.62 21.95 21.95 0 0 0 3.94 0 20.4 20.4 0 0 1-.03 2.63 21.97 21.97 0 0 0-3.88 0Zm.27 2c.13.66.3 1.26.49 1.78.24.65.51 1.12.76 1.4.25.28.4.29.42.29.03 0 .17-.01.42-.3.25-.27.52-.74.77-1.4.19-.5.36-1.1.49-1.78a20.03 20.03 0 0 0-3.35 0Z"
    clip-rule="evenodd"
  />
</svg>`;

    const checkmarkSvg = b$5 `<svg
  xmlns="http://www.w3.org/2000/svg"
  width="12"
  height="12"
  viewBox="0 0 12 12"
  fill="none"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M10.537 2.34245C10.8997 2.64654 10.9471 3.187 10.6429 3.54959L5.61072 9.54757C5.45645 9.73144 5.23212 9.84222 4.99229 9.85295C4.75247 9.86368 4.51914 9.77337 4.34906 9.60401L1.40881 6.6761C1.07343 6.34213 1.07238 5.7996 1.40647 5.46433C1.74055 5.12906 2.28326 5.12801 2.61865 5.46198L4.89731 7.73108L9.32942 2.44834C9.63362 2.08576 10.1743 2.03835 10.537 2.34245Z"
    fill="currentColor"
  /></svg
>`;

    const chevronBottomSvg = b$5 `<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M1.46 4.96a1 1 0 0 1 1.41 0L8 10.09l5.13-5.13a1 1 0 1 1 1.41 1.41l-5.83 5.84a1 1 0 0 1-1.42 0L1.46 6.37a1 1 0 0 1 0-1.41Z"
    clip-rule="evenodd"
  />
</svg>`;

    const chevronLeftSvg = b$5 `<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M11.04 1.46a1 1 0 0 1 0 1.41L5.91 8l5.13 5.13a1 1 0 1 1-1.41 1.41L3.79 8.71a1 1 0 0 1 0-1.42l5.84-5.83a1 1 0 0 1 1.41 0Z"
    clip-rule="evenodd"
  />
</svg>`;

    const chevronRightSvg = b$5 `<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M4.96 14.54a1 1 0 0 1 0-1.41L10.09 8 4.96 2.87a1 1 0 0 1 1.41-1.41l5.84 5.83a1 1 0 0 1 0 1.42l-5.84 5.83a1 1 0 0 1-1.41 0Z"
    clip-rule="evenodd"
  />
</svg>`;

    const chevronTopSvg = b$5 `<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M14.54 11.04a1 1 0 0 1-1.41 0L8 5.92l-5.13 5.12a1 1 0 1 1-1.41-1.41l5.83-5.84a1 1 0 0 1 1.42 0l5.83 5.84a1 1 0 0 1 0 1.41Z"
    clip-rule="evenodd"
  />
</svg>`;

    const chromeStoreSvg = b$5 `<svg width="36" height="36" fill="none">
  <path
    fill="#fff"
    fill-opacity=".05"
    d="M0 14.94c0-5.55 0-8.326 1.182-10.4a9 9 0 0 1 3.359-3.358C6.614 0 9.389 0 14.94 0h6.12c5.55 0 8.326 0 10.4 1.182a9 9 0 0 1 3.358 3.359C36 6.614 36 9.389 36 14.94v6.12c0 5.55 0 8.326-1.182 10.4a9 9 0 0 1-3.359 3.358C29.386 36 26.611 36 21.06 36h-6.12c-5.55 0-8.326 0-10.4-1.182a9 9 0 0 1-3.358-3.359C0 29.386 0 26.611 0 21.06v-6.12Z"
  />
  <path
    stroke="#fff"
    stroke-opacity=".05"
    d="M14.94.5h6.12c2.785 0 4.84 0 6.46.146 1.612.144 2.743.43 3.691.97a8.5 8.5 0 0 1 3.172 3.173c.541.948.826 2.08.971 3.692.145 1.62.146 3.675.146 6.459v6.12c0 2.785 0 4.84-.146 6.46-.145 1.612-.43 2.743-.97 3.691a8.5 8.5 0 0 1-3.173 3.172c-.948.541-2.08.826-3.692.971-1.62.145-3.674.146-6.459.146h-6.12c-2.784 0-4.84 0-6.46-.146-1.612-.145-2.743-.43-3.691-.97a8.5 8.5 0 0 1-3.172-3.173c-.541-.948-.827-2.08-.971-3.692C.5 25.9.5 23.845.5 21.06v-6.12c0-2.784 0-4.84.146-6.46.144-1.612.43-2.743.97-3.691A8.5 8.5 0 0 1 4.79 1.617C5.737 1.076 6.869.79 8.48.646 10.1.5 12.156.5 14.94.5Z"
  />
  <path
    fill="url(#a)"
    d="M17.998 10.8h12.469a14.397 14.397 0 0 0-24.938.001l6.234 10.798.006-.001a7.19 7.19 0 0 1 6.23-10.799Z"
  />
  <path
    fill="url(#b)"
    d="m24.237 21.598-6.234 10.798A14.397 14.397 0 0 0 30.47 10.798H18.002l-.002.006a7.191 7.191 0 0 1 6.237 10.794Z"
  />
  <path
    fill="url(#c)"
    d="M11.765 21.601 5.531 10.803A14.396 14.396 0 0 0 18.001 32.4l6.235-10.798-.004-.004a7.19 7.19 0 0 1-12.466.004Z"
  />
  <path fill="#fff" d="M18 25.2a7.2 7.2 0 1 0 0-14.4 7.2 7.2 0 0 0 0 14.4Z" />
  <path fill="#1A73E8" d="M18 23.7a5.7 5.7 0 1 0 0-11.4 5.7 5.7 0 0 0 0 11.4Z" />
  <defs>
    <linearGradient
      id="a"
      x1="6.294"
      x2="41.1"
      y1="5.995"
      y2="5.995"
      gradientUnits="userSpaceOnUse"
    >
      <stop stop-color="#D93025" />
      <stop offset="1" stop-color="#EA4335" />
    </linearGradient>
    <linearGradient
      id="b"
      x1="20.953"
      x2="37.194"
      y1="32.143"
      y2="2.701"
      gradientUnits="userSpaceOnUse"
    >
      <stop stop-color="#FCC934" />
      <stop offset="1" stop-color="#FBBC04" />
    </linearGradient>
    <linearGradient
      id="c"
      x1="25.873"
      x2="9.632"
      y1="31.2"
      y2="1.759"
      gradientUnits="userSpaceOnUse"
    >
      <stop stop-color="#1E8E3E" />
      <stop offset="1" stop-color="#34A853" />
    </linearGradient>
  </defs>
</svg>`;

    const clockSvg = b$5 `<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M7 2.99a5 5 0 1 0 0 10 5 5 0 0 0 0-10Zm-7 5a7 7 0 1 1 14 0 7 7 0 0 1-14 0Zm7-4a1 1 0 0 1 1 1v2.58l1.85 1.85a1 1 0 0 1-1.41 1.42L6.29 8.69A1 1 0 0 1 6 8v-3a1 1 0 0 1 1-1Z"
    clip-rule="evenodd"
  />
</svg>`;

    const closeSvg = b$5 `<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M2.54 2.54a1 1 0 0 1 1.42 0L8 6.6l4.04-4.05a1 1 0 1 1 1.42 1.42L9.4 8l4.05 4.04a1 1 0 0 1-1.42 1.42L8 9.4l-4.04 4.05a1 1 0 0 1-1.42-1.42L6.6 8 2.54 3.96a1 1 0 0 1 0-1.42Z"
    clip-rule="evenodd"
  />
</svg>`;

    const coinPlaceholderSvg = b$5 `<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M10 3a7 7 0 0 0-6.85 8.44l8.29-8.3C10.97 3.06 10.49 3 10 3Zm3.49.93-9.56 9.56c.32.55.71 1.06 1.16 1.5L15 5.1a7.03 7.03 0 0 0-1.5-1.16Zm2.7 2.8-9.46 9.46a7 7 0 0 0 9.46-9.46ZM1.99 5.9A9 9 0 1 1 18 14.09 9 9 0 0 1 1.98 5.91Z"
    clip-rule="evenodd"
  />
</svg>`;

    const compassSvg = b$5 `<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M8 2a6 6 0 1 0 0 12A6 6 0 0 0 8 2ZM0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm10.66-2.65a1 1 0 0 1 .23 1.06L9.83 9.24a1 1 0 0 1-.59.58l-2.83 1.06A1 1 0 0 1 5.13 9.6l1.06-2.82a1 1 0 0 1 .58-.59L9.6 5.12a1 1 0 0 1 1.06.23ZM7.9 7.89l-.13.35.35-.13.12-.35-.34.13Z"
    clip-rule="evenodd"
  />
</svg>`;

    const copySvg = b$5 `<svg
  xmlns="http://www.w3.org/2000/svg"
  width="16"
  height="16"
  viewBox="0 0 16 16"
  fill="none"
>
  <path
    fill="currentColor"
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M9.21498 1.28565H10.5944C11.1458 1.28562 11.6246 1.2856 12.0182 1.32093C12.4353 1.35836 12.853 1.44155 13.2486 1.66724C13.7005 1.92498 14.0749 2.29935 14.3326 2.75122C14.5583 3.14689 14.6415 3.56456 14.6789 3.9817C14.7143 4.37531 14.7142 4.85403 14.7142 5.40545V6.78489C14.7142 7.33631 14.7143 7.81503 14.6789 8.20865C14.6415 8.62578 14.5583 9.04345 14.3326 9.43912C14.0749 9.89099 13.7005 10.2654 13.2486 10.5231C12.853 10.7488 12.4353 10.832 12.0182 10.8694C11.7003 10.8979 11.3269 10.9034 10.9045 10.9045C10.9034 11.3269 10.8979 11.7003 10.8694 12.0182C10.832 12.4353 10.7488 12.853 10.5231 13.2486C10.2654 13.7005 9.89099 14.0749 9.43912 14.3326C9.04345 14.5583 8.62578 14.6415 8.20865 14.6789C7.81503 14.7143 7.33631 14.7142 6.78489 14.7142H5.40545C4.85403 14.7142 4.37531 14.7143 3.9817 14.6789C3.56456 14.6415 3.14689 14.5583 2.75122 14.3326C2.29935 14.0749 1.92498 13.7005 1.66724 13.2486C1.44155 12.853 1.35836 12.4353 1.32093 12.0182C1.2856 11.6246 1.28562 11.1458 1.28565 10.5944V9.21498C1.28562 8.66356 1.2856 8.18484 1.32093 7.79122C1.35836 7.37409 1.44155 6.95642 1.66724 6.56074C1.92498 6.10887 2.29935 5.73451 2.75122 5.47677C3.14689 5.25108 3.56456 5.16789 3.9817 5.13045C4.2996 5.10192 4.67301 5.09645 5.09541 5.09541C5.09645 4.67302 5.10192 4.2996 5.13045 3.9817C5.16789 3.56456 5.25108 3.14689 5.47676 2.75122C5.73451 2.29935 6.10887 1.92498 6.56074 1.66724C6.95642 1.44155 7.37409 1.35836 7.79122 1.32093C8.18484 1.2856 8.66356 1.28562 9.21498 1.28565ZM5.09541 7.09552C4.68397 7.09667 4.39263 7.10161 4.16046 7.12245C3.88053 7.14757 3.78516 7.18949 3.74214 7.21403C3.60139 7.29431 3.48478 7.41091 3.4045 7.55166C3.37997 7.59468 3.33804 7.69005 3.31292 7.96999C3.28659 8.26345 3.28565 8.65147 3.28565 9.25708V10.5523C3.28565 11.1579 3.28659 11.5459 3.31292 11.8394C3.33804 12.1193 3.37997 12.2147 3.4045 12.2577C3.48478 12.3985 3.60139 12.5151 3.74214 12.5954C3.78516 12.6199 3.88053 12.6618 4.16046 12.6869C4.45393 12.7133 4.84195 12.7142 5.44755 12.7142H6.74279C7.3484 12.7142 7.73641 12.7133 8.02988 12.6869C8.30981 12.6618 8.40518 12.6199 8.44821 12.5954C8.58895 12.5151 8.70556 12.3985 8.78584 12.2577C8.81038 12.2147 8.8523 12.1193 8.87742 11.8394C8.89825 11.6072 8.90319 11.3159 8.90435 10.9045C8.48219 10.9034 8.10898 10.8979 7.79122 10.8694C7.37409 10.832 6.95641 10.7488 6.56074 10.5231C6.10887 10.2654 5.73451 9.89099 5.47676 9.43912C5.25108 9.04345 5.16789 8.62578 5.13045 8.20865C5.10194 7.89089 5.09645 7.51767 5.09541 7.09552ZM7.96999 3.31292C7.69005 3.33804 7.59468 3.37997 7.55166 3.4045C7.41091 3.48478 7.29431 3.60139 7.21403 3.74214C7.18949 3.78516 7.14757 3.88053 7.12245 4.16046C7.09611 4.45393 7.09517 4.84195 7.09517 5.44755V6.74279C7.09517 7.3484 7.09611 7.73641 7.12245 8.02988C7.14757 8.30981 7.18949 8.40518 7.21403 8.4482C7.29431 8.58895 7.41091 8.70556 7.55166 8.78584C7.59468 8.81038 7.69005 8.8523 7.96999 8.87742C8.26345 8.90376 8.65147 8.9047 9.25708 8.9047H10.5523C11.1579 8.9047 11.5459 8.90376 11.8394 8.87742C12.1193 8.8523 12.2147 8.81038 12.2577 8.78584C12.3985 8.70556 12.5151 8.58895 12.5954 8.4482C12.6199 8.40518 12.6618 8.30981 12.6869 8.02988C12.7133 7.73641 12.7142 7.3484 12.7142 6.74279V5.44755C12.7142 4.84195 12.7133 4.45393 12.6869 4.16046C12.6618 3.88053 12.6199 3.78516 12.5954 3.74214C12.5151 3.60139 12.3985 3.48478 12.2577 3.4045C12.2147 3.37997 12.1193 3.33804 11.8394 3.31292C11.5459 3.28659 11.1579 3.28565 10.5523 3.28565H9.25708C8.65147 3.28565 8.26345 3.28659 7.96999 3.31292Z"
    fill="#788181"
  /></svg
>`;

    const addSvg = b$5 `<svg
  width="14"
  height="14"
  viewBox="0 0 14 14"
  fill="none"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    fill="currentColor"
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M7.0023 0.875C7.48571 0.875 7.8776 1.26675 7.8776 1.75V6.125H12.2541C12.7375 6.125 13.1294 6.51675 13.1294 7C13.1294 7.48325 12.7375 7.875 12.2541 7.875H7.8776V12.25C7.8776 12.7332 7.48571 13.125 7.0023 13.125C6.51889 13.125 6.12701 12.7332 6.12701 12.25V7.875H1.75054C1.26713 7.875 0.875244 7.48325 0.875244 7C0.875244 6.51675 1.26713 6.125 1.75054 6.125H6.12701V1.75C6.12701 1.26675 6.51889 0.875 7.0023 0.875Z"
    fill="#47A1FF"
  /></svg
>`;

    const cursorSvg = b$5 ` <svg fill="none" viewBox="0 0 13 4">
  <path fill="currentColor" d="M.5 0h12L8.9 3.13a3.76 3.76 0 0 1-4.8 0L.5 0Z" />
</svg>`;

    const desktopSvg = b$5 `<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M13.66 2H6.34c-1.07 0-1.96 0-2.68.08-.74.08-1.42.25-2.01.68a4 4 0 0 0-.89.89c-.43.6-.6 1.27-.68 2.01C0 6.38 0 7.26 0 8.34v.89c0 1.07 0 1.96.08 2.68.08.74.25 1.42.68 2.01a4 4 0 0 0 .89.89c.6.43 1.27.6 2.01.68a27 27 0 0 0 2.68.08h7.32a27 27 0 0 0 2.68-.08 4.03 4.03 0 0 0 2.01-.68 4 4 0 0 0 .89-.89c.43-.6.6-1.27.68-2.01.08-.72.08-1.6.08-2.68v-.89c0-1.07 0-1.96-.08-2.68a4.04 4.04 0 0 0-.68-2.01 4 4 0 0 0-.89-.89c-.6-.43-1.27-.6-2.01-.68C15.62 2 14.74 2 13.66 2ZM2.82 4.38c.2-.14.48-.25 1.06-.31C4.48 4 5.25 4 6.4 4h7.2c1.15 0 1.93 0 2.52.07.58.06.86.17 1.06.31a2 2 0 0 1 .44.44c.14.2.25.48.31 1.06.07.6.07 1.37.07 2.52v.77c0 1.15 0 1.93-.07 2.52-.06.58-.17.86-.31 1.06a2 2 0 0 1-.44.44c-.2.14-.48.25-1.06.32-.6.06-1.37.06-2.52.06H6.4c-1.15 0-1.93 0-2.52-.06-.58-.07-.86-.18-1.06-.32a2 2 0 0 1-.44-.44c-.14-.2-.25-.48-.31-1.06C2 11.1 2 10.32 2 9.17V8.4c0-1.15 0-1.93.07-2.52.06-.58.17-.86.31-1.06a2 2 0 0 1 .44-.44Z"
    clip-rule="evenodd"
  />
  <path fill="currentColor" d="M6.14 17.57a1 1 0 1 0 0 2h7.72a1 1 0 1 0 0-2H6.14Z" />
</svg>`;

    const disconnectSvg = b$5 `<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M6.07 1h.57a1 1 0 0 1 0 2h-.52c-.98 0-1.64 0-2.14.06-.48.05-.7.14-.84.24-.13.1-.25.22-.34.35-.1.14-.2.35-.25.83-.05.5-.05 1.16-.05 2.15v2.74c0 .99 0 1.65.05 2.15.05.48.14.7.25.83.1.14.2.25.34.35.14.1.36.2.84.25.5.05 1.16.05 2.14.05h.52a1 1 0 0 1 0 2h-.57c-.92 0-1.69 0-2.3-.07a3.6 3.6 0 0 1-1.8-.61c-.3-.22-.57-.49-.8-.8a3.6 3.6 0 0 1-.6-1.79C.5 11.11.5 10.35.5 9.43V6.58c0-.92 0-1.7.06-2.31a3.6 3.6 0 0 1 .62-1.8c.22-.3.48-.57.79-.79a3.6 3.6 0 0 1 1.8-.61C4.37 1 5.14 1 6.06 1ZM9.5 3a1 1 0 0 1 1.42 0l4.28 4.3a1 1 0 0 1 0 1.4L10.93 13a1 1 0 0 1-1.42-1.42L12.1 9H6.8a1 1 0 1 1 0-2h5.3L9.51 4.42a1 1 0 0 1 0-1.41Z"
    clip-rule="evenodd"
  />
</svg>`;

    const discordSvg = b$5 `<svg fill="none" viewBox="0 0 40 40">
  <g clip-path="url(#a)">
    <g clip-path="url(#b)">
      <circle cx="20" cy="19.89" r="20" fill="#5865F2" />
      <path
        fill="#fff"
        fill-rule="evenodd"
        d="M25.71 28.15C30.25 28 32 25.02 32 25.02c0-6.61-2.96-11.98-2.96-11.98-2.96-2.22-5.77-2.15-5.77-2.15l-.29.32c3.5 1.07 5.12 2.61 5.12 2.61a16.75 16.75 0 0 0-10.34-1.93l-.35.04a15.43 15.43 0 0 0-5.88 1.9s1.71-1.63 5.4-2.7l-.2-.24s-2.81-.07-5.77 2.15c0 0-2.96 5.37-2.96 11.98 0 0 1.73 2.98 6.27 3.13l1.37-1.7c-2.6-.79-3.6-2.43-3.6-2.43l.58.35.09.06.08.04.02.01.08.05a17.25 17.25 0 0 0 4.52 1.58 14.4 14.4 0 0 0 8.3-.86c.72-.27 1.52-.66 2.37-1.21 0 0-1.03 1.68-3.72 2.44.61.78 1.35 1.67 1.35 1.67Zm-9.55-9.6c-1.17 0-2.1 1.03-2.1 2.28 0 1.25.95 2.28 2.1 2.28 1.17 0 2.1-1.03 2.1-2.28.01-1.25-.93-2.28-2.1-2.28Zm7.5 0c-1.17 0-2.1 1.03-2.1 2.28 0 1.25.95 2.28 2.1 2.28 1.17 0 2.1-1.03 2.1-2.28 0-1.25-.93-2.28-2.1-2.28Z"
        clip-rule="evenodd"
      />
    </g>
  </g>
  <defs>
    <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
    <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
  </defs>
</svg>`;

    const etherscanSvg = b$5 `<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    d="M4.25 7a.63.63 0 0 0-.63.63v3.97c0 .28-.2.51-.47.54l-.75.07a.93.93 0 0 1-.9-.47A7.51 7.51 0 0 1 5.54.92a7.5 7.5 0 0 1 9.54 4.62c.12.35.06.72-.16 1-.74.97-1.68 1.78-2.6 2.44V4.44a.64.64 0 0 0-.63-.64h-1.06c-.35 0-.63.3-.63.64v5.5c0 .23-.12.42-.32.5l-.52.23V6.05c0-.36-.3-.64-.64-.64H7.45c-.35 0-.64.3-.64.64v4.97c0 .25-.17.46-.4.52a5.8 5.8 0 0 0-.45.11v-4c0-.36-.3-.65-.64-.65H4.25ZM14.07 12.4A7.49 7.49 0 0 1 3.6 14.08c4.09-.58 9.14-2.5 11.87-6.6v.03a7.56 7.56 0 0 1-1.41 4.91Z"
  />
</svg>`;

    const extensionSvg = b$5 `<svg fill="none" viewBox="0 0 14 15">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M6.71 2.99a.57.57 0 0 0-.57.57 1 1 0 0 1-1 1c-.58 0-.96 0-1.24.03-.27.03-.37.07-.42.1a.97.97 0 0 0-.36.35c-.04.08-.09.21-.11.67a2.57 2.57 0 0 1 0 5.13c.02.45.07.6.11.66.09.15.21.28.36.36.07.04.21.1.67.12a2.57 2.57 0 0 1 5.12 0c.46-.03.6-.08.67-.12a.97.97 0 0 0 .36-.36c.03-.04.07-.14.1-.41.02-.29.03-.66.03-1.24a1 1 0 0 1 1-1 .57.57 0 0 0 0-1.15 1 1 0 0 1-1-1c0-.58 0-.95-.03-1.24a1.04 1.04 0 0 0-.1-.42.97.97 0 0 0-.36-.36 1.04 1.04 0 0 0-.42-.1c-.28-.02-.65-.02-1.24-.02a1 1 0 0 1-1-1 .57.57 0 0 0-.57-.57ZM5.15 13.98a1 1 0 0 0 .99-1v-.78a.57.57 0 0 1 1.14 0v.78a1 1 0 0 0 .99 1H8.36a66.26 66.26 0 0 0 .73 0 3.78 3.78 0 0 0 1.84-.38c.46-.26.85-.64 1.1-1.1.23-.4.32-.8.36-1.22.02-.2.03-.4.03-.63a2.57 2.57 0 0 0 0-4.75c0-.23-.01-.44-.03-.63a2.96 2.96 0 0 0-.35-1.22 2.97 2.97 0 0 0-1.1-1.1c-.4-.22-.8-.31-1.22-.35a8.7 8.7 0 0 0-.64-.04 2.57 2.57 0 0 0-4.74 0c-.23 0-.44.02-.63.04-.42.04-.83.13-1.22.35-.46.26-.84.64-1.1 1.1-.33.57-.37 1.2-.39 1.84a21.39 21.39 0 0 0 0 .72v.1a1 1 0 0 0 1 .99h.78a.57.57 0 0 1 0 1.15h-.77a1 1 0 0 0-1 .98v.1a63.87 63.87 0 0 0 0 .73c0 .64.05 1.27.38 1.83.26.47.64.85 1.1 1.11.56.32 1.2.37 1.84.38a20.93 20.93 0 0 0 .72 0h.1Z"
    clip-rule="evenodd"
  />
</svg>`;

    const externalLinkSvg = b$5 `<svg fill="none" viewBox="0 0 14 15">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M3.74 3.99a1 1 0 0 1 1-1H11a1 1 0 0 1 1 1v6.26a1 1 0 0 1-2 0V6.4l-6.3 6.3a1 1 0 0 1-1.4-1.42l6.29-6.3H4.74a1 1 0 0 1-1-1Z"
    clip-rule="evenodd"
  />
</svg>`;

    const facebookSvg = b$5 `<svg fill="none" viewBox="0 0 40 40">
  <g clip-path="url(#a)">
    <g clip-path="url(#b)">
      <circle cx="20" cy="19.89" r="20" fill="#1877F2" />
      <g clip-path="url(#c)">
        <path
          fill="#fff"
          d="M26 12.38h-2.89c-.92 0-1.61.38-1.61 1.34v1.66H26l-.36 4.5H21.5v12H17v-12h-3v-4.5h3V12.5c0-3.03 1.6-4.62 5.2-4.62H26v4.5Z"
        />
      </g>
    </g>
    <path
      fill="#1877F2"
      d="M40 20a20 20 0 1 0-23.13 19.76V25.78H11.8V20h5.07v-4.4c0-5.02 3-7.79 7.56-7.79 2.19 0 4.48.4 4.48.4v4.91h-2.53c-2.48 0-3.25 1.55-3.25 3.13V20h5.54l-.88 5.78h-4.66v13.98A20 20 0 0 0 40 20Z"
    />
    <path
      fill="#fff"
      d="m27.79 25.78.88-5.78h-5.55v-3.75c0-1.58.78-3.13 3.26-3.13h2.53V8.2s-2.3-.39-4.48-.39c-4.57 0-7.55 2.77-7.55 7.78V20H11.8v5.78h5.07v13.98a20.15 20.15 0 0 0 6.25 0V25.78h4.67Z"
    />
  </g>
  <defs>
    <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
    <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
    <clipPath id="c"><path fill="#fff" d="M8 7.89h24v24H8z" /></clipPath>
  </defs>
</svg>`;

    const filtersSvg = b$5 `<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M0 3a1 1 0 0 1 1-1h14a1 1 0 1 1 0 2H1a1 1 0 0 1-1-1Zm2.63 5.25a1 1 0 0 1 1-1h8.75a1 1 0 1 1 0 2H3.63a1 1 0 0 1-1-1Zm2.62 5.25a1 1 0 0 1 1-1h3.5a1 1 0 0 1 0 2h-3.5a1 1 0 0 1-1-1Z"
    clip-rule="evenodd"
  />
</svg>`;

    const githubSvg = b$5 `<svg fill="none" viewBox="0 0 40 40">
  <g clip-path="url(#a)">
    <g clip-path="url(#b)">
      <circle cx="20" cy="19.89" r="20" fill="#1B1F23" />
      <g clip-path="url(#c)">
        <path
          fill="#fff"
          d="M8 19.89a12 12 0 1 1 15.8 11.38c-.6.12-.8-.26-.8-.57v-3.3c0-1.12-.4-1.85-.82-2.22 2.67-.3 5.48-1.31 5.48-5.92 0-1.31-.47-2.38-1.24-3.22.13-.3.54-1.52-.12-3.18 0 0-1-.32-3.3 1.23a11.54 11.54 0 0 0-6 0c-2.3-1.55-3.3-1.23-3.3-1.23a4.32 4.32 0 0 0-.12 3.18 4.64 4.64 0 0 0-1.24 3.22c0 4.6 2.8 5.63 5.47 5.93-.34.3-.65.83-.76 1.6-.69.31-2.42.84-3.5-1 0 0-.63-1.15-1.83-1.23 0 0-1.18-.02-.09.73 0 0 .8.37 1.34 1.76 0 0 .7 2.14 4.03 1.41v2.24c0 .31-.2.68-.8.57A12 12 0 0 1 8 19.9Z"
        />
      </g>
    </g>
  </g>
  <defs>
    <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
    <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
    <clipPath id="c"><path fill="#fff" d="M8 7.89h24v24H8z" /></clipPath>
  </defs>
</svg>`;

    const googleSvg = b$5 `<svg fill="none" viewBox="0 0 40 40">
  <g clip-path="url(#a)">
    <g clip-path="url(#b)">
      <circle cx="20" cy="19.89" r="20" fill="#fff" fill-opacity=".05" />
      <g clip-path="url(#c)">
        <path
          fill="#4285F4"
          d="M20 17.7v4.65h6.46a5.53 5.53 0 0 1-2.41 3.61l3.9 3.02c2.26-2.09 3.57-5.17 3.57-8.82 0-.85-.08-1.67-.22-2.46H20Z"
        />
        <path
          fill="#34A853"
          d="m13.27 22.17-.87.67-3.11 2.42A12 12 0 0 0 20 31.9c3.24 0 5.96-1.07 7.94-2.9l-3.9-3.03A7.15 7.15 0 0 1 20 27.12a7.16 7.16 0 0 1-6.72-4.94v-.01Z"
        />
        <path
          fill="#FBBC05"
          d="M9.29 14.5a11.85 11.85 0 0 0 0 10.76l3.99-3.1a7.19 7.19 0 0 1 0-4.55l-4-3.1Z"
        />
        <path
          fill="#EA4335"
          d="M20 12.66c1.77 0 3.34.61 4.6 1.8l3.43-3.44A11.51 11.51 0 0 0 20 7.89c-4.7 0-8.74 2.69-10.71 6.62l3.99 3.1A7.16 7.16 0 0 1 20 12.66Z"
        />
      </g>
    </g>
  </g>
  <defs>
    <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
    <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
    <clipPath id="c"><path fill="#fff" d="M8 7.89h24v24H8z" /></clipPath>
  </defs>
</svg>`;

    const helpCircleSvg = b$5 `<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    d="M8.51 5.66a.83.83 0 0 0-.57-.2.83.83 0 0 0-.52.28.8.8 0 0 0-.25.52 1 1 0 0 1-2 0c0-.75.34-1.43.81-1.91a2.75 2.75 0 0 1 4.78 1.92c0 1.24-.8 1.86-1.25 2.2l-.04.03c-.47.36-.5.43-.5.65a1 1 0 1 1-2 0c0-1.25.8-1.86 1.24-2.2l.04-.04c.47-.36.5-.43.5-.65 0-.3-.1-.49-.24-.6ZM9.12 11.87a1.13 1.13 0 1 1-2.25 0 1.13 1.13 0 0 1 2.25 0Z"
  />
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6a6 6 0 1 0 0 12A6 6 0 0 0 8 2Z"
    clip-rule="evenodd"
  />
</svg>`;

    const infoCircleSvg = b$5 `<svg fill="none" viewBox="0 0 14 15">
  <path
    fill="currentColor"
    d="M6 10.49a1 1 0 1 0 2 0v-2a1 1 0 0 0-2 0v2ZM7 4.49a1 1 0 1 0 0 2 1 1 0 0 0 0-2Z"
  />
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M7 14.99a7 7 0 1 0 0-14 7 7 0 0 0 0 14Zm5-7a5 5 0 1 1-10 0 5 5 0 0 1 10 0Z"
    clip-rule="evenodd"
  />
</svg>`;

    const mailSvg = b$5 `<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M4.83 1.34h6.34c.68 0 1.26 0 1.73.04.5.05.97.15 1.42.4.52.3.95.72 1.24 1.24.26.45.35.92.4 1.42.04.47.04 1.05.04 1.73v3.71c0 .69 0 1.26-.04 1.74-.05.5-.14.97-.4 1.41-.3.52-.72.95-1.24 1.25-.45.25-.92.35-1.42.4-.47.03-1.05.03-1.73.03H4.83c-.68 0-1.26 0-1.73-.04-.5-.04-.97-.14-1.42-.4-.52-.29-.95-.72-1.24-1.24a3.39 3.39 0 0 1-.4-1.41A20.9 20.9 0 0 1 0 9.88v-3.7c0-.7 0-1.27.04-1.74.05-.5.14-.97.4-1.42.3-.52.72-.95 1.24-1.24.45-.25.92-.35 1.42-.4.47-.04 1.05-.04 1.73-.04ZM3.28 3.38c-.36.03-.51.08-.6.14-.21.11-.39.29-.5.5a.8.8 0 0 0-.08.19l5.16 3.44c.45.3 1.03.3 1.48 0L13.9 4.2a.79.79 0 0 0-.08-.2c-.11-.2-.29-.38-.5-.5-.09-.05-.24-.1-.6-.13-.37-.04-.86-.04-1.6-.04H4.88c-.73 0-1.22 0-1.6.04ZM14 6.54 9.85 9.31a3.33 3.33 0 0 1-3.7 0L2 6.54v3.3c0 .74 0 1.22.03 1.6.04.36.1.5.15.6.11.2.29.38.5.5.09.05.24.1.6.14.37.03.86.03 1.6.03h6.25c.73 0 1.22 0 1.6-.03.35-.03.5-.09.6-.14.2-.12.38-.3.5-.5.05-.1.1-.24.14-.6.03-.38.03-.86.03-1.6v-3.3Z"
    clip-rule="evenodd"
  />
</svg>`;

    const mobileSvg = b$5 `<svg fill="none" viewBox="0 0 20 20">
  <path fill="currentColor" d="M10.81 5.81a2 2 0 1 1-4 0 2 2 0 0 1 4 0Z" />
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M3 4.75A4.75 4.75 0 0 1 7.75 0h4.5A4.75 4.75 0 0 1 17 4.75v10.5A4.75 4.75 0 0 1 12.25 20h-4.5A4.75 4.75 0 0 1 3 15.25V4.75ZM7.75 2A2.75 2.75 0 0 0 5 4.75v10.5A2.75 2.75 0 0 0 7.75 18h4.5A2.75 2.75 0 0 0 15 15.25V4.75A2.75 2.75 0 0 0 12.25 2h-4.5Z"
    clip-rule="evenodd"
  />
</svg>`;

    const networkPlaceholderSvg = b$5 `<svg fill="none" viewBox="0 0 22 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M16.32 13.62a3.14 3.14 0 1 1-.99 1.72l-1.6-.93a3.83 3.83 0 0 1-3.71 1 3.66 3.66 0 0 1-1.74-1l-1.6.94a3.14 3.14 0 1 1-1-1.73l1.6-.94a3.7 3.7 0 0 1 0-2 3.81 3.81 0 0 1 1.8-2.33c.29-.17.6-.3.92-.38V6.1a3.14 3.14 0 1 1 2 0l-.01.02v1.85H12a3.82 3.82 0 0 1 2.33 1.8 3.7 3.7 0 0 1 .39 2.91l1.6.93ZM2.6 16.54a1.14 1.14 0 0 0 1.98-1.14 1.14 1.14 0 0 0-1.98 1.14ZM11 2.01a1.14 1.14 0 1 0 0 2.28 1.14 1.14 0 0 0 0-2.28Zm1.68 10.45c.08-.19.14-.38.16-.58v-.05l.02-.13v-.13a1.92 1.92 0 0 0-.24-.8l-.11-.15a1.89 1.89 0 0 0-.74-.6 1.86 1.86 0 0 0-.77-.17h-.19a1.97 1.97 0 0 0-.89.34 1.98 1.98 0 0 0-.61.74 1.99 1.99 0 0 0-.16.9v.05a1.87 1.87 0 0 0 .24.74l.1.15c.12.16.26.3.42.42l.16.1.13.07.04.02a1.84 1.84 0 0 0 .76.17h.17a2 2 0 0 0 .91-.35 1.78 1.78 0 0 0 .52-.58l.03-.05a.84.84 0 0 0 .05-.11Zm5.15 4.5a1.14 1.14 0 0 0 1.14-1.97 1.13 1.13 0 0 0-1.55.41c-.32.55-.13 1.25.41 1.56Z"
    clip-rule="evenodd"
  />
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M4.63 9.43a1.5 1.5 0 1 0 1.5-2.6 1.5 1.5 0 0 0-1.5 2.6Zm.32-1.55a.5.5 0 0 1 .68-.19.5.5 0 0 1 .18.68.5.5 0 0 1-.68.19.5.5 0 0 1-.18-.68ZM17.94 8.88a1.5 1.5 0 1 1-2.6-1.5 1.5 1.5 0 1 1 2.6 1.5ZM16.9 7.69a.5.5 0 0 0-.68.19.5.5 0 0 0 .18.68.5.5 0 0 0 .68-.19.5.5 0 0 0-.18-.68ZM9.75 17.75a1.5 1.5 0 1 1 2.6 1.5 1.5 1.5 0 1 1-2.6-1.5Zm1.05 1.18a.5.5 0 0 0 .68-.18.5.5 0 0 0-.18-.68.5.5 0 0 0-.68.18.5.5 0 0 0 .18.68Z"
    clip-rule="evenodd"
  />
</svg>`;

    const nftPlaceholderSvg = b$5 `<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M9.13 1h1.71c1.46 0 2.63 0 3.56.1.97.1 1.8.33 2.53.85a5 5 0 0 1 1.1 1.11c.53.73.75 1.56.86 2.53.1.93.1 2.1.1 3.55v1.72c0 1.45 0 2.62-.1 3.55-.1.97-.33 1.8-.86 2.53a5 5 0 0 1-1.1 1.1c-.73.53-1.56.75-2.53.86-.93.1-2.1.1-3.55.1H9.13c-1.45 0-2.62 0-3.56-.1-.96-.1-1.8-.33-2.52-.85a5 5 0 0 1-1.1-1.11 5.05 5.05 0 0 1-.86-2.53c-.1-.93-.1-2.1-.1-3.55V9.14c0-1.45 0-2.62.1-3.55.1-.97.33-1.8.85-2.53a5 5 0 0 1 1.1-1.1 5.05 5.05 0 0 1 2.53-.86C6.51 1 7.67 1 9.13 1ZM5.79 3.09a3.1 3.1 0 0 0-1.57.48 3 3 0 0 0-.66.67c-.24.32-.4.77-.48 1.56-.1.82-.1 1.88-.1 3.4v1.6c0 1.15 0 2.04.05 2.76l.41-.42c.5-.5.93-.92 1.32-1.24.41-.33.86-.6 1.43-.7a3 3 0 0 1 .94 0c.35.06.66.2.95.37a17.11 17.11 0 0 0 .8.45c.1-.08.2-.2.41-.4l.04-.03a27 27 0 0 1 1.95-1.84 4.03 4.03 0 0 1 1.91-.94 4 4 0 0 1 1.25 0c.73.11 1.33.46 1.91.94l.64.55V9.2c0-1.52 0-2.58-.1-3.4a3.1 3.1 0 0 0-.48-1.56 3 3 0 0 0-.66-.67 3.1 3.1 0 0 0-1.56-.48C13.37 3 12.3 3 10.79 3h-1.6c-1.52 0-2.59 0-3.4.09Zm11.18 10-.04-.05a26.24 26.24 0 0 0-1.83-1.74c-.45-.36-.73-.48-.97-.52a2 2 0 0 0-.63 0c-.24.04-.51.16-.97.52-.46.38-1.01.93-1.83 1.74l-.02.02c-.17.18-.34.34-.49.47a2.04 2.04 0 0 1-1.08.5 1.97 1.97 0 0 1-1.25-.27l-.79-.46-.02-.02a.65.65 0 0 0-.24-.1 1 1 0 0 0-.31 0c-.08.02-.21.06-.49.28-.3.24-.65.59-1.2 1.14l-.56.56-.65.66a3 3 0 0 0 .62.6c.33.24.77.4 1.57.49.81.09 1.88.09 3.4.09h1.6c1.52 0 2.58 0 3.4-.09a3.1 3.1 0 0 0 1.56-.48 3 3 0 0 0 .66-.67c.24-.32.4-.77.49-1.56l.07-1.12Zm-8.02-1.03ZM4.99 7a2 2 0 1 1 4 0 2 2 0 0 1-4 0Z"
    clip-rule="evenodd"
  />
</svg>`;

    const offSvg = b$5 `<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M8 0a1 1 0 0 1 1 1v5.38a1 1 0 0 1-2 0V1a1 1 0 0 1 1-1ZM5.26 2.6a1 1 0 0 1-.28 1.39 5.46 5.46 0 1 0 6.04 0 1 1 0 1 1 1.1-1.67 7.46 7.46 0 1 1-8.25 0 1 1 0 0 1 1.4.28Z"
    clip-rule="evenodd"
  />
</svg>`;

    const playStoreSvg = b$5 ` <svg
  width="36"
  height="36"
  fill="none"
>
  <path
    d="M0 8a8 8 0 0 1 8-8h20a8 8 0 0 1 8 8v20a8 8 0 0 1-8 8H8a8 8 0 0 1-8-8V8Z"
    fill="#fff"
    fill-opacity=".05"
  />
  <path
    d="m18.262 17.513-8.944 9.49v.01a2.417 2.417 0 0 0 3.56 1.452l.026-.017 10.061-5.803-4.703-5.132Z"
    fill="#EA4335"
  />
  <path
    d="m27.307 15.9-.008-.008-4.342-2.52-4.896 4.36 4.913 4.912 4.325-2.494a2.42 2.42 0 0 0 .008-4.25Z"
    fill="#FBBC04"
  />
  <path
    d="M9.318 8.997c-.05.202-.084.403-.084.622V26.39c0 .218.025.42.084.621l9.246-9.247-9.246-8.768Z"
    fill="#4285F4"
  />
  <path
    d="m18.33 18 4.627-4.628-10.053-5.828a2.427 2.427 0 0 0-3.586 1.444L18.329 18Z"
    fill="#34A853"
  />
  <path
    d="M8 .5h20A7.5 7.5 0 0 1 35.5 8v20a7.5 7.5 0 0 1-7.5 7.5H8A7.5 7.5 0 0 1 .5 28V8A7.5 7.5 0 0 1 8 .5Z"
    stroke="#fff"
    stroke-opacity=".05"
  />
</svg>`;

    const qrCodeIcon = b$5 `<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    d="M3 6a3 3 0 0 1 3-3h1a1 1 0 1 0 0-2H6a5 5 0 0 0-5 5v1a1 1 0 0 0 2 0V6ZM13 1a1 1 0 1 0 0 2h1a3 3 0 0 1 3 3v1a1 1 0 1 0 2 0V6a5 5 0 0 0-5-5h-1ZM3 13a1 1 0 1 0-2 0v1a5 5 0 0 0 5 5h1a1 1 0 1 0 0-2H6a3 3 0 0 1-3-3v-1ZM19 13a1 1 0 1 0-2 0v1a3 3 0 0 1-3 3h-1a1 1 0 1 0 0 2h1.01a5 5 0 0 0 5-5v-1ZM5.3 6.36c-.04.2-.04.43-.04.89s0 .7.05.89c.14.52.54.92 1.06 1.06.19.05.42.05.89.05.46 0 .7 0 .88-.05A1.5 1.5 0 0 0 9.2 8.14c.06-.2.06-.43.06-.89s0-.7-.06-.89A1.5 1.5 0 0 0 8.14 5.3c-.19-.05-.42-.05-.88-.05-.47 0-.7 0-.9.05a1.5 1.5 0 0 0-1.05 1.06ZM10.8 6.36c-.04.2-.04.43-.04.89s0 .7.05.89c.14.52.54.92 1.06 1.06.19.05.42.05.89.05.46 0 .7 0 .88-.05a1.5 1.5 0 0 0 1.06-1.06c.06-.2.06-.43.06-.89s0-.7-.06-.89a1.5 1.5 0 0 0-1.06-1.06c-.19-.05-.42-.05-.88-.05-.47 0-.7 0-.9.05a1.5 1.5 0 0 0-1.05 1.06ZM5.26 12.75c0-.46 0-.7.05-.89a1.5 1.5 0 0 1 1.06-1.06c.19-.05.42-.05.89-.05.46 0 .7 0 .88.05.52.14.93.54 1.06 1.06.06.2.06.43.06.89s0 .7-.06.89a1.5 1.5 0 0 1-1.06 1.06c-.19.05-.42.05-.88.05-.47 0-.7 0-.9-.05a1.5 1.5 0 0 1-1.05-1.06c-.05-.2-.05-.43-.05-.89ZM10.8 11.86c-.04.2-.04.43-.04.89s0 .7.05.89c.14.52.54.92 1.06 1.06.19.05.42.05.89.05.46 0 .7 0 .88-.05a1.5 1.5 0 0 0 1.06-1.06c.06-.2.06-.43.06-.89s0-.7-.06-.89a1.5 1.5 0 0 0-1.06-1.06c-.19-.05-.42-.05-.88-.05-.47 0-.7 0-.9.05a1.5 1.5 0 0 0-1.05 1.06Z"
  />
</svg>`;

    const refreshSvg = b$5 `<svg fill="none" viewBox="0 0 14 16">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M3.94 1.04a1 1 0 0 1 .7 1.23l-.48 1.68a5.85 5.85 0 0 1 8.53 4.32 5.86 5.86 0 0 1-11.4 2.56 1 1 0 0 1 1.9-.57 3.86 3.86 0 1 0 1.83-4.5l1.87.53a1 1 0 0 1-.55 1.92l-4.1-1.15a1 1 0 0 1-.69-1.23l1.16-4.1a1 1 0 0 1 1.23-.7Z"
    clip-rule="evenodd"
  />
</svg>`;

    const searchSvg = b$5 `<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M9.36 4.21a5.14 5.14 0 1 0 0 10.29 5.14 5.14 0 0 0 0-10.29ZM1.64 9.36a7.71 7.71 0 1 1 14 4.47l2.52 2.5a1.29 1.29 0 1 1-1.82 1.83l-2.51-2.51A7.71 7.71 0 0 1 1.65 9.36Z"
    clip-rule="evenodd"
  />
</svg>`;

    const sendSvg = b$5 `<svg fill="none" viewBox="0 0 21 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M14.3808 4.34812C13.72 4.47798 12.8501 4.7587 11.5748 5.17296L9.00869 6.00646C6.90631 6.68935 5.40679 7.17779 4.38121 7.63178C3.87166 7.85734 3.5351 8.05091 3.32022 8.22035C3.11183 8.38466 3.07011 8.48486 3.05969 8.51817C2.98058 8.77103 2.98009 9.04195 3.05831 9.29509C3.06861 9.32844 3.10998 9.42878 3.31777 9.59384C3.53205 9.76404 3.86792 9.95881 4.37667 10.1862C5.29287 10.5957 6.58844 11.0341 8.35529 11.6164L10.8876 8.59854C11.2426 8.17547 11.8733 8.12028 12.2964 8.47528C12.7195 8.83029 12.7746 9.46104 12.4196 9.88412L9.88738 12.9019C10.7676 14.5408 11.4244 15.7406 11.9867 16.5718C12.299 17.0333 12.5491 17.3303 12.7539 17.5117C12.9526 17.6877 13.0586 17.711 13.0932 17.7154C13.3561 17.7484 13.6228 17.7009 13.8581 17.5791C13.8891 17.563 13.9805 17.5046 14.1061 17.2708C14.2357 17.0298 14.3679 16.6647 14.5015 16.1237C14.7705 15.0349 14.9912 13.4733 15.2986 11.2843L15.6738 8.61249C15.8603 7.28456 15.9857 6.37917 15.9989 5.7059C16.012 5.03702 15.9047 4.8056 15.8145 4.69183C15.7044 4.55297 15.5673 4.43792 15.4114 4.35365C15.2837 4.28459 15.0372 4.2191 14.3808 4.34812ZM7.99373 13.603C6.11919 12.9864 4.6304 12.4902 3.5606 12.0121C2.98683 11.7557 2.4778 11.4808 2.07383 11.1599C1.66337 10.8339 1.31312 10.4217 1.14744 9.88551C0.949667 9.24541 0.950886 8.56035 1.15094 7.92096C1.31852 7.38534 1.67024 6.97442 2.08185 6.64985C2.48697 6.33041 2.99697 6.05734 3.57166 5.80295C4.70309 5.3021 6.30179 4.78283 8.32903 4.12437L11.0196 3.25042C12.2166 2.86159 13.2017 2.54158 13.9951 2.38566C14.8065 2.22618 15.6202 2.19289 16.3627 2.59437C16.7568 2.80747 17.1035 3.09839 17.3818 3.4495C17.9062 4.111 18.0147 4.91815 17.9985 5.74496C17.9827 6.55332 17.8386 7.57903 17.6636 8.82534L17.2701 11.6268C16.9737 13.7376 16.7399 15.4022 16.4432 16.6034C16.2924 17.2135 16.1121 17.7632 15.8678 18.2176C15.6197 18.6794 15.2761 19.0971 14.7777 19.3551C14.1827 19.6632 13.5083 19.7833 12.8436 19.6997C12.2867 19.6297 11.82 19.3563 11.4277 19.0087C11.0415 18.6666 10.6824 18.213 10.3302 17.6925C9.67361 16.722 8.92648 15.342 7.99373 13.603Z"
    clip-rule="evenodd"
  />
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="21"
    height="20"
    viewBox="0 0 21 20"
    fill="none"
  ></svg></svg
>`;

    const swapHorizontalSvg = b$5 `<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M6.76.3a1 1 0 0 1 0 1.4L4.07 4.4h9a1 1 0 1 1 0 2h-9l2.69 2.68a1 1 0 1 1-1.42 1.42L.95 6.09a1 1 0 0 1 0-1.4l4.4-4.4a1 1 0 0 1 1.4 0Zm6.49 9.21a1 1 0 0 1 1.41 0l4.39 4.4a1 1 0 0 1 0 1.4l-4.39 4.4a1 1 0 0 1-1.41-1.42l2.68-2.68h-9a1 1 0 0 1 0-2h9l-2.68-2.68a1 1 0 0 1 0-1.42Z"
    clip-rule="evenodd"
  />
</svg>`;

    const swapHorizontalBoldSvg = b$5 `<svg width="10" height="10" viewBox="0 0 10 10">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M3.77986 0.566631C4.0589 0.845577 4.0589 1.29784 3.77986 1.57678L3.08261 2.2738H6.34184C6.73647 2.2738 7.05637 2.5936 7.05637 2.98808C7.05637 3.38257 6.73647 3.70237 6.34184 3.70237H3.08261L3.77986 4.39938C4.0589 4.67833 4.0589 5.13059 3.77986 5.40954C3.50082 5.68848 3.04841 5.68848 2.76937 5.40954L0.852346 3.49316C0.573306 3.21421 0.573306 2.76195 0.852346 2.48301L2.76937 0.566631C3.04841 0.287685 3.50082 0.287685 3.77986 0.566631ZM6.22 4.59102C6.49904 4.31208 6.95145 4.31208 7.23049 4.59102L9.14751 6.5074C9.42655 6.78634 9.42655 7.23861 9.14751 7.51755L7.23049 9.43393C6.95145 9.71287 6.49904 9.71287 6.22 9.43393C5.94096 9.15498 5.94096 8.70272 6.22 8.42377L6.91725 7.72676L3.65802 7.72676C3.26339 7.72676 2.94349 7.40696 2.94349 7.01247C2.94349 6.61798 3.26339 6.29819 3.65802 6.29819L6.91725 6.29819L6.22 5.60117C5.94096 5.32223 5.94096 4.86997 6.22 4.59102Z"
    clip-rule="evenodd"
  />
</svg>`;

    const swapHorizontalMediumSvg = b$5 `<svg
  width="14"
  height="14"
  viewBox="0 0 14 14"
  fill="none"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M13.7306 3.24213C14.0725 3.58384 14.0725 4.13786 13.7306 4.47957L10.7418 7.46737C10.4 7.80908 9.84581 7.80908 9.50399 7.46737C9.16216 7.12567 9.16216 6.57165 9.50399 6.22994L10.9986 4.73585H5.34082C4.85741 4.73585 4.46553 4.3441 4.46553 3.86085C4.46553 3.3776 4.85741 2.98585 5.34082 2.98585L10.9986 2.98585L9.50399 1.49177C9.16216 1.15006 9.16216 0.596037 9.50399 0.254328C9.84581 -0.0873803 10.4 -0.0873803 10.7418 0.254328L13.7306 3.24213ZM9.52515 10.1352C9.52515 10.6185 9.13327 11.0102 8.64986 11.0102L2.9921 11.0102L4.48669 12.5043C4.82852 12.846 4.82852 13.4001 4.48669 13.7418C4.14487 14.0835 3.59066 14.0835 3.24884 13.7418L0.26003 10.754C0.0958806 10.5899 0.0036621 10.3673 0.00366211 10.1352C0.00366212 9.90318 0.0958806 9.68062 0.26003 9.51652L3.24884 6.52872C3.59066 6.18701 4.14487 6.18701 4.48669 6.52872C4.82851 6.87043 4.82851 7.42445 4.48669 7.76616L2.9921 9.26024L8.64986 9.26024C9.13327 9.26024 9.52515 9.65199 9.52515 10.1352Z"
    fill="currentColor"
  />
</svg>

`;

    const swapVerticalSvg = b$5 `<svg fill="none" viewBox="0 0 14 14">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M3.48 2.18a1 1 0 0 1 1.41 0l2.68 2.68a1 1 0 1 1-1.41 1.42l-.98-.98v4.56a1 1 0 0 1-2 0V5.3l-.97.98A1 1 0 0 1 .79 4.86l2.69-2.68Zm6.34 2.93a1 1 0 0 1 1 1v4.56l.97-.98a1 1 0 1 1 1.42 1.42l-2.69 2.68a1 1 0 0 1-1.41 0l-2.68-2.68a1 1 0 0 1 1.41-1.42l.98.98V6.1a1 1 0 0 1 1-1Z"
    clip-rule="evenodd"
  />
</svg>`;

    const telegramSvg = b$5 `<svg fill="none" viewBox="0 0 40 40">
  <g clip-path="url(#a)">
    <g clip-path="url(#b)">
      <circle cx="20" cy="19.89" r="20" fill="#5865F2" />
      <path
        fill="#fff"
        fill-rule="evenodd"
        d="M25.71 28.15C30.25 28 32 25.02 32 25.02c0-6.61-2.96-11.98-2.96-11.98-2.96-2.22-5.77-2.15-5.77-2.15l-.29.32c3.5 1.07 5.12 2.61 5.12 2.61a16.75 16.75 0 0 0-10.34-1.93l-.35.04a15.43 15.43 0 0 0-5.88 1.9s1.71-1.63 5.4-2.7l-.2-.24s-2.81-.07-5.77 2.15c0 0-2.96 5.37-2.96 11.98 0 0 1.73 2.98 6.27 3.13l1.37-1.7c-2.6-.79-3.6-2.43-3.6-2.43l.58.35.09.06.08.04.02.01.08.05a17.25 17.25 0 0 0 4.52 1.58 14.4 14.4 0 0 0 8.3-.86c.72-.27 1.52-.66 2.37-1.21 0 0-1.03 1.68-3.72 2.44.61.78 1.35 1.67 1.35 1.67Zm-9.55-9.6c-1.17 0-2.1 1.03-2.1 2.28 0 1.25.95 2.28 2.1 2.28 1.17 0 2.1-1.03 2.1-2.28.01-1.25-.93-2.28-2.1-2.28Zm7.5 0c-1.17 0-2.1 1.03-2.1 2.28 0 1.25.95 2.28 2.1 2.28 1.17 0 2.1-1.03 2.1-2.28 0-1.25-.93-2.28-2.1-2.28Z"
        clip-rule="evenodd"
      />
    </g>
  </g>
  <defs>
    <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
    <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
  </defs>
</svg> `;

    const twitchSvg = b$5 `<svg fill="none" viewBox="0 0 40 40">
  <g clip-path="url(#a)">
    <g clip-path="url(#b)">
      <circle cx="20" cy="19.89" r="20" fill="#5A3E85" />
      <g clip-path="url(#c)">
        <path
          fill="#fff"
          d="M18.22 25.7 20 23.91h3.34l2.1-2.1v-6.68H15.4v8.78h2.82v1.77Zm3.87-8.16h1.25v3.66H22.1v-3.66Zm-3.34 0H20v3.66h-1.25v-3.66ZM20 7.9a12 12 0 1 0 0 24 12 12 0 0 0 0-24Zm6.69 14.56-3.66 3.66h-2.72l-1.77 1.78h-1.88V26.1H13.3v-9.82l.94-2.4H26.7v8.56Z"
        />
      </g>
    </g>
  </g>
  <defs>
    <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
    <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
    <clipPath id="c"><path fill="#fff" d="M8 7.89h24v24H8z" /></clipPath>
  </defs>
</svg>`;

    const twitterSvg = b$5 `<svg fill="none" viewBox="0 0 40 40">
  <g clip-path="url(#a)">
    <g clip-path="url(#b)">
      <circle cx="20" cy="19.89" r="20" fill="#1D9BF0" />
      <path
        fill="#fff"
        d="M30 13.81c-.74.33-1.53.55-2.36.65.85-.51 1.5-1.32 1.8-2.27-.79.47-1.66.8-2.6 1a4.1 4.1 0 0 0-7 3.73c-3.4-.17-6.42-1.8-8.45-4.28a4.1 4.1 0 0 0 1.27 5.47c-.67-.02-1.3-.2-1.86-.5a4.1 4.1 0 0 0 3.3 4.07c-.58.15-1.21.19-1.86.07a4.1 4.1 0 0 0 3.83 2.85A8.25 8.25 0 0 1 10 26.3a11.62 11.62 0 0 0 6.29 1.84c7.62 0 11.92-6.44 11.66-12.2.8-.59 1.5-1.3 2.05-2.13Z"
      />
    </g>
  </g>
  <defs>
    <clipPath id="a"><rect width="40" height="40" fill="#fff" rx="20" /></clipPath>
    <clipPath id="b"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
  </defs>
</svg>`;

    const twitterIconSvg = b$5 `<svg fill="none" viewBox="0 0 16 16">
  <path
    fill="currentColor"
    d="m14.36 4.74.01.42c0 4.34-3.3 9.34-9.34 9.34A9.3 9.3 0 0 1 0 13.03a6.6 6.6 0 0 0 4.86-1.36 3.29 3.29 0 0 1-3.07-2.28c.5.1 1 .07 1.48-.06A3.28 3.28 0 0 1 .64 6.11v-.04c.46.26.97.4 1.49.41A3.29 3.29 0 0 1 1.11 2.1a9.32 9.32 0 0 0 6.77 3.43 3.28 3.28 0 0 1 5.6-3 6.59 6.59 0 0 0 2.08-.8 3.3 3.3 0 0 1-1.45 1.82A6.53 6.53 0 0 0 16 3.04c-.44.66-1 1.23-1.64 1.7Z"
  />
</svg>`;

    const verifySvg = b$5 `<svg fill="none" viewBox="0 0 28 28">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M18.1 4.76c-.42-.73-1.33-1.01-2.09-.66l-1.42.66c-.37.18-.8.18-1.18 0l-1.4-.65a1.63 1.63 0 0 0-2.1.66l-.84 1.45c-.2.34-.53.59-.92.67l-1.7.35c-.83.17-1.39.94-1.3 1.78l.19 1.56c.04.39-.08.78-.33 1.07l-1.12 1.3c-.52.6-.52 1.5 0 2.11L5 16.38c.25.3.37.68.33 1.06l-.18 1.57c-.1.83.46 1.6 1.28 1.78l1.7.35c.4.08.73.32.93.66l.84 1.43a1.63 1.63 0 0 0 2.09.66l1.41-.66c.37-.17.8-.17 1.18 0l1.43.67c.76.35 1.66.07 2.08-.65l.86-1.45c.2-.34.54-.58.92-.66l1.68-.35A1.63 1.63 0 0 0 22.84 19l-.18-1.57a1.4 1.4 0 0 1 .33-1.06l1.12-1.32c.52-.6.52-1.5 0-2.11l-1.12-1.3a1.4 1.4 0 0 1-.33-1.07l.18-1.57c.1-.83-.46-1.6-1.28-1.77l-1.68-.35a1.4 1.4 0 0 1-.92-.66l-.86-1.47Zm-3.27-3.2a4.43 4.43 0 0 1 5.69 1.78l.54.93 1.07.22a4.43 4.43 0 0 1 3.5 4.84l-.11.96.7.83a4.43 4.43 0 0 1 .02 5.76l-.72.85.1.96a4.43 4.43 0 0 1-3.5 4.84l-1.06.22-.54.92a4.43 4.43 0 0 1-5.68 1.77l-.84-.4-.82.39a4.43 4.43 0 0 1-5.7-1.79l-.51-.89-1.09-.22a4.43 4.43 0 0 1-3.5-4.84l.1-.96-.72-.85a4.43 4.43 0 0 1 .01-5.76l.71-.83-.1-.95a4.43 4.43 0 0 1 3.5-4.84l1.08-.23.53-.9a4.43 4.43 0 0 1 5.7-1.8l.81.38.83-.39ZM18.2 9.4c.65.42.84 1.28.42 1.93l-4.4 6.87a1.4 1.4 0 0 1-2.26.14L9.5 15.39a1.4 1.4 0 0 1 2.15-1.8l1.23 1.48 3.38-5.26a1.4 1.4 0 0 1 1.93-.42Z"
    clip-rule="evenodd"
  />
</svg>`;

    const verifyFilledSvg = b$5 `<svg fill="none" viewBox="0 0 14 14">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="m4.1 12.43-.45-.78-.93-.2a1.65 1.65 0 0 1-1.31-1.8l.1-.86-.61-.71a1.65 1.65 0 0 1 0-2.16l.6-.7-.09-.85c-.1-.86.47-1.64 1.3-1.81l.94-.2.45-.78A1.65 1.65 0 0 1 6.23.9l.77.36.78-.36c.77-.36 1.69-.07 2.12.66l.47.8.91.2c.84.17 1.4.95 1.31 1.8l-.1.86.6.7c.54.62.54 1.54.01 2.16l-.6.71.09.86c.1.85-.47 1.63-1.3 1.8l-.92.2-.47.79a1.65 1.65 0 0 1-2.12.66L7 12.74l-.77.36c-.78.35-1.7.07-2.13-.67Zm5.74-6.9a1 1 0 1 0-1.68-1.07L6.32 7.3l-.55-.66a1 1 0 0 0-1.54 1.28l1.43 1.71a1 1 0 0 0 1.61-.1l2.57-4Z"
    clip-rule="evenodd"
  />
</svg>`;

    const walletPlaceholderSvg = b$5 `
  <svg fill="none" viewBox="0 0 48 44">
    <path
      style="fill: var(--wui-color-bg-300);"
      d="M4.56 8.64c-1.23 1.68-1.23 4.08-1.23 8.88v8.96c0 4.8 0 7.2 1.23 8.88.39.55.87 1.02 1.41 1.42C7.65 38 10.05 38 14.85 38h14.3c4.8 0 7.2 0 8.88-1.22a6.4 6.4 0 0 0 1.41-1.42c.83-1.14 1.1-2.6 1.19-4.92a6.4 6.4 0 0 0 5.16-4.65c.21-.81.21-1.8.21-3.79 0-1.98 0-2.98-.22-3.79a6.4 6.4 0 0 0-5.15-4.65c-.1-2.32-.36-3.78-1.19-4.92a6.4 6.4 0 0 0-1.41-1.42C36.35 6 33.95 6 29.15 6h-14.3c-4.8 0-7.2 0-8.88 1.22a6.4 6.4 0 0 0-1.41 1.42Z"
    />
    <path
      style="fill: var(--wui-color-fg-200);"
      fill-rule="evenodd"
      d="M2.27 11.33a6.4 6.4 0 0 1 6.4-6.4h26.66a6.4 6.4 0 0 1 6.4 6.4v1.7a6.4 6.4 0 0 1 5.34 6.3v5.34a6.4 6.4 0 0 1-5.34 6.3v1.7a6.4 6.4 0 0 1-6.4 6.4H8.67a6.4 6.4 0 0 1-6.4-6.4V11.33ZM39.6 31.07h-6.93a9.07 9.07 0 1 1 0-18.14h6.93v-1.6a4.27 4.27 0 0 0-4.27-4.26H8.67a4.27 4.27 0 0 0-4.27 4.26v21.34a4.27 4.27 0 0 0 4.27 4.26h26.66a4.27 4.27 0 0 0 4.27-4.26v-1.6Zm-6.93-16a6.93 6.93 0 0 0 0 13.86h8a4.27 4.27 0 0 0 4.26-4.26v-5.34a4.27 4.27 0 0 0-4.26-4.26h-8Z"
      clip-rule="evenodd"
    />
  </svg>
`;

    const walletSvg = b$5 `<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M0 5.5c0-1.8 1.46-3.25 3.25-3.25H14.5c1.8 0 3.25 1.46 3.25 3.25v.28A3.25 3.25 0 0 1 20 8.88v2.24c0 1.45-.94 2.68-2.25 3.1v.28c0 1.8-1.46 3.25-3.25 3.25H3.25A3.25 3.25 0 0 1 0 14.5v-9Zm15.75 8.88h-2.38a4.38 4.38 0 0 1 0-8.76h2.38V5.5c0-.69-.56-1.25-1.25-1.25H3.25C2.56 4.25 2 4.81 2 5.5v9c0 .69.56 1.25 1.25 1.25H14.5c.69 0 1.25-.56 1.25-1.25v-.13Zm-2.38-6.76a2.37 2.37 0 1 0 0 4.75h3.38c.69 0 1.25-.55 1.25-1.24V8.87c0-.69-.56-1.24-1.25-1.24h-3.38Z"
    clip-rule="evenodd"
  />
</svg>`;

    const walletConnectSvg = b$5 `<svg fill="none" viewBox="0 0 96 67">
  <path
    fill="currentColor"
    d="M25.32 18.8a32.56 32.56 0 0 1 45.36 0l1.5 1.47c.63.62.63 1.61 0 2.22l-5.15 5.05c-.31.3-.82.3-1.14 0l-2.07-2.03a22.71 22.71 0 0 0-31.64 0l-2.22 2.18c-.31.3-.82.3-1.14 0l-5.15-5.05a1.55 1.55 0 0 1 0-2.22l1.65-1.62Zm56.02 10.44 4.59 4.5c.63.6.63 1.6 0 2.21l-20.7 20.26c-.62.61-1.63.61-2.26 0L48.28 41.83a.4.4 0 0 0-.56 0L33.03 56.21c-.63.61-1.64.61-2.27 0L10.07 35.95a1.55 1.55 0 0 1 0-2.22l4.59-4.5a1.63 1.63 0 0 1 2.27 0L31.6 43.63a.4.4 0 0 0 .57 0l14.69-14.38a1.63 1.63 0 0 1 2.26 0l14.69 14.38a.4.4 0 0 0 .57 0l14.68-14.38a1.63 1.63 0 0 1 2.27 0Z"
  />
  <path
    stroke="#000"
    stroke-opacity=".1"
    d="M25.67 19.15a32.06 32.06 0 0 1 44.66 0l1.5 1.48c.43.42.43 1.09 0 1.5l-5.15 5.05a.31.31 0 0 1-.44 0l-2.07-2.03a23.21 23.21 0 0 0-32.34 0l-2.22 2.18a.31.31 0 0 1-.44 0l-5.15-5.05a1.05 1.05 0 0 1 0-1.5l1.65-1.63ZM81 29.6l4.6 4.5c.42.41.42 1.09 0 1.5l-20.7 20.26c-.43.43-1.14.43-1.57 0L48.63 41.47a.9.9 0 0 0-1.26 0L32.68 55.85c-.43.43-1.14.43-1.57 0L10.42 35.6a1.05 1.05 0 0 1 0-1.5l4.59-4.5a1.13 1.13 0 0 1 1.57 0l14.68 14.38a.9.9 0 0 0 1.27 0l-.35-.35.35.35L47.22 29.6a1.13 1.13 0 0 1 1.56 0l14.7 14.38a.9.9 0 0 0 1.26 0L79.42 29.6a1.13 1.13 0 0 1 1.57 0Z"
  />
</svg>`;

    const warningCircleSvg = b$5 `<svg fill="none" viewBox="0 0 20 20">
  <path
    fill="currentColor"
    d="M11 6.67a1 1 0 1 0-2 0v2.66a1 1 0 0 0 2 0V6.67ZM10 14.5a1.25 1.25 0 1 0 0-2.5 1.25 1.25 0 0 0 0 2.5Z"
  />
  <path
    fill="currentColor"
    fill-rule="evenodd"
    d="M10 1a9 9 0 1 0 0 18 9 9 0 0 0 0-18Zm-7 9a7 7 0 1 1 14 0 7 7 0 0 1-14 0Z"
    clip-rule="evenodd"
  />
</svg>`;

    const recycleHorizontalSvg = b$5 `<svg
  fill="none"
  viewBox="0 0 21 20"
>
  <path
    fill="currentColor"
    d="M8.8071 0.292893C9.19763 0.683417 9.19763 1.31658 8.8071 1.70711L6.91421 3.6H11.8404C14.3368 3.6 16.5533 5.1975 17.3427 7.56588L17.4487 7.88377C17.6233 8.40772 17.3402 8.97404 16.8162 9.14868C16.2923 9.32333 15.726 9.04017 15.5513 8.51623L15.4453 8.19834C14.9281 6.64664 13.476 5.6 11.8404 5.6H6.91421L8.8071 7.49289C9.19763 7.88342 9.19763 8.51658 8.8071 8.90711C8.41658 9.29763 7.78341 9.29763 7.39289 8.90711L3.79289 5.30711C3.40236 4.91658 3.40236 4.28342 3.79289 3.89289L7.39289 0.292893C7.78341 -0.0976311 8.41658 -0.0976311 8.8071 0.292893ZM4.18377 10.8513C4.70771 10.6767 5.27403 10.9598 5.44868 11.4838L5.55464 11.8017C6.07188 13.3534 7.52401 14.4 9.15964 14.4L14.0858 14.4L12.1929 12.5071C11.8024 12.1166 11.8024 11.4834 12.1929 11.0929C12.5834 10.7024 13.2166 10.7024 13.6071 11.0929L17.2071 14.6929C17.5976 15.0834 17.5976 15.7166 17.2071 16.1071L13.6071 19.7071C13.2166 20.0976 12.5834 20.0976 12.1929 19.7071C11.8024 19.3166 11.8024 18.6834 12.1929 18.2929L14.0858 16.4L9.15964 16.4C6.66314 16.4 4.44674 14.8025 3.65728 12.4341L3.55131 12.1162C3.37667 11.5923 3.65983 11.026 4.18377 10.8513Z"
  /></svg
>`;

    const bankSvg = b$5 `<svg
  xmlns="http://www.w3.org/2000/svg"
  width="12"
  height="13"
  viewBox="0 0 12 13"
  fill="none"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M5.61391 1.57124C5.85142 1.42873 6.14813 1.42873 6.38564 1.57124L11.0793 4.38749C11.9179 4.89067 11.5612 6.17864 10.5832 6.17864H9.96398V10.0358H10.2854C10.6996 10.0358 11.0354 10.3716 11.0354 10.7858C11.0354 11.2 10.6996 11.5358 10.2854 11.5358H1.71416C1.29995 11.5358 0.964172 11.2 0.964172 10.7858C0.964172 10.3716 1.29995 10.0358 1.71416 10.0358H2.03558L2.03558 6.17864H1.41637C0.438389 6.17864 0.0816547 4.89066 0.920263 4.38749L5.61391 1.57124ZM3.53554 6.17864V10.0358H5.24979V6.17864H3.53554ZM6.74976 6.17864V10.0358H8.46401V6.17864H6.74976ZM8.64913 4.67864H3.35043L5.99978 3.089L8.64913 4.67864Z"
    fill="currentColor"
  /></svg
>`;

    const cardSvg = b$5 `<svg
  xmlns="http://www.w3.org/2000/svg"
  width="12"
  height="13"
  viewBox="0 0 12 13"
  fill="none"
>
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M4.16072 2C4.17367 2 4.18665 2 4.19968 2L7.83857 2C8.36772 1.99998 8.82398 1.99996 9.19518 2.04018C9.5895 2.0829 9.97577 2.17811 10.3221 2.42971C10.5131 2.56849 10.6811 2.73647 10.8198 2.92749C11.0714 3.27379 11.1666 3.66007 11.2094 4.0544C11.2496 4.42561 11.2496 4.88188 11.2495 5.41105V7.58896C11.2496 8.11812 11.2496 8.57439 11.2094 8.94561C11.1666 9.33994 11.0714 9.72621 10.8198 10.0725C10.6811 10.2635 10.5131 10.4315 10.3221 10.5703C9.97577 10.8219 9.5895 10.9171 9.19518 10.9598C8.82398 11 8.36772 11 7.83856 11H4.16073C3.63157 11 3.17531 11 2.80411 10.9598C2.40979 10.9171 2.02352 10.8219 1.67722 10.5703C1.48621 10.4315 1.31824 10.2635 1.17946 10.0725C0.927858 9.72621 0.832652 9.33994 0.78993 8.94561C0.749713 8.5744 0.749733 8.11813 0.749757 7.58896L0.749758 5.45C0.749758 5.43697 0.749758 5.42399 0.749757 5.41104C0.749733 4.88188 0.749713 4.42561 0.78993 4.0544C0.832652 3.66007 0.927858 3.27379 1.17946 2.92749C1.31824 2.73647 1.48621 2.56849 1.67722 2.42971C2.02352 2.17811 2.40979 2.0829 2.80411 2.04018C3.17531 1.99996 3.63157 1.99998 4.16072 2ZM2.96567 3.53145C2.69897 3.56034 2.60687 3.60837 2.55888 3.64324C2.49521 3.6895 2.43922 3.74549 2.39296 3.80916C2.35809 3.85715 2.31007 3.94926 2.28117 4.21597C2.26629 4.35335 2.25844 4.51311 2.25431 4.70832H9.74498C9.74085 4.51311 9.733 4.35335 9.71812 4.21597C9.68922 3.94926 9.6412 3.85715 9.60633 3.80916C9.56007 3.74549 9.50408 3.6895 9.44041 3.64324C9.39242 3.60837 9.30031 3.56034 9.03362 3.53145C8.75288 3.50103 8.37876 3.5 7.79961 3.5H4.19968C3.62053 3.5 3.24641 3.50103 2.96567 3.53145ZM9.74956 6.20832H2.24973V7.55C2.24973 8.12917 2.25076 8.5033 2.28117 8.78404C2.31007 9.05074 2.35809 9.14285 2.39296 9.19084C2.43922 9.25451 2.49521 9.31051 2.55888 9.35677C2.60687 9.39163 2.69897 9.43966 2.96567 9.46856C3.24641 9.49897 3.62053 9.5 4.19968 9.5H7.79961C8.37876 9.5 8.75288 9.49897 9.03362 9.46856C9.30032 9.43966 9.39242 9.39163 9.44041 9.35677C9.50408 9.31051 9.56007 9.25451 9.60633 9.19084C9.6412 9.14285 9.68922 9.05075 9.71812 8.78404C9.74854 8.5033 9.74956 8.12917 9.74956 7.55V6.20832ZM6.74963 8C6.74963 7.58579 7.08541 7.25 7.49961 7.25H8.2496C8.6638 7.25 8.99958 7.58579 8.99958 8C8.99958 8.41422 8.6638 8.75 8.2496 8.75H7.49961C7.08541 8.75 6.74963 8.41422 6.74963 8Z"
    fill="currentColor"
  /></svg
>`;

    const plusSvg = b$5 `<svg
  width="13"
  height="12"
  viewBox="0 0 13 12"
  fill="none"
>
  <path
    fill="currentColor"
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M0.794373 5.99982C0.794373 5.52643 1.17812 5.14268 1.6515 5.14268H5.643V1.15109C5.643 0.677701 6.02675 0.293946 6.50012 0.293945C6.9735 0.293946 7.35725 0.677701 7.35725 1.15109V5.14268H11.3488C11.8221 5.14268 12.2059 5.52643 12.2059 5.99982C12.2059 6.47321 11.8221 6.85696 11.3488 6.85696H7.35725V10.8486C7.35725 11.3219 6.9735 11.7057 6.50012 11.7057C6.02675 11.7057 5.643 11.3219 5.643 10.8486V6.85696H1.6515C1.17812 6.85696 0.794373 6.47321 0.794373 5.99982Z"
  /></svg
>`;

    const cursorTransparentSvg = b$5 `<svg fill="none" viewBox="0 0 14 6">
  <path style="fill: var(--wui-color-bg-150);" d="M0 1h14L9.21 5.12a3.31 3.31 0 0 1-4.49 0L0 1Z" />
  <path
    style="stroke: var(--wui-color-inverse-100);"
    stroke-opacity=".05"
    d="M1.33 1.5h11.32L8.88 4.75l-.01.01a2.81 2.81 0 0 1-3.8 0l-.02-.01L1.33 1.5Z"
  />
  <path
    style="fill: var(--wui-color-bg-150);"
    d="M1.25.71h11.5L9.21 3.88a3.31 3.31 0 0 1-4.49 0L1.25.71Z"
  />
</svg> `;

    var __decorate$25 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    const svgOptions$1 = {
        add: addSvg,
        allWallets: allWalletsSvg,
        arrowBottomCircle: arrowBottomCircleSvg,
        appStore: appStoreSvg,
        apple: appleSvg,
        arrowBottom: arrowBottomSvg,
        arrowLeft: arrowLeftSvg,
        arrowRight: arrowRightSvg,
        arrowTop: arrowTopSvg,
        bank: bankSvg,
        browser: browserSvg$1,
        card: cardSvg,
        checkmark: checkmarkSvg,
        chevronBottom: chevronBottomSvg,
        chevronLeft: chevronLeftSvg,
        chevronRight: chevronRightSvg,
        chevronTop: chevronTopSvg,
        chromeStore: chromeStoreSvg,
        clock: clockSvg,
        close: closeSvg,
        compass: compassSvg,
        coinPlaceholder: coinPlaceholderSvg,
        copy: copySvg,
        cursor: cursorSvg,
        cursorTransparent: cursorTransparentSvg,
        desktop: desktopSvg,
        disconnect: disconnectSvg,
        discord: discordSvg,
        etherscan: etherscanSvg,
        extension: extensionSvg,
        externalLink: externalLinkSvg,
        facebook: facebookSvg,
        filters: filtersSvg,
        github: githubSvg,
        google: googleSvg,
        helpCircle: helpCircleSvg,
        infoCircle: infoCircleSvg,
        mail: mailSvg,
        mobile: mobileSvg,
        networkPlaceholder: networkPlaceholderSvg,
        nftPlaceholder: nftPlaceholderSvg,
        off: offSvg,
        playStore: playStoreSvg,
        plus: plusSvg,
        qrCode: qrCodeIcon,
        recycleHorizontal: recycleHorizontalSvg,
        refresh: refreshSvg,
        search: searchSvg,
        send: sendSvg,
        swapHorizontal: swapHorizontalSvg,
        swapHorizontalMedium: swapHorizontalMediumSvg,
        swapHorizontalBold: swapHorizontalBoldSvg,
        swapVertical: swapVerticalSvg,
        telegram: telegramSvg,
        twitch: twitchSvg,
        twitter: twitterSvg,
        twitterIcon: twitterIconSvg,
        verify: verifySvg,
        verifyFilled: verifyFilledSvg,
        wallet: walletSvg,
        walletConnect: walletConnectSvg,
        walletPlaceholder: walletPlaceholderSvg,
        warningCircle: warningCircleSvg
    };
    let WuiIcon = class WuiIcon extends s$e {
        constructor() {
            super(...arguments);
            this.size = 'md';
            this.name = 'copy';
            this.color = 'fg-300';
        }
        render() {
            this.style.cssText = `
      --local-color: ${`var(--wui-color-${this.color});`}
      --local-width: ${`var(--wui-icon-size-${this.size});`}
    `;
            return x$5 `${svgOptions$1[this.name]}`;
        }
    };
    WuiIcon.styles = [resetStyles, colorStyles, styles$1I];
    __decorate$25([
        n$j()
    ], WuiIcon.prototype, "size", void 0);
    __decorate$25([
        n$j()
    ], WuiIcon.prototype, "name", void 0);
    __decorate$25([
        n$j()
    ], WuiIcon.prototype, "color", void 0);
    WuiIcon = __decorate$25([
        customElement('wui-icon')
    ], WuiIcon);

    var styles$1H = i$h `
  :host {
    display: block;
    width: 100%;
    height: 100%;
  }

  img {
    display: block;
    width: 100%;
    height: 100%;
    object-fit: cover;
    object-position: center center;
    border-radius: inherit;
  }
`;

    var __decorate$24 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let WuiImage = class WuiImage extends s$e {
        constructor() {
            super(...arguments);
            this.src = './path/to/image.jpg';
            this.alt = 'Image';
        }
        render() {
            return x$5 `<img src=${this.src} alt=${this.alt} />`;
        }
    };
    WuiImage.styles = [resetStyles, colorStyles, styles$1H];
    __decorate$24([
        n$j()
    ], WuiImage.prototype, "src", void 0);
    __decorate$24([
        n$j()
    ], WuiImage.prototype, "alt", void 0);
    WuiImage = __decorate$24([
        customElement('wui-image')
    ], WuiImage);

    var styles$1G = i$h `
  :host {
    display: block;
    width: var(--wui-box-size-lg);
    height: var(--wui-box-size-lg);
  }

  svg {
    width: var(--wui-box-size-lg);
    height: var(--wui-box-size-lg);
    fill: none;
    stroke: transparent;
    stroke-linecap: round;
    transition: all var(--wui-ease-in-power-3) var(--wui-duration-lg);
  }

  use {
    stroke: var(--wui-color-accent-100);
    stroke-width: 2px;
    stroke-dasharray: 54, 118;
    stroke-dashoffset: 172;
    animation: dash 1s linear infinite;
  }

  @keyframes dash {
    to {
      stroke-dashoffset: 0px;
    }
  }
`;

    var __decorate$23 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let WuiLoadingHexagon = class WuiLoadingHexagon extends s$e {
        render() {
            return x$5 `
      <svg viewBox="0 0 54 59">
        <path
          id="wui-loader-path"
          d="M17.22 5.295c3.877-2.277 5.737-3.363 7.72-3.726a11.44 11.44 0 0 1 4.12 0c1.983.363 3.844 1.45 7.72 3.726l6.065 3.562c3.876 2.276 5.731 3.372 7.032 4.938a11.896 11.896 0 0 1 2.06 3.63c.683 1.928.688 4.11.688 8.663v7.124c0 4.553-.005 6.735-.688 8.664a11.896 11.896 0 0 1-2.06 3.63c-1.3 1.565-3.156 2.66-7.032 4.937l-6.065 3.563c-3.877 2.276-5.737 3.362-7.72 3.725a11.46 11.46 0 0 1-4.12 0c-1.983-.363-3.844-1.449-7.72-3.726l-6.065-3.562c-3.876-2.276-5.731-3.372-7.032-4.938a11.885 11.885 0 0 1-2.06-3.63c-.682-1.928-.688-4.11-.688-8.663v-7.124c0-4.553.006-6.735.688-8.664a11.885 11.885 0 0 1 2.06-3.63c1.3-1.565 3.156-2.66 7.032-4.937l6.065-3.562Z"
        />
        <use xlink:href="#wui-loader-path"></use>
      </svg>
    `;
        }
    };
    WuiLoadingHexagon.styles = [resetStyles, styles$1G];
    WuiLoadingHexagon = __decorate$23([
        customElement('wui-loading-hexagon')
    ], WuiLoadingHexagon);

    var styles$1F = i$h `
  :host {
    display: flex;
  }

  :host([data-size='sm']) > svg {
    width: 12px;
    height: 12px;
  }

  :host([data-size='md']) > svg {
    width: 16px;
    height: 16px;
  }

  :host([data-size='lg']) > svg {
    width: 24px;
    height: 24px;
  }

  :host([data-size='xl']) > svg {
    width: 32px;
    height: 32px;
  }

  svg {
    animation: rotate 2s linear infinite;
    transition: all var(--wui-ease-in-power-3) var(--wui-duration-lg);
  }

  circle {
    fill: none;
    stroke: var(--local-color);
    stroke-width: 4px;
    stroke-dasharray: 1, 124;
    stroke-dashoffset: 0;
    stroke-linecap: round;
    animation: dash 1.5s ease-in-out infinite;
  }

  :host([data-size='md']) > svg > circle {
    stroke-width: 6px;
  }

  :host([data-size='sm']) > svg > circle {
    stroke-width: 8px;
  }

  @keyframes rotate {
    100% {
      transform: rotate(360deg);
    }
  }

  @keyframes dash {
    0% {
      stroke-dasharray: 1, 124;
      stroke-dashoffset: 0;
    }

    50% {
      stroke-dasharray: 90, 124;
      stroke-dashoffset: -35;
    }

    100% {
      stroke-dashoffset: -125;
    }
  }
`;

    var __decorate$22 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let WuiLoadingSpinner = class WuiLoadingSpinner extends s$e {
        constructor() {
            super(...arguments);
            this.color = 'accent-100';
            this.size = 'lg';
        }
        render() {
            this.style.cssText = `--local-color: var(--wui-color-${this.color});`;
            this.dataset['size'] = this.size;
            return x$5 `<svg viewBox="25 25 50 50">
      <circle r="20" cy="50" cx="50"></circle>
    </svg>`;
        }
    };
    WuiLoadingSpinner.styles = [resetStyles, styles$1F];
    __decorate$22([
        n$j()
    ], WuiLoadingSpinner.prototype, "color", void 0);
    __decorate$22([
        n$j()
    ], WuiLoadingSpinner.prototype, "size", void 0);
    WuiLoadingSpinner = __decorate$22([
        customElement('wui-loading-spinner')
    ], WuiLoadingSpinner);

    var styles$1E = i$h `
  :host {
    display: block;
    width: var(--wui-box-size-md);
    height: var(--wui-box-size-md);
  }

  svg {
    width: var(--wui-box-size-md);
    height: var(--wui-box-size-md);
    transition: all var(--wui-ease-in-power-3) var(--wui-duration-lg);
  }

  rect {
    fill: none;
    stroke: var(--wui-color-accent-100);
    stroke-width: 4px;
    stroke-linecap: round;
    animation: dash 1s linear infinite;
  }

  @keyframes dash {
    to {
      stroke-dashoffset: 0px;
    }
  }
`;

    var __decorate$21 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let WuiLoadingThumbnail = class WuiLoadingThumbnail extends s$e {
        constructor() {
            super(...arguments);
            this.radius = 36;
        }
        render() {
            return this.svgLoaderTemplate();
        }
        svgLoaderTemplate() {
            const radius = this.radius > 50 ? 50 : this.radius;
            const standardValue = 36;
            const radiusFactor = standardValue - radius;
            const dashArrayStart = 116 + radiusFactor;
            const dashArrayEnd = 245 + radiusFactor;
            const dashOffset = 360 + radiusFactor * 1.75;
            return x$5 `
      <svg viewBox="0 0 110 110" width="110" height="110">
        <rect
          x="2"
          y="2"
          width="106"
          height="106"
          rx=${radius}
          stroke-dasharray="${dashArrayStart} ${dashArrayEnd}"
          stroke-dashoffset=${dashOffset}
        />
      </svg>
    `;
        }
    };
    WuiLoadingThumbnail.styles = [resetStyles, styles$1E];
    __decorate$21([
        n$j({ type: Number })
    ], WuiLoadingThumbnail.prototype, "radius", void 0);
    WuiLoadingThumbnail = __decorate$21([
        customElement('wui-loading-thumbnail')
    ], WuiLoadingThumbnail);

    var styles$1D = i$h `
  :host {
    display: block;
    box-shadow: inset 0 0 0 1px var(--wui-gray-glass-005);
    background: linear-gradient(
      120deg,
      var(--wui-color-bg-200) 5%,
      var(--wui-color-bg-200) 48%,
      var(--wui-color-bg-300) 55%,
      var(--wui-color-bg-300) 60%,
      var(--wui-color-bg-300) calc(60% + 10px),
      var(--wui-color-bg-200) calc(60% + 12px),
      var(--wui-color-bg-200) 100%
    );
    background-size: 250%;
    animation: shimmer 3s linear infinite reverse;
  }

  @keyframes shimmer {
    from {
      background-position: -250% 0;
    }
    to {
      background-position: 250% 0;
    }
  }
`;

    var __decorate$20 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let WuiShimmer = class WuiShimmer extends s$e {
        constructor() {
            super(...arguments);
            this.width = '';
            this.height = '';
            this.borderRadius = 'm';
        }
        render() {
            this.style.cssText = `
      width: ${this.width};
      height: ${this.height};
      border-radius: ${`clamp(0px,var(--wui-border-radius-${this.borderRadius}), 40px)`};
    `;
            return x$5 `<slot></slot>`;
        }
    };
    WuiShimmer.styles = [styles$1D];
    __decorate$20([
        n$j()
    ], WuiShimmer.prototype, "width", void 0);
    __decorate$20([
        n$j()
    ], WuiShimmer.prototype, "height", void 0);
    __decorate$20([
        n$j()
    ], WuiShimmer.prototype, "borderRadius", void 0);
    WuiShimmer = __decorate$20([
        customElement('wui-shimmer')
    ], WuiShimmer);

    /**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */
    const t$d={ATTRIBUTE:1,CHILD:2,PROPERTY:3,BOOLEAN_ATTRIBUTE:4,EVENT:5,ELEMENT:6},e$i=t=>(...e)=>({_$litDirective$:t,values:e});let i$e = class i{constructor(t){}get _$AU(){return this._$AM._$AU}_$AT(t,e,i){this._$Ct=t,this._$AM=e,this._$Ci=i;}_$AS(t,e){return this.update(t,e)}update(t,e){return this.render(...e)}};

    /**
     * @license
     * Copyright 2018 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */const e$h=e$i(class extends i$e{constructor(t){if(super(t),t.type!==t$d.ATTRIBUTE||"class"!==t.name||t.strings?.length>2)throw Error("`classMap()` can only be used in the `class` attribute and must be the only part in the attribute.")}render(t){return " "+Object.keys(t).filter((s=>t[s])).join(" ")+" "}update(s,[i]){if(void 0===this.st){this.st=new Set,void 0!==s.strings&&(this.nt=new Set(s.strings.join(" ").split(/\s/).filter((t=>""!==t))));for(const t in i)i[t]&&!this.nt?.has(t)&&this.st.add(t);return this.render(i)}const r=s.element.classList;for(const t of this.st)t in i||(r.remove(t),this.st.delete(t));for(const t in i){const s=!!i[t];s===this.st.has(t)||this.nt?.has(t)||(s?(r.add(t),this.st.add(t)):(r.remove(t),this.st.delete(t)));}return w$6}});

    var styles$1C = i$h `
  :host {
    display: inline-flex !important;
  }

  slot {
    width: 100%;
    display: inline-block;
    font-style: normal;
    font-family: var(--wui-font-family);
    font-feature-settings:
      'tnum' on,
      'lnum' on,
      'case' on;
    line-height: 130%;
    font-weight: var(--wui-font-weight-regular);
    overflow: inherit;
    text-overflow: inherit;
    text-align: var(--local-align);
    color: var(--local-color);
  }

  .wui-font-medium-400 {
    font-size: var(--wui-font-size-medium);
    font-weight: var(--wui-font-weight-light);
    letter-spacing: var(--wui-letter-spacing-medium);
  }

  .wui-font-medium-600 {
    font-size: var(--wui-font-size-medium);
    letter-spacing: var(--wui-letter-spacing-medium);
  }

  .wui-font-medium-title-600 {
    font-size: var(--wui-font-size-medium-title);
    letter-spacing: var(--wui-letter-spacing-medium-title);
  }

  .wui-font-mini-700 {
    font-size: var(--wui-font-size-mini);
    letter-spacing: var(--wui-letter-spacing-mini);
    text-transform: uppercase;
  }

  .wui-font-large-500,
  .wui-font-large-600,
  .wui-font-large-700 {
    font-size: var(--wui-font-size-large);
    letter-spacing: var(--wui-letter-spacing-large);
  }

  .wui-font-2xl-500,
  .wui-font-2xl-600,
  .wui-font-2xl-700 {
    font-size: var(--wui-font-size-2xl);
    letter-spacing: var(--wui-letter-spacing-2xl);
  }

  .wui-font-paragraph-500,
  .wui-font-paragraph-600,
  .wui-font-paragraph-700 {
    font-size: var(--wui-font-size-paragraph);
    letter-spacing: var(--wui-letter-spacing-paragraph);
  }

  .wui-font-small-400,
  .wui-font-small-500,
  .wui-font-small-600 {
    font-size: var(--wui-font-size-small);
    letter-spacing: var(--wui-letter-spacing-small);
  }

  .wui-font-tiny-400,
  .wui-font-tiny-500,
  .wui-font-tiny-600 {
    font-size: var(--wui-font-size-tiny);
    letter-spacing: var(--wui-letter-spacing-tiny);
  }

  .wui-font-micro-700,
  .wui-font-micro-600 {
    font-size: var(--wui-font-size-micro);
    letter-spacing: var(--wui-letter-spacing-micro);
    text-transform: uppercase;
  }

  .wui-font-tiny-400,
  .wui-font-small-400,
  .wui-font-paragraph-400 {
    font-weight: var(--wui-font-weight-light);
  }

  .wui-font-large-700,
  .wui-font-paragraph-700,
  .wui-font-micro-700,
  .wui-font-mini-700 {
    font-weight: var(--wui-font-weight-bold);
  }

  .wui-font-medium-600,
  .wui-font-medium-title-600,
  .wui-font-large-600,
  .wui-font-paragraph-600,
  .wui-font-small-600,
  .wui-font-tiny-600,
  .wui-font-micro-600 {
    font-weight: var(--wui-font-weight-medium);
  }
`;

    var __decorate$1$ = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let WuiText = class WuiText extends s$e {
        constructor() {
            super(...arguments);
            this.variant = 'paragraph-500';
            this.color = 'fg-300';
            this.align = 'left';
        }
        render() {
            const classes = {
                [`wui-font-${this.variant}`]: true,
                [`wui-color-${this.color}`]: true
            };
            this.style.cssText = `
      --local-align: ${this.align};
      --local-color: var(--wui-color-${this.color});
    `;
            return x$5 `<slot class=${e$h(classes)}></slot>`;
        }
    };
    WuiText.styles = [resetStyles, styles$1C];
    __decorate$1$([
        n$j()
    ], WuiText.prototype, "variant", void 0);
    __decorate$1$([
        n$j()
    ], WuiText.prototype, "color", void 0);
    __decorate$1$([
        n$j()
    ], WuiText.prototype, "align", void 0);
    WuiText = __decorate$1$([
        customElement('wui-text')
    ], WuiText);

    const browserSvg = b$5 `<svg fill="none" viewBox="0 0 60 60">
  <rect width="60" height="60" fill="#1DC956" rx="30" />
  <circle cx="30" cy="30" r="3" fill="#fff" />
  <path
    fill="#2BEE6C"
    stroke="#fff"
    stroke-width="2"
    d="m45.32 17.9-.88-.42.88.42.02-.05c.1-.2.21-.44.26-.7l-.82-.15.82.16a2 2 0 0 0-.24-1.4c-.13-.23-.32-.42-.47-.57a8.42 8.42 0 0 1-.04-.04l-.04-.04a2.9 2.9 0 0 0-.56-.47l-.51.86.5-.86a2 2 0 0 0-1.4-.24c-.26.05-.5.16-.69.26l-.05.02-15.05 7.25-.1.05c-1.14.55-1.85.89-2.46 1.37a7 7 0 0 0-1.13 1.14c-.5.6-.83 1.32-1.38 2.45l-.05.11-7.25 15.05-.02.05c-.1.2-.21.43-.26.69a2 2 0 0 0 .24 1.4l.85-.5-.85.5c.13.23.32.42.47.57l.04.04.04.04c.15.15.34.34.56.47a2 2 0 0 0 1.41.24l-.2-.98.2.98c.25-.05.5-.17.69-.26l.05-.02-.42-.87.42.87 15.05-7.25.1-.05c1.14-.55 1.85-.89 2.46-1.38a7 7 0 0 0 1.13-1.13 12.87 12.87 0 0 0 1.43-2.56l7.25-15.05Z"
  />
  <path
    fill="#1DC956"
    d="M33.38 32.72 30.7 29.3 15.86 44.14l.2.2a1 1 0 0 0 1.14.2l15.1-7.27a3 3 0 0 0 1.08-4.55Z"
  />
  <path
    fill="#86F999"
    d="m26.62 27.28 2.67 3.43 14.85-14.85-.2-.2a1 1 0 0 0-1.14-.2l-15.1 7.27a3 3 0 0 0-1.08 4.55Z"
  />
  <circle cx="30" cy="30" r="3" fill="#fff" transform="rotate(45 30 30)" />
  <rect width="59" height="59" x=".5" y=".5" stroke="#062B2B" stroke-opacity=".1" rx="29.5" />
</svg> `;

    const daoSvg = b$5 `<svg viewBox="0 0 60 60" fill="none">
  <g clip-path="url(#clip0_7734_50402)">
    <path
      d="M0 24.9C0 15.6485 0 11.0228 1.97053 7.56812C3.3015 5.23468 5.23468 3.3015 7.56812 1.97053C11.0228 0 15.6485 0 24.9 0H35.1C44.3514 0 48.9772 0 52.4319 1.97053C54.7653 3.3015 56.6985 5.23468 58.0295 7.56812C60 11.0228 60 15.6485 60 24.9V35.1C60 44.3514 60 48.9772 58.0295 52.4319C56.6985 54.7653 54.7653 56.6985 52.4319 58.0295C48.9772 60 44.3514 60 35.1 60H24.9C15.6485 60 11.0228 60 7.56812 58.0295C5.23468 56.6985 3.3015 54.7653 1.97053 52.4319C0 48.9772 0 44.3514 0 35.1V24.9Z"
      fill="#EB8B47"
    />
    <path
      d="M0.5 24.9C0.5 20.2652 0.50047 16.8221 0.744315 14.105C0.987552 11.3946 1.46987 9.45504 2.40484 7.81585C3.69145 5.56019 5.56019 3.69145 7.81585 2.40484C9.45504 1.46987 11.3946 0.987552 14.105 0.744315C16.8221 0.50047 20.2652 0.5 24.9 0.5H35.1C39.7348 0.5 43.1779 0.50047 45.895 0.744315C48.6054 0.987552 50.545 1.46987 52.1841 2.40484C54.4398 3.69145 56.3086 5.56019 57.5952 7.81585C58.5301 9.45504 59.0124 11.3946 59.2557 14.105C59.4995 16.8221 59.5 20.2652 59.5 24.9V35.1C59.5 39.7348 59.4995 43.1779 59.2557 45.895C59.0124 48.6054 58.5301 50.545 57.5952 52.1841C56.3086 54.4398 54.4398 56.3086 52.1841 57.5952C50.545 58.5301 48.6054 59.0124 45.895 59.2557C43.1779 59.4995 39.7348 59.5 35.1 59.5H24.9C20.2652 59.5 16.8221 59.4995 14.105 59.2557C11.3946 59.0124 9.45504 58.5301 7.81585 57.5952C5.56019 56.3086 3.69145 54.4398 2.40484 52.1841C1.46987 50.545 0.987552 48.6054 0.744315 45.895C0.50047 43.1779 0.5 39.7348 0.5 35.1V24.9Z"
      stroke="#062B2B"
      stroke-opacity="0.1"
    />
    <path
      d="M19 52C24.5228 52 29 47.5228 29 42C29 36.4772 24.5228 32 19 32C13.4772 32 9 36.4772 9 42C9 47.5228 13.4772 52 19 52Z"
      fill="#FF974C"
      stroke="white"
      stroke-width="2"
    />
    <path
      fill-rule="evenodd"
      clip-rule="evenodd"
      d="M42.8437 8.3264C42.4507 7.70891 41.5493 7.70891 41.1564 8.32641L28.978 27.4638C28.5544 28.1295 29.0326 29.0007 29.8217 29.0007H54.1783C54.9674 29.0007 55.4456 28.1295 55.022 27.4638L42.8437 8.3264Z"
      fill="white"
    />
    <path
      fill-rule="evenodd"
      clip-rule="evenodd"
      d="M42.3348 11.6456C42.659 11.7608 42.9061 12.1492 43.4005 12.926L50.7332 24.4488C51.2952 25.332 51.5763 25.7737 51.5254 26.1382C51.4915 26.3808 51.3698 26.6026 51.1833 26.7614C50.9031 27 50.3796 27 49.3327 27H34.6673C33.6204 27 33.0969 27 32.8167 26.7614C32.6302 26.6026 32.5085 26.3808 32.4746 26.1382C32.4237 25.7737 32.7048 25.332 33.2669 24.4488L40.5995 12.926C41.0939 12.1492 41.341 11.7608 41.6652 11.6456C41.8818 11.5687 42.1182 11.5687 42.3348 11.6456ZM35.0001 26.999C38.8661 26.999 42.0001 23.865 42.0001 19.999C42.0001 23.865 45.1341 26.999 49.0001 26.999H35.0001Z"
      fill="#FF974C"
    />
    <path
      d="M10.1061 9.35712C9.9973 9.67775 9.99867 10.0388 9.99978 10.3323C9.99989 10.3611 10 10.3893 10 10.4167V25.5833C10 25.6107 9.99989 25.6389 9.99978 25.6677C9.99867 25.9612 9.9973 26.3222 10.1061 26.6429C10.306 27.2317 10.7683 27.694 11.3571 27.8939C11.6777 28.0027 12.0388 28.0013 12.3323 28.0002C12.3611 28.0001 12.3893 28 12.4167 28H19C24.5228 28 29 23.5228 29 18C29 12.4772 24.5228 8 19 8H12.4167C12.3893 8 12.3611 7.99989 12.3323 7.99978C12.0388 7.99867 11.6778 7.9973 11.3571 8.10614C10.7683 8.306 10.306 8.76834 10.1061 9.35712Z"
      fill="#FF974C"
      stroke="white"
      stroke-width="2"
    />
    <circle cx="19" cy="18" r="4" fill="#EB8B47" stroke="white" stroke-width="2" />
    <circle cx="19" cy="42" r="4" fill="#EB8B47" stroke="white" stroke-width="2" />
  </g>
  <defs>
    <clipPath id="clip0_7734_50402">
      <rect width="60" height="60" fill="white" />
    </clipPath>
  </defs>
</svg> `;

    const defiSvg = b$5 `<svg fill="none" viewBox="0 0 60 60">
  <g clip-path="url(#a)">
    <path
      fill="#1DC956"
      d="M0 25.01c0-9.25 0-13.88 1.97-17.33a15 15 0 0 1 5.6-5.6C11.02.11 15.65.11 24.9.11h10.2c9.25 0 13.88 0 17.33 1.97a15 15 0 0 1 5.6 5.6C60 11.13 60 15.76 60 25v10.2c0 9.25 0 13.88-1.97 17.33a15 15 0 0 1-5.6 5.6c-3.45 1.97-8.08 1.97-17.33 1.97H24.9c-9.25 0-13.88 0-17.33-1.97a15 15 0 0 1-5.6-5.6C0 49.1 0 44.46 0 35.21v-10.2Z"
    />
    <path
      fill="#2BEE6C"
      d="M16.1 60c-3.82-.18-6.4-.64-8.53-1.86a15 15 0 0 1-5.6-5.6C.55 50.06.16 46.97.04 41.98L4.2 40.6a4 4 0 0 0 2.48-2.39l4.65-12.4a2 2 0 0 1 2.5-1.2l2.53.84a2 2 0 0 0 2.43-1l2.96-5.94a2 2 0 0 1 3.7.32l3.78 12.58a2 2 0 0 0 3.03 1.09l3.34-2.23a2 2 0 0 0 .65-.7l5.3-9.72a2 2 0 0 1 1.42-1.01l4.14-.69a2 2 0 0 1 1.6.44l3.9 3.24a2 2 0 0 0 2.7-.12l4.62-4.63c.08 2.2.08 4.8.08 7.93v10.2c0 9.25 0 13.88-1.97 17.33a15 15 0 0 1-5.6 5.6c-2.13 1.22-4.7 1.68-8.54 1.86H16.11Z"
    />
    <path
      fill="#fff"
      d="m.07 43.03-.05-2.1 3.85-1.28a3 3 0 0 0 1.86-1.79l4.66-12.4a3 3 0 0 1 3.75-1.8l2.53.84a1 1 0 0 0 1.21-.5l2.97-5.94a3 3 0 0 1 5.56.48l3.77 12.58a1 1 0 0 0 1.51.55l3.34-2.23a1 1 0 0 0 .33-.35l5.3-9.71a3 3 0 0 1 2.14-1.53l4.13-.69a3 3 0 0 1 2.41.66l3.9 3.24a1 1 0 0 0 1.34-.06l5.28-5.28c.05.85.08 1.75.1 2.73L56 22.41a3 3 0 0 1-4.04.19l-3.9-3.25a1 1 0 0 0-.8-.21l-4.13.69a1 1 0 0 0-.72.5l-5.3 9.72a3 3 0 0 1-.97 1.05l-3.34 2.23a3 3 0 0 1-4.53-1.63l-3.78-12.58a1 1 0 0 0-1.85-.16l-2.97 5.94a3 3 0 0 1-3.63 1.5l-2.53-.84a1 1 0 0 0-1.25.6l-4.65 12.4a5 5 0 0 1-3.1 3L.07 43.02Z"
    />
    <path
      fill="#fff"
      fill-rule="evenodd"
      d="M49.5 19a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0Z"
      clip-rule="evenodd"
    />
    <path fill="#fff" d="M45 .28v59.66l-2 .1V.19c.7.02 1.37.05 2 .1Z" />
    <path fill="#2BEE6C" d="M47.5 19a3.5 3.5 0 1 1-7 0 3.5 3.5 0 0 1 7 0Z" />
    <path
      stroke="#fff"
      stroke-opacity=".1"
      d="M.5 25.01c0-4.63 0-8.08.24-10.8.25-2.7.73-4.64 1.66-6.28a14.5 14.5 0 0 1 5.42-5.41C9.46 1.58 11.39 1.1 14.1.85A133 133 0 0 1 24.9.61h10.2c4.63 0 8.08 0 10.8.24 2.7.25 4.65.73 6.28 1.67a14.5 14.5 0 0 1 5.42 5.4c.93 1.65 1.41 3.58 1.66 6.3.24 2.71.24 6.16.24 10.79v10.2c0 4.64 0 8.08-.24 10.8-.25 2.7-.73 4.65-1.66 6.28a14.5 14.5 0 0 1-5.42 5.42c-1.63.93-3.57 1.41-6.28 1.66-2.72.24-6.17.24-10.8.24H24.9c-4.63 0-8.08 0-10.8-.24-2.7-.25-4.64-.73-6.28-1.66a14.5 14.5 0 0 1-5.42-5.42C1.47 50.66 1 48.72.74 46.01A133 133 0 0 1 .5 35.2v-10.2Z"
    />
  </g>
  <defs>
    <clipPath id="a"><path fill="#fff" d="M0 0h60v60H0z" /></clipPath>
  </defs>
</svg>`;

    const defiAltSvg = b$5 `<svg fill="none" viewBox="0 0 60 60">
  <g clip-path="url(#a)">
    <rect width="60" height="60" fill="#C653C6" rx="30" />
    <path
      fill="#E87DE8"
      d="M57.98.01v19.5a4.09 4.09 0 0 0-2.63 2.29L50.7 34.2a2 2 0 0 1-2.5 1.2l-2.53-.84a2 2 0 0 0-2.42 1l-2.97 5.94a2 2 0 0 1-3.7-.32L32.8 28.6a2 2 0 0 0-3.02-1.09l-3.35 2.23a2 2 0 0 0-.64.7l-5.3 9.72a2 2 0 0 1-1.43 1.01l-4.13.69a2 2 0 0 1-1.61-.44l-3.9-3.24a2 2 0 0 0-2.69.12L2.1 42.93.02 43V.01h57.96Z"
    />
    <path
      fill="#fff"
      d="m61.95 16.94.05 2.1-3.85 1.28a3 3 0 0 0-1.86 1.79l-4.65 12.4a3 3 0 0 1-3.76 1.8l-2.53-.84a1 1 0 0 0-1.2.5l-2.98 5.94a3 3 0 0 1-5.55-.48l-3.78-12.58a1 1 0 0 0-1.5-.55l-3.35 2.23a1 1 0 0 0-.32.35l-5.3 9.72a3 3 0 0 1-2.14 1.52l-4.14.69a3 3 0 0 1-2.41-.66l-3.9-3.24a1 1 0 0 0-1.34.06l-5.28 5.28c-.05-.84-.08-1.75-.1-2.73l3.97-3.96a3 3 0 0 1 4.04-.19l3.89 3.25a1 1 0 0 0 .8.21l4.14-.68a1 1 0 0 0 .71-.51l5.3-9.71a3 3 0 0 1 .97-1.06l3.34-2.23a3 3 0 0 1 4.54 1.63l3.77 12.58a1 1 0 0 0 1.86.16l2.96-5.93a3 3 0 0 1 3.64-1.5l2.52.83a1 1 0 0 0 1.25-.6l4.66-12.4a5 5 0 0 1 3.1-2.99l4.43-1.48Z"
    />
    <path
      fill="#fff"
      fill-rule="evenodd"
      d="M35.5 27a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0Z"
      clip-rule="evenodd"
    />
    <path fill="#fff" d="M31 0v60h-2V0h2Z" />
    <path fill="#E87DE8" d="M33.5 27a3.5 3.5 0 1 1-7 0 3.5 3.5 0 0 1 7 0Z" />
  </g>
  <rect width="59" height="59" x=".5" y=".5" stroke="#fff" stroke-opacity=".1" rx="29.5" />
  <defs>
    <clipPath id="a"><rect width="60" height="60" fill="#fff" rx="30" /></clipPath>
  </defs>
</svg> `;

    const ethSvg = b$5 `<svg fill="none" viewBox="0 0 60 60">
  <g clip-path="url(#a)">
    <rect width="60" height="60" fill="#987DE8" rx="30" />
    <path
      fill="#fff"
      fill-rule="evenodd"
      d="m15.48 28.37 11.97-19.3a3 3 0 0 1 5.1 0l11.97 19.3a6 6 0 0 1 .9 3.14v.03a6 6 0 0 1-1.16 3.56L33.23 50.2a4 4 0 0 1-6.46 0L15.73 35.1a6 6 0 0 1-1.15-3.54v-.03a6 6 0 0 1 .9-3.16Z"
      clip-rule="evenodd"
    />
    <path
      fill="#643CDD"
      d="M30.84 10.11a1 1 0 0 0-.84-.46V24.5l12.6 5.53a2 2 0 0 0-.28-1.4L30.84 10.11Z"
    />
    <path
      fill="#BDADEB"
      d="M30 9.65a1 1 0 0 0-.85.46L17.66 28.64a2 2 0 0 0-.26 1.39L30 24.5V9.65Z"
    />
    <path
      fill="#643CDD"
      d="M30 50.54a1 1 0 0 0 .8-.4l11.24-15.38c.3-.44-.2-1-.66-.73l-9.89 5.68a3 3 0 0 1-1.5.4v10.43Z"
    />
    <path
      fill="#BDADEB"
      d="m17.97 34.76 11.22 15.37c.2.28.5.41.8.41V40.11a3 3 0 0 1-1.49-.4l-9.88-5.68c-.47-.27-.97.3-.65.73Z"
    />
    <path
      fill="#401AB3"
      d="M42.6 30.03 30 24.5v13.14a3 3 0 0 0 1.5-.4l10.14-5.83a2 2 0 0 0 .95-1.38Z"
    />
    <path
      fill="#7C5AE2"
      d="M30 37.64V24.46l-12.6 5.57a2 2 0 0 0 .97 1.39l10.13 5.82a3 3 0 0 0 1.5.4Z"
    />
  </g>
  <rect width="59" height="59" x=".5" y=".5" stroke="#fff" stroke-opacity=".1" rx="29.5" />
  <defs>
    <clipPath id="a"><rect width="60" height="60" fill="#fff" rx="30" /></clipPath>
  </defs>
</svg> `;

    const layersSvg = b$5 `<svg fill="none" viewBox="0 0 60 60">
  <rect width="60" height="60" fill="#1DC956" rx="3" />
  <path
    fill="#1FAD7E"
    stroke="#fff"
    stroke-width="2"
    d="m30.49 29.13-.49-.27-.49.27-12.77 7.1-.05.02c-.86.48-1.58.88-2.1 1.24-.54.37-1.04.81-1.28 1.45a3 3 0 0 0 0 2.12c.24.63.74 1.08 1.27 1.45.53.36 1.25.76 2.11 1.24l.05.03 6.33 3.51.17.1c2.33 1.3 3.72 2.06 5.22 2.32a9 9 0 0 0 3.08 0c1.5-.26 2.9-1.03 5.22-2.32l.18-.1 6.32-3.51.05-.03a26.9 26.9 0 0 0 2.1-1.24 3.21 3.21 0 0 0 1.28-1.45l-.94-.35.94.35a3 3 0 0 0 0-2.12l-.94.35.94-.35a3.21 3.21 0 0 0-1.27-1.45c-.53-.36-1.25-.76-2.11-1.24l-.05-.03-12.77-7.1Z"
  />
  <path
    fill="#2BEE6C"
    stroke="#fff"
    stroke-width="2"
    d="m30.49 19.13-.49-.27-.49.27-12.77 7.1-.05.02c-.86.48-1.58.88-2.1 1.24-.54.37-1.04.81-1.28 1.45a3 3 0 0 0 0 2.12c.24.63.74 1.08 1.27 1.45.53.36 1.25.76 2.11 1.24l.05.03 6.33 3.51.17.1c2.33 1.3 3.72 2.06 5.22 2.32a9 9 0 0 0 3.08 0c1.5-.26 2.9-1.03 5.22-2.32l.18-.1 6.32-3.51.05-.03a26.9 26.9 0 0 0 2.1-1.24 3.21 3.21 0 0 0 1.28-1.45l-.94-.35.94.35a3 3 0 0 0 0-2.12l-.94.35.94-.35a3.21 3.21 0 0 0-1.27-1.45c-.53-.36-1.25-.76-2.11-1.24l-.05-.03-12.77-7.1Z"
  />
  <path
    fill="#86F999"
    stroke="#fff"
    stroke-width="2"
    d="m46.69 21.06-.94-.35.94.35a3 3 0 0 0 0-2.12l-.94.35.94-.35a3.21 3.21 0 0 0-1.27-1.45c-.53-.36-1.25-.76-2.11-1.24l-.05-.03-6.32-3.51-.18-.1c-2.33-1.3-3.72-2.06-5.22-2.33a9 9 0 0 0-3.08 0c-1.5.27-2.9 1.04-5.22 2.33l-.17.1-6.33 3.51-.05.03c-.86.48-1.58.88-2.1 1.24-.54.37-1.04.81-1.28 1.45a3 3 0 0 0 0 2.12c.24.63.74 1.08 1.27 1.45.53.36 1.25.76 2.11 1.24l.05.03 6.33 3.51.17.1c2.33 1.3 3.72 2.06 5.22 2.32a9 9 0 0 0 3.08 0c1.5-.26 2.9-1.03 5.22-2.32l.18-.1 6.32-3.51.05-.03a26.9 26.9 0 0 0 2.1-1.24 3.21 3.21 0 0 0 1.28-1.45Z"
  />
  <rect width="59" height="59" x=".5" y=".5" stroke="#fff" stroke-opacity=".1" rx="2.5" />
</svg>`;

    const lockSvg = b$5 `<svg fill="none" viewBox="0 0 60 60">
  <rect width="60" height="60" fill="#C653C6" rx="3" />
  <path
    fill="#fff"
    d="M20.03 15.22C20 15.6 20 16.07 20 17v2.8c0 1.14 0 1.7-.2 2.12-.15.31-.3.5-.58.71-.37.28-1.06.42-2.43.7-.59.12-1.11.29-1.6.51a9 9 0 0 0-4.35 4.36C10 30 10 32.34 10 37c0 4.66 0 7 .84 8.8a9 9 0 0 0 4.36 4.36C17 51 19.34 51 24 51h12c4.66 0 7 0 8.8-.84a9 9 0 0 0 4.36-4.36C50 44 50 41.66 50 37c0-4.66 0-7-.84-8.8a9 9 0 0 0-4.36-4.36c-.48-.22-1-.39-1.6-.5-1.36-.29-2.05-.43-2.42-.7-.27-.22-.43-.4-.58-.72-.2-.42-.2-.98-.2-2.11V17c0-.93 0-1.4-.03-1.78a9 9 0 0 0-8.19-8.19C31.4 7 30.93 7 30 7s-1.4 0-1.78.03a9 9 0 0 0-8.19 8.19Z"
  />
  <path
    fill="#E87DE8"
    d="M22 17c0-.93 0-1.4.04-1.78a7 7 0 0 1 6.18-6.18C28.6 9 29.07 9 30 9s1.4 0 1.78.04a7 7 0 0 1 6.18 6.18c.04.39.04.85.04 1.78v4.5a1.5 1.5 0 0 1-3 0V17c0-.93 0-1.4-.08-1.78a4 4 0 0 0-3.14-3.14C31.39 12 30.93 12 30 12s-1.4 0-1.78.08a4 4 0 0 0-3.14 3.14c-.08.39-.08.85-.08 1.78v4.5a1.5 1.5 0 0 1-3 0V17Z"
  />
  <path
    fill="#E87DE8"
    fill-rule="evenodd"
    d="M12 36.62c0-4.32 0-6.48.92-8.09a7 7 0 0 1 2.61-2.61C17.14 25 19.3 25 23.62 25h6.86c.46 0 .7 0 .9.02 2.73.22 4.37 2.43 4.62 4.98.27-2.7 2.11-5 5.02-5A6.98 6.98 0 0 1 48 31.98v5.4c0 4.32 0 6.48-.92 8.09a7 7 0 0 1-2.61 2.61c-1.61.92-3.77.92-8.09.92h-5.86c-.46 0-.7 0-.9-.02-2.73-.22-4.37-2.43-4.62-4.98-.26 2.58-1.94 4.82-4.71 4.99l-.7.01c-.55 0-.82 0-1.05-.02a7 7 0 0 1-6.52-6.52c-.02-.23-.02-.5-.02-1.05v-4.79Zm21.24-.27a4 4 0 1 0-6.48 0 31.28 31.28 0 0 1 1.57 2.23c.17.4.17.81.17 1.24V42.5a1.5 1.5 0 0 0 3 0V39.82c0-.43 0-.85.17-1.24.09-.2.58-.87 1.57-2.23Z"
    clip-rule="evenodd"
  />
  <rect width="59" height="59" x=".5" y=".5" stroke="#fff" stroke-opacity=".1" rx="2.5" />
</svg>`;

    const loginSvg = b$5 `<svg fill="none" viewBox="0 0 60 60">
  <g clip-path="url(#a)">
    <path
      fill="#EB8B47"
      d="M0 24.9c0-9.25 0-13.88 1.97-17.33a15 15 0 0 1 5.6-5.6C11.02 0 15.65 0 24.9 0h10.2c9.25 0 13.88 0 17.33 1.97a15 15 0 0 1 5.6 5.6C60 11.02 60 15.65 60 24.9v10.2c0 9.25 0 13.88-1.97 17.33a15 15 0 0 1-5.6 5.6C48.98 60 44.35 60 35.1 60H24.9c-9.25 0-13.88 0-17.33-1.97a15 15 0 0 1-5.6-5.6C0 48.98 0 44.35 0 35.1V24.9Z"
    />
    <path
      stroke="#062B2B"
      stroke-opacity=".1"
      d="M.5 24.9c0-4.64 0-8.08.24-10.8.25-2.7.73-4.65 1.66-6.28A14.5 14.5 0 0 1 7.82 2.4C9.46 1.47 11.39 1 14.1.74A133 133 0 0 1 24.9.5h10.2c4.63 0 8.08 0 10.8.24 2.7.25 4.65.73 6.28 1.66a14.5 14.5 0 0 1 5.42 5.42c.93 1.63 1.41 3.57 1.66 6.28.24 2.72.24 6.16.24 10.8v10.2c0 4.63 0 8.08-.24 10.8-.25 2.7-.73 4.64-1.66 6.28a14.5 14.5 0 0 1-5.42 5.41c-1.63.94-3.57 1.42-6.28 1.67-2.72.24-6.17.24-10.8.24H24.9c-4.63 0-8.08 0-10.8-.24-2.7-.25-4.64-.73-6.28-1.67a14.5 14.5 0 0 1-5.42-5.4C1.47 50.53 1 48.6.74 45.88A133 133 0 0 1 .5 35.1V24.9Z"
    />
    <path
      fill="#FF974C"
      stroke="#fff"
      stroke-width="2"
      d="M39.2 29.2a13 13 0 1 0-18.4 0l1.3 1.28a12.82 12.82 0 0 1 2.1 2.39 6 6 0 0 1 .6 1.47c.2.76.2 1.56.2 3.17v11.24c0 1.08 0 1.61.13 2.12a4 4 0 0 0 .41.98c.26.45.64.83 1.4 1.6l.3.29c.65.65.98.98 1.36 1.09.26.07.54.07.8 0 .38-.11.7-.44 1.36-1.1l3.48-3.47c.65-.65.98-.98 1.09-1.36a1.5 1.5 0 0 0 0-.8c-.1-.38-.44-.7-1.1-1.36l-.47-.48c-.65-.65-.98-.98-1.09-1.36a1.5 1.5 0 0 1 0-.8c.1-.38.44-.7 1.1-1.36l.47-.48c.65-.65.98-.98 1.09-1.36a1.5 1.5 0 0 0 0-.8c-.1-.38-.44-.7-1.1-1.36l-.48-.5c-.65-.64-.98-.97-1.08-1.35a1.5 1.5 0 0 1 0-.79c.1-.38.42-.7 1.06-1.36l5.46-5.55Z"
    />
    <circle cx="30" cy="17" r="4" fill="#EB8B47" stroke="#fff" stroke-width="2" />
  </g>
  <defs>
    <clipPath id="a"><path fill="#fff" d="M0 0h60v60H0z" /></clipPath>
  </defs>
</svg> `;

    const networkSvg = b$5 `<svg fill="none" viewBox="0 0 60 60">
  <g clip-path="url(#a)">
    <rect width="60" height="60" fill="#00ACE6" rx="30" />
    <circle cx="64" cy="39" r="50" fill="#1AC6FF" stroke="#fff" stroke-width="2" />
    <circle cx="78" cy="30" r="50" fill="#4DD2FF" stroke="#fff" stroke-width="2" />
    <circle cx="72" cy="15" r="35" fill="#80DFFF" stroke="#fff" stroke-width="2" />
    <circle cx="34" cy="-17" r="45" stroke="#fff" stroke-width="2" />
    <circle cx="34" cy="-5" r="50" stroke="#fff" stroke-width="2" />
    <circle cx="30" cy="45" r="4" fill="#4DD2FF" stroke="#fff" stroke-width="2" />
    <circle cx="39.5" cy="27.5" r="4" fill="#80DFFF" stroke="#fff" stroke-width="2" />
    <circle cx="16" cy="24" r="4" fill="#19C6FF" stroke="#fff" stroke-width="2" />
  </g>
  <rect width="59" height="59" x=".5" y=".5" stroke="#062B2B" stroke-opacity=".1" rx="29.5" />
  <defs>
    <clipPath id="a"><rect width="60" height="60" fill="#fff" rx="30" /></clipPath>
  </defs>
</svg>`;

    const nftSvg = b$5 `<svg fill="none" viewBox="0 0 60 60">
  <g clip-path="url(#a)">
    <rect width="60" height="60" fill="#C653C6" rx="3" />
    <path
      fill="#E87DE8"
      stroke="#fff"
      stroke-width="2"
      d="M52.1 47.34c0-4.24-1.44-9.55-5.9-12.4a2.86 2.86 0 0 0-1.6-3.89v-.82c0-1.19-.52-2.26-1.35-3a4.74 4.74 0 0 0-2.4-6.26v-5.5a11.31 11.31 0 1 0-22.63 0v2.15a3.34 3.34 0 0 0-1.18 5.05 4.74 4.74 0 0 0-.68 6.44A5.22 5.22 0 0 0 14 35.92c-3.06 4.13-6.1 8.3-6.1 15.64 0 2.67.37 4.86.74 6.39a20.3 20.3 0 0 0 .73 2.39l.02.04v.01l.92-.39-.92.4.26.6h38.26l.3-.49-.87-.51.86.5.02-.01.03-.07a16.32 16.32 0 0 0 .57-1.05c.36-.72.85-1.74 1.33-2.96a25.51 25.51 0 0 0 1.94-9.07Z"
    />
    <path
      fill="#fff"
      fill-rule="evenodd"
      d="M26.5 29.5c-3-.5-5.5-3-5.5-7v-7c0-.47 0-.7.03-.9a3 3 0 0 1 2.58-2.57c.2-.03.42-.03.89-.03 2 0 2.5-2.5 2.5-2.5s0 2.5 2.5 2.5c1.4 0 2.1 0 2.65.23a3 3 0 0 1 1.62 1.62c.23.55.23 1.25.23 2.65v6c0 4-3 7-6.5 7 1.35.23 4 0 6.5-2v9.53C34 38.5 31.5 40 28 40s-6-1.5-6-2.97L24 34l2.5 1.5v-6ZM26 47h4.5c2.5 0 3 4 3 5.5h-3l-1-1.5H26v-4Zm-6.25 5.5H24V57h-8c0-1 1-4.5 3.75-4.5Z"
      clip-rule="evenodd"
    />
  </g>
  <rect width="59" height="59" x=".5" y=".5" stroke="#fff" stroke-opacity=".1" rx="2.5" />
  <defs>
    <clipPath id="a"><rect width="60" height="60" fill="#fff" rx="3" /></clipPath>
  </defs>
</svg> `;

    const nounSvg = b$5 `<svg fill="none" viewBox="0 0 60 60">
  <rect width="60" height="60" fill="#794CFF" rx="3" />
  <path
    fill="#987DE8"
    stroke="#fff"
    stroke-width="2"
    d="M33 22.5v-1H16v5H8.5V36H13v-5h3v7.5h17V31h1v7.5h17v-17H34v5h-1v-4Z"
  />
  <path fill="#fff" d="M37.5 25h10v10h-10z" />
  <path fill="#4019B2" d="M42.5 25h5v10h-5z" />
  <path fill="#fff" d="M19.5 25h10v10h-10z" />
  <path fill="#4019B2" d="M24.5 25h5v10h-5z" />
  <path fill="#fff" d="M12 30.5h4V37h-4v-6.5Z" />
  <rect width="59" height="59" x=".5" y=".5" stroke="#fff" stroke-opacity=".1" rx="2.5" />
</svg>`;

    const profileSvg = b$5 `<svg
  viewBox="0 0 60 60"
  fill="none"
>
  <g clip-path="url(#1)">
    <rect width="60" height="60" rx="30" fill="#00ACE6" />
    <path
      d="M59 73C59 89.0163 46.0163 102 30 102C13.9837 102 1 89.0163 1 73C1 56.9837 12 44 30 44C48 44 59 56.9837 59 73Z"
      fill="#1AC6FF"
      stroke="white"
      stroke-width="2"
    />
    <path
      d="M18.6904 19.9015C19.6264 15.3286 23.3466 11.8445 27.9708 11.2096C29.3231 11.024 30.6751 11.0238 32.0289 11.2096C36.6532 11.8445 40.3733 15.3286 41.3094 19.9015C41.4868 20.7681 41.6309 21.6509 41.7492 22.5271C41.8811 23.5041 41.8811 24.4944 41.7492 25.4715C41.6309 26.3476 41.4868 27.2304 41.3094 28.097C40.3733 32.6699 36.6532 36.154 32.0289 36.7889C30.6772 36.9744 29.3216 36.9743 27.9708 36.7889C23.3466 36.154 19.6264 32.6699 18.6904 28.097C18.513 27.2304 18.3689 26.3476 18.2506 25.4715C18.1186 24.4944 18.1186 23.5041 18.2506 22.5271C18.3689 21.6509 18.513 20.7681 18.6904 19.9015Z"
      fill="#1AC6FF"
      stroke="white"
      stroke-width="2"
    />
    <circle cx="24.5" cy="23.5" r="1.5" fill="white" />
    <circle cx="35.5" cy="23.5" r="1.5" fill="white" />
    <path
      d="M31 20L28 28H32"
      stroke="white"
      stroke-width="2"
      stroke-linecap="round"
      stroke-linejoin="round"
    />
  </g>
  <rect x="0.5" y="0.5" width="59" height="59" rx="29.5" stroke="white" stroke-opacity="0.1" />
  <defs>
    <clipPath id="1">
      <rect width="60" height="60" rx="30" fill="white" />
    </clipPath>
  </defs>
</svg> `;

    const systemSvg = b$5 `<svg viewBox="0 0 60 60" fill="none">
  <g clip-path="url(#1)">
    <path
      d="M0 24.9C0 15.6485 0 11.0228 1.97053 7.56812C3.3015 5.23468 5.23468 3.3015 7.56812 1.97053C11.0228 0 15.6485 0 24.9 0H35.1C44.3514 0 48.9772 0 52.4319 1.97053C54.7653 3.3015 56.6985 5.23468 58.0295 7.56812C60 11.0228 60 15.6485 60 24.9V35.1C60 44.3514 60 48.9772 58.0295 52.4319C56.6985 54.7653 54.7653 56.6985 52.4319 58.0295C48.9772 60 44.3514 60 35.1 60H24.9C15.6485 60 11.0228 60 7.56812 58.0295C5.23468 56.6985 3.3015 54.7653 1.97053 52.4319C0 48.9772 0 44.3514 0 35.1V24.9Z"
      fill="#794CFF"
    />
    <path
      d="M0.5 24.9C0.5 20.2652 0.50047 16.8221 0.744315 14.105C0.987552 11.3946 1.46987 9.45504 2.40484 7.81585C3.69145 5.56019 5.56019 3.69145 7.81585 2.40484C9.45504 1.46987 11.3946 0.987552 14.105 0.744315C16.8221 0.50047 20.2652 0.5 24.9 0.5H35.1C39.7348 0.5 43.1779 0.50047 45.895 0.744315C48.6054 0.987552 50.545 1.46987 52.1841 2.40484C54.4398 3.69145 56.3086 5.56019 57.5952 7.81585C58.5301 9.45504 59.0124 11.3946 59.2557 14.105C59.4995 16.8221 59.5 20.2652 59.5 24.9V35.1C59.5 39.7348 59.4995 43.1779 59.2557 45.895C59.0124 48.6054 58.5301 50.545 57.5952 52.1841C56.3086 54.4398 54.4398 56.3086 52.1841 57.5952C50.545 58.5301 48.6054 59.0124 45.895 59.2557C43.1779 59.4995 39.7348 59.5 35.1 59.5H24.9C20.2652 59.5 16.8221 59.4995 14.105 59.2557C11.3946 59.0124 9.45504 58.5301 7.81585 57.5952C5.56019 56.3086 3.69145 54.4398 2.40484 52.1841C1.46987 50.545 0.987552 48.6054 0.744315 45.895C0.50047 43.1779 0.5 39.7348 0.5 35.1V24.9Z"
      stroke="#062B2B"
      stroke-opacity="0.1"
    />
    <path
      d="M35.1403 31.5016C35.1193 30.9637 35.388 30.4558 35.8446 30.1707C36.1207 29.9982 36.4761 29.8473 36.7921 29.7685C37.3143 29.6382 37.8664 29.7977 38.2386 30.1864C38.8507 30.8257 39.3004 31.6836 39.8033 32.408C40.2796 33.0942 41.4695 33.2512 41.9687 32.5047C42.4839 31.7341 42.9405 30.8229 43.572 30.1399C43.9375 29.7447 44.4866 29.5756 45.0111 29.6967C45.3283 29.7701 45.6863 29.9147 45.9655 30.0823C46.4269 30.3595 46.7045 30.8626 46.6928 31.4008C46.6731 32.3083 46.3764 33.2571 46.2158 34.1473C46.061 35.0048 46.9045 35.8337 47.7592 35.664C48.6464 35.4878 49.5899 35.1747 50.497 35.1391C51.0348 35.1181 51.5427 35.3868 51.8279 35.8433C52.0004 36.1195 52.1513 36.4749 52.2301 36.7908C52.3604 37.3131 52.2009 37.8651 51.8121 38.2374C51.1729 38.8495 50.3151 39.2991 49.5908 39.8019C48.9046 40.2782 48.7473 41.4683 49.4939 41.9675C50.2644 42.4827 51.1757 42.9393 51.8587 43.5708C52.2539 43.9362 52.423 44.4854 52.3018 45.0099C52.2285 45.3271 52.0839 45.6851 51.9162 45.9642C51.6391 46.4257 51.1359 46.7032 50.5978 46.6916C49.6903 46.6719 48.7417 46.3753 47.8516 46.2146C46.9939 46.0598 46.1648 46.9035 46.3346 47.7583C46.5108 48.6454 46.8239 49.5888 46.8594 50.4958C46.8805 51.0336 46.6117 51.5415 46.1552 51.8267C45.879 51.9992 45.5236 52.15 45.2077 52.2289C44.6854 52.3592 44.1334 52.1997 43.7611 51.8109C43.1491 51.1718 42.6996 50.314 42.1968 49.5897C41.7203 48.9034 40.5301 48.7463 40.0309 49.493C39.5157 50.2634 39.0592 51.1746 38.4278 51.8574C38.0623 52.2527 37.5132 52.4218 36.9887 52.3006C36.6715 52.2273 36.3135 52.0826 36.0343 51.915C35.5729 51.6379 35.2953 51.1347 35.307 50.5966C35.3267 49.6891 35.6233 48.7405 35.7839 47.8505C35.9388 46.9928 35.0951 46.1636 34.2402 46.3334C33.3531 46.5096 32.4098 46.8227 31.5028 46.8582C30.9649 46.8793 30.457 46.6105 30.1719 46.154C29.9994 45.8778 29.8485 45.5224 29.7697 45.2065C29.6394 44.6842 29.7989 44.1322 30.1877 43.7599C30.8269 43.1479 31.6847 42.6982 32.4091 42.1954C33.0954 41.7189 33.2522 40.5289 32.5056 40.0297C31.7351 39.5145 30.824 39.058 30.1411 38.4265C29.7459 38.0611 29.5768 37.5119 29.698 36.9875C29.7713 36.6702 29.9159 36.3122 30.0836 36.0331C30.3607 35.5717 30.8638 35.2941 31.402 35.3058C32.3095 35.3255 33.2583 35.6221 34.1485 35.7828C35.006 35.9376 35.8349 35.094 35.6652 34.2393C35.489 33.3521 35.1759 32.4087 35.1403 31.5016Z"
      fill="#906EF7"
      stroke="white"
      stroke-width="2"
    />
    <path
      d="M20.7706 8.22357C20.9036 7.51411 21.5231 7 22.2449 7H23.7551C24.4769 7 25.0964 7.51411 25.2294 8.22357C25.5051 9.69403 25.4829 11.6321 27.1202 12.2606C27.3092 12.3331 27.4958 12.4105 27.6798 12.4926C29.2818 13.2072 30.6374 11.8199 31.8721 10.9752C32.4678 10.5676 33.2694 10.6421 33.7798 11.1525L34.8477 12.2204C35.3581 12.7308 35.4326 13.5323 35.025 14.128C34.1802 15.3627 32.7931 16.7183 33.5077 18.3202C33.5898 18.5043 33.6672 18.6909 33.7398 18.88C34.3683 20.5171 36.3061 20.4949 37.7764 20.7706C38.4859 20.9036 39 21.5231 39 22.2449V23.7551C39 24.4769 38.4859 25.0964 37.7764 25.2294C36.3061 25.5051 34.3685 25.483 33.7401 27.1201C33.6675 27.3093 33.59 27.4961 33.5079 27.6803C32.7934 29.282 34.1803 30.6374 35.025 31.8719C35.4326 32.4677 35.3581 33.2692 34.8477 33.7796L33.7798 34.8475C33.2694 35.3579 32.4678 35.4324 31.8721 35.0248C30.6376 34.1801 29.2823 32.7934 27.6806 33.508C27.4962 33.5903 27.3093 33.6678 27.12 33.7405C25.483 34.3688 25.5051 36.3062 25.2294 37.7764C25.0964 38.4859 24.4769 39 23.7551 39H22.2449C21.5231 39 20.9036 38.4859 20.7706 37.7764C20.4949 36.3062 20.517 34.3688 18.88 33.7405C18.6908 33.6678 18.5039 33.5903 18.3196 33.5081C16.7179 32.7936 15.3625 34.1804 14.1279 35.0251C13.5322 35.4327 12.7307 35.3582 12.2203 34.8478L11.1524 33.7799C10.642 33.2695 10.5675 32.4679 10.9751 31.8722C11.8198 30.6376 13.2067 29.2822 12.4922 27.6804C12.41 27.4962 12.3325 27.3093 12.2599 27.1201C11.6315 25.483 9.69392 25.5051 8.22357 25.2294C7.51411 25.0964 7 24.4769 7 23.7551V22.2449C7 21.5231 7.51411 20.9036 8.22357 20.7706C9.69394 20.4949 11.6317 20.5171 12.2602 18.88C12.3328 18.6909 12.4103 18.5042 12.4924 18.3201C13.207 16.7181 11.8198 15.3625 10.975 14.1278C10.5674 13.5321 10.6419 12.7305 11.1523 12.2201L12.2202 11.1522C12.7306 10.6418 13.5322 10.5673 14.1279 10.9749C15.3626 11.8197 16.7184 13.2071 18.3204 12.4925C18.5044 12.4105 18.6909 12.3331 18.8799 12.2606C20.5171 11.6321 20.4949 9.69403 20.7706 8.22357Z"
      fill="#906EF7"
      stroke="white"
      stroke-width="2"
    />
    <circle cx="23" cy="23" r="6" fill="#794CFF" stroke="white" stroke-width="2" />
    <circle cx="41" cy="41" r="4" fill="#794CFF" stroke="white" stroke-width="2" />
  </g>
  <defs>
    <clipPath id="1">
      <rect width="60" height="60" fill="white" />
    </clipPath>
  </defs>
</svg> `;

    const coinbaseSvg = b$5 `<svg xmlns="http://www.w3.org/2000/svg" width="40" height="40" viewBox="0 0 40 40" fill="none">
  <g clip-path="url(#clip0_187_29)">
    <path d="M1.18187e-05 15.8055C1.18187e-05 9.8015 -5.19442e-07 6.91338 1.69991e-08 0C4.5 3.72236e-05 9.62249 0 16.5 0L23.5 4.31399e-05C29.9349 4.31399e-05 35.5 0.000206332 40 3.73468e-05C40 2.77754 40 9.36708 40 15.8055V22.8364C40 29.2647 40 33.7962 40 40C31.5 40 29.8337 40 23.4 40H16.6C10.5092 40 6.50004 40 4.04289e-05 40C3.05176e-05 32.2453 1.18187e-05 29.6382 1.18187e-05 22.8364V15.8055Z" fill="#0052FF"/>
    <path d="M20.0236 26.5C16.4342 26.5 13.5236 23.5931 13.5236 20C13.5236 16.4069 16.4342 13.5 20.0236 13.5C23.2411 13.5 25.9134 15.8472 26.4261 18.9167H32.9731C32.4206 12.2433 26.8342 7 20.02 7C12.8411 7 7.02002 12.8211 7.02002 20C7.02002 27.1789 12.8411 33 20.02 33C26.8342 33 32.4206 27.7567 32.9731 21.0833H26.4225C25.9061 24.1528 23.2411 26.5 20.0236 26.5Z" fill="white"/>
  </g>
  <defs>
    <clipPath id="clip0_187_29">
      <rect width="40" height="40" fill="white"/>
    </clipPath>
  </defs>
</svg>`;

    const moonpaySvg = b$5 `
  <svg width="40" height="40" fill="none" xmlns="http://www.w3.org/2000/svg">
    <g clip-path="url(#a)">
      <path
        d="M0 16.6c0-6.168 0-9.251 1.314-11.555a10 10 0 0 1 3.731-3.731C7.35 0 10.432 0 16.6 0h6.8c6.168 0 9.252 0 11.555 1.314a10 10 0 0 1 3.731 3.731C40 7.35 40 10.432 40 16.6v6.8c0 6.168 0 9.252-1.314 11.555a10 10 0 0 1-3.731 3.731C32.652 40 29.568 40 23.4 40h-6.8c-6.168 0-9.251 0-11.555-1.314a10 10 0 0 1-3.731-3.731C0 32.652 0 29.568 0 23.4v-6.8Z"
        fill="#7D00FF"
      />
      <path
        d="M.5 16.6c0-3.093 0-5.38.162-7.182.161-1.795.48-3.061 1.086-4.125a9.5 9.5 0 0 1 3.545-3.545C6.357 1.141 7.623.823 9.418.662 11.221.5 13.508.5 16.6.5h6.8c3.093 0 5.38 0 7.182.162 1.795.161 3.062.48 4.125 1.086a9.5 9.5 0 0 1 3.545 3.545c.607 1.064.925 2.33 1.086 4.125.161 1.803.162 4.09.162 7.182v6.8c0 3.093 0 5.38-.162 7.182-.161 1.795-.48 3.062-1.086 4.125a9.5 9.5 0 0 1-3.545 3.545c-1.063.607-2.33.925-4.125 1.086-1.803.161-4.09.162-7.182.162h-6.8c-3.093 0-5.38 0-7.182-.162-1.795-.161-3.061-.48-4.125-1.086a9.5 9.5 0 0 1-3.545-3.545c-.607-1.063-.925-2.33-1.086-4.125C.5 28.779.5 26.492.5 23.4v-6.8Z"
        stroke="#fff"
        stroke-opacity=".05"
      />
      <path
        d="M28.306 15.381a3.69 3.69 0 1 0 0-7.381 3.69 3.69 0 0 0 0 7.381ZM16.987 32a8.991 8.991 0 1 1 .016-17.983A8.991 8.991 0 0 1 16.988 32Z"
        fill="#fff"
      />
    </g>
    <defs>
      <clipPath id="a"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
    </defs>
  </svg>
`;

    const stripeSvg = b$5 `
  <svg width="40" height="40" fill="none" xmlns="http://www.w3.org/2000/svg">
    <g clip-path="url(#a)">
      <path
        d="M0 16.6c0-6.168 0-9.251 1.314-11.555a10 10 0 0 1 3.731-3.731C7.35 0 10.432 0 16.6 0h6.8c6.168 0 9.252 0 11.555 1.314a10 10 0 0 1 3.731 3.731C40 7.35 40 10.432 40 16.6v6.8c0 6.168 0 9.252-1.314 11.555a10 10 0 0 1-3.731 3.731C32.652 40 29.568 40 23.4 40h-6.8c-6.168 0-9.251 0-11.555-1.314a10 10 0 0 1-3.731-3.731C0 32.652 0 29.568 0 23.4v-6.8Z"
        fill="#635BFF"
      />
      <path
        d="M.5 16.6c0-3.093 0-5.38.162-7.182.161-1.795.48-3.061 1.086-4.125a9.5 9.5 0 0 1 3.545-3.545C6.357 1.141 7.623.823 9.418.662 11.221.5 13.508.5 16.6.5h6.8c3.093 0 5.38 0 7.182.162 1.795.161 3.062.48 4.125 1.086a9.5 9.5 0 0 1 3.545 3.545c.607 1.064.925 2.33 1.086 4.125.161 1.803.162 4.09.162 7.182v6.8c0 3.093 0 5.38-.162 7.182-.161 1.795-.48 3.062-1.086 4.125a9.5 9.5 0 0 1-3.545 3.545c-1.063.607-2.33.925-4.125 1.086-1.803.161-4.09.162-7.182.162h-6.8c-3.093 0-5.38 0-7.182-.162-1.795-.161-3.061-.48-4.125-1.086a9.5 9.5 0 0 1-3.545-3.545c-.607-1.063-.925-2.33-1.086-4.125C.5 28.779.5 26.492.5 23.4v-6.8Z"
        stroke="#fff"
        stroke-opacity=".05"
      />
      <path
        fill-rule="evenodd"
        clip-rule="evenodd"
        d="M18.299 15.147c0-1.028.844-1.424 2.242-1.424 2.004 0 4.536.607 6.54 1.688V9.213C24.892 8.343 22.73 8 20.541 8c-5.354 0-8.915 2.796-8.915 7.464 0 7.279 10.022 6.118 10.022 9.257 0 1.213-1.055 1.609-2.531 1.609-2.19 0-4.985-.897-7.2-2.11v6.277a18.283 18.283 0 0 0 7.2 1.503c5.485 0 9.257-2.716 9.257-7.437-.027-7.86-10.075-6.462-10.075-9.416Z"
        fill="#fff"
      />
    </g>
    <defs>
      <clipPath id="a"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
    </defs>
  </svg>
`;

    const paypalSvg = b$5 `
  <svg width="40" height="40" fill="none" xmlns="http://www.w3.org/2000/svg">
    <g clip-path="url(#a)">
      <path
        d="M0 16.6c0-6.168 0-9.251 1.314-11.555a10 10 0 0 1 3.731-3.731C7.35 0 10.432 0 16.6 0h6.8c6.168 0 9.252 0 11.555 1.314a10 10 0 0 1 3.731 3.731C40 7.35 40 10.432 40 16.6v6.8c0 6.168 0 9.252-1.314 11.555a10 10 0 0 1-3.731 3.731C32.652 40 29.568 40 23.4 40h-6.8c-6.168 0-9.251 0-11.555-1.314a10 10 0 0 1-3.731-3.731C0 32.652 0 29.568 0 23.4v-6.8Z"
        fill="#fff"
      />
      <path
        d="M.5 16.6c0-3.093 0-5.38.162-7.182.161-1.795.48-3.061 1.086-4.125a9.5 9.5 0 0 1 3.545-3.545C6.357 1.141 7.623.823 9.418.662 11.221.5 13.508.5 16.6.5h6.8c3.093 0 5.38 0 7.182.162 1.795.161 3.062.48 4.125 1.086a9.5 9.5 0 0 1 3.545 3.545c.607 1.064.925 2.33 1.086 4.125.161 1.803.162 4.09.162 7.182v6.8c0 3.093 0 5.38-.162 7.182-.161 1.795-.48 3.062-1.086 4.125a9.5 9.5 0 0 1-3.545 3.545c-1.063.607-2.33.925-4.125 1.086-1.803.161-4.09.162-7.182.162h-6.8c-3.093 0-5.38 0-7.182-.162-1.795-.161-3.061-.48-4.125-1.086a9.5 9.5 0 0 1-3.545-3.545c-.607-1.063-.925-2.33-1.086-4.125C.5 28.779.5 26.492.5 23.4v-6.8Z"
        stroke="#fff"
        stroke-opacity=".05"
      />
      <path
        d="M18.606 12.642a.781.781 0 0 0-.771.66l-1.281 8.125a.78.78 0 0 1 .77-.66h3.755a7.668 7.668 0 0 0 7.57-6.49 6.26 6.26 0 0 0 .075-.843c-.96-.504-2.089-.792-3.325-.792h-6.793Z"
        fill="#001C64"
      />
      <path
        d="M28.724 13.434c-.006.282-.03.564-.075.843a7.668 7.668 0 0 1-7.57 6.491h-3.754a.78.78 0 0 0-.771.66l-1.916 12.15a.634.634 0 0 0 .626.734h4.075a.781.781 0 0 0 .77-.66l1.074-6.807a.781.781 0 0 1 .772-.66h2.4a7.668 7.668 0 0 0 7.57-6.491c.415-2.651-.92-5.064-3.201-6.26Z"
        fill="#0070E0"
      />
      <path
        d="M13.977 7.226a.78.78 0 0 0-.771.658l-3.198 20.277a.634.634 0 0 0 .626.733h4.742l1.178-7.467 1.281-8.125a.782.782 0 0 1 .771-.66H25.4c1.237 0 2.364.289 3.325.792.065-3.4-2.74-6.208-6.599-6.208h-8.148Z"
        fill="#003087"
      />
    </g>
    <defs>
      <clipPath id="a"><path fill="#fff" d="M0 0h40v40H0z" /></clipPath>
    </defs>
  </svg>
`;

    const onrampCardSvg = b$5 `<svg width="60" height="60" viewBox="0 0 60 60" fill="none">
<g clip-path="url(#clip0_13859_31161)">
  <path d="M0 24.8995C0 15.6481 0 11.0223 1.97053 7.56763C3.3015 5.2342 5.23468 3.30101 7.56812 1.97004C11.0228 -0.000488281 15.6485 -0.000488281 24.9 -0.000488281H35.1C44.3514 -0.000488281 48.9772 -0.000488281 52.4319 1.97004C54.7653 3.30101 56.6985 5.2342 58.0295 7.56763C60 11.0223 60 15.6481 60 24.8995V35.0995C60 44.351 60 48.9767 58.0295 52.4314C56.6985 54.7648 54.7653 56.698 52.4319 58.029C48.9772 59.9995 44.3514 59.9995 35.1 59.9995H24.9C15.6485 59.9995 11.0228 59.9995 7.56812 58.029C5.23468 56.698 3.3015 54.7648 1.97053 52.4314C0 48.9767 0 44.351 0 35.0995V24.8995Z" fill="#EB8B47"/>
  <path d="M0.5 24.8995C0.5 20.2647 0.50047 16.8216 0.744315 14.1045C0.987552 11.3941 1.46987 9.45455 2.40484 7.81536C3.69145 5.55971 5.56019 3.69096 7.81585 2.40435C9.45504 1.46938 11.3946 0.987064 14.105 0.743826C16.8221 0.499981 20.2652 0.499512 24.9 0.499512H35.1C39.7348 0.499512 43.1779 0.499981 45.895 0.743826C48.6054 0.987064 50.545 1.46938 52.1841 2.40435C54.4398 3.69096 56.3086 5.55971 57.5952 7.81536C58.5301 9.45455 59.0124 11.3941 59.2557 14.1045C59.4995 16.8216 59.5 20.2647 59.5 24.8995V35.0995C59.5 39.7343 59.4995 43.1774 59.2557 45.8945C59.0124 48.6049 58.5301 50.5445 57.5952 52.1837C56.3086 54.4393 54.4398 56.3081 52.1841 57.5947C50.545 58.5296 48.6054 59.012 45.895 59.2552C43.1779 59.499 39.7348 59.4995 35.1 59.4995H24.9C20.2652 59.4995 16.8221 59.499 14.105 59.2552C11.3946 59.012 9.45504 58.5296 7.81585 57.5947C5.56019 56.3081 3.69145 54.4393 2.40484 52.1837C1.46987 50.5445 0.987552 48.6049 0.744315 45.8945C0.50047 43.1774 0.5 39.7343 0.5 35.0995V24.8995Z" stroke="#141414" stroke-opacity="0.1"/>
  <path d="M13 26.0335C13 21.7838 13 19.659 14.0822 18.1694C14.4318 17.6883 14.8548 17.2653 15.3359 16.9157C16.8255 15.8335 18.9503 15.8335 23.2 15.8335H36.8C41.0497 15.8335 43.1745 15.8335 44.6641 16.9157C45.1452 17.2653 45.5682 17.6883 45.9178 18.1694C47 19.659 47 21.7838 47 26.0335V33.9668C47 38.2165 47 40.3414 45.9178 41.831C45.5682 42.312 45.1452 42.7351 44.6641 43.0846C43.1745 44.1668 41.0497 44.1668 36.8 44.1668H23.2C18.9503 44.1668 16.8255 44.1668 15.3359 43.0846C14.8548 42.7351 14.4318 42.312 14.0822 41.831C13 40.3414 13 38.2165 13 33.9668V26.0335Z" fill="#FF974C" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
  <path d="M39.5 36.667H36.6666" stroke="white" stroke-width="4" stroke-linecap="round" stroke-linejoin="round"/>
  <path d="M45.2 23.0645H14.8C14.0501 23.0645 13.6751 23.0645 13.4122 23.2554C13.3273 23.3171 13.2527 23.3918 13.191 23.4767C13 23.7395 13 24.1145 13 24.8645V27.2645C13 28.0144 13 28.3894 13.191 28.6522C13.2527 28.7371 13.3273 28.8118 13.4122 28.8735C13.6751 29.0645 14.0501 29.0645 14.8 29.0645H45.2C45.9499 29.0645 46.3249 29.0645 46.5878 28.8735C46.6727 28.8118 46.7473 28.7371 46.809 28.6522C47 28.3894 47 28.0144 47 27.2645V24.8645C47 24.1145 47 23.7395 46.809 23.4767C46.7473 23.3918 46.6727 23.3171 46.5878 23.2554C46.3249 23.0645 45.9499 23.0645 45.2 23.0645Z" fill="white" fill-opacity="0.4" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</g>
<defs>
  <clipPath id="clip0_13859_31161">
    <rect width="60" height="60" fill="white"/>
  </clipPath>
</defs>
</svg>`;

    var styles$1B = i$h `
  :host {
    display: block;
    width: var(--local-size);
    height: var(--local-size);
  }

  :host svg {
    width: 100%;
    height: 100%;
  }
`;

    var __decorate$1_ = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    const svgOptions = {
        browser: browserSvg,
        dao: daoSvg,
        defi: defiSvg,
        defiAlt: defiAltSvg,
        eth: ethSvg,
        layers: layersSvg,
        lock: lockSvg,
        login: loginSvg,
        network: networkSvg,
        nft: nftSvg,
        noun: nounSvg,
        profile: profileSvg,
        system: systemSvg,
        coinbase: coinbaseSvg,
        onrampCard: onrampCardSvg,
        moonpay: moonpaySvg,
        stripe: stripeSvg,
        paypal: paypalSvg
    };
    let WuiVisual = class WuiVisual extends s$e {
        constructor() {
            super(...arguments);
            this.name = 'browser';
            this.size = 'md';
        }
        render() {
            this.style.cssText = `
       --local-size: var(--wui-visual-size-${this.size});
   `;
            return x$5 `${svgOptions[this.name]}`;
        }
    };
    WuiVisual.styles = [resetStyles, styles$1B];
    __decorate$1_([
        n$j()
    ], WuiVisual.prototype, "name", void 0);
    __decorate$1_([
        n$j()
    ], WuiVisual.prototype, "size", void 0);
    WuiVisual = __decorate$1_([
        customElement('wui-visual')
    ], WuiVisual);

    /**
     * @license
     * Copyright 2018 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */const o$l=o=>o??T$7;

    const UiHelperUtil = {
        getSpacingStyles(spacing, index) {
            if (Array.isArray(spacing)) {
                return spacing[index] ? `var(--wui-spacing-${spacing[index]})` : undefined;
            }
            else if (typeof spacing === 'string') {
                return `var(--wui-spacing-${spacing})`;
            }
            return undefined;
        },
        getFormattedDate(date) {
            return new Intl.DateTimeFormat('en-US', { month: 'short', day: 'numeric' }).format(date);
        },
        getHostName(url) {
            const newUrl = new URL(url);
            return newUrl.hostname;
        },
        getTruncateString({ string, charsStart, charsEnd, truncate }) {
            if (string.length <= charsStart + charsEnd) {
                return string;
            }
            if (truncate === 'end') {
                return `${string.substring(0, charsStart)}...`;
            }
            else if (truncate === 'start') {
                return `...${string.substring(string.length - charsEnd)}`;
            }
            return `${string.substring(0, Math.floor(charsStart))}...${string.substring(string.length - Math.floor(charsEnd))}`;
        },
        generateAvatarColors(address) {
            const hash = address.toLowerCase().replace(/^0x/iu, '');
            const baseColor = hash.substring(0, 6);
            const rgbColor = this.hexToRgb(baseColor);
            const masterBorderRadius = getComputedStyle(document.documentElement).getPropertyValue('--w3m-border-radius-master');
            const radius = Number(masterBorderRadius?.replace('px', ''));
            const edge = 100 - 3 * radius;
            const gradientCircle = `${edge}% ${edge}% at 65% 40%`;
            const colors = [];
            for (let i = 0; i < 5; i += 1) {
                const tintedColor = this.tintColor(rgbColor, 0.15 * i);
                colors.push(`rgb(${tintedColor[0]}, ${tintedColor[1]}, ${tintedColor[2]})`);
            }
            return `
    --local-color-1: ${colors[0]};
    --local-color-2: ${colors[1]};
    --local-color-3: ${colors[2]};
    --local-color-4: ${colors[3]};
    --local-color-5: ${colors[4]};
    --local-radial-circle: ${gradientCircle}
   `;
        },
        hexToRgb(hex) {
            const bigint = parseInt(hex, 16);
            const r = (bigint >> 16) & 255;
            const g = (bigint >> 8) & 255;
            const b = bigint & 255;
            return [r, g, b];
        },
        tintColor(rgb, tint) {
            const [r, g, b] = rgb;
            const tintedR = Math.round(r + (255 - r) * tint);
            const tintedG = Math.round(g + (255 - g) * tint);
            const tintedB = Math.round(b + (255 - b) * tint);
            return [tintedR, tintedG, tintedB];
        },
        isNumber(character) {
            const regex = {
                number: /^[0-9]+$/u
            };
            return regex.number.test(character);
        },
        getColorTheme(theme) {
            if (theme) {
                return theme;
            }
            else if (typeof window !== 'undefined' && window.matchMedia) {
                if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
                    return 'dark';
                }
                return 'light';
            }
            return 'dark';
        },
        splitBalance(input) {
            const parts = input.split('.');
            if (parts.length === 2) {
                return [parts[0], parts[1]];
            }
            return ['0', '00'];
        },
        roundNumber(number, threshold, fixed) {
            const roundedNumber = Math.abs(number) >= threshold ? Number(number.toFixed(fixed)) : number;
            return roundedNumber;
        }
    };

    var styles$1A = i$h `
  :host {
    display: flex;
    width: inherit;
    height: inherit;
  }
`;

    var __decorate$1Z = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let WuiFlex = class WuiFlex extends s$e {
        render() {
            this.style.cssText = `
      flex-direction: ${this.flexDirection};
      flex-wrap: ${this.flexWrap};
      flex-basis: ${this.flexBasis};
      flex-grow: ${this.flexGrow};
      flex-shrink: ${this.flexShrink};
      align-items: ${this.alignItems};
      justify-content: ${this.justifyContent};
      column-gap: ${this.columnGap && `var(--wui-spacing-${this.columnGap})`};
      row-gap: ${this.rowGap && `var(--wui-spacing-${this.rowGap})`};
      gap: ${this.gap && `var(--wui-spacing-${this.gap})`};
      padding-top: ${this.padding && UiHelperUtil.getSpacingStyles(this.padding, 0)};
      padding-right: ${this.padding && UiHelperUtil.getSpacingStyles(this.padding, 1)};
      padding-bottom: ${this.padding && UiHelperUtil.getSpacingStyles(this.padding, 2)};
      padding-left: ${this.padding && UiHelperUtil.getSpacingStyles(this.padding, 3)};
      margin-top: ${this.margin && UiHelperUtil.getSpacingStyles(this.margin, 0)};
      margin-right: ${this.margin && UiHelperUtil.getSpacingStyles(this.margin, 1)};
      margin-bottom: ${this.margin && UiHelperUtil.getSpacingStyles(this.margin, 2)};
      margin-left: ${this.margin && UiHelperUtil.getSpacingStyles(this.margin, 3)};
    `;
            return x$5 `<slot></slot>`;
        }
    };
    WuiFlex.styles = [resetStyles, styles$1A];
    __decorate$1Z([
        n$j()
    ], WuiFlex.prototype, "flexDirection", void 0);
    __decorate$1Z([
        n$j()
    ], WuiFlex.prototype, "flexWrap", void 0);
    __decorate$1Z([
        n$j()
    ], WuiFlex.prototype, "flexBasis", void 0);
    __decorate$1Z([
        n$j()
    ], WuiFlex.prototype, "flexGrow", void 0);
    __decorate$1Z([
        n$j()
    ], WuiFlex.prototype, "flexShrink", void 0);
    __decorate$1Z([
        n$j()
    ], WuiFlex.prototype, "alignItems", void 0);
    __decorate$1Z([
        n$j()
    ], WuiFlex.prototype, "justifyContent", void 0);
    __decorate$1Z([
        n$j()
    ], WuiFlex.prototype, "columnGap", void 0);
    __decorate$1Z([
        n$j()
    ], WuiFlex.prototype, "rowGap", void 0);
    __decorate$1Z([
        n$j()
    ], WuiFlex.prototype, "gap", void 0);
    __decorate$1Z([
        n$j()
    ], WuiFlex.prototype, "padding", void 0);
    __decorate$1Z([
        n$j()
    ], WuiFlex.prototype, "margin", void 0);
    WuiFlex = __decorate$1Z([
        customElement('wui-flex')
    ], WuiFlex);

    var styles$1z = i$h `
  :host {
    display: block;
    width: var(--wui-icon-box-size-xl);
    height: var(--wui-icon-box-size-xl);
    border-radius: var(--wui-border-radius-3xl);
    box-shadow: 0 0 0 8px var(--wui-gray-glass-005);
    overflow: hidden;
    position: relative;
  }

  :host([data-variant='generated']) {
    --mixed-local-color-1: var(--local-color-1);
    --mixed-local-color-2: var(--local-color-2);
    --mixed-local-color-3: var(--local-color-3);
    --mixed-local-color-4: var(--local-color-4);
    --mixed-local-color-5: var(--local-color-5);
  }

  @supports (background: color-mix(in srgb, white 50%, black)) {
    :host([data-variant='generated']) {
      --mixed-local-color-1: color-mix(
        in srgb,
        var(--w3m-color-mix) var(--w3m-color-mix-strength),
        var(--local-color-1)
      );
      --mixed-local-color-2: color-mix(
        in srgb,
        var(--w3m-color-mix) var(--w3m-color-mix-strength),
        var(--local-color-2)
      );
      --mixed-local-color-3: color-mix(
        in srgb,
        var(--w3m-color-mix) var(--w3m-color-mix-strength),
        var(--local-color-3)
      );
      --mixed-local-color-4: color-mix(
        in srgb,
        var(--w3m-color-mix) var(--w3m-color-mix-strength),
        var(--local-color-4)
      );
      --mixed-local-color-5: color-mix(
        in srgb,
        var(--w3m-color-mix) var(--w3m-color-mix-strength),
        var(--local-color-5)
      );
    }
  }

  :host([data-variant='generated']) {
    box-shadow: 0 0 0 8px var(--wui-gray-glass-005);
    background: radial-gradient(
      var(--local-radial-circle),
      #fff 0.52%,
      var(--mixed-local-color-5) 31.25%,
      var(--mixed-local-color-3) 51.56%,
      var(--mixed-local-color-2) 65.63%,
      var(--mixed-local-color-1) 82.29%,
      var(--mixed-local-color-4) 100%
    );
  }

  :host([data-variant='default']) {
    box-shadow: 0 0 0 8px var(--wui-gray-glass-005);
    background: radial-gradient(
      75.29% 75.29% at 64.96% 24.36%,
      #fff 0.52%,
      #f5ccfc 31.25%,
      #dba4f5 51.56%,
      #9a8ee8 65.63%,
      #6493da 82.29%,
      #6ebdea 100%
    );
  }
`;

    var __decorate$1Y = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let WuiAvatar = class WuiAvatar extends s$e {
        constructor() {
            super(...arguments);
            this.imageSrc = undefined;
            this.alt = undefined;
            this.address = undefined;
        }
        render() {
            return x$5 `${this.visualTemplate()}`;
        }
        visualTemplate() {
            if (this.imageSrc) {
                this.dataset['variant'] = 'image';
                return x$5 `<wui-image src=${this.imageSrc} alt=${this.alt ?? 'avatar'}></wui-image>`;
            }
            else if (this.address) {
                this.dataset['variant'] = 'generated';
                const cssColors = UiHelperUtil.generateAvatarColors(this.address);
                this.style.cssText = cssColors;
                return null;
            }
            this.dataset['variant'] = 'default';
            return null;
        }
    };
    WuiAvatar.styles = [resetStyles, styles$1z];
    __decorate$1Y([
        n$j()
    ], WuiAvatar.prototype, "imageSrc", void 0);
    __decorate$1Y([
        n$j()
    ], WuiAvatar.prototype, "alt", void 0);
    __decorate$1Y([
        n$j()
    ], WuiAvatar.prototype, "address", void 0);
    WuiAvatar = __decorate$1Y([
        customElement('wui-avatar')
    ], WuiAvatar);

    var styles$1y = i$h `
  :host {
    display: inline-flex;
    justify-content: center;
    align-items: center;
    position: relative;
    overflow: hidden;
    background-color: var(--wui-gray-glass-020);
    border-radius: var(--local-border-radius);
    border: var(--local-border);
    box-sizing: content-box;
    width: var(--local-size);
    height: var(--local-size);
    min-height: var(--local-size);
    min-width: var(--local-size);
  }

  @supports (background: color-mix(in srgb, white 50%, black)) {
    :host {
      background-color: color-mix(in srgb, var(--local-bg-value) var(--local-bg-mix), transparent);
    }
  }
`;

    var __decorate$1X = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let WuiIconBox = class WuiIconBox extends s$e {
        constructor() {
            super(...arguments);
            this.size = 'md';
            this.backgroundColor = 'accent-100';
            this.iconColor = 'accent-100';
            this.background = 'transparent';
            this.border = false;
            this.borderColor = 'wui-color-bg-125';
            this.icon = 'copy';
        }
        render() {
            const iconSize = this.iconSize || this.size;
            const isLg = this.size === 'lg';
            const isXl = this.size === 'xl';
            const bgMix = isLg ? '12%' : '16%';
            const borderRadius = isLg ? 'xxs' : isXl ? 's' : '3xl';
            const isGray = this.background === 'gray';
            const isOpaque = this.background === 'opaque';
            const isColorChange = (this.backgroundColor === 'accent-100' && isOpaque) ||
                (this.backgroundColor === 'success-100' && isOpaque) ||
                (this.backgroundColor === 'error-100' && isOpaque) ||
                (this.backgroundColor === 'inverse-100' && isOpaque);
            let bgValueVariable = `var(--wui-color-${this.backgroundColor})`;
            if (isColorChange) {
                bgValueVariable = `var(--wui-icon-box-bg-${this.backgroundColor})`;
            }
            else if (isGray) {
                bgValueVariable = `var(--wui-gray-${this.backgroundColor})`;
            }
            this.style.cssText = `
       --local-bg-value: ${bgValueVariable};
       --local-bg-mix: ${isColorChange || isGray ? `100%` : bgMix};
       --local-border-radius: var(--wui-border-radius-${borderRadius});
       --local-size: var(--wui-icon-box-size-${this.size});
       --local-border: ${this.borderColor === 'wui-color-bg-125' ? `2px` : `1px`} solid ${this.border ? `var(--${this.borderColor})` : `transparent`}
   `;
            return x$5 ` <wui-icon color=${this.iconColor} size=${iconSize} name=${this.icon}></wui-icon> `;
        }
    };
    WuiIconBox.styles = [resetStyles, elementStyles, styles$1y];
    __decorate$1X([
        n$j()
    ], WuiIconBox.prototype, "size", void 0);
    __decorate$1X([
        n$j()
    ], WuiIconBox.prototype, "backgroundColor", void 0);
    __decorate$1X([
        n$j()
    ], WuiIconBox.prototype, "iconColor", void 0);
    __decorate$1X([
        n$j()
    ], WuiIconBox.prototype, "iconSize", void 0);
    __decorate$1X([
        n$j()
    ], WuiIconBox.prototype, "background", void 0);
    __decorate$1X([
        n$j({ type: Boolean })
    ], WuiIconBox.prototype, "border", void 0);
    __decorate$1X([
        n$j()
    ], WuiIconBox.prototype, "borderColor", void 0);
    __decorate$1X([
        n$j()
    ], WuiIconBox.prototype, "icon", void 0);
    WuiIconBox = __decorate$1X([
        customElement('wui-icon-box')
    ], WuiIconBox);

    var styles$1x = i$h `
  :host {
    display: block;
  }

  button {
    border-radius: var(--wui-border-radius-3xl);
    background: var(--wui-gray-glass-002);
    display: flex;
    gap: var(--wui-spacing-xs);
    padding: var(--wui-spacing-3xs) var(--wui-spacing-xs) var(--wui-spacing-3xs)
      var(--wui-spacing-xs);
    border: 1px solid var(--wui-gray-glass-005);
  }

  button:disabled {
    background: var(--wui-gray-glass-015);
  }

  button:disabled > wui-text {
    color: var(--wui-gray-glass-015);
  }

  button:disabled > wui-flex > wui-text {
    color: var(--wui-gray-glass-015);
  }

  button:disabled > wui-image,
  button:disabled > wui-icon-box,
  button:disabled > wui-flex > wui-avatar {
    filter: grayscale(1);
  }

  button:has(wui-image) {
    padding: var(--wui-spacing-3xs) var(--wui-spacing-3xs) var(--wui-spacing-3xs)
      var(--wui-spacing-xs);
  }

  wui-text {
    color: var(--wui-color-fg-100);
  }

  wui-flex > wui-text {
    color: var(--wui-color-fg-200);
    transition: all var(--wui-ease-out-power-1) var(--wui-duration-lg);
  }

  wui-image,
  wui-icon-box {
    border-radius: var(--wui-border-radius-3xl);
    width: 24px;
    height: 24px;
    box-shadow: 0 0 0 2px var(--wui-gray-glass-005);
  }

  wui-flex {
    border-radius: var(--wui-border-radius-3xl);
    border: 1px solid var(--wui-gray-glass-005);
    background: var(--wui-gray-glass-005);
    padding: 4px var(--wui-spacing-m) 4px var(--wui-spacing-xxs);
  }

  button.local-no-balance {
    border-radius: 0px;
    border: none;
    background: transparent;
  }

  wui-avatar {
    width: 20px;
    height: 20px;
    box-shadow: 0 0 0 2px var(--wui-accent-glass-010);
  }

  @media (max-width: 500px) {
    button {
      gap: 0px;
      padding: var(--wui-spacing-3xs) var(--wui-spacing-xs) !important;
      height: 32px;
    }
    wui-image,
    wui-icon-box,
    button > wui-text {
      visibility: hidden;
      width: 0px;
      height: 0px;
    }
    button {
      border-radius: 0px;
      border: none;
      background: transparent;
      padding: 0px;
    }
  }

  @media (hover: hover) and (pointer: fine) {
    button:hover:enabled > wui-flex > wui-text {
      color: var(--wui-color-fg-175);
    }

    button:active:enabled > wui-flex > wui-text {
      color: var(--wui-color-fg-175);
    }
  }
`;

    var __decorate$1W = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let WuiAccountButton = class WuiAccountButton extends s$e {
        constructor() {
            super(...arguments);
            this.networkSrc = undefined;
            this.avatarSrc = undefined;
            this.balance = undefined;
            this.isUnsupportedChain = undefined;
            this.disabled = false;
            this.isProfileName = false;
            this.address = '';
            this.profileName = '';
            this.charsStart = 4;
            this.charsEnd = 6;
        }
        render() {
            return x$5 `
      <button
        ?disabled=${this.disabled}
        class=${o$l(this.balance ? undefined : 'local-no-balance')}
      >
        ${this.balanceTemplate()}
        <wui-flex gap="xxs" alignItems="center">
          <wui-avatar
            .imageSrc=${this.avatarSrc}
            alt=${this.address}
            address=${this.address}
          ></wui-avatar>
          <wui-text variant="paragraph-600" color="inherit">
            ${this.address
            ? UiHelperUtil.getTruncateString({
                string: this.isProfileName ? this.profileName : this.address,
                charsStart: this.isProfileName ? 18 : this.charsStart,
                charsEnd: this.isProfileName ? 0 : this.charsEnd,
                truncate: this.isProfileName ? 'end' : 'middle'
            })
            : null}
          </wui-text>
        </wui-flex>
      </button>
    `;
        }
        balanceTemplate() {
            if (this.isUnsupportedChain) {
                return x$5 ` <wui-icon-box
          size="sm"
          iconColor="error-100"
          backgroundColor="error-100"
          icon="warningCircle"
        ></wui-icon-box>
        <wui-text variant="paragraph-600" color="inherit"> Switch Network</wui-text>`;
            }
            if (this.balance) {
                const networkElement = this.networkSrc
                    ? x$5 `<wui-image src=${this.networkSrc}></wui-image>`
                    : x$5 `
            <wui-icon-box
              size="sm"
              iconColor="fg-200"
              backgroundColor="fg-300"
              icon="networkPlaceholder"
            ></wui-icon-box>
          `;
                return x$5 `
        ${networkElement}
        <wui-text variant="paragraph-600" color="inherit"> ${this.balance}</wui-text>
      `;
            }
            return null;
        }
    };
    WuiAccountButton.styles = [resetStyles, elementStyles, styles$1x];
    __decorate$1W([
        n$j()
    ], WuiAccountButton.prototype, "networkSrc", void 0);
    __decorate$1W([
        n$j()
    ], WuiAccountButton.prototype, "avatarSrc", void 0);
    __decorate$1W([
        n$j()
    ], WuiAccountButton.prototype, "balance", void 0);
    __decorate$1W([
        n$j({ type: Boolean })
    ], WuiAccountButton.prototype, "isUnsupportedChain", void 0);
    __decorate$1W([
        n$j({ type: Boolean })
    ], WuiAccountButton.prototype, "disabled", void 0);
    __decorate$1W([
        n$j({ type: Boolean })
    ], WuiAccountButton.prototype, "isProfileName", void 0);
    __decorate$1W([
        n$j()
    ], WuiAccountButton.prototype, "address", void 0);
    __decorate$1W([
        n$j()
    ], WuiAccountButton.prototype, "profileName", void 0);
    __decorate$1W([
        n$j()
    ], WuiAccountButton.prototype, "charsStart", void 0);
    __decorate$1W([
        n$j()
    ], WuiAccountButton.prototype, "charsEnd", void 0);
    WuiAccountButton = __decorate$1W([
        customElement('wui-account-button')
    ], WuiAccountButton);

    var styles$1w = i$h `
  :host {
    position: relative;
    background-color: var(--wui-gray-glass-002);
    display: flex;
    justify-content: center;
    align-items: center;
    width: var(--local-size);
    height: var(--local-size);
    border-radius: inherit;
    border-radius: var(--local-border-radius);
  }

  :host > wui-flex {
    overflow: hidden;
    border-radius: inherit;
    border-radius: var(--local-border-radius);
  }

  :host::after {
    content: '';
    position: absolute;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    border-radius: inherit;
    border: 1px solid var(--wui-gray-glass-010);
    pointer-events: none;
  }

  :host([name='Extension'])::after {
    border: 1px solid var(--wui-accent-glass-010);
  }

  :host([data-wallet-icon='allWallets']) {
    background-color: var(--wui-all-wallets-bg-100);
  }

  :host([data-wallet-icon='allWallets'])::after {
    border: 1px solid var(--wui-accent-glass-010);
  }

  wui-icon[data-parent-size='inherit'] {
    width: 75%;
    height: 75%;
    align-items: center;
  }

  wui-icon[data-parent-size='sm'] {
    width: 18px;
    height: 18px;
  }

  wui-icon[data-parent-size='md'] {
    width: 24px;
    height: 24px;
  }

  wui-icon[data-parent-size='lg'] {
    width: 42px;
    height: 42px;
  }

  wui-icon[data-parent-size='full'] {
    width: 100%;
    height: 100%;
  }

  :host > wui-icon-box {
    position: absolute;
    overflow: hidden;
    right: -1px;
    bottom: -2px;
    z-index: 1;
    border: 2px solid var(--wui-color-bg-base-150, #1e1f1f);
    padding: 1px;
  }
`;

    var __decorate$1V = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let WuiWalletImage = class WuiWalletImage extends s$e {
        constructor() {
            super(...arguments);
            this.size = 'md';
            this.name = '';
            this.installed = false;
            this.badgeSize = 'xs';
        }
        render() {
            let borderRadius = 'xxs';
            if (this.size === 'lg') {
                borderRadius = 'm';
            }
            else if (this.size === 'md') {
                borderRadius = 'xs';
            }
            else {
                borderRadius = 'xxs';
            }
            this.style.cssText = `
       --local-border-radius: var(--wui-border-radius-${borderRadius});
       --local-size: var(--wui-wallet-image-size-${this.size});
   `;
            if (this.walletIcon) {
                this.dataset['walletIcon'] = this.walletIcon;
            }
            return x$5 `
      <wui-flex justifyContent="center" alignItems="center"> ${this.templateVisual()} </wui-flex>
    `;
        }
        templateVisual() {
            if (this.imageSrc) {
                return x$5 `<wui-image src=${this.imageSrc} alt=${this.name}></wui-image>`;
            }
            else if (this.walletIcon) {
                return x$5 `<wui-icon
        data-parent-size="md"
        size="md"
        color="inherit"
        name=${this.walletIcon}
      ></wui-icon>`;
            }
            return x$5 `<wui-icon
      data-parent-size=${this.size}
      size="inherit"
      color="inherit"
      name="walletPlaceholder"
    ></wui-icon>`;
        }
    };
    WuiWalletImage.styles = [resetStyles, styles$1w];
    __decorate$1V([
        n$j()
    ], WuiWalletImage.prototype, "size", void 0);
    __decorate$1V([
        n$j()
    ], WuiWalletImage.prototype, "name", void 0);
    __decorate$1V([
        n$j()
    ], WuiWalletImage.prototype, "imageSrc", void 0);
    __decorate$1V([
        n$j()
    ], WuiWalletImage.prototype, "walletIcon", void 0);
    __decorate$1V([
        n$j({ type: Boolean })
    ], WuiWalletImage.prototype, "installed", void 0);
    __decorate$1V([
        n$j()
    ], WuiWalletImage.prototype, "badgeSize", void 0);
    WuiWalletImage = __decorate$1V([
        customElement('wui-wallet-image')
    ], WuiWalletImage);

    var styles$1v = i$h `
  :host {
    position: relative;
    border-radius: var(--wui-border-radius-xxs);
    width: 40px;
    height: 40px;
    overflow: hidden;
    background: var(--wui-gray-glass-002);
    display: flex;
    justify-content: center;
    align-items: center;
    flex-wrap: wrap;
    gap: var(--wui-spacing-4xs);
    padding: 3.75px !important;
  }

  :host::after {
    content: '';
    position: absolute;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    border-radius: inherit;
    border: 1px solid var(--wui-gray-glass-010);
    pointer-events: none;
  }

  :host > wui-wallet-image {
    width: 14px;
    height: 14px;
    border-radius: var(--wui-border-radius-5xs);
  }

  :host > wui-flex {
    padding: 2px;
    position: fixed;
    overflow: hidden;
    left: 34px;
    bottom: 8px;
    background: var(--dark-background-150, #1e1f1f);
    border-radius: 50%;
    z-index: 2;
    display: flex;
  }
`;

    var __decorate$1U = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    const TOTAL_IMAGES = 4;
    let WuiAllWalletsImage = class WuiAllWalletsImage extends s$e {
        constructor() {
            super(...arguments);
            this.walletImages = [];
        }
        render() {
            const isPlaceholders = this.walletImages.length < TOTAL_IMAGES;
            return x$5 `${this.walletImages
            .slice(0, TOTAL_IMAGES)
            .map(({ src, walletName }) => x$5 `
            <wui-wallet-image
              size="inherit"
              imageSrc=${src}
              name=${o$l(walletName)}
            ></wui-wallet-image>
          `)}
      ${isPlaceholders
            ? [...Array(TOTAL_IMAGES - this.walletImages.length)].map(() => x$5 ` <wui-wallet-image size="inherit" name=""></wui-wallet-image>`)
            : null}
      <wui-flex>
        <wui-icon-box
          size="xxs"
          iconSize="xxs"
          iconcolor="success-100"
          backgroundcolor="success-100"
          icon="checkmark"
          background="opaque"
        ></wui-icon-box>
      </wui-flex>`;
        }
    };
    WuiAllWalletsImage.styles = [resetStyles, styles$1v];
    __decorate$1U([
        n$j({ type: Array })
    ], WuiAllWalletsImage.prototype, "walletImages", void 0);
    WuiAllWalletsImage = __decorate$1U([
        customElement('wui-all-wallets-image')
    ], WuiAllWalletsImage);

    var styles$1u = i$h `
  :host {
    width: var(--local-width);
    position: relative;
  }

  button {
    border: 1px solid var(--wui-gray-glass-010);
    border-radius: var(--local-border-radius);
    width: var(--local-width);
  }

  button:disabled {
    border: 1px solid var(--wui-gray-glass-010);
  }

  /* xs settings */
  button[data-size='xs'] {
    padding: var(--wui-spacing-xs) var(--wui-spacing-1xs);
  }

  button[data-size='xs'][data-icon-left='true'][data-icon-right='false'] {
    padding-left: var(--wui-spacing-xxs);
  }

  button[data-size='xs'][data-icon-right='true'][data-icon-left='false'] {
    padding-right: var(--wui-spacing-xxs);
  }

  /* sm settings */
  button[data-size='sm'] {
    padding: var(--wui-spacing-xxs) var(--wui-spacing-s);
  }

  button[data-size='sm'][data-icon-left='true'][data-icon-right='false'] {
    padding: var(--wui-spacing-xxs) var(--wui-spacing-s) var(--wui-spacing-xxs)
      var(--wui-spacing-xs);
  }

  button[data-size='sm'][data-icon-right='true'][data-icon-left='false'] {
    padding: var(--wui-spacing-xxs) var(--wui-spacing-xs) var(--wui-spacing-xxs)
      var(--wui-spacing-s);
  }

  /* md settings */
  button[data-size='md'] {
    padding: 8.2px var(--wui-spacing-l) 9px var(--wui-spacing-l);
  }

  button[data-size='md'][data-icon-left='true'][data-icon-right='false'] {
    padding: 8.2px var(--wui-spacing-l) 9px var(--wui-spacing-s);
  }

  button[data-size='md'][data-icon-right='true'][data-icon-left='false'] {
    padding: 8.2px var(--wui-spacing-s) 9px var(--wui-spacing-l);
  }

  /* lg settings */
  button[data-size='lg'] {
    padding: var(--wui-spacing-m) var(--wui-spacing-2l);
  }

  button[data-size='lg'][data-icon-left='true'][data-icon-right='false'] {
    padding-left: var(--wui-spacing-m);
  }

  button[data-size='lg'][data-icon-right='true'][data-icon-left='false'] {
    padding-right: var(--wui-spacing-m);
  }

  button > wui-text {
    transition: opacity 200ms ease-in-out;
    opacity: var(--local-opacity-100);
  }

  ::slotted(*) {
    transition: opacity 200ms ease-in-out;
    opacity: var(--local-opacity-100);
  }

  wui-loading-spinner {
    position: absolute;
    left: 50%;
    top: 50%;
    transition: all 200ms ease-in-out;
    transform: translate(-50%, -50%);
    opacity: var(--local-opacity-000);
  }
`;

    var __decorate$1T = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    const TEXT_VARIANT_BY_SIZE = {
        xs: 'small-600',
        sm: 'paragraph-600',
        md: 'small-600',
        mdl: 'small-600',
        lg: 'paragraph-600'
    };
    let WuiButton = class WuiButton extends s$e {
        constructor() {
            super(...arguments);
            this.size = 'md';
            this.disabled = false;
            this.fullWidth = false;
            this.loading = false;
            this.variant = 'fill';
            this.hasIconLeft = false;
            this.hasIconRight = false;
            this.borderRadius = 'm';
        }
        render() {
            this.style.cssText = `
    --local-width: ${this.fullWidth ? '100%' : 'auto'};
    --local-opacity-100: ${this.loading ? 0 : 1};
    --local-opacity-000: ${this.loading ? 1 : 0};
    --local-border-radius: var(--wui-border-radius-${this.borderRadius});
    `;
            const textVariant = this.textVariant ?? TEXT_VARIANT_BY_SIZE[this.size];
            return x$5 `
      <button
        data-variant=${this.variant}
        data-icon-left=${this.hasIconLeft}
        data-icon-right=${this.hasIconRight}
        data-size=${this.size}
        ?disabled=${this.disabled || this.loading}
        ontouchstart
      >
        ${this.loadingTemplate()}
        <slot name="iconLeft" @slotchange=${() => this.handleSlotLeftChange()}></slot>
        <wui-text variant=${textVariant} color="inherit">
          <slot></slot>
        </wui-text>
        <slot name="iconRight" @slotchange=${() => this.handleSlotRightChange()}></slot>
      </button>
    `;
        }
        handleSlotLeftChange() {
            this.hasIconLeft = true;
        }
        handleSlotRightChange() {
            this.hasIconRight = true;
        }
        loadingTemplate() {
            if (this.loading) {
                return x$5 `<wui-loading-spinner color="fg-300"></wui-loading-spinner>`;
            }
            return x$5 ``;
        }
    };
    WuiButton.styles = [resetStyles, elementStyles, styles$1u];
    __decorate$1T([
        n$j()
    ], WuiButton.prototype, "size", void 0);
    __decorate$1T([
        n$j({ type: Boolean })
    ], WuiButton.prototype, "disabled", void 0);
    __decorate$1T([
        n$j({ type: Boolean })
    ], WuiButton.prototype, "fullWidth", void 0);
    __decorate$1T([
        n$j({ type: Boolean })
    ], WuiButton.prototype, "loading", void 0);
    __decorate$1T([
        n$j()
    ], WuiButton.prototype, "variant", void 0);
    __decorate$1T([
        n$j({ type: Boolean })
    ], WuiButton.prototype, "hasIconLeft", void 0);
    __decorate$1T([
        n$j({ type: Boolean })
    ], WuiButton.prototype, "hasIconRight", void 0);
    __decorate$1T([
        n$j()
    ], WuiButton.prototype, "borderRadius", void 0);
    __decorate$1T([
        n$j()
    ], WuiButton.prototype, "textVariant", void 0);
    WuiButton = __decorate$1T([
        customElement('wui-button')
    ], WuiButton);

    const networkSvgMd = b$5 `<svg  viewBox="0 0 48 54" fill="none">
  <path
    d="M43.4605 10.7248L28.0485 1.61089C25.5438 0.129705 22.4562 0.129705 19.9515 1.61088L4.53951 10.7248C2.03626 12.2051 0.5 14.9365 0.5 17.886V36.1139C0.5 39.0635 2.03626 41.7949 4.53951 43.2752L19.9515 52.3891C22.4562 53.8703 25.5438 53.8703 28.0485 52.3891L43.4605 43.2752C45.9637 41.7949 47.5 39.0635 47.5 36.114V17.8861C47.5 14.9365 45.9637 12.2051 43.4605 10.7248Z"
  />
</svg>`;

    var styles$1t = i$h `
  :host {
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 76px;
    row-gap: var(--wui-spacing-xs);
    padding: var(--wui-spacing-xs) 10px;
    background-color: var(--wui-gray-glass-002);
    border-radius: clamp(0px, var(--wui-border-radius-xs), 20px);
    position: relative;
  }

  wui-shimmer[data-type='network'] {
    border: none;
    -webkit-clip-path: var(--wui-path-network);
    clip-path: var(--wui-path-network);
  }

  svg {
    position: absolute;
    width: 48px;
    height: 54px;
    z-index: 1;
  }

  svg > path {
    stroke: var(--wui-gray-glass-010);
    stroke-width: 1px;
  }
`;

    var __decorate$1S = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let WuiCardSelectLoader = class WuiCardSelectLoader extends s$e {
        constructor() {
            super(...arguments);
            this.type = 'wallet';
        }
        render() {
            return x$5 `
      ${this.shimmerTemplate()}
      <wui-shimmer width="56px" height="20px" borderRadius="xs"></wui-shimmer>
    `;
        }
        shimmerTemplate() {
            if (this.type === 'network') {
                return x$5 ` <wui-shimmer
          data-type=${this.type}
          width="48px"
          height="54px"
          borderRadius="xs"
        ></wui-shimmer>
        ${networkSvgMd}`;
            }
            return x$5 `<wui-shimmer width="56px" height="56px" borderRadius="xs"></wui-shimmer>`;
        }
    };
    WuiCardSelectLoader.styles = [resetStyles, elementStyles, styles$1t];
    __decorate$1S([
        n$j()
    ], WuiCardSelectLoader.prototype, "type", void 0);
    WuiCardSelectLoader = __decorate$1S([
        customElement('wui-card-select-loader')
    ], WuiCardSelectLoader);

    const networkSvgSm = b$5 `
  <svg fill="none" viewBox="0 0 36 40">
    <path
      d="M15.4 2.1a5.21 5.21 0 0 1 5.2 0l11.61 6.7a5.21 5.21 0 0 1 2.61 4.52v13.4c0 1.87-1 3.59-2.6 4.52l-11.61 6.7c-1.62.93-3.6.93-5.22 0l-11.6-6.7a5.21 5.21 0 0 1-2.61-4.51v-13.4c0-1.87 1-3.6 2.6-4.52L15.4 2.1Z"
    />
  </svg>
`;

    const networkSvgLg = b$5 `<svg width="86" height="96" fill="none">
  <path
    d="M78.3244 18.926L50.1808 2.45078C45.7376 -0.150261 40.2624 -0.150262 35.8192 2.45078L7.6756 18.926C3.23322 21.5266 0.5 26.3301 0.5 31.5248V64.4752C0.5 69.6699 3.23322 74.4734 7.6756 77.074L35.8192 93.5492C40.2624 96.1503 45.7376 96.1503 50.1808 93.5492L78.3244 77.074C82.7668 74.4734 85.5 69.6699 85.5 64.4752V31.5248C85.5 26.3301 82.7668 21.5266 78.3244 18.926Z"
  />
</svg>`;

    var styles$1s = i$h `
  :host {
    position: relative;
    border-radius: inherit;
    display: flex;
    justify-content: center;
    align-items: center;
    width: var(--local-width);
    height: var(--local-height);
  }

  svg {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 1;
    fill: var(--wui-gray-glass-002);
  }

  svg > path {
    stroke: var(--local-stroke);
    transition: stroke var(--wui-ease-out-power-1) var(--wui-duration-lg);
  }

  wui-image {
    width: 100%;
    height: 100%;
    -webkit-clip-path: var(--local-path);
    clip-path: var(--local-path);
    background: var(--wui-gray-glass-002);
  }

  wui-icon {
    transform: translateY(-5%);
    width: var(--local-icon-size);
    height: var(--local-icon-size);
  }
`;

    var __decorate$1R = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let WuiNetworkImage = class WuiNetworkImage extends s$e {
        constructor() {
            super(...arguments);
            this.size = 'md';
            this.name = 'uknown';
            this.selected = false;
        }
        render() {
            const networkImagesBySize = { sm: networkSvgSm, md: networkSvgMd, lg: networkSvgLg };
            this.style.cssText = `
      --local-stroke: ${this.selected ? 'var(--wui-color-accent-100)' : 'var(--wui-gray-glass-010)'};
      --local-path: var(--wui-path-network-${this.size});
      --local-width:  var(--wui-width-network-${this.size});
      --local-height:  var(--wui-height-network-${this.size});
      --local-icon-size:  var(--wui-icon-size-network-${this.size});
    `;
            return x$5 `${this.templateVisual()} ${networkImagesBySize[this.size]}`;
        }
        templateVisual() {
            if (this.imageSrc) {
                return x$5 `<wui-image src=${this.imageSrc} alt=${this.name}></wui-image>`;
            }
            return x$5 `<wui-icon size="inherit" color="fg-200" name="networkPlaceholder"></wui-icon>`;
        }
    };
    WuiNetworkImage.styles = [resetStyles, styles$1s];
    __decorate$1R([
        n$j()
    ], WuiNetworkImage.prototype, "size", void 0);
    __decorate$1R([
        n$j()
    ], WuiNetworkImage.prototype, "name", void 0);
    __decorate$1R([
        n$j()
    ], WuiNetworkImage.prototype, "imageSrc", void 0);
    __decorate$1R([
        n$j({ type: Boolean })
    ], WuiNetworkImage.prototype, "selected", void 0);
    WuiNetworkImage = __decorate$1R([
        customElement('wui-network-image')
    ], WuiNetworkImage);

    var styles$1r = i$h `
  button {
    flex-direction: column;
    width: 76px;
    row-gap: var(--wui-spacing-xs);
    padding: var(--wui-spacing-xs) var(--wui-spacing-0);
    background-color: var(--wui-gray-glass-002);
    border-radius: clamp(0px, var(--wui-border-radius-xs), 20px);
  }

  button > wui-text {
    color: var(--wui-color-fg-100);
    max-width: var(--wui-icon-box-size-xl);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    justify-content: center;
  }

  button:disabled > wui-text {
    color: var(--wui-gray-glass-015);
  }

  [data-selected='true'] {
    background-color: var(--wui-accent-glass-020);
  }

  @media (hover: hover) and (pointer: fine) {
    [data-selected='true']:hover:enabled {
      background-color: var(--wui-accent-glass-015);
    }
  }

  [data-selected='true']:active:enabled {
    background-color: var(--wui-accent-glass-010);
  }
`;

    var __decorate$1Q = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let WuiCardSelect = class WuiCardSelect extends s$e {
        constructor() {
            super(...arguments);
            this.name = 'Unknown';
            this.type = 'wallet';
            this.imageSrc = undefined;
            this.disabled = false;
            this.selected = false;
            this.installed = false;
        }
        render() {
            return x$5 `
      <button data-selected=${o$l(this.selected)} ?disabled=${this.disabled} ontouchstart>
        ${this.imageTemplate()}
        <wui-text variant="tiny-500" color=${this.selected ? 'accent-100' : 'inherit'}>
          ${this.name}
        </wui-text>
      </button>
    `;
        }
        imageTemplate() {
            if (this.type === 'network') {
                return x$5 `
        <wui-network-image
          .selected=${this.selected}
          imageSrc=${o$l(this.imageSrc)}
          name=${this.name}
        >
        </wui-network-image>
      `;
            }
            return x$5 `
      <wui-wallet-image
        size="md"
        imageSrc=${o$l(this.imageSrc)}
        name=${this.name}
        .installed=${this.installed}
        badgeSize="sm"
      >
      </wui-wallet-image>
    `;
        }
    };
    WuiCardSelect.styles = [resetStyles, elementStyles, styles$1r];
    __decorate$1Q([
        n$j()
    ], WuiCardSelect.prototype, "name", void 0);
    __decorate$1Q([
        n$j()
    ], WuiCardSelect.prototype, "type", void 0);
    __decorate$1Q([
        n$j()
    ], WuiCardSelect.prototype, "imageSrc", void 0);
    __decorate$1Q([
        n$j({ type: Boolean })
    ], WuiCardSelect.prototype, "disabled", void 0);
    __decorate$1Q([
        n$j({ type: Boolean })
    ], WuiCardSelect.prototype, "selected", void 0);
    __decorate$1Q([
        n$j({ type: Boolean })
    ], WuiCardSelect.prototype, "installed", void 0);
    WuiCardSelect = __decorate$1Q([
        customElement('wui-card-select')
    ], WuiCardSelect);

    var styles$1q = i$h `
  a {
    border: 1px solid var(--wui-gray-glass-010);
    border-radius: var(--wui-border-radius-3xl);
  }

  wui-image {
    border-radius: var(--wui-border-radius-3xl);
    overflow: hidden;
  }

  a.disabled > wui-icon,
  a.disabled > wui-image {
    filter: grayscale(1);
  }

  a[data-variant='fill'] {
    color: var(--wui-color-inverse-100);
    background-color: var(--wui-color-accent-100);
  }

  a[data-variant='shade'],
  a[data-variant='shadeSmall'] {
    background-color: transparent;
    background-color: var(--wui-gray-glass-010);
    color: var(--wui-color-fg-200);
  }

  a[data-variant='success'] {
    column-gap: var(--wui-spacing-xxs);
    border: 1px solid var(--wui-success-glass-010);
    background-color: var(--wui-success-glass-010);
    color: var(--wui-color-success-100);
  }

  a[data-variant='error'] {
    column-gap: var(--wui-spacing-xxs);
    border: 1px solid var(--wui-error-glass-010);
    background-color: var(--wui-error-glass-010);
    color: var(--wui-color-error-100);
  }

  a[data-variant='transparent'] {
    column-gap: var(--wui-spacing-xxs);
    background-color: transparent;
    color: var(--wui-color-fg-150);
  }

  a[data-variant='transparent'],
  a[data-variant='success'],
  a[data-variant='shadeSmall'],
  a[data-variant='error'] {
    padding: 7px var(--wui-spacing-s) 7px 10px;
  }

  a[data-variant='transparent']:has(wui-text:first-child),
  a[data-variant='success']:has(wui-text:first-child),
  a[data-variant='shadeSmall']:has(wui-text:first-child),
  a[data-variant='error']:has(wui-text:first-child) {
    padding: 7px var(--wui-spacing-s);
  }

  a[data-variant='fill'],
  a[data-variant='shade'] {
    column-gap: var(--wui-spacing-xs);
    padding: var(--wui-spacing-xxs) var(--wui-spacing-m) var(--wui-spacing-xxs)
      var(--wui-spacing-xs);
  }

  a[data-variant='fill']:has(wui-text:first-child),
  a[data-variant='shade']:has(wui-text:first-child) {
    padding: 9px var(--wui-spacing-m) 9px var(--wui-spacing-m);
  }

  a[data-variant='fill'] > wui-image,
  a[data-variant='shade'] > wui-image {
    width: 24px;
    height: 24px;
  }

  a[data-variant='fill'] > wui-image {
    box-shadow: inset 0 0 0 1px var(--wui-color-accent-090);
  }

  a[data-variant='shade'] > wui-image,
  a[data-variant='shadeSmall'] > wui-image {
    box-shadow: inset 0 0 0 1px var(--wui-gray-glass-010);
  }

  a[data-variant='fill'] > wui-icon,
  a[data-variant='shade'] > wui-icon {
    width: 14px;
    height: 14px;
  }

  a[data-variant='transparent'] > wui-image,
  a[data-variant='success'] > wui-image,
  a[data-variant='shadeSmall'] > wui-image,
  a[data-variant='error'] > wui-image {
    width: 14px;
    height: 14px;
  }

  a[data-variant='transparent'] > wui-icon,
  a[data-variant='success'] > wui-icon,
  a[data-variant='shadeSmall'] > wui-icon,
  a[data-variant='error'] > wui-icon {
    width: 12px;
    height: 12px;
  }

  a[data-variant='fill']:focus-visible {
    background-color: var(--wui-color-accent-090);
  }

  a[data-variant='shade']:focus-visible,
  a[data-variant='shadeSmall']:focus-visible {
    background-color: var(--wui-gray-glass-015);
  }

  a[data-variant='transparent']:focus-visible {
    background-color: var(--wui-gray-glass-005);
  }

  a[data-variant='success']:focus-visible {
    background-color: var(--wui-success-glass-015);
  }

  a[data-variant='error']:focus-visible {
    background-color: var(--wui-error-glass-015);
  }

  a.disabled {
    color: var(--wui-gray-glass-015);
    background-color: var(--wui-gray-glass-015);
    pointer-events: none;
  }

  @media (hover: hover) and (pointer: fine) {
    a[data-variant='fill']:hover {
      background-color: var(--wui-color-accent-090);
    }

    a[data-variant='shade']:hover,
    a[data-variant='shadeSmall']:hover {
      background-color: var(--wui-gray-glass-015);
    }

    a[data-variant='transparent']:hover {
      background-color: var(--wui-gray-glass-005);
    }

    a[data-variant='success']:hover {
      background-color: var(--wui-success-glass-015);
    }

    a[data-variant='error']:hover {
      background-color: var(--wui-error-glass-015);
    }
  }

  a[data-variant='fill']:active {
    background-color: var(--wui-color-accent-080);
  }

  a[data-variant='shade']:active,
  a[data-variant='shadeSmall']:active {
    background-color: var(--wui-gray-glass-020);
  }

  a[data-variant='transparent']:active {
    background-color: var(--wui-gray-glass-010);
  }

  a[data-variant='success']:active {
    background-color: var(--wui-success-glass-020);
  }

  a[data-variant='error']:active {
    background-color: var(--wui-error-glass-020);
  }
`;

    var __decorate$1P = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let WuiChip = class WuiChip extends s$e {
        constructor() {
            super(...arguments);
            this.variant = 'fill';
            this.imageSrc = undefined;
            this.disabled = false;
            this.icon = 'externalLink';
            this.href = '';
            this.text = undefined;
        }
        render() {
            const isSmall = this.variant === 'success' || this.variant === 'transparent' || this.variant === 'shadeSmall';
            const textVariant = isSmall ? 'small-600' : 'paragraph-600';
            return x$5 `
      <a
        rel="noreferrer"
        target="_blank"
        href=${this.href}
        class=${this.disabled ? 'disabled' : ''}
        data-variant=${this.variant}
      >
        ${this.imageTemplate()}
        <wui-text variant=${textVariant} color="inherit">
          ${this.title ? this.title : UiHelperUtil.getHostName(this.href)}
        </wui-text>
        <wui-icon name=${this.icon} color="inherit" size="inherit"></wui-icon>
      </a>
    `;
        }
        imageTemplate() {
            if (this.imageSrc) {
                return x$5 `<wui-image src=${this.imageSrc}></wui-image>`;
            }
            return null;
        }
    };
    WuiChip.styles = [resetStyles, elementStyles, styles$1q];
    __decorate$1P([
        n$j()
    ], WuiChip.prototype, "variant", void 0);
    __decorate$1P([
        n$j()
    ], WuiChip.prototype, "imageSrc", void 0);
    __decorate$1P([
        n$j({ type: Boolean })
    ], WuiChip.prototype, "disabled", void 0);
    __decorate$1P([
        n$j()
    ], WuiChip.prototype, "icon", void 0);
    __decorate$1P([
        n$j()
    ], WuiChip.prototype, "href", void 0);
    __decorate$1P([
        n$j()
    ], WuiChip.prototype, "text", void 0);
    WuiChip = __decorate$1P([
        customElement('wui-chip')
    ], WuiChip);

    var styles$1p = i$h `
  :host {
    position: relative;
    display: block;
  }

  button {
    background: var(--wui-color-accent-100);
    border: 1px solid var(--wui-gray-glass-010);
    border-radius: var(--wui-border-radius-m);
    gap: var(--wui-spacing-xs);
  }

  button.loading {
    background: var(--wui-gray-glass-010);
    border: 1px solid var(--wui-gray-glass-010);
    pointer-events: none;
  }

  button:disabled {
    background-color: var(--wui-gray-glass-015);
    border: 1px solid var(--wui-gray-glass-010);
  }

  button:disabled > wui-text {
    color: var(--wui-gray-glass-015);
  }

  @media (hover: hover) and (pointer: fine) {
    button:hover:enabled {
      background-color: var(--wui-color-accent-090);
    }

    button:active:enabled {
      background-color: var(--wui-color-accent-080);
    }
  }

  button:focus-visible {
    border: 1px solid var(--wui-gray-glass-010);
    background-color: var(--wui-color-accent-090);
    -webkit-box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
    -moz-box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
    box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
  }

  button[data-size='sm'] {
    padding: 6.75px 10px 7.25px;
  }

  ::slotted(*) {
    transition: opacity 200ms ease-in-out;
    opacity: var(--local-opacity-100);
  }

  button > wui-text {
    transition: opacity 200ms ease-in-out;
    opacity: var(--local-opacity-100);
    color: var(--wui-color-inverse-100);
  }

  button[data-size='md'] {
    padding: 9px var(--wui-spacing-l) 9px var(--wui-spacing-l);
  }

  button[data-size='md'] + wui-text {
    padding-left: var(--wui-spacing-3xs);
  }

  @media (max-width: 500px) {
    button[data-size='md'] {
      height: 32px;
      padding: 5px 12px;
    }

    button[data-size='md'] > wui-text > slot {
      font-size: 14px !important;
    }
  }

  wui-loading-spinner {
    width: 14px;
    height: 14px;
  }

  wui-loading-spinner::slotted(svg) {
    width: 10px !important;
    height: 10px !important;
  }

  button[data-size='sm'] > wui-loading-spinner {
    width: 12px;
    height: 12px;
  }
`;

    var __decorate$1O = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let WuiConnectButton = class WuiConnectButton extends s$e {
        constructor() {
            super(...arguments);
            this.size = 'md';
            this.loading = false;
        }
        render() {
            const textVariant = this.size === 'md' ? 'paragraph-600' : 'small-600';
            return x$5 `
      <button data-size=${this.size} ?disabled=${this.loading} ontouchstart>
        ${this.loadingTemplate()}
        <wui-text variant=${textVariant} color=${this.loading ? 'accent-100' : 'inherit'}>
          <slot></slot>
        </wui-text>
      </button>
    `;
        }
        loadingTemplate() {
            if (!this.loading) {
                return null;
            }
            return x$5 `<wui-loading-spinner size=${this.size} color="accent-100"></wui-loading-spinner>`;
        }
    };
    WuiConnectButton.styles = [resetStyles, elementStyles, styles$1p];
    __decorate$1O([
        n$j()
    ], WuiConnectButton.prototype, "size", void 0);
    __decorate$1O([
        n$j({ type: Boolean })
    ], WuiConnectButton.prototype, "loading", void 0);
    WuiConnectButton = __decorate$1O([
        customElement('wui-connect-button')
    ], WuiConnectButton);

    var styles$1o = i$h `
  wui-flex {
    width: 100%;
    background-color: var(--wui-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
  }
`;

    var __decorate$1N = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let WuiCtaButton = class WuiCtaButton extends s$e {
        constructor() {
            super(...arguments);
            this.disabled = false;
            this.label = '';
            this.buttonLabel = '';
        }
        render() {
            return x$5 `
      <wui-flex
        justifyContent="space-between"
        alignItems="center"
        .padding=${['1xs', '2l', '1xs', '2l']}
      >
        <wui-text variant="paragraph-500" color="fg-200">${this.label}</wui-text>
        <wui-button size="sm" variant="accent">
          ${this.buttonLabel}
          <wui-icon size="xs" color="inherit" slot="iconRight" name="chevronRight"></wui-icon>
        </wui-button>
      </wui-flex>
    `;
        }
    };
    WuiCtaButton.styles = [resetStyles, elementStyles, styles$1o];
    __decorate$1N([
        n$j({ type: Boolean })
    ], WuiCtaButton.prototype, "disabled", void 0);
    __decorate$1N([
        n$j()
    ], WuiCtaButton.prototype, "label", void 0);
    __decorate$1N([
        n$j()
    ], WuiCtaButton.prototype, "buttonLabel", void 0);
    WuiCtaButton = __decorate$1N([
        customElement('wui-cta-button')
    ], WuiCtaButton);

    /**
     * @license
     * Copyright 2020 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */const f$a=o=>void 0===o.strings;

    /**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */const s$d=(i,t)=>{const e=i._$AN;if(void 0===e)return !1;for(const i of e)i._$AO?.(t,!1),s$d(i,t);return !0},o$k=i=>{let t,e;do{if(void 0===(t=i._$AM))break;e=t._$AN,e.delete(i),i=t;}while(0===e?.size)},r$k=i=>{for(let t;t=i._$AM;i=t){let e=t._$AN;if(void 0===e)t._$AN=e=new Set;else if(e.has(i))break;e.add(i),c$d(t);}};function h$c(i){void 0!==this._$AN?(o$k(this),this._$AM=i,r$k(this)):this._$AM=i;}function n$i(i,t=!1,e=0){const r=this._$AH,h=this._$AN;if(void 0!==h&&0!==h.size)if(t)if(Array.isArray(r))for(let i=e;i<r.length;i++)s$d(r[i],!1),o$k(r[i]);else null!=r&&(s$d(r,!1),o$k(r));else s$d(this,i);}const c$d=i=>{i.type==t$d.CHILD&&(i._$AP??=n$i,i._$AQ??=h$c);};let f$9 = class f extends i$e{constructor(){super(...arguments),this._$AN=void 0;}_$AT(i,t,e){super._$AT(i,t,e),r$k(this),this.isConnected=i._$AU;}_$AO(i,t=!0){i!==this.isConnected&&(this.isConnected=i,i?this.reconnected?.():this.disconnected?.()),t&&(s$d(this,i),o$k(this));}setValue(t){if(f$a(this._$Ct))this._$Ct._$AI(t,this);else {const i=[...this._$Ct._$AH];i[this._$Ci]=t,this._$Ct._$AI(i,this,0);}}disconnected(){}reconnected(){}};

    /**
     * @license
     * Copyright 2020 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */const e$g=()=>new h$b;let h$b = class h{};const o$j=new WeakMap,n$h=e$i(class extends f$9{render(i){return T$7}update(i,[s]){const e=s!==this.Y;return e&&void 0!==this.Y&&this.rt(void 0),(e||this.lt!==this.ct)&&(this.Y=s,this.ht=i.options?.host,this.rt(this.ct=i.element)),T$7}rt(t){if("function"==typeof this.Y){const i=this.ht??globalThis;let s=o$j.get(i);void 0===s&&(s=new WeakMap,o$j.set(i,s)),void 0!==s.get(this.Y)&&this.Y.call(this.ht,void 0),s.set(this.Y,t),void 0!==t&&this.Y.call(this.ht,t);}else this.Y.value=t;}get lt(){return "function"==typeof this.Y?o$j.get(this.ht??globalThis)?.get(this.Y):this.Y?.value}disconnected(){this.lt===this.ct&&this.rt(void 0);}reconnected(){this.rt(this.ct);}});

    var styles$1n = i$h `
  :host {
    position: relative;
    width: 100%;
    display: inline-block;
    color: var(--wui-color-fg-275);
  }

  input {
    width: 100%;
    border-radius: var(--wui-border-radius-xs);
    border: 1px solid var(--wui-gray-glass-005);
    background: var(--wui-gray-glass-005);
    font-size: var(--wui-font-size-paragraph);
    font-weight: var(--wui-font-weight-light);
    letter-spacing: var(--wui-letter-spacing-paragraph);
    color: var(--wui-color-fg-100);
    transition: all var(--wui-ease-inout-power-1) var(--wui-duration-lg);
    caret-color: var(--wui-color-accent-100);
  }

  input:disabled {
    cursor: not-allowed;
    border: 1px solid var(--wui-gray-glass-010);
  }

  input:disabled::placeholder,
  input:disabled + wui-icon {
    color: var(--wui-color-fg-300);
  }

  input::placeholder {
    color: var(--wui-color-fg-275);
  }

  input:focus:enabled {
    transition: all var(--wui-ease-out-power-2) var(--wui-duration-sm);
    background-color: var(--wui-gray-glass-010);
    border: 1px solid var(--wui-color-accent-100);
    -webkit-box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
    -moz-box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
    box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
  }

  input:hover:enabled {
    background-color: var(--wui-gray-glass-010);
  }

  wui-icon {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    pointer-events: none;
  }

  .wui-size-sm {
    padding: 9px var(--wui-spacing-m) 10px var(--wui-spacing-s);
  }

  wui-icon + .wui-size-sm {
    padding: 9px var(--wui-spacing-m) 10px 36px;
  }

  wui-icon[data-input='sm'] {
    left: var(--wui-spacing-s);
  }

  .wui-size-md {
    padding: 15px var(--wui-spacing-m) var(--wui-spacing-l) var(--wui-spacing-m);
  }

  wui-icon + .wui-size-md,
  wui-loading-spinner + .wui-size-md {
    padding: 10.5px var(--wui-spacing-3xl) 10.5px 40px;
  }

  wui-icon[data-input='md'] {
    left: var(--wui-spacing-l);
  }

  .wui-size-lg {
    padding: var(--wui-spacing-s) var(--wui-spacing-s) var(--wui-spacing-s) var(--wui-spacing-l);
    letter-spacing: var(--wui-letter-spacing-medium-title);
    font-size: var(--wui-font-size-medium-title);
    font-weight: var(--wui-font-weight-light);
    line-height: 130%;
    color: var(--wui-color-fg-100);
    height: 64px;
  }

  wui-icon + .wui-size-lg,
  wui-loading-spinner + .wui-size-lg {
    padding-left: 50px;
  }

  wui-icon[data-input='lg'] {
    left: var(--wui-spacing-l);
  }

  input:placeholder-shown ~ ::slotted(wui-input-element),
  input:placeholder-shown ~ ::slotted(wui-icon) {
    opacity: 0;
    pointer-events: none;
  }

  input::-webkit-outer-spin-button,
  input::-webkit-inner-spin-button {
    -webkit-appearance: none;
    margin: 0;
  }

  input[type='number'] {
    -moz-appearance: textfield;
  }

  ::slotted(wui-input-element),
  ::slotted(wui-icon) {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    transition: all var(--wui-ease-in-power-2) var(--wui-duration-md);
  }

  ::slotted(wui-input-element) {
    right: var(--wui-spacing-m);
  }

  ::slotted(wui-icon) {
    right: 0px;
  }
`;

    var __decorate$1M = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let WuiInputText = class WuiInputText extends s$e {
        constructor() {
            super(...arguments);
            this.inputElementRef = e$g();
            this.size = 'md';
            this.disabled = false;
            this.placeholder = '';
            this.type = 'text';
        }
        render() {
            const sizeClass = `wui-size-${this.size}`;
            return x$5 ` ${this.templateIcon()}
      <input
        ${n$h(this.inputElementRef)}
        class=${sizeClass}
        type=${this.type}
        enterkeyhint=${o$l(this.enterKeyHint)}
        ?disabled=${this.disabled}
        placeholder=${this.placeholder}
        @input=${this.dispatchInputChangeEvent.bind(this)}
        value=${o$l(this.value)}
        .value=${this.value || ''}
      />
      <slot></slot>`;
        }
        templateIcon() {
            if (this.icon) {
                return x$5 `<wui-icon
        data-input=${this.size}
        size=${this.size}
        color="inherit"
        name=${this.icon}
      ></wui-icon>`;
            }
            return null;
        }
        dispatchInputChangeEvent() {
            this.dispatchEvent(new CustomEvent('inputChange', {
                detail: this.inputElementRef.value?.value,
                bubbles: true,
                composed: true
            }));
        }
    };
    WuiInputText.styles = [resetStyles, elementStyles, styles$1n];
    __decorate$1M([
        n$j()
    ], WuiInputText.prototype, "size", void 0);
    __decorate$1M([
        n$j()
    ], WuiInputText.prototype, "icon", void 0);
    __decorate$1M([
        n$j({ type: Boolean })
    ], WuiInputText.prototype, "disabled", void 0);
    __decorate$1M([
        n$j()
    ], WuiInputText.prototype, "placeholder", void 0);
    __decorate$1M([
        n$j()
    ], WuiInputText.prototype, "type", void 0);
    __decorate$1M([
        n$j()
    ], WuiInputText.prototype, "keyHint", void 0);
    __decorate$1M([
        n$j()
    ], WuiInputText.prototype, "value", void 0);
    WuiInputText = __decorate$1M([
        customElement('wui-input-text')
    ], WuiInputText);

    var styles$1m = i$h `
  :host {
    position: relative;
    display: inline-block;
  }

  wui-text {
    margin: var(--wui-spacing-xxs) var(--wui-spacing-m) var(--wui-spacing-0) var(--wui-spacing-m);
  }
`;

    var __decorate$1L = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let WuiEmailInput = class WuiEmailInput extends s$e {
        constructor() {
            super(...arguments);
            this.disabled = false;
        }
        render() {
            return x$5 `
      <wui-input-text
        placeholder="Email"
        icon="mail"
        size="md"
        .disabled=${this.disabled}
        .value=${this.value}
        data-testid="wui-email-input"
      ></wui-input-text>
      ${this.templateError()}
    `;
        }
        templateError() {
            if (this.errorMessage) {
                return x$5 `<wui-text variant="tiny-500" color="error-100">${this.errorMessage}</wui-text>`;
            }
            return null;
        }
    };
    WuiEmailInput.styles = [resetStyles, styles$1m];
    __decorate$1L([
        n$j()
    ], WuiEmailInput.prototype, "errorMessage", void 0);
    __decorate$1L([
        n$j({ type: Boolean })
    ], WuiEmailInput.prototype, "disabled", void 0);
    __decorate$1L([
        n$j()
    ], WuiEmailInput.prototype, "value", void 0);
    WuiEmailInput = __decorate$1L([
        customElement('wui-email-input')
    ], WuiEmailInput);

    var styles$1l = i$h `
  button {
    border-radius: var(--local-border-radius);
    color: var(--wui-color-fg-100);
    padding: var(--local-padding);
  }

  @media (max-width: 700px) {
    button {
      padding: var(--wui-spacing-s);
    }
  }

  button > wui-icon {
    pointer-events: none;
  }

  button:disabled > wui-icon {
    color: var(--wui-color-bg-300) !important;
  }

  button:disabled {
    background-color: transparent;
  }
`;

    var __decorate$1K = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let WuiIconLink = class WuiIconLink extends s$e {
        constructor() {
            super(...arguments);
            this.size = 'md';
            this.disabled = false;
            this.icon = 'copy';
            this.iconColor = 'inherit';
        }
        render() {
            const borderRadius = this.size === 'lg' ? '--wui-border-radius-xs' : '--wui-border-radius-xxs';
            const padding = this.size === 'lg' ? '--wui-spacing-1xs' : '--wui-spacing-2xs';
            this.style.cssText = `
    --local-border-radius: var(${borderRadius});
    --local-padding: var(${padding});
`;
            return x$5 `
      <button ?disabled=${this.disabled} ontouchstart>
        <wui-icon color=${this.iconColor} size=${this.size} name=${this.icon}></wui-icon>
      </button>
    `;
        }
    };
    WuiIconLink.styles = [resetStyles, elementStyles, colorStyles, styles$1l];
    __decorate$1K([
        n$j()
    ], WuiIconLink.prototype, "size", void 0);
    __decorate$1K([
        n$j({ type: Boolean })
    ], WuiIconLink.prototype, "disabled", void 0);
    __decorate$1K([
        n$j()
    ], WuiIconLink.prototype, "icon", void 0);
    __decorate$1K([
        n$j()
    ], WuiIconLink.prototype, "iconColor", void 0);
    WuiIconLink = __decorate$1K([
        customElement('wui-icon-link')
    ], WuiIconLink);

    var styles$1k = i$h `
  button {
    background-color: var(--wui-color-fg-300);
    border-radius: var(--wui-border-radius-4xs);
    width: 16px;
    height: 16px;
  }

  button:disabled {
    background-color: var(--wui-color-bg-300);
  }

  wui-icon {
    color: var(--wui-color-bg-200) !important;
  }

  button:focus-visible {
    background-color: var(--wui-color-fg-250);
    border: 1px solid var(--wui-color-accent-100);
  }

  button:active:enabled {
    background-color: var(--wui-color-fg-225);
  }

  @media (hover: hover) and (pointer: fine) {
    button:hover:enabled {
      background-color: var(--wui-color-fg-250);
    }
  }
`;

    var __decorate$1J = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let WuiInputElement = class WuiInputElement extends s$e {
        constructor() {
            super(...arguments);
            this.icon = 'copy';
        }
        render() {
            return x$5 `
      <button>
        <wui-icon color="inherit" size="xxs" name=${this.icon}></wui-icon>
      </button>
    `;
        }
    };
    WuiInputElement.styles = [resetStyles, elementStyles, styles$1k];
    __decorate$1J([
        n$j()
    ], WuiInputElement.prototype, "icon", void 0);
    WuiInputElement = __decorate$1J([
        customElement('wui-input-element')
    ], WuiInputElement);

    var styles$1j = i$h `
  :host {
    position: relative;
    display: inline-block;
  }

  input {
    width: 50px;
    height: 50px;
    background: var(--wui-gray-glass-010);
    border-radius: var(--wui-border-radius-xs);
    border: 1px solid var(--wui-gray-glass-005);
    font-family: var(--wui-font-family);
    font-size: var(--wui-font-size-large);
    font-weight: var(--wui-font-weight-regular);
    letter-spacing: var(--wui-letter-spacing-large);
    text-align: center;
    color: var(--wui-color-fg-100);
    caret-color: var(--wui-color-accent-100);
    transition: all var(--wui-ease-inout-power-1) var(--wui-duration-lg);
    box-sizing: border-box;
    -webkit-appearance: none;
    -moz-appearance: textfield;
    padding: 0px;
  }

  input::-webkit-outer-spin-button,
  input::-webkit-inner-spin-button {
    -webkit-appearance: none;
    margin: 0;
  }

  input[type='number'] {
    -moz-appearance: textfield;
  }

  input:disabled {
    cursor: not-allowed;
    border: 1px solid var(--wui-gray-glass-010);
    background: var(--wui-gray-glass-005);
  }

  input:focus:enabled {
    transition: all var(--wui-ease-out-power-2) var(--wui-duration-sm);
    background-color: var(--wui-gray-glass-015);
    border: 1px solid var(--wui-color-accent-100);
    -webkit-box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
    -moz-box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
    box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
  }
  @media (hover: hover) and (pointer: fine) {
    input:hover:enabled {
      background-color: var(--wui-gray-glass-015);
    }
  }
`;

    var __decorate$1I = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let WuiInputNumeric = class WuiInputNumeric extends s$e {
        constructor() {
            super(...arguments);
            this.disabled = false;
            this.value = '';
        }
        render() {
            return x$5 `<input
      type="number"
      maxlength="1"
      inputmode="numeric"
      autofocus
      ?disabled=${this.disabled}
      value=${this.value}
    /> `;
        }
    };
    WuiInputNumeric.styles = [resetStyles, elementStyles, styles$1j];
    __decorate$1I([
        n$j({ type: Boolean })
    ], WuiInputNumeric.prototype, "disabled", void 0);
    __decorate$1I([
        n$j({ type: String })
    ], WuiInputNumeric.prototype, "value", void 0);
    WuiInputNumeric = __decorate$1I([
        customElement('wui-input-numeric')
    ], WuiInputNumeric);

    var styles$1i = i$h `
  button {
    padding: var(--wui-spacing-4xs) var(--wui-spacing-xxs);
    border-radius: var(--wui-border-radius-3xs);
    background-color: transparent;
    color: var(--wui-color-accent-100);
  }

  button:disabled {
    background-color: transparent;
    color: var(--wui-gray-glass-015);
  }
`;

    var __decorate$1H = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let WuiLink = class WuiLink extends s$e {
        constructor() {
            super(...arguments);
            this.disabled = false;
            this.color = 'inherit';
        }
        render() {
            return x$5 `
      <button ?disabled=${this.disabled} ontouchstart>
        <slot name="iconLeft"></slot>
        <wui-text variant="small-600" color=${this.color}>
          <slot></slot>
        </wui-text>
        <slot name="iconRight"></slot>
      </button>
    `;
        }
    };
    WuiLink.styles = [resetStyles, elementStyles, styles$1i];
    __decorate$1H([
        n$j({ type: Boolean })
    ], WuiLink.prototype, "disabled", void 0);
    __decorate$1H([
        n$j()
    ], WuiLink.prototype, "color", void 0);
    WuiLink = __decorate$1H([
        customElement('wui-link')
    ], WuiLink);

    var styles$1h = i$h `
  button {
    column-gap: var(--wui-spacing-s);
    padding: 11px 18px 11px var(--wui-spacing-s);
    width: 100%;
    background-color: var(--wui-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
    color: var(--wui-color-fg-250);
  }

  button[data-iconvariant='square'],
  button[data-iconvariant='square-blue'] {
    padding: 6px 18px 6px 9px;
  }

  button > wui-flex {
    flex: 1;
  }

  button > wui-image {
    width: 32px;
    height: 32px;
    box-shadow: 0 0 0 2px var(--wui-gray-glass-005);
    border-radius: var(--wui-border-radius-3xl);
  }

  button > wui-icon {
    width: 36px;
    height: 36px;
  }

  button > wui-icon-box[data-variant='blue'] {
    box-shadow: 0 0 0 2px var(--wui-accent-glass-005);
  }

  button > wui-icon-box[data-variant='overlay'] {
    box-shadow: 0 0 0 2px var(--wui-gray-glass-005);
  }

  button > wui-icon-box[data-variant='square-blue'] {
    border-radius: var(--wui-border-radius-3xs);
    position: relative;
    border: none;
    width: 36px;
    height: 36px;
  }

  button > wui-icon-box[data-variant='square-blue']::after {
    content: '';
    position: absolute;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    border-radius: inherit;
    border: 1px solid var(--wui-accent-glass-010);
    pointer-events: none;
  }

  button > wui-icon:last-child {
    width: 14px;
    height: 14px;
  }

  button:disabled {
    background-color: var(--wui-gray-glass-015);
    color: var(--wui-gray-glass-015);
  }

  button[data-loading='true'] > wui-icon {
    transition: opacity 200ms ease-in-out;
    opacity: 0;
  }

  wui-loading-spinner {
    position: absolute;
    right: 18px;
    top: 50%;
    transform: translateY(-50%);
  }
`;

    var __decorate$1G = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let WuiListItem = class WuiListItem extends s$e {
        constructor() {
            super(...arguments);
            this.variant = 'icon';
            this.disabled = false;
            this.imageSrc = undefined;
            this.alt = undefined;
            this.chevron = false;
            this.loading = false;
        }
        render() {
            return x$5 `
      <button
        ?disabled=${this.loading ? true : Boolean(this.disabled)}
        data-loading=${this.loading}
        data-iconvariant=${o$l(this.iconVariant)}
        ontouchstart
      >
        ${this.loadingTemplate()} ${this.visualTemplate()}
        <wui-flex gap="3xs">
          <slot></slot>
        </wui-flex>
        ${this.chevronTemplate()}
      </button>
    `;
        }
        visualTemplate() {
            if (this.variant === 'image' && this.imageSrc) {
                return x$5 `<wui-image src=${this.imageSrc} alt=${this.alt ?? 'list item'}></wui-image>`;
            }
            if (this.iconVariant === 'square' && this.icon && this.variant === 'icon') {
                return x$5 `<wui-icon name=${this.icon}></wui-icon>`;
            }
            if (this.variant === 'icon' && this.icon && this.iconVariant) {
                const color = ['blue', 'square-blue'].includes(this.iconVariant) ? 'accent-100' : 'fg-200';
                const size = this.iconVariant === 'square-blue' ? 'mdl' : 'md';
                const iconSize = this.iconSize ? this.iconSize : size;
                return x$5 `
        <wui-icon-box
          data-variant=${this.iconVariant}
          icon=${this.icon}
          iconSize=${iconSize}
          background="transparent"
          iconColor=${color}
          backgroundColor=${color}
          size=${size}
        ></wui-icon-box>
      `;
            }
            return null;
        }
        loadingTemplate() {
            if (this.loading) {
                return x$5 `<wui-loading-spinner color="fg-300"></wui-loading-spinner>`;
            }
            return x$5 ``;
        }
        chevronTemplate() {
            if (this.chevron) {
                return x$5 `<wui-icon size="inherit" color="fg-200" name="chevronRight"></wui-icon>`;
            }
            return null;
        }
    };
    WuiListItem.styles = [resetStyles, elementStyles, styles$1h];
    __decorate$1G([
        n$j()
    ], WuiListItem.prototype, "icon", void 0);
    __decorate$1G([
        n$j()
    ], WuiListItem.prototype, "iconSize", void 0);
    __decorate$1G([
        n$j()
    ], WuiListItem.prototype, "variant", void 0);
    __decorate$1G([
        n$j()
    ], WuiListItem.prototype, "iconVariant", void 0);
    __decorate$1G([
        n$j({ type: Boolean })
    ], WuiListItem.prototype, "disabled", void 0);
    __decorate$1G([
        n$j()
    ], WuiListItem.prototype, "imageSrc", void 0);
    __decorate$1G([
        n$j()
    ], WuiListItem.prototype, "alt", void 0);
    __decorate$1G([
        n$j({ type: Boolean })
    ], WuiListItem.prototype, "chevron", void 0);
    __decorate$1G([
        n$j({ type: Boolean })
    ], WuiListItem.prototype, "loading", void 0);
    WuiListItem = __decorate$1G([
        customElement('wui-list-item')
    ], WuiListItem);

    var TransactionTypePastTense;
    (function (TransactionTypePastTense) {
        TransactionTypePastTense["approve"] = "approved";
        TransactionTypePastTense["bought"] = "bought";
        TransactionTypePastTense["borrow"] = "borrowed";
        TransactionTypePastTense["burn"] = "burnt";
        TransactionTypePastTense["cancel"] = "canceled";
        TransactionTypePastTense["claim"] = "claimed";
        TransactionTypePastTense["deploy"] = "deployed";
        TransactionTypePastTense["deposit"] = "deposited";
        TransactionTypePastTense["execute"] = "executed";
        TransactionTypePastTense["mint"] = "minted";
        TransactionTypePastTense["receive"] = "received";
        TransactionTypePastTense["repay"] = "repaid";
        TransactionTypePastTense["send"] = "sent";
        TransactionTypePastTense["sell"] = "sold";
        TransactionTypePastTense["stake"] = "staked";
        TransactionTypePastTense["trade"] = "swapped";
        TransactionTypePastTense["unstake"] = "unstaked";
        TransactionTypePastTense["withdraw"] = "withdrawn";
    })(TransactionTypePastTense || (TransactionTypePastTense = {}));

    var styles$1g = i$h `
  :host > wui-flex {
    display: flex;
    justify-content: center;
    align-items: center;
    position: relative;
    width: 40px;
    height: 40px;
    box-shadow: inset 0 0 0 1px var(--wui-gray-glass-005);
    background-color: var(--wui-gray-glass-005);
  }

  :host > wui-flex wui-image {
    display: block;
  }

  :host > wui-flex,
  :host > wui-flex wui-image,
  .swap-images-container,
  .swap-images-container.nft,
  wui-image.nft {
    border-top-left-radius: var(--local-left-border-radius);
    border-top-right-radius: var(--local-right-border-radius);
    border-bottom-left-radius: var(--local-left-border-radius);
    border-bottom-right-radius: var(--local-right-border-radius);
  }

  wui-icon {
    width: 20px;
    height: 20px;
  }

  wui-icon-box {
    position: absolute;
    right: 0;
    bottom: 0;
    transform: translate(20%, 20%);
  }

  .swap-images-container {
    position: relative;
    width: 40px;
    height: 40px;
    overflow: hidden;
  }

  .swap-images-container wui-image:first-child {
    position: absolute;
    width: 40px;
    height: 40px;
    top: 0;
    left: 0%;
    clip-path: inset(0px calc(50% + 2px) 0px 0%);
  }

  .swap-images-container wui-image:last-child {
    clip-path: inset(0px 0px 0px calc(50% + 2px));
  }
`;

    var __decorate$1F = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let WuiTransactionVisual = class WuiTransactionVisual extends s$e {
        constructor() {
            super(...arguments);
            this.images = [];
            this.secondImage = {
                type: undefined,
                url: ''
            };
        }
        render() {
            const [firstImage, secondImage] = this.images;
            const isLeftNFT = firstImage?.type === 'NFT';
            const isRightNFT = secondImage?.url ? secondImage.type === 'NFT' : isLeftNFT;
            const leftRadius = isLeftNFT ? 'var(--wui-border-radius-xxs)' : 'var(--wui-border-radius-s)';
            const rightRadius = isRightNFT ? 'var(--wui-border-radius-xxs)' : 'var(--wui-border-radius-s)';
            this.style.cssText = `
    --local-left-border-radius: ${leftRadius};
    --local-right-border-radius: ${rightRadius};
    `;
            return x$5 `<wui-flex> ${this.templateVisual()} ${this.templateIcon()} </wui-flex>`;
        }
        templateVisual() {
            const [firstImage, secondImage] = this.images;
            const firstImageType = firstImage?.type;
            const haveTwoImages = this.images.length === 2;
            if (haveTwoImages && (firstImage?.url || secondImage?.url)) {
                return x$5 `<div class="swap-images-container">
        ${firstImage?.url
                ? x$5 `<wui-image src=${firstImage.url} alt="Transaction image"></wui-image>`
                : null}
        ${secondImage?.url
                ? x$5 `<wui-image src=${secondImage.url} alt="Transaction image"></wui-image>`
                : null}
      </div>`;
            }
            else if (firstImage?.url) {
                return x$5 `<wui-image src=${firstImage.url} alt="Transaction image"></wui-image>`;
            }
            else if (firstImageType === 'NFT') {
                return x$5 `<wui-icon size="inherit" color="fg-200" name="nftPlaceholder"></wui-icon>`;
            }
            return x$5 `<wui-icon size="inherit" color="fg-200" name="coinPlaceholder"></wui-icon>`;
        }
        templateIcon() {
            let color = 'accent-100';
            let icon = undefined;
            icon = this.getIcon();
            if (this.status) {
                color = this.getStatusColor();
            }
            if (!icon) {
                return null;
            }
            return x$5 `
      <wui-icon-box
        size="xxs"
        iconColor=${color}
        backgroundColor=${color}
        background="opaque"
        icon=${icon}
        ?border=${true}
        borderColor="wui-color-bg-125"
      ></wui-icon-box>
    `;
        }
        getDirectionIcon() {
            switch (this.direction) {
                case 'in':
                    return 'arrowBottom';
                case 'out':
                    return 'arrowTop';
                default:
                    return undefined;
            }
        }
        getIcon() {
            if (this.onlyDirectionIcon) {
                return this.getDirectionIcon();
            }
            if (this.type === 'trade') {
                return 'swapHorizontalBold';
            }
            else if (this.type === 'approve') {
                return 'checkmark';
            }
            else if (this.type === 'cancel') {
                return 'close';
            }
            return this.getDirectionIcon();
        }
        getStatusColor() {
            switch (this.status) {
                case 'confirmed':
                    return 'success-100';
                case 'failed':
                    return 'error-100';
                case 'pending':
                    return 'inverse-100';
                default:
                    return 'accent-100';
            }
        }
    };
    WuiTransactionVisual.styles = [styles$1g];
    __decorate$1F([
        n$j()
    ], WuiTransactionVisual.prototype, "type", void 0);
    __decorate$1F([
        n$j()
    ], WuiTransactionVisual.prototype, "status", void 0);
    __decorate$1F([
        n$j()
    ], WuiTransactionVisual.prototype, "direction", void 0);
    __decorate$1F([
        n$j({ type: Boolean })
    ], WuiTransactionVisual.prototype, "onlyDirectionIcon", void 0);
    __decorate$1F([
        n$j({ type: Array })
    ], WuiTransactionVisual.prototype, "images", void 0);
    __decorate$1F([
        n$j({ type: Object })
    ], WuiTransactionVisual.prototype, "secondImage", void 0);
    WuiTransactionVisual = __decorate$1F([
        customElement('wui-transaction-visual')
    ], WuiTransactionVisual);

    var styles$1f = i$h `
  :host > wui-flex:first-child {
    align-items: center;
    column-gap: var(--wui-spacing-s);
    padding: 6.5px var(--wui-spacing-xs) 6.5px var(--wui-spacing-xs);
    width: 100%;
  }

  :host > wui-flex:first-child wui-text:nth-child(1) {
    text-transform: capitalize;
  }

  wui-transaction-visual {
    width: 40px;
    height: 40px;
  }

  wui-flex {
    flex: 1;
  }

  :host wui-flex wui-flex {
    overflow: hidden;
  }

  :host .description-container wui-text span {
    word-break: break-all;
  }

  :host .description-container wui-text {
    overflow: hidden;
  }

  :host .description-separator-icon {
    margin: 0px 6px;
  }

  :host wui-text > span {
    overflow: hidden;
    display: -webkit-box;
    -webkit-box-orient: vertical;
    -webkit-line-clamp: 1;
  }
`;

    var __decorate$1E = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let WuiTransactionListItem = class WuiTransactionListItem extends s$e {
        constructor() {
            super(...arguments);
            this.type = 'approve';
            this.onlyDirectionIcon = false;
            this.images = [];
            this.price = [];
            this.amount = [];
            this.symbol = [];
        }
        render() {
            return x$5 `
      <wui-flex>
        <wui-transaction-visual
          .status=${this.status}
          direction=${o$l(this.direction)}
          type=${this.type}
          onlyDirectionIcon=${o$l(this.onlyDirectionIcon)}
          .images=${this.images}
        ></wui-transaction-visual>
        <wui-flex flexDirection="column" gap="3xs">
          <wui-text variant="paragraph-600" color="fg-100">
            ${TransactionTypePastTense[this.type] || this.type}
          </wui-text>
          <wui-flex class="description-container">
            ${this.templateDescription()} ${this.templateSecondDescription()}
          </wui-flex>
        </wui-flex>
        <wui-text variant="micro-700" color="fg-300"><span>${this.date}</span></wui-text>
      </wui-flex>
    `;
        }
        templateDescription() {
            const description = this.descriptions?.[0];
            return description
                ? x$5 `
          <wui-text variant="small-500" color="fg-200">
            <span>${description}</span>
          </wui-text>
        `
                : null;
        }
        templateSecondDescription() {
            const description = this.descriptions?.[1];
            return description
                ? x$5 `
          <wui-icon class="description-separator-icon" size="xxs" name="arrowRight"></wui-icon>
          <wui-text variant="small-400" color="fg-200">
            <span>${description}</span>
          </wui-text>
        `
                : null;
        }
    };
    WuiTransactionListItem.styles = [resetStyles, styles$1f];
    __decorate$1E([
        n$j()
    ], WuiTransactionListItem.prototype, "type", void 0);
    __decorate$1E([
        n$j({ type: Array })
    ], WuiTransactionListItem.prototype, "descriptions", void 0);
    __decorate$1E([
        n$j()
    ], WuiTransactionListItem.prototype, "date", void 0);
    __decorate$1E([
        n$j({ type: Boolean })
    ], WuiTransactionListItem.prototype, "onlyDirectionIcon", void 0);
    __decorate$1E([
        n$j()
    ], WuiTransactionListItem.prototype, "status", void 0);
    __decorate$1E([
        n$j()
    ], WuiTransactionListItem.prototype, "direction", void 0);
    __decorate$1E([
        n$j({ type: Array })
    ], WuiTransactionListItem.prototype, "images", void 0);
    __decorate$1E([
        n$j({ type: Array })
    ], WuiTransactionListItem.prototype, "price", void 0);
    __decorate$1E([
        n$j({ type: Array })
    ], WuiTransactionListItem.prototype, "amount", void 0);
    __decorate$1E([
        n$j({ type: Array })
    ], WuiTransactionListItem.prototype, "symbol", void 0);
    WuiTransactionListItem = __decorate$1E([
        customElement('wui-transaction-list-item')
    ], WuiTransactionListItem);

    var styles$1e = i$h `
  :host > wui-flex:first-child {
    column-gap: var(--wui-spacing-s);
    padding: 7px var(--wui-spacing-l) 7px var(--wui-spacing-xs);
    width: 100%;
  }

  wui-flex {
    display: flex;
    flex: 1;
  }
`;

    var __decorate$1D = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let WuiTransactionListItemLoader = class WuiTransactionListItemLoader extends s$e {
        render() {
            return x$5 `
      <wui-flex alignItems="center">
        <wui-shimmer width="40px" height="40px"></wui-shimmer>
        <wui-flex flexDirection="column" gap="2xs">
          <wui-shimmer width="72px" height="16px" borderRadius="4xs"></wui-shimmer>
          <wui-shimmer width="148px" height="14px" borderRadius="4xs"></wui-shimmer>
        </wui-flex>
        <wui-shimmer width="24px" height="12px" borderRadius="5xs"></wui-shimmer>
      </wui-flex>
    `;
        }
    };
    WuiTransactionListItemLoader.styles = [resetStyles, styles$1e];
    WuiTransactionListItemLoader = __decorate$1D([
        customElement('wui-transaction-list-item-loader')
    ], WuiTransactionListItemLoader);

    var styles$1d = i$h `
  :host {
    display: flex;
    justify-content: center;
    align-items: center;
    height: var(--wui-spacing-m);
    padding: 0 var(--wui-spacing-3xs) !important;
    border-radius: var(--wui-border-radius-5xs);
  }

  :host > wui-text {
    transform: translateY(5%);
  }

  :host([data-variant='main']) {
    background-color: var(--wui-accent-glass-015);
    color: var(--wui-color-accent-100);
  }

  :host([data-variant='shade']) {
    background-color: var(--wui-gray-glass-010);
    color: var(--wui-color-fg-200);
  }

  :host([data-variant='success']) {
    background-color: var(--wui-icon-box-bg-success-100);
    color: var(--wui-color-success-100);
  }

  :host([data-variant='error']) {
    background-color: var(--wui-icon-box-bg-error-100);
    color: var(--wui-color-error-100);
  }

  :host([data-size='lg']) {
    padding: 9px 5px !important;
  }

  :host([data-size='lg']) > wui-text {
    transform: translateY(2%);
  }
`;

    var __decorate$1C = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let WuiTag = class WuiTag extends s$e {
        constructor() {
            super(...arguments);
            this.variant = 'main';
            this.size = 'lg';
        }
        render() {
            this.dataset['variant'] = this.variant;
            this.dataset['size'] = this.size;
            const textVariant = this.size === 'md' ? 'mini-700' : 'micro-700';
            return x$5 `
      <wui-text data-variant=${this.variant} variant=${textVariant} color="inherit">
        <slot></slot>
      </wui-text>
    `;
        }
    };
    WuiTag.styles = [resetStyles, styles$1d];
    __decorate$1C([
        n$j()
    ], WuiTag.prototype, "variant", void 0);
    __decorate$1C([
        n$j()
    ], WuiTag.prototype, "size", void 0);
    WuiTag = __decorate$1C([
        customElement('wui-tag')
    ], WuiTag);

    var styles$1c = i$h `
  button {
    column-gap: var(--wui-spacing-s);
    padding: 7px var(--wui-spacing-l) 7px var(--wui-spacing-xs);
    width: 100%;
    background-color: var(--wui-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
    color: var(--wui-color-fg-100);
  }

  button > wui-text:nth-child(2) {
    display: flex;
    flex: 1;
  }

  wui-icon {
    color: var(--wui-color-fg-200) !important;
  }

  button:disabled {
    background-color: var(--wui-gray-glass-015);
    color: var(--wui-gray-glass-015);
  }

  button:disabled > wui-tag {
    background-color: var(--wui-gray-glass-010);
    color: var(--wui-color-fg-300);
  }
`;

    var __decorate$1B = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let WuiListWallet = class WuiListWallet extends s$e {
        constructor() {
            super(...arguments);
            this.walletImages = [];
            this.imageSrc = '';
            this.name = '';
            this.installed = false;
            this.disabled = false;
            this.showAllWallets = false;
        }
        render() {
            return x$5 `
      <button ?disabled=${this.disabled} ontouchstart>
        ${this.templateAllWallets()} ${this.templateWalletImage()}
        <wui-text variant="paragraph-500" color="inherit">${this.name}</wui-text>
        ${this.templateStatus()}
      </button>
    `;
        }
        templateAllWallets() {
            if (this.showAllWallets && this.imageSrc) {
                return x$5 ` <wui-all-wallets-image .imageeSrc=${this.imageSrc}> </wui-all-wallets-image> `;
            }
            else if (this.showAllWallets && this.walletIcon) {
                return x$5 ` <wui-wallet-image .walletIcon=${this.walletIcon} size="sm"> </wui-wallet-image> `;
            }
            return null;
        }
        templateWalletImage() {
            if (!this.showAllWallets && this.imageSrc) {
                return x$5 `<wui-wallet-image
        size="sm"
        imageSrc=${this.imageSrc}
        name=${this.name}
        .installed=${this.installed}
      ></wui-wallet-image>`;
            }
            else if (!this.showAllWallets && !this.imageSrc) {
                return x$5 `<wui-wallet-image size="sm" name=${this.name}></wui-wallet-image>`;
            }
            return null;
        }
        templateStatus() {
            if (this.tagLabel && this.tagVariant) {
                return x$5 `<wui-tag variant=${this.tagVariant}>${this.tagLabel}</wui-tag>`;
            }
            else if (this.icon) {
                return x$5 `<wui-icon color="inherit" size="sm" name=${this.icon}></wui-icon>`;
            }
            return null;
        }
    };
    WuiListWallet.styles = [resetStyles, elementStyles, styles$1c];
    __decorate$1B([
        n$j({ type: Array })
    ], WuiListWallet.prototype, "walletImages", void 0);
    __decorate$1B([
        n$j()
    ], WuiListWallet.prototype, "imageSrc", void 0);
    __decorate$1B([
        n$j()
    ], WuiListWallet.prototype, "name", void 0);
    __decorate$1B([
        n$j()
    ], WuiListWallet.prototype, "tagLabel", void 0);
    __decorate$1B([
        n$j()
    ], WuiListWallet.prototype, "tagVariant", void 0);
    __decorate$1B([
        n$j()
    ], WuiListWallet.prototype, "icon", void 0);
    __decorate$1B([
        n$j()
    ], WuiListWallet.prototype, "walletIcon", void 0);
    __decorate$1B([
        n$j({ type: Boolean })
    ], WuiListWallet.prototype, "installed", void 0);
    __decorate$1B([
        n$j({ type: Boolean })
    ], WuiListWallet.prototype, "disabled", void 0);
    __decorate$1B([
        n$j({ type: Boolean })
    ], WuiListWallet.prototype, "showAllWallets", void 0);
    WuiListWallet = __decorate$1B([
        customElement('wui-list-wallet')
    ], WuiListWallet);

    var styles$1b = i$h `
  :host {
    display: block;
    width: 40px;
    height: 40px;
    border-radius: var(--wui-border-radius-3xl);
    border: 1px solid var(--wui-gray-glass-010);
    overflow: hidden;
  }

  wui-icon {
    width: 100%;
    height: 100%;
  }
`;

    var __decorate$1A = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let WuiLogo = class WuiLogo extends s$e {
        constructor() {
            super(...arguments);
            this.logo = 'google';
        }
        render() {
            return x$5 `<wui-icon color="inherit" size="inherit" name=${this.logo}></wui-icon> `;
        }
    };
    WuiLogo.styles = [resetStyles, styles$1b];
    __decorate$1A([
        n$j()
    ], WuiLogo.prototype, "logo", void 0);
    WuiLogo = __decorate$1A([
        customElement('wui-logo')
    ], WuiLogo);

    var styles$1a = i$h `
  :host {
    display: block;
  }

  button {
    width: 50px;
    height: 50px;
    background: var(--wui-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
  }
`;

    var __decorate$1z = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let WuiLogoSelect = class WuiLogoSelect extends s$e {
        constructor() {
            super(...arguments);
            this.logo = 'google';
            this.disabled = false;
        }
        render() {
            return x$5 `
      <button ?disabled=${this.disabled} ontouchstart>
        <wui-logo logo=${this.logo}></wui-logo>
      </button>
    `;
        }
    };
    WuiLogoSelect.styles = [resetStyles, elementStyles, styles$1a];
    __decorate$1z([
        n$j()
    ], WuiLogoSelect.prototype, "logo", void 0);
    __decorate$1z([
        n$j({ type: Boolean })
    ], WuiLogoSelect.prototype, "disabled", void 0);
    WuiLogoSelect = __decorate$1z([
        customElement('wui-logo-select')
    ], WuiLogoSelect);

    var styles$19 = i$h `
  :host {
    display: block;
  }

  button {
    border-radius: var(--wui-border-radius-3xl);
    display: flex;
    gap: var(--wui-spacing-xs);
    padding: var(--wui-spacing-2xs) var(--wui-spacing-s) var(--wui-spacing-2xs)
      var(--wui-spacing-xs);
    border: 1px solid var(--wui-gray-glass-010);
    background-color: var(--wui-gray-glass-005);
    color: var(--wui-color-fg-100);
  }

  button:disabled {
    border: 1px solid var(--wui-gray-glass-005);
    background-color: var(--wui-gray-glass-015);
    color: var(--wui-gray-glass-015);
  }

  @media (hover: hover) and (pointer: fine) {
    button:hover:enabled {
      background-color: var(--wui-gray-glass-010);
    }

    button:active:enabled {
      background-color: var(--wui-gray-glass-015);
    }
  }

  wui-image,
  wui-icon-box {
    border-radius: var(--wui-border-radius-3xl);
    width: 24px;
    height: 24px;
    box-shadow: 0 0 0 2px var(--wui-gray-glass-005);
  }
`;

    var __decorate$1y = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let WuiNetworkButton = class WuiNetworkButton extends s$e {
        constructor() {
            super(...arguments);
            this.imageSrc = undefined;
            this.isUnsupportedChain = undefined;
            this.disabled = false;
        }
        render() {
            return x$5 `
      <button ?disabled=${this.disabled}>
        ${this.visualTemplate()}
        <wui-text variant="paragraph-600" color="inherit">
          <slot></slot>
        </wui-text>
      </button>
    `;
        }
        visualTemplate() {
            if (this.isUnsupportedChain) {
                return x$5 `
        <wui-icon-box
          size="sm"
          iconColor="error-100"
          backgroundColor="error-100"
          icon="warningCircle"
        ></wui-icon-box>
      `;
            }
            if (this.imageSrc) {
                return x$5 `<wui-image src=${this.imageSrc}></wui-image>`;
            }
            return x$5 `
      <wui-icon-box
        size="sm"
        iconColor="inverse-100"
        backgroundColor="fg-100"
        icon="networkPlaceholder"
      ></wui-icon-box>
    `;
        }
    };
    WuiNetworkButton.styles = [resetStyles, elementStyles, styles$19];
    __decorate$1y([
        n$j()
    ], WuiNetworkButton.prototype, "imageSrc", void 0);
    __decorate$1y([
        n$j({ type: Boolean })
    ], WuiNetworkButton.prototype, "isUnsupportedChain", void 0);
    __decorate$1y([
        n$j({ type: Boolean })
    ], WuiNetworkButton.prototype, "disabled", void 0);
    WuiNetworkButton = __decorate$1y([
        customElement('wui-network-button')
    ], WuiNetworkButton);

    var styles$18 = i$h `
  :host {
    position: relative;
    display: block;
  }
`;

    var __decorate$1x = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let WuiOtp = class WuiOtp extends s$e {
        constructor() {
            super(...arguments);
            this.length = 6;
            this.otp = '';
            this.values = Array.from({ length: this.length }).map(() => '');
            this.numerics = [];
            this.shouldInputBeEnabled = (index) => {
                const previousInputs = this.values.slice(0, index);
                return previousInputs.every(input => input !== '');
            };
            this.handleKeyDown = (e, index) => {
                const inputElement = e.target;
                const input = this.getInputElement(inputElement);
                const keyArr = ['ArrowLeft', 'ArrowRight', 'Shift', 'Delete'];
                if (!input) {
                    return;
                }
                if (keyArr.includes(e.key)) {
                    e.preventDefault();
                }
                const currentCaretPos = input.selectionStart;
                switch (e.key) {
                    case 'ArrowLeft':
                        if (currentCaretPos) {
                            input.setSelectionRange(currentCaretPos + 1, currentCaretPos + 1);
                        }
                        this.focusInputField('prev', index);
                        break;
                    case 'ArrowRight':
                        this.focusInputField('next', index);
                        break;
                    case 'Shift':
                        this.focusInputField('next', index);
                        break;
                    case 'Delete':
                        if (input.value === '') {
                            this.focusInputField('prev', index);
                        }
                        else {
                            this.updateInput(input, index, '');
                        }
                        break;
                    case 'Backspace':
                        if (input.value === '') {
                            this.focusInputField('prev', index);
                        }
                        else {
                            this.updateInput(input, index, '');
                        }
                        break;
                }
            };
            this.focusInputField = (dir, index) => {
                if (dir === 'next') {
                    const nextIndex = index + 1;
                    if (!this.shouldInputBeEnabled(nextIndex)) {
                        return;
                    }
                    const numeric = this.numerics[nextIndex < this.length ? nextIndex : index];
                    const input = numeric ? this.getInputElement(numeric) : undefined;
                    if (input) {
                        input.disabled = false;
                        input.focus();
                    }
                }
                if (dir === 'prev') {
                    const nextIndex = index - 1;
                    const numeric = this.numerics[nextIndex > -1 ? nextIndex : index];
                    const input = numeric ? this.getInputElement(numeric) : undefined;
                    if (input) {
                        input.focus();
                    }
                }
            };
        }
        firstUpdated() {
            if (this.otp) {
                this.values = this.otp.split('');
            }
            const numericElements = this.shadowRoot?.querySelectorAll('wui-input-numeric');
            if (numericElements) {
                this.numerics = Array.from(numericElements);
            }
            this.numerics[0]?.focus();
        }
        render() {
            return x$5 `
      <wui-flex gap="xxs" data-testid="wui-otp-input">
        ${Array.from({ length: this.length }).map((_, index) => x$5 `
            <wui-input-numeric
              @input=${(e) => this.handleInput(e, index)}
              @click=${(e) => this.selectInput(e)}
              @keydown=${(e) => this.handleKeyDown(e, index)}
              .disabled=${!this.shouldInputBeEnabled(index)}
              .value=${this.values[index] || ''}
            >
            </wui-input-numeric>
          `)}
      </wui-flex>
    `;
        }
        updateInput(element, index, value) {
            const numeric = this.numerics[index];
            const input = element || (numeric ? this.getInputElement(numeric) : undefined);
            if (input) {
                input.value = value;
                this.values = this.values.map((val, i) => (i === index ? value : val));
            }
        }
        selectInput(e) {
            const targetElement = e.target;
            if (targetElement) {
                const inputElement = this.getInputElement(targetElement);
                inputElement?.select();
            }
        }
        handleInput(e, index) {
            const inputElement = e.target;
            const input = this.getInputElement(inputElement);
            if (input) {
                const inputValue = input.value;
                if (e.inputType === 'insertFromPaste') {
                    this.handlePaste(input, inputValue, index);
                }
                else {
                    const isValid = UiHelperUtil.isNumber(inputValue);
                    if (isValid && e.data) {
                        this.updateInput(input, index, e.data);
                        this.focusInputField('next', index);
                    }
                    else {
                        this.updateInput(input, index, '');
                    }
                }
            }
            this.dispatchInputChangeEvent();
        }
        handlePaste(input, inputValue, index) {
            const value = inputValue[0];
            const isValid = value && UiHelperUtil.isNumber(value);
            if (isValid) {
                this.updateInput(input, index, value);
                const inputString = inputValue.substring(1);
                if (index + 1 < this.length && inputString.length) {
                    const nextNumeric = this.numerics[index + 1];
                    const nextInput = nextNumeric ? this.getInputElement(nextNumeric) : undefined;
                    if (nextInput) {
                        this.handlePaste(nextInput, inputString, index + 1);
                    }
                }
                else {
                    this.focusInputField('next', index);
                }
            }
            else {
                this.updateInput(input, index, '');
            }
        }
        getInputElement(el) {
            if (el.shadowRoot?.querySelector('input')) {
                return el.shadowRoot.querySelector('input');
            }
            return null;
        }
        dispatchInputChangeEvent() {
            const value = this.values.join('');
            this.dispatchEvent(new CustomEvent('inputChange', {
                detail: value,
                bubbles: true,
                composed: true
            }));
        }
    };
    WuiOtp.styles = [resetStyles, styles$18];
    __decorate$1x([
        n$j({ type: Number })
    ], WuiOtp.prototype, "length", void 0);
    __decorate$1x([
        n$j({ type: String })
    ], WuiOtp.prototype, "otp", void 0);
    __decorate$1x([
        r$l()
    ], WuiOtp.prototype, "values", void 0);
    WuiOtp = __decorate$1x([
        customElement('wui-otp')
    ], WuiOtp);

    var browser$2 = {};

    // can-promise has a crash in some versions of react native that dont have
    // standard global objects
    // https://github.com/soldair/node-qrcode/issues/157

    var canPromise$1 = function () {
      return typeof Promise === 'function' && Promise.prototype && Promise.prototype.then
    };

    var qrcode = {};

    var utils$3 = {};

    let toSJISFunction;
    const CODEWORDS_COUNT = [
      0, // Not used
      26, 44, 70, 100, 134, 172, 196, 242, 292, 346,
      404, 466, 532, 581, 655, 733, 815, 901, 991, 1085,
      1156, 1258, 1364, 1474, 1588, 1706, 1828, 1921, 2051, 2185,
      2323, 2465, 2611, 2761, 2876, 3034, 3196, 3362, 3532, 3706
    ];

    /**
     * Returns the QR Code size for the specified version
     *
     * @param  {Number} version QR Code version
     * @return {Number}         size of QR code
     */
    utils$3.getSymbolSize = function getSymbolSize (version) {
      if (!version) throw new Error('"version" cannot be null or undefined')
      if (version < 1 || version > 40) throw new Error('"version" should be in range from 1 to 40')
      return version * 4 + 17
    };

    /**
     * Returns the total number of codewords used to store data and EC information.
     *
     * @param  {Number} version QR Code version
     * @return {Number}         Data length in bits
     */
    utils$3.getSymbolTotalCodewords = function getSymbolTotalCodewords (version) {
      return CODEWORDS_COUNT[version]
    };

    /**
     * Encode data with Bose-Chaudhuri-Hocquenghem
     *
     * @param  {Number} data Value to encode
     * @return {Number}      Encoded value
     */
    utils$3.getBCHDigit = function (data) {
      let digit = 0;

      while (data !== 0) {
        digit++;
        data >>>= 1;
      }

      return digit
    };

    utils$3.setToSJISFunction = function setToSJISFunction (f) {
      if (typeof f !== 'function') {
        throw new Error('"toSJISFunc" is not a valid function.')
      }

      toSJISFunction = f;
    };

    utils$3.isKanjiModeEnabled = function () {
      return typeof toSJISFunction !== 'undefined'
    };

    utils$3.toSJIS = function toSJIS (kanji) {
      return toSJISFunction(kanji)
    };

    var errorCorrectionLevel = {};

    (function (exports) {
    	exports.L = { bit: 1 };
    	exports.M = { bit: 0 };
    	exports.Q = { bit: 3 };
    	exports.H = { bit: 2 };

    	function fromString (string) {
    	  if (typeof string !== 'string') {
    	    throw new Error('Param is not a string')
    	  }

    	  const lcStr = string.toLowerCase();

    	  switch (lcStr) {
    	    case 'l':
    	    case 'low':
    	      return exports.L

    	    case 'm':
    	    case 'medium':
    	      return exports.M

    	    case 'q':
    	    case 'quartile':
    	      return exports.Q

    	    case 'h':
    	    case 'high':
    	      return exports.H

    	    default:
    	      throw new Error('Unknown EC Level: ' + string)
    	  }
    	}

    	exports.isValid = function isValid (level) {
    	  return level && typeof level.bit !== 'undefined' &&
    	    level.bit >= 0 && level.bit < 4
    	};

    	exports.from = function from (value, defaultValue) {
    	  if (exports.isValid(value)) {
    	    return value
    	  }

    	  try {
    	    return fromString(value)
    	  } catch (e) {
    	    return defaultValue
    	  }
    	}; 
    } (errorCorrectionLevel));

    function BitBuffer$1 () {
      this.buffer = [];
      this.length = 0;
    }

    BitBuffer$1.prototype = {

      get: function (index) {
        const bufIndex = Math.floor(index / 8);
        return ((this.buffer[bufIndex] >>> (7 - index % 8)) & 1) === 1
      },

      put: function (num, length) {
        for (let i = 0; i < length; i++) {
          this.putBit(((num >>> (length - i - 1)) & 1) === 1);
        }
      },

      getLengthInBits: function () {
        return this.length
      },

      putBit: function (bit) {
        const bufIndex = Math.floor(this.length / 8);
        if (this.buffer.length <= bufIndex) {
          this.buffer.push(0);
        }

        if (bit) {
          this.buffer[bufIndex] |= (0x80 >>> (this.length % 8));
        }

        this.length++;
      }
    };

    var bitBuffer = BitBuffer$1;

    /**
     * Helper class to handle QR Code symbol modules
     *
     * @param {Number} size Symbol size
     */

    function BitMatrix$1 (size) {
      if (!size || size < 1) {
        throw new Error('BitMatrix size must be defined and greater than 0')
      }

      this.size = size;
      this.data = new Uint8Array(size * size);
      this.reservedBit = new Uint8Array(size * size);
    }

    /**
     * Set bit value at specified location
     * If reserved flag is set, this bit will be ignored during masking process
     *
     * @param {Number}  row
     * @param {Number}  col
     * @param {Boolean} value
     * @param {Boolean} reserved
     */
    BitMatrix$1.prototype.set = function (row, col, value, reserved) {
      const index = row * this.size + col;
      this.data[index] = value;
      if (reserved) this.reservedBit[index] = true;
    };

    /**
     * Returns bit value at specified location
     *
     * @param  {Number}  row
     * @param  {Number}  col
     * @return {Boolean}
     */
    BitMatrix$1.prototype.get = function (row, col) {
      return this.data[row * this.size + col]
    };

    /**
     * Applies xor operator at specified location
     * (used during masking process)
     *
     * @param {Number}  row
     * @param {Number}  col
     * @param {Boolean} value
     */
    BitMatrix$1.prototype.xor = function (row, col, value) {
      this.data[row * this.size + col] ^= value;
    };

    /**
     * Check if bit at specified location is reserved
     *
     * @param {Number}   row
     * @param {Number}   col
     * @return {Boolean}
     */
    BitMatrix$1.prototype.isReserved = function (row, col) {
      return this.reservedBit[row * this.size + col]
    };

    var bitMatrix = BitMatrix$1;

    var alignmentPattern = {};

    /**
     * Alignment pattern are fixed reference pattern in defined positions
     * in a matrix symbology, which enables the decode software to re-synchronise
     * the coordinate mapping of the image modules in the event of moderate amounts
     * of distortion of the image.
     *
     * Alignment patterns are present only in QR Code symbols of version 2 or larger
     * and their number depends on the symbol version.
     */

    (function (exports) {
    	const getSymbolSize = utils$3.getSymbolSize;

    	/**
    	 * Calculate the row/column coordinates of the center module of each alignment pattern
    	 * for the specified QR Code version.
    	 *
    	 * The alignment patterns are positioned symmetrically on either side of the diagonal
    	 * running from the top left corner of the symbol to the bottom right corner.
    	 *
    	 * Since positions are simmetrical only half of the coordinates are returned.
    	 * Each item of the array will represent in turn the x and y coordinate.
    	 * @see {@link getPositions}
    	 *
    	 * @param  {Number} version QR Code version
    	 * @return {Array}          Array of coordinate
    	 */
    	exports.getRowColCoords = function getRowColCoords (version) {
    	  if (version === 1) return []

    	  const posCount = Math.floor(version / 7) + 2;
    	  const size = getSymbolSize(version);
    	  const intervals = size === 145 ? 26 : Math.ceil((size - 13) / (2 * posCount - 2)) * 2;
    	  const positions = [size - 7]; // Last coord is always (size - 7)

    	  for (let i = 1; i < posCount - 1; i++) {
    	    positions[i] = positions[i - 1] - intervals;
    	  }

    	  positions.push(6); // First coord is always 6

    	  return positions.reverse()
    	};

    	/**
    	 * Returns an array containing the positions of each alignment pattern.
    	 * Each array's element represent the center point of the pattern as (x, y) coordinates
    	 *
    	 * Coordinates are calculated expanding the row/column coordinates returned by {@link getRowColCoords}
    	 * and filtering out the items that overlaps with finder pattern
    	 *
    	 * @example
    	 * For a Version 7 symbol {@link getRowColCoords} returns values 6, 22 and 38.
    	 * The alignment patterns, therefore, are to be centered on (row, column)
    	 * positions (6,22), (22,6), (22,22), (22,38), (38,22), (38,38).
    	 * Note that the coordinates (6,6), (6,38), (38,6) are occupied by finder patterns
    	 * and are not therefore used for alignment patterns.
    	 *
    	 * let pos = getPositions(7)
    	 * // [[6,22], [22,6], [22,22], [22,38], [38,22], [38,38]]
    	 *
    	 * @param  {Number} version QR Code version
    	 * @return {Array}          Array of coordinates
    	 */
    	exports.getPositions = function getPositions (version) {
    	  const coords = [];
    	  const pos = exports.getRowColCoords(version);
    	  const posLength = pos.length;

    	  for (let i = 0; i < posLength; i++) {
    	    for (let j = 0; j < posLength; j++) {
    	      // Skip if position is occupied by finder patterns
    	      if ((i === 0 && j === 0) || // top-left
    	          (i === 0 && j === posLength - 1) || // bottom-left
    	          (i === posLength - 1 && j === 0)) { // top-right
    	        continue
    	      }

    	      coords.push([pos[i], pos[j]]);
    	    }
    	  }

    	  return coords
    	}; 
    } (alignmentPattern));

    var finderPattern = {};

    const getSymbolSize = utils$3.getSymbolSize;
    const FINDER_PATTERN_SIZE = 7;

    /**
     * Returns an array containing the positions of each finder pattern.
     * Each array's element represent the top-left point of the pattern as (x, y) coordinates
     *
     * @param  {Number} version QR Code version
     * @return {Array}          Array of coordinates
     */
    finderPattern.getPositions = function getPositions (version) {
      const size = getSymbolSize(version);

      return [
        // top-left
        [0, 0],
        // top-right
        [size - FINDER_PATTERN_SIZE, 0],
        // bottom-left
        [0, size - FINDER_PATTERN_SIZE]
      ]
    };

    var maskPattern = {};

    /**
     * Data mask pattern reference
     * @type {Object}
     */

    (function (exports) {
    	exports.Patterns = {
    	  PATTERN000: 0,
    	  PATTERN001: 1,
    	  PATTERN010: 2,
    	  PATTERN011: 3,
    	  PATTERN100: 4,
    	  PATTERN101: 5,
    	  PATTERN110: 6,
    	  PATTERN111: 7
    	};

    	/**
    	 * Weighted penalty scores for the undesirable features
    	 * @type {Object}
    	 */
    	const PenaltyScores = {
    	  N1: 3,
    	  N2: 3,
    	  N3: 40,
    	  N4: 10
    	};

    	/**
    	 * Check if mask pattern value is valid
    	 *
    	 * @param  {Number}  mask    Mask pattern
    	 * @return {Boolean}         true if valid, false otherwise
    	 */
    	exports.isValid = function isValid (mask) {
    	  return mask != null && mask !== '' && !isNaN(mask) && mask >= 0 && mask <= 7
    	};

    	/**
    	 * Returns mask pattern from a value.
    	 * If value is not valid, returns undefined
    	 *
    	 * @param  {Number|String} value        Mask pattern value
    	 * @return {Number}                     Valid mask pattern or undefined
    	 */
    	exports.from = function from (value) {
    	  return exports.isValid(value) ? parseInt(value, 10) : undefined
    	};

    	/**
    	* Find adjacent modules in row/column with the same color
    	* and assign a penalty value.
    	*
    	* Points: N1 + i
    	* i is the amount by which the number of adjacent modules of the same color exceeds 5
    	*/
    	exports.getPenaltyN1 = function getPenaltyN1 (data) {
    	  const size = data.size;
    	  let points = 0;
    	  let sameCountCol = 0;
    	  let sameCountRow = 0;
    	  let lastCol = null;
    	  let lastRow = null;

    	  for (let row = 0; row < size; row++) {
    	    sameCountCol = sameCountRow = 0;
    	    lastCol = lastRow = null;

    	    for (let col = 0; col < size; col++) {
    	      let module = data.get(row, col);
    	      if (module === lastCol) {
    	        sameCountCol++;
    	      } else {
    	        if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5);
    	        lastCol = module;
    	        sameCountCol = 1;
    	      }

    	      module = data.get(col, row);
    	      if (module === lastRow) {
    	        sameCountRow++;
    	      } else {
    	        if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5);
    	        lastRow = module;
    	        sameCountRow = 1;
    	      }
    	    }

    	    if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5);
    	    if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5);
    	  }

    	  return points
    	};

    	/**
    	 * Find 2x2 blocks with the same color and assign a penalty value
    	 *
    	 * Points: N2 * (m - 1) * (n - 1)
    	 */
    	exports.getPenaltyN2 = function getPenaltyN2 (data) {
    	  const size = data.size;
    	  let points = 0;

    	  for (let row = 0; row < size - 1; row++) {
    	    for (let col = 0; col < size - 1; col++) {
    	      const last = data.get(row, col) +
    	        data.get(row, col + 1) +
    	        data.get(row + 1, col) +
    	        data.get(row + 1, col + 1);

    	      if (last === 4 || last === 0) points++;
    	    }
    	  }

    	  return points * PenaltyScores.N2
    	};

    	/**
    	 * Find 1:1:3:1:1 ratio (dark:light:dark:light:dark) pattern in row/column,
    	 * preceded or followed by light area 4 modules wide
    	 *
    	 * Points: N3 * number of pattern found
    	 */
    	exports.getPenaltyN3 = function getPenaltyN3 (data) {
    	  const size = data.size;
    	  let points = 0;
    	  let bitsCol = 0;
    	  let bitsRow = 0;

    	  for (let row = 0; row < size; row++) {
    	    bitsCol = bitsRow = 0;
    	    for (let col = 0; col < size; col++) {
    	      bitsCol = ((bitsCol << 1) & 0x7FF) | data.get(row, col);
    	      if (col >= 10 && (bitsCol === 0x5D0 || bitsCol === 0x05D)) points++;

    	      bitsRow = ((bitsRow << 1) & 0x7FF) | data.get(col, row);
    	      if (col >= 10 && (bitsRow === 0x5D0 || bitsRow === 0x05D)) points++;
    	    }
    	  }

    	  return points * PenaltyScores.N3
    	};

    	/**
    	 * Calculate proportion of dark modules in entire symbol
    	 *
    	 * Points: N4 * k
    	 *
    	 * k is the rating of the deviation of the proportion of dark modules
    	 * in the symbol from 50% in steps of 5%
    	 */
    	exports.getPenaltyN4 = function getPenaltyN4 (data) {
    	  let darkCount = 0;
    	  const modulesCount = data.data.length;

    	  for (let i = 0; i < modulesCount; i++) darkCount += data.data[i];

    	  const k = Math.abs(Math.ceil((darkCount * 100 / modulesCount) / 5) - 10);

    	  return k * PenaltyScores.N4
    	};

    	/**
    	 * Return mask value at given position
    	 *
    	 * @param  {Number} maskPattern Pattern reference value
    	 * @param  {Number} i           Row
    	 * @param  {Number} j           Column
    	 * @return {Boolean}            Mask value
    	 */
    	function getMaskAt (maskPattern, i, j) {
    	  switch (maskPattern) {
    	    case exports.Patterns.PATTERN000: return (i + j) % 2 === 0
    	    case exports.Patterns.PATTERN001: return i % 2 === 0
    	    case exports.Patterns.PATTERN010: return j % 3 === 0
    	    case exports.Patterns.PATTERN011: return (i + j) % 3 === 0
    	    case exports.Patterns.PATTERN100: return (Math.floor(i / 2) + Math.floor(j / 3)) % 2 === 0
    	    case exports.Patterns.PATTERN101: return (i * j) % 2 + (i * j) % 3 === 0
    	    case exports.Patterns.PATTERN110: return ((i * j) % 2 + (i * j) % 3) % 2 === 0
    	    case exports.Patterns.PATTERN111: return ((i * j) % 3 + (i + j) % 2) % 2 === 0

    	    default: throw new Error('bad maskPattern:' + maskPattern)
    	  }
    	}

    	/**
    	 * Apply a mask pattern to a BitMatrix
    	 *
    	 * @param  {Number}    pattern Pattern reference number
    	 * @param  {BitMatrix} data    BitMatrix data
    	 */
    	exports.applyMask = function applyMask (pattern, data) {
    	  const size = data.size;

    	  for (let col = 0; col < size; col++) {
    	    for (let row = 0; row < size; row++) {
    	      if (data.isReserved(row, col)) continue
    	      data.xor(row, col, getMaskAt(pattern, row, col));
    	    }
    	  }
    	};

    	/**
    	 * Returns the best mask pattern for data
    	 *
    	 * @param  {BitMatrix} data
    	 * @return {Number} Mask pattern reference number
    	 */
    	exports.getBestMask = function getBestMask (data, setupFormatFunc) {
    	  const numPatterns = Object.keys(exports.Patterns).length;
    	  let bestPattern = 0;
    	  let lowerPenalty = Infinity;

    	  for (let p = 0; p < numPatterns; p++) {
    	    setupFormatFunc(p);
    	    exports.applyMask(p, data);

    	    // Calculate penalty
    	    const penalty =
    	      exports.getPenaltyN1(data) +
    	      exports.getPenaltyN2(data) +
    	      exports.getPenaltyN3(data) +
    	      exports.getPenaltyN4(data);

    	    // Undo previously applied mask
    	    exports.applyMask(p, data);

    	    if (penalty < lowerPenalty) {
    	      lowerPenalty = penalty;
    	      bestPattern = p;
    	    }
    	  }

    	  return bestPattern
    	}; 
    } (maskPattern));

    var errorCorrectionCode = {};

    const ECLevel$1 = errorCorrectionLevel;

    const EC_BLOCKS_TABLE = [
    // L  M  Q  H
      1, 1, 1, 1,
      1, 1, 1, 1,
      1, 1, 2, 2,
      1, 2, 2, 4,
      1, 2, 4, 4,
      2, 4, 4, 4,
      2, 4, 6, 5,
      2, 4, 6, 6,
      2, 5, 8, 8,
      4, 5, 8, 8,
      4, 5, 8, 11,
      4, 8, 10, 11,
      4, 9, 12, 16,
      4, 9, 16, 16,
      6, 10, 12, 18,
      6, 10, 17, 16,
      6, 11, 16, 19,
      6, 13, 18, 21,
      7, 14, 21, 25,
      8, 16, 20, 25,
      8, 17, 23, 25,
      9, 17, 23, 34,
      9, 18, 25, 30,
      10, 20, 27, 32,
      12, 21, 29, 35,
      12, 23, 34, 37,
      12, 25, 34, 40,
      13, 26, 35, 42,
      14, 28, 38, 45,
      15, 29, 40, 48,
      16, 31, 43, 51,
      17, 33, 45, 54,
      18, 35, 48, 57,
      19, 37, 51, 60,
      19, 38, 53, 63,
      20, 40, 56, 66,
      21, 43, 59, 70,
      22, 45, 62, 74,
      24, 47, 65, 77,
      25, 49, 68, 81
    ];

    const EC_CODEWORDS_TABLE = [
    // L  M  Q  H
      7, 10, 13, 17,
      10, 16, 22, 28,
      15, 26, 36, 44,
      20, 36, 52, 64,
      26, 48, 72, 88,
      36, 64, 96, 112,
      40, 72, 108, 130,
      48, 88, 132, 156,
      60, 110, 160, 192,
      72, 130, 192, 224,
      80, 150, 224, 264,
      96, 176, 260, 308,
      104, 198, 288, 352,
      120, 216, 320, 384,
      132, 240, 360, 432,
      144, 280, 408, 480,
      168, 308, 448, 532,
      180, 338, 504, 588,
      196, 364, 546, 650,
      224, 416, 600, 700,
      224, 442, 644, 750,
      252, 476, 690, 816,
      270, 504, 750, 900,
      300, 560, 810, 960,
      312, 588, 870, 1050,
      336, 644, 952, 1110,
      360, 700, 1020, 1200,
      390, 728, 1050, 1260,
      420, 784, 1140, 1350,
      450, 812, 1200, 1440,
      480, 868, 1290, 1530,
      510, 924, 1350, 1620,
      540, 980, 1440, 1710,
      570, 1036, 1530, 1800,
      570, 1064, 1590, 1890,
      600, 1120, 1680, 1980,
      630, 1204, 1770, 2100,
      660, 1260, 1860, 2220,
      720, 1316, 1950, 2310,
      750, 1372, 2040, 2430
    ];

    /**
     * Returns the number of error correction block that the QR Code should contain
     * for the specified version and error correction level.
     *
     * @param  {Number} version              QR Code version
     * @param  {Number} errorCorrectionLevel Error correction level
     * @return {Number}                      Number of error correction blocks
     */
    errorCorrectionCode.getBlocksCount = function getBlocksCount (version, errorCorrectionLevel) {
      switch (errorCorrectionLevel) {
        case ECLevel$1.L:
          return EC_BLOCKS_TABLE[(version - 1) * 4 + 0]
        case ECLevel$1.M:
          return EC_BLOCKS_TABLE[(version - 1) * 4 + 1]
        case ECLevel$1.Q:
          return EC_BLOCKS_TABLE[(version - 1) * 4 + 2]
        case ECLevel$1.H:
          return EC_BLOCKS_TABLE[(version - 1) * 4 + 3]
        default:
          return undefined
      }
    };

    /**
     * Returns the number of error correction codewords to use for the specified
     * version and error correction level.
     *
     * @param  {Number} version              QR Code version
     * @param  {Number} errorCorrectionLevel Error correction level
     * @return {Number}                      Number of error correction codewords
     */
    errorCorrectionCode.getTotalCodewordsCount = function getTotalCodewordsCount (version, errorCorrectionLevel) {
      switch (errorCorrectionLevel) {
        case ECLevel$1.L:
          return EC_CODEWORDS_TABLE[(version - 1) * 4 + 0]
        case ECLevel$1.M:
          return EC_CODEWORDS_TABLE[(version - 1) * 4 + 1]
        case ECLevel$1.Q:
          return EC_CODEWORDS_TABLE[(version - 1) * 4 + 2]
        case ECLevel$1.H:
          return EC_CODEWORDS_TABLE[(version - 1) * 4 + 3]
        default:
          return undefined
      }
    };

    var polynomial = {};

    var galoisField = {};

    const EXP_TABLE = new Uint8Array(512);
    const LOG_TABLE = new Uint8Array(256)
    /**
     * Precompute the log and anti-log tables for faster computation later
     *
     * For each possible value in the galois field 2^8, we will pre-compute
     * the logarithm and anti-logarithm (exponential) of this value
     *
     * ref {@link https://en.wikiversity.org/wiki/Reed%E2%80%93Solomon_codes_for_coders#Introduction_to_mathematical_fields}
     */
    ;(function initTables () {
      let x = 1;
      for (let i = 0; i < 255; i++) {
        EXP_TABLE[i] = x;
        LOG_TABLE[x] = i;

        x <<= 1; // multiply by 2

        // The QR code specification says to use byte-wise modulo 100011101 arithmetic.
        // This means that when a number is 256 or larger, it should be XORed with 0x11D.
        if (x & 0x100) { // similar to x >= 256, but a lot faster (because 0x100 == 256)
          x ^= 0x11D;
        }
      }

      // Optimization: double the size of the anti-log table so that we don't need to mod 255 to
      // stay inside the bounds (because we will mainly use this table for the multiplication of
      // two GF numbers, no more).
      // @see {@link mul}
      for (let i = 255; i < 512; i++) {
        EXP_TABLE[i] = EXP_TABLE[i - 255];
      }
    }());

    /**
     * Returns log value of n inside Galois Field
     *
     * @param  {Number} n
     * @return {Number}
     */
    galoisField.log = function log (n) {
      if (n < 1) throw new Error('log(' + n + ')')
      return LOG_TABLE[n]
    };

    /**
     * Returns anti-log value of n inside Galois Field
     *
     * @param  {Number} n
     * @return {Number}
     */
    galoisField.exp = function exp (n) {
      return EXP_TABLE[n]
    };

    /**
     * Multiplies two number inside Galois Field
     *
     * @param  {Number} x
     * @param  {Number} y
     * @return {Number}
     */
    galoisField.mul = function mul (x, y) {
      if (x === 0 || y === 0) return 0

      // should be EXP_TABLE[(LOG_TABLE[x] + LOG_TABLE[y]) % 255] if EXP_TABLE wasn't oversized
      // @see {@link initTables}
      return EXP_TABLE[LOG_TABLE[x] + LOG_TABLE[y]]
    };

    (function (exports) {
    	const GF = galoisField;

    	/**
    	 * Multiplies two polynomials inside Galois Field
    	 *
    	 * @param  {Uint8Array} p1 Polynomial
    	 * @param  {Uint8Array} p2 Polynomial
    	 * @return {Uint8Array}    Product of p1 and p2
    	 */
    	exports.mul = function mul (p1, p2) {
    	  const coeff = new Uint8Array(p1.length + p2.length - 1);

    	  for (let i = 0; i < p1.length; i++) {
    	    for (let j = 0; j < p2.length; j++) {
    	      coeff[i + j] ^= GF.mul(p1[i], p2[j]);
    	    }
    	  }

    	  return coeff
    	};

    	/**
    	 * Calculate the remainder of polynomials division
    	 *
    	 * @param  {Uint8Array} divident Polynomial
    	 * @param  {Uint8Array} divisor  Polynomial
    	 * @return {Uint8Array}          Remainder
    	 */
    	exports.mod = function mod (divident, divisor) {
    	  let result = new Uint8Array(divident);

    	  while ((result.length - divisor.length) >= 0) {
    	    const coeff = result[0];

    	    for (let i = 0; i < divisor.length; i++) {
    	      result[i] ^= GF.mul(divisor[i], coeff);
    	    }

    	    // remove all zeros from buffer head
    	    let offset = 0;
    	    while (offset < result.length && result[offset] === 0) offset++;
    	    result = result.slice(offset);
    	  }

    	  return result
    	};

    	/**
    	 * Generate an irreducible generator polynomial of specified degree
    	 * (used by Reed-Solomon encoder)
    	 *
    	 * @param  {Number} degree Degree of the generator polynomial
    	 * @return {Uint8Array}    Buffer containing polynomial coefficients
    	 */
    	exports.generateECPolynomial = function generateECPolynomial (degree) {
    	  let poly = new Uint8Array([1]);
    	  for (let i = 0; i < degree; i++) {
    	    poly = exports.mul(poly, new Uint8Array([1, GF.exp(i)]));
    	  }

    	  return poly
    	}; 
    } (polynomial));

    const Polynomial = polynomial;

    function ReedSolomonEncoder$1 (degree) {
      this.genPoly = undefined;
      this.degree = degree;

      if (this.degree) this.initialize(this.degree);
    }

    /**
     * Initialize the encoder.
     * The input param should correspond to the number of error correction codewords.
     *
     * @param  {Number} degree
     */
    ReedSolomonEncoder$1.prototype.initialize = function initialize (degree) {
      // create an irreducible generator polynomial
      this.degree = degree;
      this.genPoly = Polynomial.generateECPolynomial(this.degree);
    };

    /**
     * Encodes a chunk of data
     *
     * @param  {Uint8Array} data Buffer containing input data
     * @return {Uint8Array}      Buffer containing encoded data
     */
    ReedSolomonEncoder$1.prototype.encode = function encode (data) {
      if (!this.genPoly) {
        throw new Error('Encoder not initialized')
      }

      // Calculate EC for this data block
      // extends data size to data+genPoly size
      const paddedData = new Uint8Array(data.length + this.degree);
      paddedData.set(data);

      // The error correction codewords are the remainder after dividing the data codewords
      // by a generator polynomial
      const remainder = Polynomial.mod(paddedData, this.genPoly);

      // return EC data blocks (last n byte, where n is the degree of genPoly)
      // If coefficients number in remainder are less than genPoly degree,
      // pad with 0s to the left to reach the needed number of coefficients
      const start = this.degree - remainder.length;
      if (start > 0) {
        const buff = new Uint8Array(this.degree);
        buff.set(remainder, start);

        return buff
      }

      return remainder
    };

    var reedSolomonEncoder = ReedSolomonEncoder$1;

    var version$1 = {};

    var mode = {};

    var versionCheck = {};

    /**
     * Check if QR Code version is valid
     *
     * @param  {Number}  version QR Code version
     * @return {Boolean}         true if valid version, false otherwise
     */

    versionCheck.isValid = function isValid (version) {
      return !isNaN(version) && version >= 1 && version <= 40
    };

    var regex = {};

    const numeric$1 = '[0-9]+';
    const alphanumeric = '[A-Z $%*+\\-./:]+';
    let kanji = '(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|' +
      '[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|' +
      '[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|' +
      '[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+';
    kanji = kanji.replace(/u/g, '\\u');

    const byte = '(?:(?![A-Z0-9 $%*+\\-./:]|' + kanji + ')(?:.|[\r\n]))+';

    regex.KANJI = new RegExp(kanji, 'g');
    regex.BYTE_KANJI = new RegExp('[^A-Z0-9 $%*+\\-./:]+', 'g');
    regex.BYTE = new RegExp(byte, 'g');
    regex.NUMERIC = new RegExp(numeric$1, 'g');
    regex.ALPHANUMERIC = new RegExp(alphanumeric, 'g');

    const TEST_KANJI = new RegExp('^' + kanji + '$');
    const TEST_NUMERIC = new RegExp('^' + numeric$1 + '$');
    const TEST_ALPHANUMERIC = new RegExp('^[A-Z0-9 $%*+\\-./:]+$');

    regex.testKanji = function testKanji (str) {
      return TEST_KANJI.test(str)
    };

    regex.testNumeric = function testNumeric (str) {
      return TEST_NUMERIC.test(str)
    };

    regex.testAlphanumeric = function testAlphanumeric (str) {
      return TEST_ALPHANUMERIC.test(str)
    };

    (function (exports) {
    	const VersionCheck = versionCheck;
    	const Regex = regex;

    	/**
    	 * Numeric mode encodes data from the decimal digit set (0 - 9)
    	 * (byte values 30HEX to 39HEX).
    	 * Normally, 3 data characters are represented by 10 bits.
    	 *
    	 * @type {Object}
    	 */
    	exports.NUMERIC = {
    	  id: 'Numeric',
    	  bit: 1 << 0,
    	  ccBits: [10, 12, 14]
    	};

    	/**
    	 * Alphanumeric mode encodes data from a set of 45 characters,
    	 * i.e. 10 numeric digits (0 - 9),
    	 *      26 alphabetic characters (A - Z),
    	 *   and 9 symbols (SP, $, %, *, +, -, ., /, :).
    	 * Normally, two input characters are represented by 11 bits.
    	 *
    	 * @type {Object}
    	 */
    	exports.ALPHANUMERIC = {
    	  id: 'Alphanumeric',
    	  bit: 1 << 1,
    	  ccBits: [9, 11, 13]
    	};

    	/**
    	 * In byte mode, data is encoded at 8 bits per character.
    	 *
    	 * @type {Object}
    	 */
    	exports.BYTE = {
    	  id: 'Byte',
    	  bit: 1 << 2,
    	  ccBits: [8, 16, 16]
    	};

    	/**
    	 * The Kanji mode efficiently encodes Kanji characters in accordance with
    	 * the Shift JIS system based on JIS X 0208.
    	 * The Shift JIS values are shifted from the JIS X 0208 values.
    	 * JIS X 0208 gives details of the shift coded representation.
    	 * Each two-byte character value is compacted to a 13-bit binary codeword.
    	 *
    	 * @type {Object}
    	 */
    	exports.KANJI = {
    	  id: 'Kanji',
    	  bit: 1 << 3,
    	  ccBits: [8, 10, 12]
    	};

    	/**
    	 * Mixed mode will contain a sequences of data in a combination of any of
    	 * the modes described above
    	 *
    	 * @type {Object}
    	 */
    	exports.MIXED = {
    	  bit: -1
    	};

    	/**
    	 * Returns the number of bits needed to store the data length
    	 * according to QR Code specifications.
    	 *
    	 * @param  {Mode}   mode    Data mode
    	 * @param  {Number} version QR Code version
    	 * @return {Number}         Number of bits
    	 */
    	exports.getCharCountIndicator = function getCharCountIndicator (mode, version) {
    	  if (!mode.ccBits) throw new Error('Invalid mode: ' + mode)

    	  if (!VersionCheck.isValid(version)) {
    	    throw new Error('Invalid version: ' + version)
    	  }

    	  if (version >= 1 && version < 10) return mode.ccBits[0]
    	  else if (version < 27) return mode.ccBits[1]
    	  return mode.ccBits[2]
    	};

    	/**
    	 * Returns the most efficient mode to store the specified data
    	 *
    	 * @param  {String} dataStr Input data string
    	 * @return {Mode}           Best mode
    	 */
    	exports.getBestModeForData = function getBestModeForData (dataStr) {
    	  if (Regex.testNumeric(dataStr)) return exports.NUMERIC
    	  else if (Regex.testAlphanumeric(dataStr)) return exports.ALPHANUMERIC
    	  else if (Regex.testKanji(dataStr)) return exports.KANJI
    	  else return exports.BYTE
    	};

    	/**
    	 * Return mode name as string
    	 *
    	 * @param {Mode} mode Mode object
    	 * @returns {String}  Mode name
    	 */
    	exports.toString = function toString (mode) {
    	  if (mode && mode.id) return mode.id
    	  throw new Error('Invalid mode')
    	};

    	/**
    	 * Check if input param is a valid mode object
    	 *
    	 * @param   {Mode}    mode Mode object
    	 * @returns {Boolean} True if valid mode, false otherwise
    	 */
    	exports.isValid = function isValid (mode) {
    	  return mode && mode.bit && mode.ccBits
    	};

    	/**
    	 * Get mode object from its name
    	 *
    	 * @param   {String} string Mode name
    	 * @returns {Mode}          Mode object
    	 */
    	function fromString (string) {
    	  if (typeof string !== 'string') {
    	    throw new Error('Param is not a string')
    	  }

    	  const lcStr = string.toLowerCase();

    	  switch (lcStr) {
    	    case 'numeric':
    	      return exports.NUMERIC
    	    case 'alphanumeric':
    	      return exports.ALPHANUMERIC
    	    case 'kanji':
    	      return exports.KANJI
    	    case 'byte':
    	      return exports.BYTE
    	    default:
    	      throw new Error('Unknown mode: ' + string)
    	  }
    	}

    	/**
    	 * Returns mode from a value.
    	 * If value is not a valid mode, returns defaultValue
    	 *
    	 * @param  {Mode|String} value        Encoding mode
    	 * @param  {Mode}        defaultValue Fallback value
    	 * @return {Mode}                     Encoding mode
    	 */
    	exports.from = function from (value, defaultValue) {
    	  if (exports.isValid(value)) {
    	    return value
    	  }

    	  try {
    	    return fromString(value)
    	  } catch (e) {
    	    return defaultValue
    	  }
    	}; 
    } (mode));

    (function (exports) {
    	const Utils = utils$3;
    	const ECCode = errorCorrectionCode;
    	const ECLevel = errorCorrectionLevel;
    	const Mode = mode;
    	const VersionCheck = versionCheck;

    	// Generator polynomial used to encode version information
    	const G18 = (1 << 12) | (1 << 11) | (1 << 10) | (1 << 9) | (1 << 8) | (1 << 5) | (1 << 2) | (1 << 0);
    	const G18_BCH = Utils.getBCHDigit(G18);

    	function getBestVersionForDataLength (mode, length, errorCorrectionLevel) {
    	  for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {
    	    if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, mode)) {
    	      return currentVersion
    	    }
    	  }

    	  return undefined
    	}

    	function getReservedBitsCount (mode, version) {
    	  // Character count indicator + mode indicator bits
    	  return Mode.getCharCountIndicator(mode, version) + 4
    	}

    	function getTotalBitsFromDataArray (segments, version) {
    	  let totalBits = 0;

    	  segments.forEach(function (data) {
    	    const reservedBits = getReservedBitsCount(data.mode, version);
    	    totalBits += reservedBits + data.getBitsLength();
    	  });

    	  return totalBits
    	}

    	function getBestVersionForMixedData (segments, errorCorrectionLevel) {
    	  for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {
    	    const length = getTotalBitsFromDataArray(segments, currentVersion);
    	    if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, Mode.MIXED)) {
    	      return currentVersion
    	    }
    	  }

    	  return undefined
    	}

    	/**
    	 * Returns version number from a value.
    	 * If value is not a valid version, returns defaultValue
    	 *
    	 * @param  {Number|String} value        QR Code version
    	 * @param  {Number}        defaultValue Fallback value
    	 * @return {Number}                     QR Code version number
    	 */
    	exports.from = function from (value, defaultValue) {
    	  if (VersionCheck.isValid(value)) {
    	    return parseInt(value, 10)
    	  }

    	  return defaultValue
    	};

    	/**
    	 * Returns how much data can be stored with the specified QR code version
    	 * and error correction level
    	 *
    	 * @param  {Number} version              QR Code version (1-40)
    	 * @param  {Number} errorCorrectionLevel Error correction level
    	 * @param  {Mode}   mode                 Data mode
    	 * @return {Number}                      Quantity of storable data
    	 */
    	exports.getCapacity = function getCapacity (version, errorCorrectionLevel, mode) {
    	  if (!VersionCheck.isValid(version)) {
    	    throw new Error('Invalid QR Code version')
    	  }

    	  // Use Byte mode as default
    	  if (typeof mode === 'undefined') mode = Mode.BYTE;

    	  // Total codewords for this QR code version (Data + Error correction)
    	  const totalCodewords = Utils.getSymbolTotalCodewords(version);

    	  // Total number of error correction codewords
    	  const ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel);

    	  // Total number of data codewords
    	  const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;

    	  if (mode === Mode.MIXED) return dataTotalCodewordsBits

    	  const usableBits = dataTotalCodewordsBits - getReservedBitsCount(mode, version);

    	  // Return max number of storable codewords
    	  switch (mode) {
    	    case Mode.NUMERIC:
    	      return Math.floor((usableBits / 10) * 3)

    	    case Mode.ALPHANUMERIC:
    	      return Math.floor((usableBits / 11) * 2)

    	    case Mode.KANJI:
    	      return Math.floor(usableBits / 13)

    	    case Mode.BYTE:
    	    default:
    	      return Math.floor(usableBits / 8)
    	  }
    	};

    	/**
    	 * Returns the minimum version needed to contain the amount of data
    	 *
    	 * @param  {Segment} data                    Segment of data
    	 * @param  {Number} [errorCorrectionLevel=H] Error correction level
    	 * @param  {Mode} mode                       Data mode
    	 * @return {Number}                          QR Code version
    	 */
    	exports.getBestVersionForData = function getBestVersionForData (data, errorCorrectionLevel) {
    	  let seg;

    	  const ecl = ECLevel.from(errorCorrectionLevel, ECLevel.M);

    	  if (Array.isArray(data)) {
    	    if (data.length > 1) {
    	      return getBestVersionForMixedData(data, ecl)
    	    }

    	    if (data.length === 0) {
    	      return 1
    	    }

    	    seg = data[0];
    	  } else {
    	    seg = data;
    	  }

    	  return getBestVersionForDataLength(seg.mode, seg.getLength(), ecl)
    	};

    	/**
    	 * Returns version information with relative error correction bits
    	 *
    	 * The version information is included in QR Code symbols of version 7 or larger.
    	 * It consists of an 18-bit sequence containing 6 data bits,
    	 * with 12 error correction bits calculated using the (18, 6) Golay code.
    	 *
    	 * @param  {Number} version QR Code version
    	 * @return {Number}         Encoded version info bits
    	 */
    	exports.getEncodedBits = function getEncodedBits (version) {
    	  if (!VersionCheck.isValid(version) || version < 7) {
    	    throw new Error('Invalid QR Code version')
    	  }

    	  let d = version << 12;

    	  while (Utils.getBCHDigit(d) - G18_BCH >= 0) {
    	    d ^= (G18 << (Utils.getBCHDigit(d) - G18_BCH));
    	  }

    	  return (version << 12) | d
    	}; 
    } (version$1));

    var formatInfo = {};

    const Utils$3 = utils$3;

    const G15 = (1 << 10) | (1 << 8) | (1 << 5) | (1 << 4) | (1 << 2) | (1 << 1) | (1 << 0);
    const G15_MASK = (1 << 14) | (1 << 12) | (1 << 10) | (1 << 4) | (1 << 1);
    const G15_BCH = Utils$3.getBCHDigit(G15);

    /**
     * Returns format information with relative error correction bits
     *
     * The format information is a 15-bit sequence containing 5 data bits,
     * with 10 error correction bits calculated using the (15, 5) BCH code.
     *
     * @param  {Number} errorCorrectionLevel Error correction level
     * @param  {Number} mask                 Mask pattern
     * @return {Number}                      Encoded format information bits
     */
    formatInfo.getEncodedBits = function getEncodedBits (errorCorrectionLevel, mask) {
      const data = ((errorCorrectionLevel.bit << 3) | mask);
      let d = data << 10;

      while (Utils$3.getBCHDigit(d) - G15_BCH >= 0) {
        d ^= (G15 << (Utils$3.getBCHDigit(d) - G15_BCH));
      }

      // xor final data with mask pattern in order to ensure that
      // no combination of Error Correction Level and data mask pattern
      // will result in an all-zero data string
      return ((data << 10) | d) ^ G15_MASK
    };

    var segments = {};

    const Mode$4 = mode;

    function NumericData (data) {
      this.mode = Mode$4.NUMERIC;
      this.data = data.toString();
    }

    NumericData.getBitsLength = function getBitsLength (length) {
      return 10 * Math.floor(length / 3) + ((length % 3) ? ((length % 3) * 3 + 1) : 0)
    };

    NumericData.prototype.getLength = function getLength () {
      return this.data.length
    };

    NumericData.prototype.getBitsLength = function getBitsLength () {
      return NumericData.getBitsLength(this.data.length)
    };

    NumericData.prototype.write = function write (bitBuffer) {
      let i, group, value;

      // The input data string is divided into groups of three digits,
      // and each group is converted to its 10-bit binary equivalent.
      for (i = 0; i + 3 <= this.data.length; i += 3) {
        group = this.data.substr(i, 3);
        value = parseInt(group, 10);

        bitBuffer.put(value, 10);
      }

      // If the number of input digits is not an exact multiple of three,
      // the final one or two digits are converted to 4 or 7 bits respectively.
      const remainingNum = this.data.length - i;
      if (remainingNum > 0) {
        group = this.data.substr(i);
        value = parseInt(group, 10);

        bitBuffer.put(value, remainingNum * 3 + 1);
      }
    };

    var numericData = NumericData;

    const Mode$3 = mode;

    /**
     * Array of characters available in alphanumeric mode
     *
     * As per QR Code specification, to each character
     * is assigned a value from 0 to 44 which in this case coincides
     * with the array index
     *
     * @type {Array}
     */
    const ALPHA_NUM_CHARS = [
      '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
      'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
      'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
      ' ', '$', '%', '*', '+', '-', '.', '/', ':'
    ];

    function AlphanumericData (data) {
      this.mode = Mode$3.ALPHANUMERIC;
      this.data = data;
    }

    AlphanumericData.getBitsLength = function getBitsLength (length) {
      return 11 * Math.floor(length / 2) + 6 * (length % 2)
    };

    AlphanumericData.prototype.getLength = function getLength () {
      return this.data.length
    };

    AlphanumericData.prototype.getBitsLength = function getBitsLength () {
      return AlphanumericData.getBitsLength(this.data.length)
    };

    AlphanumericData.prototype.write = function write (bitBuffer) {
      let i;

      // Input data characters are divided into groups of two characters
      // and encoded as 11-bit binary codes.
      for (i = 0; i + 2 <= this.data.length; i += 2) {
        // The character value of the first character is multiplied by 45
        let value = ALPHA_NUM_CHARS.indexOf(this.data[i]) * 45;

        // The character value of the second digit is added to the product
        value += ALPHA_NUM_CHARS.indexOf(this.data[i + 1]);

        // The sum is then stored as 11-bit binary number
        bitBuffer.put(value, 11);
      }

      // If the number of input data characters is not a multiple of two,
      // the character value of the final character is encoded as a 6-bit binary number.
      if (this.data.length % 2) {
        bitBuffer.put(ALPHA_NUM_CHARS.indexOf(this.data[i]), 6);
      }
    };

    var alphanumericData = AlphanumericData;

    var encodeUtf8$1 = function encodeUtf8 (input) {
      var result = [];
      var size = input.length;

      for (var index = 0; index < size; index++) {
        var point = input.charCodeAt(index);

        if (point >= 0xD800 && point <= 0xDBFF && size > index + 1) {
          var second = input.charCodeAt(index + 1);

          if (second >= 0xDC00 && second <= 0xDFFF) {
            // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
            point = (point - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
            index += 1;
          }
        }

        // US-ASCII
        if (point < 0x80) {
          result.push(point);
          continue
        }

        // 2-byte UTF-8
        if (point < 0x800) {
          result.push((point >> 6) | 192);
          result.push((point & 63) | 128);
          continue
        }

        // 3-byte UTF-8
        if (point < 0xD800 || (point >= 0xE000 && point < 0x10000)) {
          result.push((point >> 12) | 224);
          result.push(((point >> 6) & 63) | 128);
          result.push((point & 63) | 128);
          continue
        }

        // 4-byte UTF-8
        if (point >= 0x10000 && point <= 0x10FFFF) {
          result.push((point >> 18) | 240);
          result.push(((point >> 12) & 63) | 128);
          result.push(((point >> 6) & 63) | 128);
          result.push((point & 63) | 128);
          continue
        }

        // Invalid character
        result.push(0xEF, 0xBF, 0xBD);
      }

      return new Uint8Array(result).buffer
    };

    const encodeUtf8 = encodeUtf8$1;
    const Mode$2 = mode;

    function ByteData (data) {
      this.mode = Mode$2.BYTE;
      if (typeof (data) === 'string') {
        data = encodeUtf8(data);
      }
      this.data = new Uint8Array(data);
    }

    ByteData.getBitsLength = function getBitsLength (length) {
      return length * 8
    };

    ByteData.prototype.getLength = function getLength () {
      return this.data.length
    };

    ByteData.prototype.getBitsLength = function getBitsLength () {
      return ByteData.getBitsLength(this.data.length)
    };

    ByteData.prototype.write = function (bitBuffer) {
      for (let i = 0, l = this.data.length; i < l; i++) {
        bitBuffer.put(this.data[i], 8);
      }
    };

    var byteData = ByteData;

    const Mode$1 = mode;
    const Utils$2 = utils$3;

    function KanjiData (data) {
      this.mode = Mode$1.KANJI;
      this.data = data;
    }

    KanjiData.getBitsLength = function getBitsLength (length) {
      return length * 13
    };

    KanjiData.prototype.getLength = function getLength () {
      return this.data.length
    };

    KanjiData.prototype.getBitsLength = function getBitsLength () {
      return KanjiData.getBitsLength(this.data.length)
    };

    KanjiData.prototype.write = function (bitBuffer) {
      let i;

      // In the Shift JIS system, Kanji characters are represented by a two byte combination.
      // These byte values are shifted from the JIS X 0208 values.
      // JIS X 0208 gives details of the shift coded representation.
      for (i = 0; i < this.data.length; i++) {
        let value = Utils$2.toSJIS(this.data[i]);

        // For characters with Shift JIS values from 0x8140 to 0x9FFC:
        if (value >= 0x8140 && value <= 0x9FFC) {
          // Subtract 0x8140 from Shift JIS value
          value -= 0x8140;

        // For characters with Shift JIS values from 0xE040 to 0xEBBF
        } else if (value >= 0xE040 && value <= 0xEBBF) {
          // Subtract 0xC140 from Shift JIS value
          value -= 0xC140;
        } else {
          throw new Error(
            'Invalid SJIS character: ' + this.data[i] + '\n' +
            'Make sure your charset is UTF-8')
        }

        // Multiply most significant byte of result by 0xC0
        // and add least significant byte to product
        value = (((value >>> 8) & 0xff) * 0xC0) + (value & 0xff);

        // Convert result to a 13-bit binary string
        bitBuffer.put(value, 13);
      }
    };

    var kanjiData = KanjiData;

    var dijkstra = {exports: {}};

    (function (module) {

    	/******************************************************************************
    	 * Created 2008-08-19.
    	 *
    	 * Dijkstra path-finding functions. Adapted from the Dijkstar Python project.
    	 *
    	 * Copyright (C) 2008
    	 *   Wyatt Baldwin <self@wyattbaldwin.com>
    	 *   All rights reserved
    	 *
    	 * Licensed under the MIT license.
    	 *
    	 *   http://www.opensource.org/licenses/mit-license.php
    	 *
    	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
    	 * THE SOFTWARE.
    	 *****************************************************************************/
    	var dijkstra = {
    	  single_source_shortest_paths: function(graph, s, d) {
    	    // Predecessor map for each node that has been encountered.
    	    // node ID => predecessor node ID
    	    var predecessors = {};

    	    // Costs of shortest paths from s to all nodes encountered.
    	    // node ID => cost
    	    var costs = {};
    	    costs[s] = 0;

    	    // Costs of shortest paths from s to all nodes encountered; differs from
    	    // `costs` in that it provides easy access to the node that currently has
    	    // the known shortest path from s.
    	    // XXX: Do we actually need both `costs` and `open`?
    	    var open = dijkstra.PriorityQueue.make();
    	    open.push(s, 0);

    	    var closest,
    	        u, v,
    	        cost_of_s_to_u,
    	        adjacent_nodes,
    	        cost_of_e,
    	        cost_of_s_to_u_plus_cost_of_e,
    	        cost_of_s_to_v,
    	        first_visit;
    	    while (!open.empty()) {
    	      // In the nodes remaining in graph that have a known cost from s,
    	      // find the node, u, that currently has the shortest path from s.
    	      closest = open.pop();
    	      u = closest.value;
    	      cost_of_s_to_u = closest.cost;

    	      // Get nodes adjacent to u...
    	      adjacent_nodes = graph[u] || {};

    	      // ...and explore the edges that connect u to those nodes, updating
    	      // the cost of the shortest paths to any or all of those nodes as
    	      // necessary. v is the node across the current edge from u.
    	      for (v in adjacent_nodes) {
    	        if (adjacent_nodes.hasOwnProperty(v)) {
    	          // Get the cost of the edge running from u to v.
    	          cost_of_e = adjacent_nodes[v];

    	          // Cost of s to u plus the cost of u to v across e--this is *a*
    	          // cost from s to v that may or may not be less than the current
    	          // known cost to v.
    	          cost_of_s_to_u_plus_cost_of_e = cost_of_s_to_u + cost_of_e;

    	          // If we haven't visited v yet OR if the current known cost from s to
    	          // v is greater than the new cost we just found (cost of s to u plus
    	          // cost of u to v across e), update v's cost in the cost list and
    	          // update v's predecessor in the predecessor list (it's now u).
    	          cost_of_s_to_v = costs[v];
    	          first_visit = (typeof costs[v] === 'undefined');
    	          if (first_visit || cost_of_s_to_v > cost_of_s_to_u_plus_cost_of_e) {
    	            costs[v] = cost_of_s_to_u_plus_cost_of_e;
    	            open.push(v, cost_of_s_to_u_plus_cost_of_e);
    	            predecessors[v] = u;
    	          }
    	        }
    	      }
    	    }

    	    if (typeof d !== 'undefined' && typeof costs[d] === 'undefined') {
    	      var msg = ['Could not find a path from ', s, ' to ', d, '.'].join('');
    	      throw new Error(msg);
    	    }

    	    return predecessors;
    	  },

    	  extract_shortest_path_from_predecessor_list: function(predecessors, d) {
    	    var nodes = [];
    	    var u = d;
    	    while (u) {
    	      nodes.push(u);
    	      predecessors[u];
    	      u = predecessors[u];
    	    }
    	    nodes.reverse();
    	    return nodes;
    	  },

    	  find_path: function(graph, s, d) {
    	    var predecessors = dijkstra.single_source_shortest_paths(graph, s, d);
    	    return dijkstra.extract_shortest_path_from_predecessor_list(
    	      predecessors, d);
    	  },

    	  /**
    	   * A very naive priority queue implementation.
    	   */
    	  PriorityQueue: {
    	    make: function (opts) {
    	      var T = dijkstra.PriorityQueue,
    	          t = {},
    	          key;
    	      opts = opts || {};
    	      for (key in T) {
    	        if (T.hasOwnProperty(key)) {
    	          t[key] = T[key];
    	        }
    	      }
    	      t.queue = [];
    	      t.sorter = opts.sorter || T.default_sorter;
    	      return t;
    	    },

    	    default_sorter: function (a, b) {
    	      return a.cost - b.cost;
    	    },

    	    /**
    	     * Add a new item to the queue and ensure the highest priority element
    	     * is at the front of the queue.
    	     */
    	    push: function (value, cost) {
    	      var item = {value: value, cost: cost};
    	      this.queue.push(item);
    	      this.queue.sort(this.sorter);
    	    },

    	    /**
    	     * Return the highest priority element in the queue.
    	     */
    	    pop: function () {
    	      return this.queue.shift();
    	    },

    	    empty: function () {
    	      return this.queue.length === 0;
    	    }
    	  }
    	};


    	// node.js module exports
    	{
    	  module.exports = dijkstra;
    	} 
    } (dijkstra));

    var dijkstraExports = dijkstra.exports;

    (function (exports) {
    	const Mode = mode;
    	const NumericData = numericData;
    	const AlphanumericData = alphanumericData;
    	const ByteData = byteData;
    	const KanjiData = kanjiData;
    	const Regex = regex;
    	const Utils = utils$3;
    	const dijkstra = dijkstraExports;

    	/**
    	 * Returns UTF8 byte length
    	 *
    	 * @param  {String} str Input string
    	 * @return {Number}     Number of byte
    	 */
    	function getStringByteLength (str) {
    	  return unescape(encodeURIComponent(str)).length
    	}

    	/**
    	 * Get a list of segments of the specified mode
    	 * from a string
    	 *
    	 * @param  {Mode}   mode Segment mode
    	 * @param  {String} str  String to process
    	 * @return {Array}       Array of object with segments data
    	 */
    	function getSegments (regex, mode, str) {
    	  const segments = [];
    	  let result;

    	  while ((result = regex.exec(str)) !== null) {
    	    segments.push({
    	      data: result[0],
    	      index: result.index,
    	      mode: mode,
    	      length: result[0].length
    	    });
    	  }

    	  return segments
    	}

    	/**
    	 * Extracts a series of segments with the appropriate
    	 * modes from a string
    	 *
    	 * @param  {String} dataStr Input string
    	 * @return {Array}          Array of object with segments data
    	 */
    	function getSegmentsFromString (dataStr) {
    	  const numSegs = getSegments(Regex.NUMERIC, Mode.NUMERIC, dataStr);
    	  const alphaNumSegs = getSegments(Regex.ALPHANUMERIC, Mode.ALPHANUMERIC, dataStr);
    	  let byteSegs;
    	  let kanjiSegs;

    	  if (Utils.isKanjiModeEnabled()) {
    	    byteSegs = getSegments(Regex.BYTE, Mode.BYTE, dataStr);
    	    kanjiSegs = getSegments(Regex.KANJI, Mode.KANJI, dataStr);
    	  } else {
    	    byteSegs = getSegments(Regex.BYTE_KANJI, Mode.BYTE, dataStr);
    	    kanjiSegs = [];
    	  }

    	  const segs = numSegs.concat(alphaNumSegs, byteSegs, kanjiSegs);

    	  return segs
    	    .sort(function (s1, s2) {
    	      return s1.index - s2.index
    	    })
    	    .map(function (obj) {
    	      return {
    	        data: obj.data,
    	        mode: obj.mode,
    	        length: obj.length
    	      }
    	    })
    	}

    	/**
    	 * Returns how many bits are needed to encode a string of
    	 * specified length with the specified mode
    	 *
    	 * @param  {Number} length String length
    	 * @param  {Mode} mode     Segment mode
    	 * @return {Number}        Bit length
    	 */
    	function getSegmentBitsLength (length, mode) {
    	  switch (mode) {
    	    case Mode.NUMERIC:
    	      return NumericData.getBitsLength(length)
    	    case Mode.ALPHANUMERIC:
    	      return AlphanumericData.getBitsLength(length)
    	    case Mode.KANJI:
    	      return KanjiData.getBitsLength(length)
    	    case Mode.BYTE:
    	      return ByteData.getBitsLength(length)
    	  }
    	}

    	/**
    	 * Merges adjacent segments which have the same mode
    	 *
    	 * @param  {Array} segs Array of object with segments data
    	 * @return {Array}      Array of object with segments data
    	 */
    	function mergeSegments (segs) {
    	  return segs.reduce(function (acc, curr) {
    	    const prevSeg = acc.length - 1 >= 0 ? acc[acc.length - 1] : null;
    	    if (prevSeg && prevSeg.mode === curr.mode) {
    	      acc[acc.length - 1].data += curr.data;
    	      return acc
    	    }

    	    acc.push(curr);
    	    return acc
    	  }, [])
    	}

    	/**
    	 * Generates a list of all possible nodes combination which
    	 * will be used to build a segments graph.
    	 *
    	 * Nodes are divided by groups. Each group will contain a list of all the modes
    	 * in which is possible to encode the given text.
    	 *
    	 * For example the text '12345' can be encoded as Numeric, Alphanumeric or Byte.
    	 * The group for '12345' will contain then 3 objects, one for each
    	 * possible encoding mode.
    	 *
    	 * Each node represents a possible segment.
    	 *
    	 * @param  {Array} segs Array of object with segments data
    	 * @return {Array}      Array of object with segments data
    	 */
    	function buildNodes (segs) {
    	  const nodes = [];
    	  for (let i = 0; i < segs.length; i++) {
    	    const seg = segs[i];

    	    switch (seg.mode) {
    	      case Mode.NUMERIC:
    	        nodes.push([seg,
    	          { data: seg.data, mode: Mode.ALPHANUMERIC, length: seg.length },
    	          { data: seg.data, mode: Mode.BYTE, length: seg.length }
    	        ]);
    	        break
    	      case Mode.ALPHANUMERIC:
    	        nodes.push([seg,
    	          { data: seg.data, mode: Mode.BYTE, length: seg.length }
    	        ]);
    	        break
    	      case Mode.KANJI:
    	        nodes.push([seg,
    	          { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }
    	        ]);
    	        break
    	      case Mode.BYTE:
    	        nodes.push([
    	          { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }
    	        ]);
    	    }
    	  }

    	  return nodes
    	}

    	/**
    	 * Builds a graph from a list of nodes.
    	 * All segments in each node group will be connected with all the segments of
    	 * the next group and so on.
    	 *
    	 * At each connection will be assigned a weight depending on the
    	 * segment's byte length.
    	 *
    	 * @param  {Array} nodes    Array of object with segments data
    	 * @param  {Number} version QR Code version
    	 * @return {Object}         Graph of all possible segments
    	 */
    	function buildGraph (nodes, version) {
    	  const table = {};
    	  const graph = { start: {} };
    	  let prevNodeIds = ['start'];

    	  for (let i = 0; i < nodes.length; i++) {
    	    const nodeGroup = nodes[i];
    	    const currentNodeIds = [];

    	    for (let j = 0; j < nodeGroup.length; j++) {
    	      const node = nodeGroup[j];
    	      const key = '' + i + j;

    	      currentNodeIds.push(key);
    	      table[key] = { node: node, lastCount: 0 };
    	      graph[key] = {};

    	      for (let n = 0; n < prevNodeIds.length; n++) {
    	        const prevNodeId = prevNodeIds[n];

    	        if (table[prevNodeId] && table[prevNodeId].node.mode === node.mode) {
    	          graph[prevNodeId][key] =
    	            getSegmentBitsLength(table[prevNodeId].lastCount + node.length, node.mode) -
    	            getSegmentBitsLength(table[prevNodeId].lastCount, node.mode);

    	          table[prevNodeId].lastCount += node.length;
    	        } else {
    	          if (table[prevNodeId]) table[prevNodeId].lastCount = node.length;

    	          graph[prevNodeId][key] = getSegmentBitsLength(node.length, node.mode) +
    	            4 + Mode.getCharCountIndicator(node.mode, version); // switch cost
    	        }
    	      }
    	    }

    	    prevNodeIds = currentNodeIds;
    	  }

    	  for (let n = 0; n < prevNodeIds.length; n++) {
    	    graph[prevNodeIds[n]].end = 0;
    	  }

    	  return { map: graph, table: table }
    	}

    	/**
    	 * Builds a segment from a specified data and mode.
    	 * If a mode is not specified, the more suitable will be used.
    	 *
    	 * @param  {String} data             Input data
    	 * @param  {Mode | String} modesHint Data mode
    	 * @return {Segment}                 Segment
    	 */
    	function buildSingleSegment (data, modesHint) {
    	  let mode;
    	  const bestMode = Mode.getBestModeForData(data);

    	  mode = Mode.from(modesHint, bestMode);

    	  // Make sure data can be encoded
    	  if (mode !== Mode.BYTE && mode.bit < bestMode.bit) {
    	    throw new Error('"' + data + '"' +
    	      ' cannot be encoded with mode ' + Mode.toString(mode) +
    	      '.\n Suggested mode is: ' + Mode.toString(bestMode))
    	  }

    	  // Use Mode.BYTE if Kanji support is disabled
    	  if (mode === Mode.KANJI && !Utils.isKanjiModeEnabled()) {
    	    mode = Mode.BYTE;
    	  }

    	  switch (mode) {
    	    case Mode.NUMERIC:
    	      return new NumericData(data)

    	    case Mode.ALPHANUMERIC:
    	      return new AlphanumericData(data)

    	    case Mode.KANJI:
    	      return new KanjiData(data)

    	    case Mode.BYTE:
    	      return new ByteData(data)
    	  }
    	}

    	/**
    	 * Builds a list of segments from an array.
    	 * Array can contain Strings or Objects with segment's info.
    	 *
    	 * For each item which is a string, will be generated a segment with the given
    	 * string and the more appropriate encoding mode.
    	 *
    	 * For each item which is an object, will be generated a segment with the given
    	 * data and mode.
    	 * Objects must contain at least the property "data".
    	 * If property "mode" is not present, the more suitable mode will be used.
    	 *
    	 * @param  {Array} array Array of objects with segments data
    	 * @return {Array}       Array of Segments
    	 */
    	exports.fromArray = function fromArray (array) {
    	  return array.reduce(function (acc, seg) {
    	    if (typeof seg === 'string') {
    	      acc.push(buildSingleSegment(seg, null));
    	    } else if (seg.data) {
    	      acc.push(buildSingleSegment(seg.data, seg.mode));
    	    }

    	    return acc
    	  }, [])
    	};

    	/**
    	 * Builds an optimized sequence of segments from a string,
    	 * which will produce the shortest possible bitstream.
    	 *
    	 * @param  {String} data    Input string
    	 * @param  {Number} version QR Code version
    	 * @return {Array}          Array of segments
    	 */
    	exports.fromString = function fromString (data, version) {
    	  const segs = getSegmentsFromString(data, Utils.isKanjiModeEnabled());

    	  const nodes = buildNodes(segs);
    	  const graph = buildGraph(nodes, version);
    	  const path = dijkstra.find_path(graph.map, 'start', 'end');

    	  const optimizedSegs = [];
    	  for (let i = 1; i < path.length - 1; i++) {
    	    optimizedSegs.push(graph.table[path[i]].node);
    	  }

    	  return exports.fromArray(mergeSegments(optimizedSegs))
    	};

    	/**
    	 * Splits a string in various segments with the modes which
    	 * best represent their content.
    	 * The produced segments are far from being optimized.
    	 * The output of this function is only used to estimate a QR Code version
    	 * which may contain the data.
    	 *
    	 * @param  {string} data Input string
    	 * @return {Array}       Array of segments
    	 */
    	exports.rawSplit = function rawSplit (data) {
    	  return exports.fromArray(
    	    getSegmentsFromString(data, Utils.isKanjiModeEnabled())
    	  )
    	}; 
    } (segments));

    const Utils$1 = utils$3;
    const ECLevel = errorCorrectionLevel;
    const BitBuffer = bitBuffer;
    const BitMatrix = bitMatrix;
    const AlignmentPattern = alignmentPattern;
    const FinderPattern = finderPattern;
    const MaskPattern = maskPattern;
    const ECCode = errorCorrectionCode;
    const ReedSolomonEncoder = reedSolomonEncoder;
    const Version = version$1;
    const FormatInfo = formatInfo;
    const Mode = mode;
    const Segments = segments;

    /**
     * QRCode for JavaScript
     *
     * modified by Ryan Day for nodejs support
     * Copyright (c) 2011 Ryan Day
     *
     * Licensed under the MIT license:
     *   http://www.opensource.org/licenses/mit-license.php
     *
    //---------------------------------------------------------------------
    // QRCode for JavaScript
    //
    // Copyright (c) 2009 Kazuhiko Arase
    //
    // URL: http://www.d-project.com/
    //
    // Licensed under the MIT license:
    //   http://www.opensource.org/licenses/mit-license.php
    //
    // The word "QR Code" is registered trademark of
    // DENSO WAVE INCORPORATED
    //   http://www.denso-wave.com/qrcode/faqpatent-e.html
    //
    //---------------------------------------------------------------------
    */

    /**
     * Add finder patterns bits to matrix
     *
     * @param  {BitMatrix} matrix  Modules matrix
     * @param  {Number}    version QR Code version
     */
    function setupFinderPattern (matrix, version) {
      const size = matrix.size;
      const pos = FinderPattern.getPositions(version);

      for (let i = 0; i < pos.length; i++) {
        const row = pos[i][0];
        const col = pos[i][1];

        for (let r = -1; r <= 7; r++) {
          if (row + r <= -1 || size <= row + r) continue

          for (let c = -1; c <= 7; c++) {
            if (col + c <= -1 || size <= col + c) continue

            if ((r >= 0 && r <= 6 && (c === 0 || c === 6)) ||
              (c >= 0 && c <= 6 && (r === 0 || r === 6)) ||
              (r >= 2 && r <= 4 && c >= 2 && c <= 4)) {
              matrix.set(row + r, col + c, true, true);
            } else {
              matrix.set(row + r, col + c, false, true);
            }
          }
        }
      }
    }

    /**
     * Add timing pattern bits to matrix
     *
     * Note: this function must be called before {@link setupAlignmentPattern}
     *
     * @param  {BitMatrix} matrix Modules matrix
     */
    function setupTimingPattern (matrix) {
      const size = matrix.size;

      for (let r = 8; r < size - 8; r++) {
        const value = r % 2 === 0;
        matrix.set(r, 6, value, true);
        matrix.set(6, r, value, true);
      }
    }

    /**
     * Add alignment patterns bits to matrix
     *
     * Note: this function must be called after {@link setupTimingPattern}
     *
     * @param  {BitMatrix} matrix  Modules matrix
     * @param  {Number}    version QR Code version
     */
    function setupAlignmentPattern (matrix, version) {
      const pos = AlignmentPattern.getPositions(version);

      for (let i = 0; i < pos.length; i++) {
        const row = pos[i][0];
        const col = pos[i][1];

        for (let r = -2; r <= 2; r++) {
          for (let c = -2; c <= 2; c++) {
            if (r === -2 || r === 2 || c === -2 || c === 2 ||
              (r === 0 && c === 0)) {
              matrix.set(row + r, col + c, true, true);
            } else {
              matrix.set(row + r, col + c, false, true);
            }
          }
        }
      }
    }

    /**
     * Add version info bits to matrix
     *
     * @param  {BitMatrix} matrix  Modules matrix
     * @param  {Number}    version QR Code version
     */
    function setupVersionInfo (matrix, version) {
      const size = matrix.size;
      const bits = Version.getEncodedBits(version);
      let row, col, mod;

      for (let i = 0; i < 18; i++) {
        row = Math.floor(i / 3);
        col = i % 3 + size - 8 - 3;
        mod = ((bits >> i) & 1) === 1;

        matrix.set(row, col, mod, true);
        matrix.set(col, row, mod, true);
      }
    }

    /**
     * Add format info bits to matrix
     *
     * @param  {BitMatrix} matrix               Modules matrix
     * @param  {ErrorCorrectionLevel}    errorCorrectionLevel Error correction level
     * @param  {Number}    maskPattern          Mask pattern reference value
     */
    function setupFormatInfo (matrix, errorCorrectionLevel, maskPattern) {
      const size = matrix.size;
      const bits = FormatInfo.getEncodedBits(errorCorrectionLevel, maskPattern);
      let i, mod;

      for (i = 0; i < 15; i++) {
        mod = ((bits >> i) & 1) === 1;

        // vertical
        if (i < 6) {
          matrix.set(i, 8, mod, true);
        } else if (i < 8) {
          matrix.set(i + 1, 8, mod, true);
        } else {
          matrix.set(size - 15 + i, 8, mod, true);
        }

        // horizontal
        if (i < 8) {
          matrix.set(8, size - i - 1, mod, true);
        } else if (i < 9) {
          matrix.set(8, 15 - i - 1 + 1, mod, true);
        } else {
          matrix.set(8, 15 - i - 1, mod, true);
        }
      }

      // fixed module
      matrix.set(size - 8, 8, 1, true);
    }

    /**
     * Add encoded data bits to matrix
     *
     * @param  {BitMatrix}  matrix Modules matrix
     * @param  {Uint8Array} data   Data codewords
     */
    function setupData (matrix, data) {
      const size = matrix.size;
      let inc = -1;
      let row = size - 1;
      let bitIndex = 7;
      let byteIndex = 0;

      for (let col = size - 1; col > 0; col -= 2) {
        if (col === 6) col--;

        while (true) {
          for (let c = 0; c < 2; c++) {
            if (!matrix.isReserved(row, col - c)) {
              let dark = false;

              if (byteIndex < data.length) {
                dark = (((data[byteIndex] >>> bitIndex) & 1) === 1);
              }

              matrix.set(row, col - c, dark);
              bitIndex--;

              if (bitIndex === -1) {
                byteIndex++;
                bitIndex = 7;
              }
            }
          }

          row += inc;

          if (row < 0 || size <= row) {
            row -= inc;
            inc = -inc;
            break
          }
        }
      }
    }

    /**
     * Create encoded codewords from data input
     *
     * @param  {Number}   version              QR Code version
     * @param  {ErrorCorrectionLevel}   errorCorrectionLevel Error correction level
     * @param  {ByteData} data                 Data input
     * @return {Uint8Array}                    Buffer containing encoded codewords
     */
    function createData (version, errorCorrectionLevel, segments) {
      // Prepare data buffer
      const buffer = new BitBuffer();

      segments.forEach(function (data) {
        // prefix data with mode indicator (4 bits)
        buffer.put(data.mode.bit, 4);

        // Prefix data with character count indicator.
        // The character count indicator is a string of bits that represents the
        // number of characters that are being encoded.
        // The character count indicator must be placed after the mode indicator
        // and must be a certain number of bits long, depending on the QR version
        // and data mode
        // @see {@link Mode.getCharCountIndicator}.
        buffer.put(data.getLength(), Mode.getCharCountIndicator(data.mode, version));

        // add binary data sequence to buffer
        data.write(buffer);
      });

      // Calculate required number of bits
      const totalCodewords = Utils$1.getSymbolTotalCodewords(version);
      const ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel);
      const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;

      // Add a terminator.
      // If the bit string is shorter than the total number of required bits,
      // a terminator of up to four 0s must be added to the right side of the string.
      // If the bit string is more than four bits shorter than the required number of bits,
      // add four 0s to the end.
      if (buffer.getLengthInBits() + 4 <= dataTotalCodewordsBits) {
        buffer.put(0, 4);
      }

      // If the bit string is fewer than four bits shorter, add only the number of 0s that
      // are needed to reach the required number of bits.

      // After adding the terminator, if the number of bits in the string is not a multiple of 8,
      // pad the string on the right with 0s to make the string's length a multiple of 8.
      while (buffer.getLengthInBits() % 8 !== 0) {
        buffer.putBit(0);
      }

      // Add pad bytes if the string is still shorter than the total number of required bits.
      // Extend the buffer to fill the data capacity of the symbol corresponding to
      // the Version and Error Correction Level by adding the Pad Codewords 11101100 (0xEC)
      // and 00010001 (0x11) alternately.
      const remainingByte = (dataTotalCodewordsBits - buffer.getLengthInBits()) / 8;
      for (let i = 0; i < remainingByte; i++) {
        buffer.put(i % 2 ? 0x11 : 0xEC, 8);
      }

      return createCodewords(buffer, version, errorCorrectionLevel)
    }

    /**
     * Encode input data with Reed-Solomon and return codewords with
     * relative error correction bits
     *
     * @param  {BitBuffer} bitBuffer            Data to encode
     * @param  {Number}    version              QR Code version
     * @param  {ErrorCorrectionLevel} errorCorrectionLevel Error correction level
     * @return {Uint8Array}                     Buffer containing encoded codewords
     */
    function createCodewords (bitBuffer, version, errorCorrectionLevel) {
      // Total codewords for this QR code version (Data + Error correction)
      const totalCodewords = Utils$1.getSymbolTotalCodewords(version);

      // Total number of error correction codewords
      const ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel);

      // Total number of data codewords
      const dataTotalCodewords = totalCodewords - ecTotalCodewords;

      // Total number of blocks
      const ecTotalBlocks = ECCode.getBlocksCount(version, errorCorrectionLevel);

      // Calculate how many blocks each group should contain
      const blocksInGroup2 = totalCodewords % ecTotalBlocks;
      const blocksInGroup1 = ecTotalBlocks - blocksInGroup2;

      const totalCodewordsInGroup1 = Math.floor(totalCodewords / ecTotalBlocks);

      const dataCodewordsInGroup1 = Math.floor(dataTotalCodewords / ecTotalBlocks);
      const dataCodewordsInGroup2 = dataCodewordsInGroup1 + 1;

      // Number of EC codewords is the same for both groups
      const ecCount = totalCodewordsInGroup1 - dataCodewordsInGroup1;

      // Initialize a Reed-Solomon encoder with a generator polynomial of degree ecCount
      const rs = new ReedSolomonEncoder(ecCount);

      let offset = 0;
      const dcData = new Array(ecTotalBlocks);
      const ecData = new Array(ecTotalBlocks);
      let maxDataSize = 0;
      const buffer = new Uint8Array(bitBuffer.buffer);

      // Divide the buffer into the required number of blocks
      for (let b = 0; b < ecTotalBlocks; b++) {
        const dataSize = b < blocksInGroup1 ? dataCodewordsInGroup1 : dataCodewordsInGroup2;

        // extract a block of data from buffer
        dcData[b] = buffer.slice(offset, offset + dataSize);

        // Calculate EC codewords for this data block
        ecData[b] = rs.encode(dcData[b]);

        offset += dataSize;
        maxDataSize = Math.max(maxDataSize, dataSize);
      }

      // Create final data
      // Interleave the data and error correction codewords from each block
      const data = new Uint8Array(totalCodewords);
      let index = 0;
      let i, r;

      // Add data codewords
      for (i = 0; i < maxDataSize; i++) {
        for (r = 0; r < ecTotalBlocks; r++) {
          if (i < dcData[r].length) {
            data[index++] = dcData[r][i];
          }
        }
      }

      // Apped EC codewords
      for (i = 0; i < ecCount; i++) {
        for (r = 0; r < ecTotalBlocks; r++) {
          data[index++] = ecData[r][i];
        }
      }

      return data
    }

    /**
     * Build QR Code symbol
     *
     * @param  {String} data                 Input string
     * @param  {Number} version              QR Code version
     * @param  {ErrorCorretionLevel} errorCorrectionLevel Error level
     * @param  {MaskPattern} maskPattern     Mask pattern
     * @return {Object}                      Object containing symbol data
     */
    function createSymbol (data, version, errorCorrectionLevel, maskPattern) {
      let segments;

      if (Array.isArray(data)) {
        segments = Segments.fromArray(data);
      } else if (typeof data === 'string') {
        let estimatedVersion = version;

        if (!estimatedVersion) {
          const rawSegments = Segments.rawSplit(data);

          // Estimate best version that can contain raw splitted segments
          estimatedVersion = Version.getBestVersionForData(rawSegments, errorCorrectionLevel);
        }

        // Build optimized segments
        // If estimated version is undefined, try with the highest version
        segments = Segments.fromString(data, estimatedVersion || 40);
      } else {
        throw new Error('Invalid data')
      }

      // Get the min version that can contain data
      const bestVersion = Version.getBestVersionForData(segments, errorCorrectionLevel);

      // If no version is found, data cannot be stored
      if (!bestVersion) {
        throw new Error('The amount of data is too big to be stored in a QR Code')
      }

      // If not specified, use min version as default
      if (!version) {
        version = bestVersion;

      // Check if the specified version can contain the data
      } else if (version < bestVersion) {
        throw new Error('\n' +
          'The chosen QR Code version cannot contain this amount of data.\n' +
          'Minimum version required to store current data is: ' + bestVersion + '.\n'
        )
      }

      const dataBits = createData(version, errorCorrectionLevel, segments);

      // Allocate matrix buffer
      const moduleCount = Utils$1.getSymbolSize(version);
      const modules = new BitMatrix(moduleCount);

      // Add function modules
      setupFinderPattern(modules, version);
      setupTimingPattern(modules);
      setupAlignmentPattern(modules, version);

      // Add temporary dummy bits for format info just to set them as reserved.
      // This is needed to prevent these bits from being masked by {@link MaskPattern.applyMask}
      // since the masking operation must be performed only on the encoding region.
      // These blocks will be replaced with correct values later in code.
      setupFormatInfo(modules, errorCorrectionLevel, 0);

      if (version >= 7) {
        setupVersionInfo(modules, version);
      }

      // Add data codewords
      setupData(modules, dataBits);

      if (isNaN(maskPattern)) {
        // Find best mask pattern
        maskPattern = MaskPattern.getBestMask(modules,
          setupFormatInfo.bind(null, modules, errorCorrectionLevel));
      }

      // Apply mask pattern
      MaskPattern.applyMask(maskPattern, modules);

      // Replace format info bits with correct values
      setupFormatInfo(modules, errorCorrectionLevel, maskPattern);

      return {
        modules: modules,
        version: version,
        errorCorrectionLevel: errorCorrectionLevel,
        maskPattern: maskPattern,
        segments: segments
      }
    }

    /**
     * QR Code
     *
     * @param {String | Array} data                 Input data
     * @param {Object} options                      Optional configurations
     * @param {Number} options.version              QR Code version
     * @param {String} options.errorCorrectionLevel Error correction level
     * @param {Function} options.toSJISFunc         Helper func to convert utf8 to sjis
     */
    qrcode.create = function create (data, options) {
      if (typeof data === 'undefined' || data === '') {
        throw new Error('No input text')
      }

      let errorCorrectionLevel = ECLevel.M;
      let version;
      let mask;

      if (typeof options !== 'undefined') {
        // Use higher error correction level as default
        errorCorrectionLevel = ECLevel.from(options.errorCorrectionLevel, ECLevel.M);
        version = Version.from(options.version);
        mask = MaskPattern.from(options.maskPattern);

        if (options.toSJISFunc) {
          Utils$1.setToSJISFunction(options.toSJISFunc);
        }
      }

      return createSymbol(data, version, errorCorrectionLevel, mask)
    };

    var canvas = {};

    var utils$2 = {};

    (function (exports) {
    	function hex2rgba (hex) {
    	  if (typeof hex === 'number') {
    	    hex = hex.toString();
    	  }

    	  if (typeof hex !== 'string') {
    	    throw new Error('Color should be defined as hex string')
    	  }

    	  let hexCode = hex.slice().replace('#', '').split('');
    	  if (hexCode.length < 3 || hexCode.length === 5 || hexCode.length > 8) {
    	    throw new Error('Invalid hex color: ' + hex)
    	  }

    	  // Convert from short to long form (fff -> ffffff)
    	  if (hexCode.length === 3 || hexCode.length === 4) {
    	    hexCode = Array.prototype.concat.apply([], hexCode.map(function (c) {
    	      return [c, c]
    	    }));
    	  }

    	  // Add default alpha value
    	  if (hexCode.length === 6) hexCode.push('F', 'F');

    	  const hexValue = parseInt(hexCode.join(''), 16);

    	  return {
    	    r: (hexValue >> 24) & 255,
    	    g: (hexValue >> 16) & 255,
    	    b: (hexValue >> 8) & 255,
    	    a: hexValue & 255,
    	    hex: '#' + hexCode.slice(0, 6).join('')
    	  }
    	}

    	exports.getOptions = function getOptions (options) {
    	  if (!options) options = {};
    	  if (!options.color) options.color = {};

    	  const margin = typeof options.margin === 'undefined' ||
    	    options.margin === null ||
    	    options.margin < 0
    	    ? 4
    	    : options.margin;

    	  const width = options.width && options.width >= 21 ? options.width : undefined;
    	  const scale = options.scale || 4;

    	  return {
    	    width: width,
    	    scale: width ? 4 : scale,
    	    margin: margin,
    	    color: {
    	      dark: hex2rgba(options.color.dark || '#000000ff'),
    	      light: hex2rgba(options.color.light || '#ffffffff')
    	    },
    	    type: options.type,
    	    rendererOpts: options.rendererOpts || {}
    	  }
    	};

    	exports.getScale = function getScale (qrSize, opts) {
    	  return opts.width && opts.width >= qrSize + opts.margin * 2
    	    ? opts.width / (qrSize + opts.margin * 2)
    	    : opts.scale
    	};

    	exports.getImageWidth = function getImageWidth (qrSize, opts) {
    	  const scale = exports.getScale(qrSize, opts);
    	  return Math.floor((qrSize + opts.margin * 2) * scale)
    	};

    	exports.qrToImageData = function qrToImageData (imgData, qr, opts) {
    	  const size = qr.modules.size;
    	  const data = qr.modules.data;
    	  const scale = exports.getScale(size, opts);
    	  const symbolSize = Math.floor((size + opts.margin * 2) * scale);
    	  const scaledMargin = opts.margin * scale;
    	  const palette = [opts.color.light, opts.color.dark];

    	  for (let i = 0; i < symbolSize; i++) {
    	    for (let j = 0; j < symbolSize; j++) {
    	      let posDst = (i * symbolSize + j) * 4;
    	      let pxColor = opts.color.light;

    	      if (i >= scaledMargin && j >= scaledMargin &&
    	        i < symbolSize - scaledMargin && j < symbolSize - scaledMargin) {
    	        const iSrc = Math.floor((i - scaledMargin) / scale);
    	        const jSrc = Math.floor((j - scaledMargin) / scale);
    	        pxColor = palette[data[iSrc * size + jSrc] ? 1 : 0];
    	      }

    	      imgData[posDst++] = pxColor.r;
    	      imgData[posDst++] = pxColor.g;
    	      imgData[posDst++] = pxColor.b;
    	      imgData[posDst] = pxColor.a;
    	    }
    	  }
    	}; 
    } (utils$2));

    (function (exports) {
    	const Utils = utils$2;

    	function clearCanvas (ctx, canvas, size) {
    	  ctx.clearRect(0, 0, canvas.width, canvas.height);

    	  if (!canvas.style) canvas.style = {};
    	  canvas.height = size;
    	  canvas.width = size;
    	  canvas.style.height = size + 'px';
    	  canvas.style.width = size + 'px';
    	}

    	function getCanvasElement () {
    	  try {
    	    return document.createElement('canvas')
    	  } catch (e) {
    	    throw new Error('You need to specify a canvas element')
    	  }
    	}

    	exports.render = function render (qrData, canvas, options) {
    	  let opts = options;
    	  let canvasEl = canvas;

    	  if (typeof opts === 'undefined' && (!canvas || !canvas.getContext)) {
    	    opts = canvas;
    	    canvas = undefined;
    	  }

    	  if (!canvas) {
    	    canvasEl = getCanvasElement();
    	  }

    	  opts = Utils.getOptions(opts);
    	  const size = Utils.getImageWidth(qrData.modules.size, opts);

    	  const ctx = canvasEl.getContext('2d');
    	  const image = ctx.createImageData(size, size);
    	  Utils.qrToImageData(image.data, qrData, opts);

    	  clearCanvas(ctx, canvasEl, size);
    	  ctx.putImageData(image, 0, 0);

    	  return canvasEl
    	};

    	exports.renderToDataURL = function renderToDataURL (qrData, canvas, options) {
    	  let opts = options;

    	  if (typeof opts === 'undefined' && (!canvas || !canvas.getContext)) {
    	    opts = canvas;
    	    canvas = undefined;
    	  }

    	  if (!opts) opts = {};

    	  const canvasEl = exports.render(qrData, canvas, opts);

    	  const type = opts.type || 'image/png';
    	  const rendererOpts = opts.rendererOpts || {};

    	  return canvasEl.toDataURL(type, rendererOpts.quality)
    	}; 
    } (canvas));

    var svgTag = {};

    const Utils = utils$2;

    function getColorAttrib (color, attrib) {
      const alpha = color.a / 255;
      const str = attrib + '="' + color.hex + '"';

      return alpha < 1
        ? str + ' ' + attrib + '-opacity="' + alpha.toFixed(2).slice(1) + '"'
        : str
    }

    function svgCmd (cmd, x, y) {
      let str = cmd + x;
      if (typeof y !== 'undefined') str += ' ' + y;

      return str
    }

    function qrToPath (data, size, margin) {
      let path = '';
      let moveBy = 0;
      let newRow = false;
      let lineLength = 0;

      for (let i = 0; i < data.length; i++) {
        const col = Math.floor(i % size);
        const row = Math.floor(i / size);

        if (!col && !newRow) newRow = true;

        if (data[i]) {
          lineLength++;

          if (!(i > 0 && col > 0 && data[i - 1])) {
            path += newRow
              ? svgCmd('M', col + margin, 0.5 + row + margin)
              : svgCmd('m', moveBy, 0);

            moveBy = 0;
            newRow = false;
          }

          if (!(col + 1 < size && data[i + 1])) {
            path += svgCmd('h', lineLength);
            lineLength = 0;
          }
        } else {
          moveBy++;
        }
      }

      return path
    }

    svgTag.render = function render (qrData, options, cb) {
      const opts = Utils.getOptions(options);
      const size = qrData.modules.size;
      const data = qrData.modules.data;
      const qrcodesize = size + opts.margin * 2;

      const bg = !opts.color.light.a
        ? ''
        : '<path ' + getColorAttrib(opts.color.light, 'fill') +
          ' d="M0 0h' + qrcodesize + 'v' + qrcodesize + 'H0z"/>';

      const path =
        '<path ' + getColorAttrib(opts.color.dark, 'stroke') +
        ' d="' + qrToPath(data, size, opts.margin) + '"/>';

      const viewBox = 'viewBox="' + '0 0 ' + qrcodesize + ' ' + qrcodesize + '"';

      const width = !opts.width ? '' : 'width="' + opts.width + '" height="' + opts.width + '" ';

      const svgTag = '<svg xmlns="http://www.w3.org/2000/svg" ' + width + viewBox + ' shape-rendering="crispEdges">' + bg + path + '</svg>\n';

      if (typeof cb === 'function') {
        cb(null, svgTag);
      }

      return svgTag
    };

    const canPromise = canPromise$1;

    const QRCode$3 = qrcode;
    const CanvasRenderer = canvas;
    const SvgRenderer = svgTag;

    function renderCanvas (renderFunc, canvas, text, opts, cb) {
      const args = [].slice.call(arguments, 1);
      const argsNum = args.length;
      const isLastArgCb = typeof args[argsNum - 1] === 'function';

      if (!isLastArgCb && !canPromise()) {
        throw new Error('Callback required as last argument')
      }

      if (isLastArgCb) {
        if (argsNum < 2) {
          throw new Error('Too few arguments provided')
        }

        if (argsNum === 2) {
          cb = text;
          text = canvas;
          canvas = opts = undefined;
        } else if (argsNum === 3) {
          if (canvas.getContext && typeof cb === 'undefined') {
            cb = opts;
            opts = undefined;
          } else {
            cb = opts;
            opts = text;
            text = canvas;
            canvas = undefined;
          }
        }
      } else {
        if (argsNum < 1) {
          throw new Error('Too few arguments provided')
        }

        if (argsNum === 1) {
          text = canvas;
          canvas = opts = undefined;
        } else if (argsNum === 2 && !canvas.getContext) {
          opts = text;
          text = canvas;
          canvas = undefined;
        }

        return new Promise(function (resolve, reject) {
          try {
            const data = QRCode$3.create(text, opts);
            resolve(renderFunc(data, canvas, opts));
          } catch (e) {
            reject(e);
          }
        })
      }

      try {
        const data = QRCode$3.create(text, opts);
        cb(null, renderFunc(data, canvas, opts));
      } catch (e) {
        cb(e);
      }
    }

    browser$2.create = QRCode$3.create;
    browser$2.toCanvas = renderCanvas.bind(null, CanvasRenderer.render);
    browser$2.toDataURL = renderCanvas.bind(null, CanvasRenderer.renderToDataURL);

    // only svg for now.
    browser$2.toString = renderCanvas.bind(null, function (data, _, opts) {
      return SvgRenderer.render(data, opts)
    });

    const CONNECTING_ERROR_MARGIN = 0.1;
    const CIRCLE_SIZE_MODIFIER = 2.5;
    const QRCODE_MATRIX_MARGIN = 7;
    function isAdjecentDots(cy, otherCy, cellSize) {
        if (cy === otherCy) {
            return false;
        }
        const diff = cy - otherCy < 0 ? otherCy - cy : cy - otherCy;
        return diff <= cellSize + CONNECTING_ERROR_MARGIN;
    }
    function getMatrix(value, errorCorrectionLevel) {
        const arr = Array.prototype.slice.call(browser$2.create(value, { errorCorrectionLevel }).modules.data, 0);
        const sqrt = Math.sqrt(arr.length);
        return arr.reduce((rows, key, index) => (index % sqrt === 0 ? rows.push([key]) : rows[rows.length - 1].push(key)) && rows, []);
    }
    const QrCodeUtil = {
        generate(uri, size, logoSize) {
            const dotColor = '#141414';
            const edgeColor = 'transparent';
            const strokeWidth = 5;
            const dots = [];
            const matrix = getMatrix(uri, 'Q');
            const cellSize = size / matrix.length;
            const qrList = [
                { x: 0, y: 0 },
                { x: 1, y: 0 },
                { x: 0, y: 1 }
            ];
            qrList.forEach(({ x, y }) => {
                const x1 = (matrix.length - QRCODE_MATRIX_MARGIN) * cellSize * x;
                const y1 = (matrix.length - QRCODE_MATRIX_MARGIN) * cellSize * y;
                const borderRadius = 0.45;
                for (let i = 0; i < qrList.length; i += 1) {
                    const dotSize = cellSize * (QRCODE_MATRIX_MARGIN - i * 2);
                    dots.push(b$5 `
            <rect
              fill=${i === 2 ? dotColor : edgeColor}
              width=${i === 0 ? dotSize - strokeWidth : dotSize}
              rx= ${i === 0 ? (dotSize - strokeWidth) * borderRadius : dotSize * borderRadius}
              ry= ${i === 0 ? (dotSize - strokeWidth) * borderRadius : dotSize * borderRadius}
              stroke=${dotColor}
              stroke-width=${i === 0 ? strokeWidth : 0}
              height=${i === 0 ? dotSize - strokeWidth : dotSize}
              x= ${i === 0 ? y1 + cellSize * i + strokeWidth / 2 : y1 + cellSize * i}
              y= ${i === 0 ? x1 + cellSize * i + strokeWidth / 2 : x1 + cellSize * i}
            />
          `);
                }
            });
            const clearArenaSize = Math.floor((logoSize + 25) / cellSize);
            const matrixMiddleStart = matrix.length / 2 - clearArenaSize / 2;
            const matrixMiddleEnd = matrix.length / 2 + clearArenaSize / 2 - 1;
            const circles = [];
            matrix.forEach((row, i) => {
                row.forEach((_, j) => {
                    if (matrix[i][j]) {
                        if (!((i < QRCODE_MATRIX_MARGIN && j < QRCODE_MATRIX_MARGIN) ||
                            (i > matrix.length - (QRCODE_MATRIX_MARGIN + 1) && j < QRCODE_MATRIX_MARGIN) ||
                            (i < QRCODE_MATRIX_MARGIN && j > matrix.length - (QRCODE_MATRIX_MARGIN + 1)))) {
                            if (!(i > matrixMiddleStart &&
                                i < matrixMiddleEnd &&
                                j > matrixMiddleStart &&
                                j < matrixMiddleEnd)) {
                                const cx = i * cellSize + cellSize / 2;
                                const cy = j * cellSize + cellSize / 2;
                                circles.push([cx, cy]);
                            }
                        }
                    }
                });
            });
            const circlesToConnect = {};
            circles.forEach(([cx, cy]) => {
                if (circlesToConnect[cx]) {
                    circlesToConnect[cx]?.push(cy);
                }
                else {
                    circlesToConnect[cx] = [cy];
                }
            });
            Object.entries(circlesToConnect)
                .map(([cx, cys]) => {
                const newCys = cys.filter(cy => cys.every(otherCy => !isAdjecentDots(cy, otherCy, cellSize)));
                return [Number(cx), newCys];
            })
                .forEach(([cx, cys]) => {
                cys.forEach(cy => {
                    dots.push(b$5 `<circle cx=${cx} cy=${cy} fill=${dotColor} r=${cellSize / CIRCLE_SIZE_MODIFIER} />`);
                });
            });
            Object.entries(circlesToConnect)
                .filter(([_, cys]) => cys.length > 1)
                .map(([cx, cys]) => {
                const newCys = cys.filter(cy => cys.some(otherCy => isAdjecentDots(cy, otherCy, cellSize)));
                return [Number(cx), newCys];
            })
                .map(([cx, cys]) => {
                cys.sort((a, b) => (a < b ? -1 : 1));
                const groups = [];
                for (const cy of cys) {
                    const group = groups.find(item => item.some(otherCy => isAdjecentDots(cy, otherCy, cellSize)));
                    if (group) {
                        group.push(cy);
                    }
                    else {
                        groups.push([cy]);
                    }
                }
                return [cx, groups.map(item => [item[0], item[item.length - 1]])];
            })
                .forEach(([cx, groups]) => {
                groups.forEach(([y1, y2]) => {
                    dots.push(b$5 `
              <line
                x1=${cx}
                x2=${cx}
                y1=${y1}
                y2=${y2}
                stroke=${dotColor}
                stroke-width=${cellSize / (CIRCLE_SIZE_MODIFIER / 2)}
                stroke-linecap="round"
              />
            `);
                });
            });
            return dots;
        }
    };

    var styles$17 = i$h `
  :host {
    position: relative;
    user-select: none;
    display: block;
    overflow: hidden;
    aspect-ratio: 1 / 1;
    width: var(--local-size);
  }

  :host([data-theme='dark']) {
    border-radius: clamp(0px, var(--wui-border-radius-l), 40px);
    background-color: var(--wui-color-inverse-100);
    padding: var(--wui-spacing-l);
  }

  :host([data-theme='light']) {
    box-shadow: 0 0 0 1px var(--wui-color-bg-125);
    background-color: var(--wui-color-bg-125);
  }

  :host([data-clear='true']) > wui-icon {
    display: none;
  }

  svg:first-child,
  wui-image,
  wui-icon {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translateY(-50%) translateX(-50%);
  }

  wui-image {
    width: 25%;
    height: 25%;
    border-radius: var(--wui-border-radius-xs);
  }

  wui-icon {
    width: 100%;
    height: 100%;
    color: #3396ff !important;
    transform: translateY(-50%) translateX(-50%) scale(0.25);
  }
`;

    var __decorate$1w = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let WuiQrCode = class WuiQrCode extends s$e {
        constructor() {
            super(...arguments);
            this.uri = '';
            this.size = 0;
            this.theme = 'dark';
            this.imageSrc = undefined;
            this.alt = undefined;
            this.arenaClear = undefined;
        }
        render() {
            this.dataset['theme'] = this.theme;
            this.dataset['clear'] = String(this.arenaClear);
            this.style.cssText = `--local-size: ${this.size}px`;
            return x$5 `${this.templateVisual()} ${this.templateSvg()}`;
        }
        templateSvg() {
            const size = this.theme === 'light' ? this.size : this.size - 16 * 2;
            return b$5 `
      <svg height=${size} width=${size}>
        ${QrCodeUtil.generate(this.uri, size, this.arenaClear ? 0 : size / 4)}
      </svg>
    `;
        }
        templateVisual() {
            if (this.imageSrc) {
                return x$5 `<wui-image src=${this.imageSrc} alt=${this.alt ?? 'logo'}></wui-image>`;
            }
            return x$5 `<wui-icon size="inherit" color="inherit" name="walletConnect"></wui-icon>`;
        }
    };
    WuiQrCode.styles = [resetStyles, styles$17];
    __decorate$1w([
        n$j()
    ], WuiQrCode.prototype, "uri", void 0);
    __decorate$1w([
        n$j({ type: Number })
    ], WuiQrCode.prototype, "size", void 0);
    __decorate$1w([
        n$j()
    ], WuiQrCode.prototype, "theme", void 0);
    __decorate$1w([
        n$j()
    ], WuiQrCode.prototype, "imageSrc", void 0);
    __decorate$1w([
        n$j()
    ], WuiQrCode.prototype, "alt", void 0);
    __decorate$1w([
        n$j({ type: Boolean })
    ], WuiQrCode.prototype, "arenaClear", void 0);
    WuiQrCode = __decorate$1w([
        customElement('wui-qr-code')
    ], WuiQrCode);

    var styles$16 = i$h `
  :host {
    position: relative;
    display: inline-block;
    width: 100%;
  }
`;

    var __decorate$1v = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let WuiSearchBar = class WuiSearchBar extends s$e {
        constructor() {
            super(...arguments);
            this.inputComponentRef = e$g();
        }
        render() {
            return x$5 `
      <wui-input-text
        ${n$h(this.inputComponentRef)}
        placeholder="Search wallet"
        icon="search"
        type="search"
        enterKeyHint="search"
        size="sm"
      >
        <wui-input-element @click=${this.clearValue} icon="close"></wui-input-element>
      </wui-input-text>
    `;
        }
        clearValue() {
            const inputComponent = this.inputComponentRef.value;
            const inputElement = inputComponent?.inputElementRef.value;
            if (inputElement) {
                inputElement.value = '';
                inputElement.focus();
                inputElement.dispatchEvent(new Event('input'));
            }
        }
    };
    WuiSearchBar.styles = [resetStyles, styles$16];
    WuiSearchBar = __decorate$1v([
        customElement('wui-search-bar')
    ], WuiSearchBar);

    var styles$15 = i$h `
  :host {
    display: flex;
    column-gap: var(--wui-spacing-xs);
    align-items: center;
    padding: var(--wui-spacing-xs) var(--wui-spacing-m) var(--wui-spacing-xs) var(--wui-spacing-xs);
    border-radius: var(--wui-border-radius-3xl);
    border: 1px solid var(--wui-gray-glass-005);
    box-sizing: border-box;
    max-height: 40px;
    background-color: var(--wui-color-bg-175);
    box-shadow:
      0px 14px 64px -4px rgba(0, 0, 0, 0.15),
      0px 8px 22px -6px rgba(0, 0, 0, 0.15);
  }
`;

    var __decorate$1u = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let WuiSnackbar = class WuiSnackbar extends s$e {
        constructor() {
            super(...arguments);
            this.backgroundColor = 'accent-100';
            this.iconColor = 'accent-100';
            this.icon = 'checkmark';
            this.message = '';
        }
        render() {
            return x$5 `
      <wui-icon-box
        size="sm"
        iconSize="xs"
        iconColor=${this.iconColor}
        backgroundColor=${this.backgroundColor}
        icon=${this.icon}
        background="opaque"
      ></wui-icon-box>
      <wui-text variant="paragraph-500" color="fg-100">${this.message}</wui-text>
    `;
        }
    };
    WuiSnackbar.styles = [resetStyles, styles$15];
    __decorate$1u([
        n$j()
    ], WuiSnackbar.prototype, "backgroundColor", void 0);
    __decorate$1u([
        n$j()
    ], WuiSnackbar.prototype, "iconColor", void 0);
    __decorate$1u([
        n$j()
    ], WuiSnackbar.prototype, "icon", void 0);
    __decorate$1u([
        n$j()
    ], WuiSnackbar.prototype, "message", void 0);
    WuiSnackbar = __decorate$1u([
        customElement('wui-snackbar')
    ], WuiSnackbar);

    var styles$14 = i$h `
  :host {
    display: inline-flex;
    background-color: var(--wui-gray-glass-002);
    border-radius: var(--wui-border-radius-3xl);
    padding: var(--wui-spacing-3xs);
    position: relative;
    height: 36px;
    overflow: hidden;
  }

  :host::before {
    content: '';
    position: absolute;
    pointer-events: none;
    top: 4px;
    left: 4px;
    display: block;
    width: var(--local-tab-width);
    height: 28px;
    border-radius: var(--wui-border-radius-3xl);
    background-color: var(--wui-gray-glass-002);
    box-shadow: inset 0 0 0 1px var(--wui-gray-glass-002);
    transform: translateX(calc(var(--local-tab) * var(--local-tab-width)));
    transition: transform var(--wui-ease-out-power-2) var(--wui-duration-lg);
  }

  :host([data-type='flex'])::before {
    left: 3px;
    transform: translateX(calc((var(--local-tab) * 34px) + (var(--local-tab) * 4px)));
  }

  :host([data-type='flex']) {
    display: flex;
    padding: 0px 0px 0px 12px;
    gap: 4px;
  }

  :host([data-type='flex']) > button > wui-text {
    position: absolute;
    left: 18px;
    opacity: 0;
  }

  button[data-active='true'] > wui-icon,
  button[data-active='true'] > wui-text {
    color: var(--wui-color-fg-100);
  }

  button[data-active='false'] > wui-icon,
  button[data-active='false'] > wui-text {
    color: var(--wui-color-fg-200);
  }

  button[data-active='true']:disabled,
  button[data-active='false']:disabled {
    background-color: transparent;
    opacity: 0.5;
    cursor: not-allowed;
  }

  button[data-active='true']:disabled > wui-text {
    color: var(--wui-color-fg-200);
  }

  button[data-active='false']:disabled > wui-text {
    color: var(--wui-color-fg-300);
  }

  button > wui-icon,
  button > wui-text {
    pointer-events: none;
    transition: all var(--wui-ease-out-power-2) var(--wui-duration-lg);
  }

  button {
    width: var(--local-tab-width);
  }

  :host([data-type='flex']) > button {
    width: 34px;
    position: relative;
    display: flex;
    justify-content: flex-start;
  }

  button:hover:enabled,
  button:active:enabled {
    background-color: transparent !important;
  }

  button:hover:enabled > wui-icon,
  button:active:enabled > wui-icon {
    color: var(--wui-color-fg-125);
  }

  button:hover:enabled > wui-text,
  button:active:enabled > wui-text {
    color: var(--wui-color-fg-125);
  }

  button {
    border-radius: var(--wui-border-radius-3xl);
  }
`;

    var __decorate$1t = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let WuiTabs = class WuiTabs extends s$e {
        constructor() {
            super(...arguments);
            this.tabs = [];
            this.onTabChange = () => null;
            this.buttons = [];
            this.disabled = false;
            this.localTabWidth = '100px';
            this.activeTab = 0;
            this.isDense = false;
        }
        render() {
            this.isDense = this.tabs.length > 3;
            this.style.cssText = `
      --local-tab: ${this.activeTab};
      --local-tab-width: ${this.localTabWidth};
    `;
            this.dataset['type'] = this.isDense ? 'flex' : 'block';
            return this.tabs.map((tab, index) => {
                const isActive = index === this.activeTab;
                return x$5 `
        <button
          ?disabled=${this.disabled}
          @click=${() => this.onTabClick(index)}
          data-active=${isActive}
          data-testid="tab-${tab.label?.toLowerCase()}"
        >
          ${this.iconTemplate(tab)}
          <wui-text variant="small-600" color="inherit"> ${tab.label} </wui-text>
        </button>
      `;
            });
        }
        firstUpdated() {
            if (this.shadowRoot && this.isDense) {
                this.buttons = [...this.shadowRoot.querySelectorAll('button')];
                setTimeout(() => {
                    this.animateTabs(0, true);
                }, 0);
            }
        }
        iconTemplate(tab) {
            if (tab.icon) {
                return x$5 `<wui-icon size="xs" color="inherit" name=${tab.icon}></wui-icon>`;
            }
            return null;
        }
        onTabClick(index) {
            if (this.buttons) {
                this.animateTabs(index, false);
            }
            this.activeTab = index;
            this.onTabChange(index);
        }
        animateTabs(index, initialAnimation) {
            const passiveBtn = this.buttons[this.activeTab];
            const activeBtn = this.buttons[index];
            const passiveBtnText = passiveBtn?.querySelector('wui-text');
            const activeBtnText = activeBtn?.querySelector('wui-text');
            const activeBtnBounds = activeBtn?.getBoundingClientRect();
            const activeBtnTextBounds = activeBtnText?.getBoundingClientRect();
            if (passiveBtn && passiveBtnText && !initialAnimation && index !== this.activeTab) {
                passiveBtnText.animate([{ opacity: 0 }], {
                    duration: 50,
                    easing: 'ease',
                    fill: 'forwards'
                });
                passiveBtn.animate([{ width: `34px` }], {
                    duration: 500,
                    easing: 'ease',
                    fill: 'forwards'
                });
            }
            if (activeBtn && activeBtnBounds && activeBtnTextBounds && activeBtnText) {
                if (index !== this.activeTab || initialAnimation) {
                    this.localTabWidth = `${Math.round(activeBtnBounds.width + activeBtnTextBounds.width) + 6}px`;
                    activeBtn.animate([{ width: `${activeBtnBounds.width + activeBtnTextBounds.width}px` }], {
                        duration: initialAnimation ? 0 : 500,
                        fill: 'forwards',
                        easing: 'ease'
                    });
                    activeBtnText.animate([{ opacity: 1 }], {
                        duration: initialAnimation ? 0 : 125,
                        delay: initialAnimation ? 0 : 200,
                        fill: 'forwards',
                        easing: 'ease'
                    });
                }
            }
        }
    };
    WuiTabs.styles = [resetStyles, elementStyles, styles$14];
    __decorate$1t([
        n$j({ type: Array })
    ], WuiTabs.prototype, "tabs", void 0);
    __decorate$1t([
        n$j()
    ], WuiTabs.prototype, "onTabChange", void 0);
    __decorate$1t([
        n$j({ type: Array })
    ], WuiTabs.prototype, "buttons", void 0);
    __decorate$1t([
        n$j({ type: Boolean })
    ], WuiTabs.prototype, "disabled", void 0);
    __decorate$1t([
        n$j()
    ], WuiTabs.prototype, "localTabWidth", void 0);
    __decorate$1t([
        r$l()
    ], WuiTabs.prototype, "activeTab", void 0);
    __decorate$1t([
        r$l()
    ], WuiTabs.prototype, "isDense", void 0);
    WuiTabs = __decorate$1t([
        customElement('wui-tabs')
    ], WuiTabs);

    var styles$13 = i$h `
  :host {
    display: block;
    padding: 9px var(--wui-spacing-s) 10px var(--wui-spacing-s);
    border-radius: var(--wui-border-radius-xxs);

    color: var(--wui-color-bg-100);
    position: relative;
  }

  :host([data-variant='shade']) {
    background-color: var(--wui-color-bg-150);
    border: 1px solid var(--wui-gray-glass-005);
  }

  :host([data-variant='shade']) > wui-text {
    color: var(--wui-color-fg-150);
  }

  :host([data-variant='fill']) {
    background-color: var(--wui-color-fg-100);
    border: none;
  }

  wui-icon {
    position: absolute;
    width: 12px !important;
    height: 4px !important;
  }

  wui-icon[data-placement='top'] {
    bottom: 0px;
    left: 50%;
    transform: translate(-50%, 95%);
  }

  wui-icon[data-placement='bottom'] {
    top: 0;
    left: 50%;
    transform: translate(-50%, -95%) rotate(180deg);
  }

  wui-icon[data-placement='right'] {
    top: 50%;
    left: 0;
    transform: translate(-65%, -50%) rotate(90deg);
  }

  wui-icon[data-placement='left'] {
    top: 50%;
    right: 0%;
    transform: translate(65%, -50%) rotate(270deg);
  }
`;

    var __decorate$1s = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let WuiTooltip = class WuiTooltip extends s$e {
        constructor() {
            super(...arguments);
            this.placement = 'top';
            this.variant = 'fill';
            this.message = '';
        }
        render() {
            this.dataset['variant'] = this.variant;
            return x$5 `<wui-icon
        data-placement=${this.placement}
        color="fg-100"
        size="inherit"
        name=${this.variant === 'fill' ? 'cursor' : 'cursorTransparent'}
      ></wui-icon>
      <wui-text color="inherit" variant="small-500">${this.message}</wui-text>`;
        }
    };
    WuiTooltip.styles = [resetStyles, elementStyles, styles$13];
    __decorate$1s([
        n$j()
    ], WuiTooltip.prototype, "placement", void 0);
    __decorate$1s([
        n$j()
    ], WuiTooltip.prototype, "variant", void 0);
    __decorate$1s([
        n$j()
    ], WuiTooltip.prototype, "message", void 0);
    WuiTooltip = __decorate$1s([
        customElement('wui-tooltip')
    ], WuiTooltip);

    var styles$12 = i$h `
  :host {
    display: flex;
    justify-content: center;
    align-items: center;
    width: var(--wui-icon-box-size-xl);
    height: var(--wui-icon-box-size-xl);
    box-shadow: 0 0 0 8px var(--wui-thumbnail-border);
    border-radius: var(--local-border-radius);
    overflow: hidden;
  }

  wui-icon {
    width: 32px;
    height: 32px;
  }
`;

    var __decorate$1r = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let WuiVisualThumbnail = class WuiVisualThumbnail extends s$e {
        render() {
            this.style.cssText = `--local-border-radius: ${this.borderRadiusFull ? '1000px' : '20px'};`;
            return x$5 `${this.templateVisual()}`;
        }
        templateVisual() {
            if (this.imageSrc) {
                return x$5 `<wui-image src=${this.imageSrc} alt=${this.alt ?? ''}></wui-image>`;
            }
            return x$5 `<wui-icon
      data-parent-size="md"
      size="inherit"
      color="inherit"
      name="walletPlaceholder"
    ></wui-icon>`;
        }
    };
    WuiVisualThumbnail.styles = [resetStyles, styles$12];
    __decorate$1r([
        n$j()
    ], WuiVisualThumbnail.prototype, "imageSrc", void 0);
    __decorate$1r([
        n$j()
    ], WuiVisualThumbnail.prototype, "alt", void 0);
    __decorate$1r([
        n$j({ type: Boolean })
    ], WuiVisualThumbnail.prototype, "borderRadiusFull", void 0);
    WuiVisualThumbnail = __decorate$1r([
        customElement('wui-visual-thumbnail')
    ], WuiVisualThumbnail);

    var styles$11 = i$h `
  :host {
    display: block;
  }

  button {
    width: 100%;
    display: block;
    padding-top: var(--wui-spacing-l);
    padding-bottom: var(--wui-spacing-l);
    padding-left: var(--wui-spacing-s);
    padding-right: var(--wui-spacing-2l);
    border-radius: var(--wui-border-radius-s);
    background-color: var(--wui-accent-glass-015);
  }

  button:hover {
    background-color: var(--wui-accent-glass-010) !important;
  }

  button:active {
    background-color: var(--wui-accent-glass-020) !important;
  }
`;

    var __decorate$1q = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let WuiNoticeCard = class WuiNoticeCard extends s$e {
        constructor() {
            super(...arguments);
            this.label = '';
            this.description = '';
            this.icon = 'wallet';
        }
        render() {
            return x$5 `
      <button>
        <wui-flex gap="m" alignItems="center" justifyContent="space-between">
          <wui-icon-box
            size="lg"
            iconcolor="accent-100"
            backgroundcolor="accent-100"
            icon=${this.icon}
            background="transparent"
          ></wui-icon-box>

          <wui-flex flexDirection="column" gap="3xs">
            <wui-text variant="paragraph-500" color="fg-100">${this.label}</wui-text>
            <wui-text variant="small-400" color="fg-200">${this.description}</wui-text>
          </wui-flex>

          <wui-icon size="md" color="fg-200" name="chevronRight"></wui-icon>
        </wui-flex>
      </button>
    `;
        }
    };
    WuiNoticeCard.styles = [resetStyles, elementStyles, styles$11];
    __decorate$1q([
        n$j()
    ], WuiNoticeCard.prototype, "label", void 0);
    __decorate$1q([
        n$j()
    ], WuiNoticeCard.prototype, "description", void 0);
    __decorate$1q([
        n$j()
    ], WuiNoticeCard.prototype, "icon", void 0);
    WuiNoticeCard = __decorate$1q([
        customElement('wui-notice-card')
    ], WuiNoticeCard);

    var styles$10 = i$h `
  button {
    height: auto;
    position: relative;
    flex-direction: column;
    gap: var(--wui-spacing-s);
    padding: 17px 18px 17px var(--wui-spacing-m);
    width: 100%;
    background-color: var(--wui-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
    color: var(--wui-color-fg-250);
  }

  .overflowedContent {
    width: 100%;
    overflow: hidden;
  }

  .overflowedContent[data-active='false']:after {
    content: '';
    position: absolute;
    top: 50%;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(to top, var(--wui-color-bg-200), transparent);
    border-bottom-left-radius: var(--wui-border-radius-xs);
    border-bottom-right-radius: var(--wui-border-radius-xs);
  }

  .heightContent {
    max-height: 100px;
  }

  pre {
    text-align: left;
    white-space: pre-wrap;
    height: auto;
    overflow-x: auto;
    overflow-wrap: anywhere;
  }
`;

    var __decorate$1p = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    const MAX_HEIGHT = 100;
    let WuiListAccordion = class WuiListAccordion extends s$e {
        constructor() {
            super(...arguments);
            this.textTitle = '';
            this.overflowedContent = '';
            this.toggled = false;
            this.enableAccordion = false;
            this.scrollElement = undefined;
            this.scrollHeightElement = 0;
        }
        updated(changedProperties) {
            super.updated(changedProperties);
            if (changedProperties.has('textTitle') || changedProperties.has('overflowedContent')) {
                setTimeout(() => {
                    this.checkHeight();
                }, 1);
            }
        }
        checkHeight() {
            this.updateComplete.then(() => {
                const heightElement = this.shadowRoot?.querySelector('.heightContent');
                const textElement = this.shadowRoot?.querySelector('.textContent');
                if (heightElement && textElement) {
                    this.scrollElement = heightElement;
                    const scrollHeight = textElement?.scrollHeight;
                    if (scrollHeight && scrollHeight > MAX_HEIGHT) {
                        this.enableAccordion = true;
                        this.scrollHeightElement = scrollHeight;
                        this.requestUpdate();
                    }
                }
            });
        }
        render() {
            return x$5 `
      <button ontouchstart @click=${() => this.onClick()}>
        <wui-flex justifyContent="space-between" alignItems="center">
          <wui-text variant="paragraph-500" color="fg-100">${this.textTitle}</wui-text>
          ${this.chevronTemplate()}
        </wui-flex>
        <div
          data-active=${this.enableAccordion ? Boolean(this.toggled) : true}
          class="overflowedContent"
        >
          <div class="heightContent">
            <wui-text class="textContent" variant="paragraph-400" color="fg-200">
              <pre>${this.overflowedContent}</pre>
            </wui-text>
          </div>
        </div>
      </button>
    `;
        }
        onClick() {
            const icon = this.shadowRoot?.querySelector('wui-icon');
            if (this.enableAccordion) {
                this.toggled = !this.toggled;
                this.requestUpdate();
                if (this.scrollElement) {
                    this.scrollElement.animate([
                        { maxHeight: this.toggled ? `${MAX_HEIGHT}px` : `${this.scrollHeightElement}px` },
                        { maxHeight: this.toggled ? `${this.scrollHeightElement}px` : `${MAX_HEIGHT}px` }
                    ], {
                        duration: 300,
                        fill: 'forwards',
                        easing: 'ease'
                    });
                }
                if (icon) {
                    icon.animate([
                        { transform: this.toggled ? `rotate(0deg)` : `rotate(180deg)` },
                        { transform: this.toggled ? `rotate(180deg)` : `rotate(0deg)` }
                    ], {
                        duration: 300,
                        fill: 'forwards',
                        easing: 'ease'
                    });
                }
            }
        }
        chevronTemplate() {
            if (this.enableAccordion) {
                return x$5 ` <wui-icon color="fg-100" size="sm" name="chevronBottom"></wui-icon>`;
            }
            return null;
        }
    };
    WuiListAccordion.styles = [resetStyles, elementStyles, styles$10];
    __decorate$1p([
        n$j()
    ], WuiListAccordion.prototype, "textTitle", void 0);
    __decorate$1p([
        n$j()
    ], WuiListAccordion.prototype, "overflowedContent", void 0);
    WuiListAccordion = __decorate$1p([
        customElement('wui-list-accordion')
    ], WuiListAccordion);

    var styles$$ = i$h `
  :host {
    display: flex;
    column-gap: var(--wui-spacing-s);
    padding: 17px 18px 17px var(--wui-spacing-m);
    width: 100%;
    background-color: var(--wui-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
    color: var(--wui-color-fg-250);
  }

  wui-image {
    width: var(--wui-icon-size-lg);
    height: var(--wui-icon-size-lg);
    border-radius: var(--wui-border-radius-3xl);
  }

  wui-icon {
    width: var(--wui-icon-size-lg);
    height: var(--wui-icon-size-lg);
  }
`;

    var __decorate$1o = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let WuiListContent = class WuiListContent extends s$e {
        constructor() {
            super(...arguments);
            this.imageSrc = undefined;
            this.textTitle = '';
            this.textValue = undefined;
        }
        render() {
            return x$5 `
      <wui-flex justifyContent="space-between" alignItems="center">
        <wui-text variant="paragraph-500" color=${this.textValue ? 'fg-200' : 'fg-100'}>
          ${this.textTitle}
        </wui-text>
        ${this.templateContent()}
      </wui-flex>
    `;
        }
        templateContent() {
            if (this.imageSrc) {
                return x$5 `<wui-image src=${this.imageSrc} alt=${this.textTitle}></wui-image>`;
            }
            else if (this.textValue) {
                return x$5 ` <wui-text variant="paragraph-400" color="fg-100"> ${this.textValue} </wui-text>`;
            }
            return x$5 `<wui-icon size="inherit" color="fg-200" name="networkPlaceholder"></wui-icon>`;
        }
    };
    WuiListContent.styles = [resetStyles, elementStyles, styles$$];
    __decorate$1o([
        n$j()
    ], WuiListContent.prototype, "imageSrc", void 0);
    __decorate$1o([
        n$j()
    ], WuiListContent.prototype, "textTitle", void 0);
    __decorate$1o([
        n$j()
    ], WuiListContent.prototype, "textValue", void 0);
    WuiListContent = __decorate$1o([
        customElement('wui-list-content')
    ], WuiListContent);

    var styles$_ = i$h `
  button {
    column-gap: var(--wui-spacing-s);
    padding: 7px var(--wui-spacing-l) 7px var(--wui-spacing-xs);
    width: 100%;
    background-color: var(--wui-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
    color: var(--wui-color-fg-100);
  }

  button > wui-text:nth-child(2) {
    display: flex;
    flex: 1;
  }

  button[data-transparent='true'] {
    pointer-events: none;
    background-color: transparent;
  }

  wui-icon {
    color: var(--wui-color-fg-200) !important;
  }

  button:disabled {
    background-color: var(--wui-gray-glass-015);
    color: var(--wui-gray-glass-015);
  }

  button:disabled > wui-tag {
    background-color: var(--wui-gray-glass-010);
    color: var(--wui-color-fg-300);
  }
`;

    var __decorate$1n = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let WuiListNetwork = class WuiListNetwork extends s$e {
        constructor() {
            super(...arguments);
            this.imageSrc = '';
            this.name = '';
            this.disabled = false;
            this.transparent = false;
        }
        render() {
            return x$5 `
      <button data-transparent=${this.transparent} ?disabled=${this.disabled} ontouchstart>
        ${this.templateNetworkImage()}
        <wui-text variant="paragraph-500" color="inherit">${this.name}</wui-text>
      </button>
    `;
        }
        templateNetworkImage() {
            if (this.imageSrc) {
                return x$5 `<wui-network-image
        size="sm"
        imageSrc=${this.imageSrc}
        name=${this.name}
      ></wui-network-image>`;
            }
            if (!this.imageSrc) {
                return x$5 `<wui-network-image size="sm" name=${this.name}></wui-network-image>`;
            }
            return null;
        }
    };
    WuiListNetwork.styles = [resetStyles, elementStyles, styles$_];
    __decorate$1n([
        n$j()
    ], WuiListNetwork.prototype, "imageSrc", void 0);
    __decorate$1n([
        n$j()
    ], WuiListNetwork.prototype, "name", void 0);
    __decorate$1n([
        n$j({ type: Boolean })
    ], WuiListNetwork.prototype, "disabled", void 0);
    __decorate$1n([
        n$j({ type: Boolean })
    ], WuiListNetwork.prototype, "transparent", void 0);
    WuiListNetwork = __decorate$1n([
        customElement('wui-list-network')
    ], WuiListNetwork);

    var styles$Z = i$h `
  :host {
    display: flex;
    flex-direction: column;
    gap: var(--wui-spacing-l);
    padding: 17px 18px 17px var(--wui-spacing-m);
    width: 100%;
    background-color: var(--wui-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
    color: var(--wui-color-fg-250);
  }

  wui-image {
    width: var(--wui-icon-size-lg);
    height: var(--wui-icon-size-lg);
    border-radius: var(--wui-border-radius-3xl);
  }

  wui-icon {
    width: var(--wui-icon-size-lg);
    height: var(--wui-icon-size-lg);
  }
`;

    var __decorate$1m = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let WuiListWalletTransaction = class WuiListWalletTransaction extends s$e {
        constructor() {
            super(...arguments);
            this.amount = '';
            this.networkCurreny = '';
            this.networkImageUrl = '';
            this.receiverAddress = '';
            this.addressExplorerUrl = '';
        }
        render() {
            return x$5 `
      <wui-flex justifyContent="space-between" alignItems="center">
        <wui-text variant="paragraph-500" color="fg-200">Sending</wui-text>
        <wui-flex gap="xs" alignItems="center">
          <wui-text variant="paragraph-400" color="fg-100">
            ${this.amount} ${this.networkCurreny}
          </wui-text>
          ${this.templateNetworkVisual()}
        </wui-flex>
      </wui-flex>
      <wui-flex justifyContent="space-between" alignItems="center">
        <wui-text variant="paragraph-500" color="fg-200">To</wui-text>
        <wui-chip
          icon="externalLink"
          variant="shadeSmall"
          href=${this.addressExplorerUrl}
          title=${this.receiverAddress}
        ></wui-chip>
      </wui-flex>
    `;
        }
        templateNetworkVisual() {
            if (this.networkImageUrl) {
                return x$5 `<wui-image src=${this.networkImageUrl} alt="Network Image"></wui-image>`;
            }
            return x$5 `<wui-icon size="inherit" color="fg-200" name="networkPlaceholder"></wui-icon>`;
        }
    };
    WuiListWalletTransaction.styles = [resetStyles, elementStyles, styles$Z];
    __decorate$1m([
        n$j()
    ], WuiListWalletTransaction.prototype, "amount", void 0);
    __decorate$1m([
        n$j()
    ], WuiListWalletTransaction.prototype, "networkCurreny", void 0);
    __decorate$1m([
        n$j()
    ], WuiListWalletTransaction.prototype, "networkImageUrl", void 0);
    __decorate$1m([
        n$j()
    ], WuiListWalletTransaction.prototype, "receiverAddress", void 0);
    __decorate$1m([
        n$j()
    ], WuiListWalletTransaction.prototype, "addressExplorerUrl", void 0);
    WuiListWalletTransaction = __decorate$1m([
        customElement('wui-list-wallet-transaction')
    ], WuiListWalletTransaction);

    var styles$Y = i$h `
  :host {
    width: 100%;
  }

  :host > wui-flex {
    width: 100%;
    padding: var(--wui-spacing-s);
    border-radius: var(--wui-border-radius-xs);
    width: 100%;
    display: flex;
    align-items: center;
    justify-content: flex-start;
    gap: var(--wui-spacing-s);
  }

  :host > wui-flex:hover {
    background-color: var(--wui-gray-glass-002);
  }

  .purchase-image-container {
    display: flex;
    justify-content: center;
    align-items: center;
    position: relative;
    width: var(--wui-icon-box-size-lg);
    height: var(--wui-icon-box-size-lg);
  }

  .purchase-image-container wui-image {
    width: 100%;
    height: 100%;
    position: relative;
    border-radius: calc(var(--wui-icon-box-size-lg) / 2);
  }

  .purchase-image-container wui-image::after {
    content: '';
    display: block;
    width: 100%;
    height: 100%;
    position: absolute;
    inset: 0;
    border-radius: calc(var(--wui-icon-box-size-lg) / 2);
    box-shadow: inset 0 0 0 1px var(--wui-gray-glass-005);
  }

  .purchase-image-container wui-icon-box {
    position: absolute;
    right: 0;
    bottom: 0;
    transform: translate(20%, 20%);
  }
`;

    var __decorate$1l = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let WuiOnRampActivityItem = class WuiOnRampActivityItem extends s$e {
        constructor() {
            super(...arguments);
            this.disabled = false;
            this.color = 'inherit';
            this.label = 'Bought';
            this.purchaseValue = '';
            this.purchaseCurrency = '';
            this.date = '';
            this.completed = false;
            this.inProgress = false;
            this.failed = false;
            this.onClick = null;
            this.symbol = '';
        }
        firstUpdated() {
            if (!this.icon) {
                this.fetchTokenImage();
            }
        }
        render() {
            return x$5 `
      <wui-flex>
        ${this.imageTemplate()}
        <wui-flex flexDirection="column" gap="4xs" flexGrow="1">
          <wui-flex gap="xxs" alignItems="center" justifyContent="flex-start">
            ${this.statusIconTemplate()}
            <wui-text variant="paragraph-500" color="fg-100"> ${this.label}</wui-text>
          </wui-flex>
          <wui-text variant="small-400" color="fg-200">
            + ${this.purchaseValue} ${this.purchaseCurrency}
          </wui-text>
        </wui-flex>
        ${this.inProgress
            ? x$5 `<wui-loading-spinner color="fg-200" size="md"></wui-loading-spinner>`
            : x$5 `<wui-text variant="micro-700" color="fg-300"><span>${this.date}</span></wui-text>`}
      </wui-flex>
    `;
        }
        async fetchTokenImage() {
            await ApiController._fetchTokenImage(this.purchaseCurrency);
        }
        statusIconTemplate() {
            if (this.inProgress) {
                return null;
            }
            return this.completed ? this.boughtIconTemplate() : this.errorIconTemplate();
        }
        errorIconTemplate() {
            return x$5 `<wui-icon-box
      size="xxs"
      iconColor="error-100"
      backgroundColor="error-100"
      background="opaque"
      icon="close"
      borderColor="wui-color-bg-125"
    ></wui-icon-box>`;
        }
        imageTemplate() {
            const icon = this.icon || `https://avatar.vercel.sh/andrew.svg?size=50&text=${this.symbol}`;
            return x$5 `<wui-flex class="purchase-image-container">
      <wui-image src=${icon}></wui-image>
    </wui-flex>`;
        }
        boughtIconTemplate() {
            return x$5 `<wui-icon-box
      size="xxs"
      iconColor="success-100"
      backgroundColor="success-100"
      background="opaque"
      icon="arrowBottom"
      borderColor="wui-color-bg-125"
    ></wui-icon-box>`;
        }
    };
    WuiOnRampActivityItem.styles = [resetStyles, elementStyles, styles$Y];
    __decorate$1l([
        n$j({ type: Boolean })
    ], WuiOnRampActivityItem.prototype, "disabled", void 0);
    __decorate$1l([
        n$j()
    ], WuiOnRampActivityItem.prototype, "color", void 0);
    __decorate$1l([
        n$j()
    ], WuiOnRampActivityItem.prototype, "label", void 0);
    __decorate$1l([
        n$j()
    ], WuiOnRampActivityItem.prototype, "purchaseValue", void 0);
    __decorate$1l([
        n$j()
    ], WuiOnRampActivityItem.prototype, "purchaseCurrency", void 0);
    __decorate$1l([
        n$j()
    ], WuiOnRampActivityItem.prototype, "date", void 0);
    __decorate$1l([
        n$j({ type: Boolean })
    ], WuiOnRampActivityItem.prototype, "completed", void 0);
    __decorate$1l([
        n$j({ type: Boolean })
    ], WuiOnRampActivityItem.prototype, "inProgress", void 0);
    __decorate$1l([
        n$j({ type: Boolean })
    ], WuiOnRampActivityItem.prototype, "failed", void 0);
    __decorate$1l([
        n$j()
    ], WuiOnRampActivityItem.prototype, "onClick", void 0);
    __decorate$1l([
        n$j()
    ], WuiOnRampActivityItem.prototype, "symbol", void 0);
    __decorate$1l([
        n$j()
    ], WuiOnRampActivityItem.prototype, "icon", void 0);
    WuiOnRampActivityItem = __decorate$1l([
        customElement('wui-onramp-activity-item')
    ], WuiOnRampActivityItem);

    var styles$X = i$h `
  button {
    padding: var(--wui-spacing-s);
    border-radius: var(--wui-border-radius-xs);
    background-color: var(--wui-gray-glass-002);
    width: 100%;
    display: flex;
    align-items: center;
    justify-content: flex-start;
    gap: var(--wui-spacing-s);
    transition: background-color 0.2s linear;
  }

  button:hover {
    background-color: var(--wui-gray-glass-005);
  }

  .provider-image {
    width: var(--wui-spacing-3xl);
    min-width: var(--wui-spacing-3xl);
    height: var(--wui-spacing-3xl);
    border-radius: calc(var(--wui-border-radius-xs) - calc(var(--wui-spacing-s) / 2));
    position: relative;
    overflow: hidden;
  }

  .provider-image::after {
    content: '';
    display: block;
    width: 100%;
    height: 100%;
    position: absolute;
    inset: 0;
    border-radius: calc(var(--wui-border-radius-xs) - calc(var(--wui-spacing-s) / 2));
    box-shadow: inset 0 0 0 1px var(--wui-gray-glass-005);
  }

  .network-icon {
    width: var(--wui-spacing-m);
    height: var(--wui-spacing-m);
    border-radius: calc(var(--wui-spacing-m) / 2);
    overflow: hidden;
    box-shadow:
      0 0 0 3px var(--wui-gray-glass-002),
      0 0 0 3px var(--wui-color-modal-bg);
    transition: box-shadow 0.2s linear;
  }

  button:hover .network-icon {
    box-shadow:
      0 0 0 3px var(--wui-gray-glass-005),
      0 0 0 3px var(--wui-color-modal-bg);
  }
`;

    var __decorate$1k = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let WuiOnRampProviderItem = class WuiOnRampProviderItem extends s$e {
        constructor() {
            super(...arguments);
            this.disabled = false;
            this.color = 'inherit';
            this.label = '';
            this.feeRange = '';
            this.loading = false;
            this.onClick = null;
        }
        render() {
            return x$5 `
      <button ?disabled=${this.disabled} ontouchstart>
        <wui-visual name=${o$l(this.name)} class="provider-image"></wui-visual>
        <wui-flex flexDirection="column" gap="4xs">
          <wui-text variant="paragraph-500" color="fg-100">${this.label}</wui-text>
          <wui-flex alignItems="center" justifyContent="flex-start" gap="l">
            <wui-text variant="tiny-500" color="fg-100">
              <wui-text variant="tiny-400" color="fg-200">Fees</wui-text>
              ${this.feeRange}
            </wui-text>
            <wui-flex gap="xxs">
              <wui-icon name="bank" size="xs" color="fg-150"></wui-icon>
              <wui-icon name="card" size="xs" color="fg-150"></wui-icon>
            </wui-flex>
            ${this.networksTemplate()}
          </wui-flex>
        </wui-flex>
        ${this.loading
            ? x$5 `<wui-loading-spinner color="fg-200" size="md"></wui-loading-spinner>`
            : x$5 `<wui-icon name="chevronRight" color="fg-200" size="sm"></wui-icon>`}
      </button>
    `;
        }
        networksTemplate() {
            const networks = NetworkController.getRequestedCaipNetworks();
            const slicedNetworks = networks?.filter(network => network?.imageId)?.slice(0, 5);
            return x$5 `
      <wui-flex class="networks">
        ${slicedNetworks?.map(network => x$5 `
            <wui-flex class="network-icon">
              <wui-image src=${o$l(AssetUtil.getNetworkImage(network))}></wui-image>
            </wui-flex>
          `)}
      </wui-flex>
    `;
        }
    };
    WuiOnRampProviderItem.styles = [resetStyles, elementStyles, styles$X];
    __decorate$1k([
        n$j({ type: Boolean })
    ], WuiOnRampProviderItem.prototype, "disabled", void 0);
    __decorate$1k([
        n$j()
    ], WuiOnRampProviderItem.prototype, "color", void 0);
    __decorate$1k([
        n$j()
    ], WuiOnRampProviderItem.prototype, "name", void 0);
    __decorate$1k([
        n$j()
    ], WuiOnRampProviderItem.prototype, "label", void 0);
    __decorate$1k([
        n$j()
    ], WuiOnRampProviderItem.prototype, "feeRange", void 0);
    __decorate$1k([
        n$j({ type: Boolean })
    ], WuiOnRampProviderItem.prototype, "loading", void 0);
    __decorate$1k([
        n$j()
    ], WuiOnRampProviderItem.prototype, "onClick", void 0);
    WuiOnRampProviderItem = __decorate$1k([
        customElement('wui-onramp-provider-item')
    ], WuiOnRampProviderItem);

    var styles$W = i$h `
  button {
    display: flex;
    gap: var(--wui-spacing-3xs);
    align-items: center;
    padding: 6.25px var(--wui-spacing-xs) 7.25px var(--wui-spacing-s);
    background-color: var(--wui-gray-glass-090);
    border-radius: var(--wui-border-radius-3xl);
    border: 1px solid var(--wui-gray-glass-060);
  }

  @media (hover: hover) and (pointer: fine) {
    button:hover:enabled {
      background-color: var(--wui-gray-glass-080);
    }

    button:active:enabled {
      transition: all var(--wui-ease-out-power-2) var(--wui-duration-sm);
      background-color: var(--wui-gray-glass-060);
    }
  }
`;

    var __decorate$1j = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let WuiPromo = class WuiPromo extends s$e {
        constructor() {
            super(...arguments);
            this.text = '';
        }
        render() {
            return x$5 `<button ontouchstart>
      <wui-text variant="small-600" color="bg-100">${this.text}</wui-text>
      <wui-icon color="bg-100" size="xs" name="arrowRight"></wui-icon>
    </button>`;
        }
    };
    WuiPromo.styles = [resetStyles, elementStyles, styles$W];
    __decorate$1j([
        n$j()
    ], WuiPromo.prototype, "text", void 0);
    WuiPromo = __decorate$1j([
        customElement('wui-promo')
    ], WuiPromo);

    var styles$V = i$h `
  :host {
    position: relative;
  }
  button {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 48px;
    width: 100%;
    background-color: var(--wui-accent-glass-010);
    border-radius: var(--wui-border-radius-xs);
    border: 1px solid var(--wui-accent-glass-010);
  }

  wui-tooltip {
    padding: 7px var(--wui-spacing-s) 8px var(--wui-spacing-s);
    position: absolute;
    top: -8px;
    left: 50%;
    transform: translate(-50%, -100%);
    opacity: 0;
  }

  @media (hover: hover) and (pointer: fine) {
    button:hover:enabled {
      background-color: var(--wui-accent-glass-015);
    }

    button:active:enabled {
      background-color: var(--wui-accent-glass-020);
      transition: all var(--wui-ease-out-power-2) var(--wui-duration-sm);
    }
  }
`;

    var __decorate$1i = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let WuiTooltipSelect = class WuiTooltipSelect extends s$e {
        constructor() {
            super(...arguments);
            this.text = '';
            this.icon = 'card';
        }
        render() {
            return x$5 `<button
        @mouseenter=${this.onMouseEnter.bind(this)}
        @mouseleave=${this.onMouseLeave.bind(this)}
        ontouchstart
      >
        <wui-icon color="accent-100" name=${this.icon} size="lg"></wui-icon>
      </button>
      <wui-tooltip variant="shade" message=${this.text} placement="top"></wui-tooltip>`;
        }
        onMouseEnter() {
            const element = this.shadowRoot?.querySelector('wui-tooltip');
            if (element) {
                element?.animate([{ opacity: 0 }, { opacity: 1 }], {
                    fill: 'forwards',
                    easing: 'ease',
                    duration: 250
                });
            }
        }
        onMouseLeave() {
            const element = this.shadowRoot?.querySelector('wui-tooltip');
            if (element) {
                element?.animate([{ opacity: 1 }, { opacity: 0 }], {
                    fill: 'forwards',
                    easing: 'ease',
                    duration: 200
                });
            }
        }
    };
    WuiTooltipSelect.styles = [resetStyles, elementStyles, styles$V];
    __decorate$1i([
        n$j()
    ], WuiTooltipSelect.prototype, "text", void 0);
    __decorate$1i([
        n$j()
    ], WuiTooltipSelect.prototype, "icon", void 0);
    WuiTooltipSelect = __decorate$1i([
        customElement('wui-tooltip-select')
    ], WuiTooltipSelect);

    var styles$U = i$h `
  span {
    font-weight: 500;
    font-size: 40px;
    color: var(--wui-color-fg-100);
    line-height: 130%; /* 52px */
    letter-spacing: -1.6px;
    text-align: center;
  }

  .pennies {
    color: var(--wui-color-fg-200);
  }
`;

    var __decorate$1h = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let WuiBalance = class WuiBalance extends s$e {
        constructor() {
            super(...arguments);
            this.dollars = '0';
            this.pennies = '00';
        }
        render() {
            return x$5 `<span>$${this.dollars}<span class="pennies">.${this.pennies}</span></span>`;
        }
    };
    WuiBalance.styles = [resetStyles, styles$U];
    __decorate$1h([
        n$j()
    ], WuiBalance.prototype, "dollars", void 0);
    __decorate$1h([
        n$j()
    ], WuiBalance.prototype, "pennies", void 0);
    WuiBalance = __decorate$1h([
        customElement('wui-balance')
    ], WuiBalance);

    var styles$T = i$h `
  button {
    background-color: var(--wui-gray-glass-002);
    border-radius: var(--wui-border-radius-3xl);
    border: 1px solid var(--wui-gray-glass-002);
    padding: var(--wui-spacing-xs) var(--wui-spacing-s) var(--wui-spacing-xs) var(--wui-spacing-xs);
    position: relative;
  }

  wui-avatar {
    width: 32px;
    height: 32px;
    box-shadow: 0 0 0 0;
    outline: 3px solid var(--wui-gray-glass-005);
  }

  wui-icon-box,
  wui-image {
    width: 16px;
    height: 16px;
    border-radius: var(--wui-border-radius-3xl);
    position: absolute;
    left: 26px;
    top: 24px;
  }

  wui-image {
    outline: 2px solid var(--wui-color-bg-125);
  }

  wui-icon-box {
    outline: 2px solid var(--wui-color-bg-200);
    background-color: var(--wui-color-bg-250);
  }
`;

    var __decorate$1g = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let WuiProfileButton = class WuiProfileButton extends s$e {
        constructor() {
            super(...arguments);
            this.networkSrc = undefined;
            this.avatarSrc = undefined;
            this.isProfileName = false;
            this.address = '';
            this.icon = 'chevronBottom';
        }
        render() {
            return x$5 ` <button ontouchstart>
      <wui-flex gap="xs" alignItems="center">
        <wui-avatar
          .imageSrc=${this.avatarSrc}
          alt=${this.address}
          address=${this.address}
        ></wui-avatar>
        ${this.networkImageTemplate()}
        <wui-flex gap="xs" alignItems="center">
          <wui-text variant="large-600" color="fg-100">
            ${UiHelperUtil.getTruncateString({
            string: this.address,
            charsStart: this.isProfileName ? 18 : 4,
            charsEnd: this.isProfileName ? 0 : 4,
            truncate: this.isProfileName ? 'end' : 'middle'
        })}
          </wui-text>
          <wui-icon size="sm" color="fg-200" name=${this.icon}></wui-icon>
        </wui-flex>
      </wui-flex>
    </button>`;
        }
        networkImageTemplate() {
            if (this.networkSrc) {
                return x$5 `<wui-image src=${this.networkSrc}></wui-image>`;
            }
            return x$5 `
      <wui-icon-box
        size="xxs"
        iconColor="fg-200"
        backgroundColor="bg-100"
        icon="networkPlaceholder"
      ></wui-icon-box>
    `;
        }
    };
    WuiProfileButton.styles = [resetStyles, elementStyles, styles$T];
    __decorate$1g([
        n$j()
    ], WuiProfileButton.prototype, "networkSrc", void 0);
    __decorate$1g([
        n$j()
    ], WuiProfileButton.prototype, "avatarSrc", void 0);
    __decorate$1g([
        n$j({ type: Boolean })
    ], WuiProfileButton.prototype, "isProfileName", void 0);
    __decorate$1g([
        n$j()
    ], WuiProfileButton.prototype, "address", void 0);
    __decorate$1g([
        n$j()
    ], WuiProfileButton.prototype, "icon", void 0);
    WuiProfileButton = __decorate$1g([
        customElement('wui-profile-button')
    ], WuiProfileButton);

    var styles$S = i$h `
  button {
    border: 1px solid var(--wui-gray-glass-010);
    border-radius: var(--wui-border-radius-3xl);
  }

  wui-image {
    border-radius: var(--wui-border-radius-3xl);
    overflow: hidden;
  }

  button.disabled > wui-icon,
  button.disabled > wui-image {
    filter: grayscale(1);
  }

  button[data-variant='fill'] {
    color: var(--wui-color-inverse-100);
    background-color: var(--wui-color-accent-100);
  }

  button[data-variant='shade'],
  button[data-variant='shadeSmall'] {
    background-color: transparent;
    background-color: var(--wui-gray-glass-010);
    color: var(--wui-color-fg-200);
  }

  button[data-variant='success'] {
    column-gap: var(--wui-spacing-xxs);
    border: 1px solid var(--wui-success-glass-010);
    background-color: var(--wui-success-glass-010);
    color: var(--wui-color-success-100);
  }

  button[data-variant='error'] {
    column-gap: var(--wui-spacing-xxs);
    border: 1px solid var(--wui-error-glass-010);
    background-color: var(--wui-error-glass-010);
    color: var(--wui-color-error-100);
  }

  button[data-variant='transparent'] {
    column-gap: var(--wui-spacing-xxs);
    background-color: transparent;
    color: var(--wui-color-fg-150);
  }

  button[data-variant='transparent'],
  button[data-variant='success'],
  button[data-variant='shadeSmall'],
  button[data-variant='error'] {
    padding: 7px var(--wui-spacing-s) 7px 8px;
  }

  button[data-variant='transparent']:has(wui-text:first-child),
  button[data-variant='success']:has(wui-text:first-child),
  button[data-variant='shadeSmall']:has(wui-text:first-child),
  button[data-variant='error']:has(wui-text:first-child) {
    padding: 7px var(--wui-spacing-s);
  }

  button[data-variant='fill'],
  button[data-variant='shade'] {
    column-gap: var(--wui-spacing-xs);
    padding: var(--wui-spacing-xxs) var(--wui-spacing-m) var(--wui-spacing-xxs)
      var(--wui-spacing-xs);
  }

  button[data-variant='fill']:has(wui-text:first-child),
  button[data-variant='shade']:has(wui-text:first-child) {
    padding: 9px var(--wui-spacing-m) 9px var(--wui-spacing-m);
  }

  button[data-variant='fill'] > wui-image,
  button[data-variant='shade'] > wui-image {
    width: 24px;
    height: 24px;
  }

  button[data-variant='fill'] > wui-image {
    box-shadow: inset 0 0 0 1px var(--wui-color-accent-090);
  }

  button[data-variant='shade'] > wui-image,
  button[data-variant='shadeSmall'] > wui-image {
    box-shadow: inset 0 0 0 1px var(--wui-gray-glass-010);
  }

  button[data-variant='fill'] > wui-icon,
  button[data-variant='shade'] > wui-icon {
    width: 14px;
    height: 14px;
  }

  button[data-variant='transparent'] > wui-image,
  button[data-variant='success'] > wui-image,
  button[data-variant='shadeSmall'] > wui-image,
  button[data-variant='error'] > wui-image {
    width: 14px;
    height: 14px;
  }

  button[data-variant='transparent'] > wui-icon,
  button[data-variant='success'] > wui-icon,
  button[data-variant='shadeSmall'] > wui-icon,
  button[data-variant='error'] > wui-icon {
    width: 12px;
    height: 12px;
  }

  button[data-variant='fill']:focus-visible {
    background-color: var(--wui-color-accent-090);
  }

  button[data-variant='shade']:focus-visible,
  button[data-variant='shadeSmall']:focus-visible {
    background-color: var(--wui-gray-glass-015);
  }

  button[data-variant='transparent']:focus-visible {
    background-color: var(--wui-gray-glass-005);
  }

  button[data-variant='success']:focus-visible {
    background-color: var(--wui-success-glass-015);
  }

  button[data-variant='error']:focus-visible {
    background-color: var(--wui-error-glass-015);
  }

  button.disabled {
    color: var(--wui-gray-glass-015);
    background-color: var(--wui-gray-glass-015);
    pointer-events: none;
  }

  @media (hover: hover) and (pointer: fine) {
    button[data-variant='fill']:hover {
      background-color: var(--wui-color-accent-090);
    }

    button[data-variant='shade']:hover,
    button[data-variant='shadeSmall']:hover {
      background-color: var(--wui-gray-glass-015);
    }

    button[data-variant='transparent']:hover {
      background-color: var(--wui-gray-glass-005);
    }

    button[data-variant='success']:hover {
      background-color: var(--wui-success-glass-015);
    }

    button[data-variant='error']:hover {
      background-color: var(--wui-error-glass-015);
    }
  }

  button[data-variant='fill']:active {
    background-color: var(--wui-color-accent-080);
  }

  button[data-variant='shade']:active,
  button[data-variant='shadeSmall']:active {
    background-color: var(--wui-gray-glass-020);
  }

  button[data-variant='transparent']:active {
    background-color: var(--wui-gray-glass-010);
  }

  button[data-variant='success']:active {
    background-color: var(--wui-success-glass-020);
  }

  button[data-variant='error']:active {
    background-color: var(--wui-error-glass-020);
  }
`;

    var __decorate$1f = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let WuiChipButton = class WuiChipButton extends s$e {
        constructor() {
            super(...arguments);
            this.variant = 'fill';
            this.imageSrc = '';
            this.disabled = false;
            this.icon = 'externalLink';
            this.text = '';
        }
        render() {
            const isSmall = this.variant === 'success' || this.variant === 'transparent' || this.variant === 'shadeSmall';
            const textVariant = isSmall ? 'small-600' : 'paragraph-600';
            return x$5 `
      <button class=${this.disabled ? 'disabled' : ''} data-variant=${this.variant}>
        <wui-image src=${this.imageSrc}></wui-image>
        <wui-text variant=${textVariant} color="inherit"> ${this.text} </wui-text>
        <wui-icon name=${this.icon} color="inherit" size="inherit"></wui-icon>
      </button>
    `;
        }
    };
    WuiChipButton.styles = [resetStyles, elementStyles, styles$S];
    __decorate$1f([
        n$j()
    ], WuiChipButton.prototype, "variant", void 0);
    __decorate$1f([
        n$j()
    ], WuiChipButton.prototype, "imageSrc", void 0);
    __decorate$1f([
        n$j({ type: Boolean })
    ], WuiChipButton.prototype, "disabled", void 0);
    __decorate$1f([
        n$j()
    ], WuiChipButton.prototype, "icon", void 0);
    __decorate$1f([
        n$j()
    ], WuiChipButton.prototype, "text", void 0);
    WuiChipButton = __decorate$1f([
        customElement('wui-chip-button')
    ], WuiChipButton);

    var styles$R = i$h `
  button {
    display: flex;
    gap: var(--wui-spacing-xl);
    width: 100%;
    background-color: var(--wui-gray-glass-002);
    border-radius: var(--wui-border-radius-xxs);
    padding: var(--wui-spacing-m) var(--wui-spacing-s);
  }

  wui-text {
    width: 100%;
  }

  wui-flex {
    width: auto;
  }

  .network-icon {
    width: var(--wui-spacing-2l);
    height: var(--wui-spacing-2l);
    border-radius: calc(var(--wui-spacing-2l) / 2);
    overflow: hidden;
    box-shadow:
      0 0 0 3px var(--wui-gray-glass-002),
      0 0 0 3px var(--wui-color-modal-bg);
  }
`;

    var __decorate$1e = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let WuiCompatibleNetwork = class WuiCompatibleNetwork extends s$e {
        constructor() {
            super(...arguments);
            this.networkImages = [''];
            this.text = '';
        }
        render() {
            return x$5 `
      <button ontouchstart>
        <wui-text variant="small-400" color="fg-200">${this.text}</wui-text>
        <wui-flex gap="3xs" alignItems="center">
          ${this.networksTemplate()}
          <wui-icon name="chevronRight" size="sm" color="fg-200"></wui-icon>
        </wui-flex>
      </button>
    `;
        }
        networksTemplate() {
            const slicedNetworks = this.networkImages.slice(0, 5);
            return x$5 ` <wui-flex class="networks">
      ${slicedNetworks?.map(network => x$5 ` <wui-flex class="network-icon"> <wui-image src=${network}></wui-image> </wui-flex>`)}
    </wui-flex>`;
        }
    };
    WuiCompatibleNetwork.styles = [resetStyles, elementStyles, styles$R];
    __decorate$1e([
        n$j({ type: Array })
    ], WuiCompatibleNetwork.prototype, "networkImages", void 0);
    __decorate$1e([
        n$j()
    ], WuiCompatibleNetwork.prototype, "text", void 0);
    WuiCompatibleNetwork = __decorate$1e([
        customElement('wui-compatible-network')
    ], WuiCompatibleNetwork);

    var styles$Q = i$h `
  wui-flex {
    width: 100%;
    background-color: var(--wui-gray-glass-005);
    border-radius: var(--wui-border-radius-s);
    padding: var(--wui-spacing-1xs) var(--wui-spacing-s) var(--wui-spacing-1xs)
      var(--wui-spacing-1xs);
  }
`;

    var __decorate$1d = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let WuiBanner = class WuiBanner extends s$e {
        constructor() {
            super(...arguments);
            this.icon = 'externalLink';
            this.text = '';
        }
        render() {
            return x$5 `
      <wui-flex gap="1xs" alignItems="center">
        <wui-icon-box
          size="sm"
          iconcolor="fg-200"
          backgroundcolor="fg-200"
          icon=${this.icon}
          background="transparent"
        ></wui-icon-box>
        <wui-text variant="small-400" color="fg-200">${this.text}</wui-text>
      </wui-flex>
    `;
        }
    };
    WuiBanner.styles = [resetStyles, elementStyles, styles$Q];
    __decorate$1d([
        n$j()
    ], WuiBanner.prototype, "icon", void 0);
    __decorate$1d([
        n$j()
    ], WuiBanner.prototype, "text", void 0);
    WuiBanner = __decorate$1d([
        customElement('wui-banner')
    ], WuiBanner);

    var styles$P = i$h `
  button {
    padding: 6.5px var(--wui-spacing-l) 6.5px var(--wui-spacing-xs);
    display: flex;
    justify-content: space-between;
    width: 100%;
    border-radius: var(--wui-border-radius-xs);
    background-color: var(--wui-gray-glass-002);
  }

  button[data-clickable='false'] {
    pointer-events: none;
    background-color: transparent;
  }

  wui-image {
    width: var(--wui-spacing-3xl);
    height: var(--wui-spacing-3xl);
    border-radius: var(--wui-border-radius-3xl);
  }
`;

    var __decorate$1c = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let WuiListToken = class WuiListToken extends s$e {
        constructor() {
            super(...arguments);
            this.tokenName = '';
            this.tokenImageUrl = '';
            this.tokenValue = 0.0;
            this.tokenAmount = '0.0';
            this.tokenCurrency = '';
            this.clickable = false;
        }
        render() {
            return x$5 `
      <button data-clickable=${String(this.clickable)} ontouchstart>
        <wui-flex gap="s" alignItems="center">
          <wui-image alt=${this.tokenName} src=${this.tokenImageUrl}></wui-image>
          <wui-flex flexDirection="column" justifyContent="spaceBetween">
            <wui-text variant="paragraph-500" color="fg-100">${this.tokenName}</wui-text>
            <wui-text variant="small-400" color="fg-200"
              >${UiHelperUtil.roundNumber(Number(this.tokenAmount), 6, 5)}
              ${this.tokenCurrency}</wui-text
            ></wui-flex
          >
        </wui-flex>
        <wui-text variant="paragraph-500" color="fg-100">$${this.tokenValue.toFixed(2)}</wui-text>
      </button>
    `;
        }
    };
    WuiListToken.styles = [resetStyles, elementStyles, styles$P];
    __decorate$1c([
        n$j()
    ], WuiListToken.prototype, "tokenName", void 0);
    __decorate$1c([
        n$j()
    ], WuiListToken.prototype, "tokenImageUrl", void 0);
    __decorate$1c([
        n$j({ type: Number })
    ], WuiListToken.prototype, "tokenValue", void 0);
    __decorate$1c([
        n$j()
    ], WuiListToken.prototype, "tokenAmount", void 0);
    __decorate$1c([
        n$j()
    ], WuiListToken.prototype, "tokenCurrency", void 0);
    __decorate$1c([
        n$j({ type: Boolean })
    ], WuiListToken.prototype, "clickable", void 0);
    WuiListToken = __decorate$1c([
        customElement('wui-list-token')
    ], WuiListToken);

    var styles$O = i$h `
  button {
    width: 100%;
    display: flex;
    gap: var(--wui-spacing-s);
    align-items: center;
    justify-content: flex-start;
    padding: var(--wui-spacing-s) var(--wui-spacing-m) var(--wui-spacing-s) var(--wui-spacing-s);
    background-color: var(--wui-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
  }

  wui-icon-box {
    width: var(--wui-spacing-2xl);
    height: var(--wui-spacing-2xl);
  }

  wui-flex {
    width: auto;
  }
`;

    var __decorate$1b = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let WuiListDescription = class WuiListDescription extends s$e {
        constructor() {
            super(...arguments);
            this.icon = 'card';
            this.text = '';
            this.description = '';
            this.tag = undefined;
            this.iconBackgroundColor = 'accent-100';
            this.iconColor = 'accent-100';
            this.disabled = false;
        }
        render() {
            return x$5 `
      <button ontouchstart ?disabled=${this.disabled}>
        <wui-icon-box
          iconColor=${this.iconColor}
          backgroundColor=${this.iconBackgroundColor}
          size="inherit"
          icon=${this.icon}
          iconSize="md"
        ></wui-icon-box>
        <wui-flex flexDirection="column" justifyContent="spaceBetween">
          ${this.titleTemplate()}
          <wui-text variant="small-400" color="fg-200"> ${this.description}</wui-text></wui-flex
        >
      </button>
    `;
        }
        titleTemplate() {
            if (this.tag) {
                return x$5 ` <wui-flex alignItems="center" gap="xxs"
        ><wui-text variant="paragraph-500" color="fg-100">${this.text}</wui-text
        ><wui-tag tagType="main" size="md">${this.tag}</wui-tag>
      </wui-flex>`;
            }
            return x$5 `<wui-text variant="paragraph-500" color="fg-100">${this.text}</wui-text>`;
        }
    };
    WuiListDescription.styles = [resetStyles, elementStyles, styles$O];
    __decorate$1b([
        n$j()
    ], WuiListDescription.prototype, "icon", void 0);
    __decorate$1b([
        n$j()
    ], WuiListDescription.prototype, "text", void 0);
    __decorate$1b([
        n$j()
    ], WuiListDescription.prototype, "description", void 0);
    __decorate$1b([
        n$j()
    ], WuiListDescription.prototype, "tag", void 0);
    __decorate$1b([
        n$j()
    ], WuiListDescription.prototype, "iconBackgroundColor", void 0);
    __decorate$1b([
        n$j()
    ], WuiListDescription.prototype, "iconColor", void 0);
    __decorate$1b([
        n$j({ type: Boolean })
    ], WuiListDescription.prototype, "disabled", void 0);
    WuiListDescription = __decorate$1b([
        customElement('wui-list-description')
    ], WuiListDescription);

    var styles$N = i$h `
  :host {
    position: relative;
    display: inline-block;
  }

  input {
    background: transparent;
    width: 100%;
    height: auto;
    font-family: var(--wui-font-family);
    color: var(--wui-color-fg-100);

    font-feature-settings: 'case' on;
    font-size: 32px;
    font-weight: var(--wui-font-weight-light);
    caret-color: var(--wui-color-accent-100);
    line-height: 130%;
    letter-spacing: -1.28px;
    box-sizing: border-box;
    -webkit-appearance: none;
    -moz-appearance: textfield;
    padding: 0px;
  }

  input::-webkit-outer-spin-button,
  input::-webkit-inner-spin-button {
    -webkit-appearance: none;
    margin: 0;
  }

  input::placeholder {
    color: var(--wui-color-fg-275);
  }
`;

    const specialCharactersRegex = /[.*+?^${}()|[\]\\]/gu;
    const numbersRegex = /[0-9,.]/u;

    var __decorate$1a = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let WuiInputAmount = class WuiInputAmount extends s$e {
        constructor() {
            super(...arguments);
            this.inputElementRef = e$g();
            this.disabled = false;
            this.value = '';
            this.placeholder = '0';
        }
        render() {
            if (this.inputElementRef?.value && this.value) {
                this.inputElementRef.value.value = this.value;
            }
            return x$5 `<input
      ${n$h(this.inputElementRef)}
      type="text"
      inputmode="numeric"
      pattern="[0-9,.]*"
      placeholder=${this.placeholder}
      ?disabled=${this.disabled}
      autofocus
      value=${this.value ?? ''}
      @input=${this.dispatchInputChangeEvent.bind(this)}
    /> `;
        }
        dispatchInputChangeEvent(e) {
            const inputChar = e.data;
            if (inputChar) {
                if (!numbersRegex.test(inputChar) && this.inputElementRef?.value) {
                    this.inputElementRef.value.value = this.value.replace(new RegExp(inputChar.replace(specialCharactersRegex, '\\$&'), 'gu'), '');
                }
            }
            this.dispatchEvent(new CustomEvent('inputChange', {
                detail: this.inputElementRef.value?.value,
                bubbles: true,
                composed: true
            }));
        }
    };
    WuiInputAmount.styles = [resetStyles, elementStyles, styles$N];
    __decorate$1a([
        n$j({ type: Boolean })
    ], WuiInputAmount.prototype, "disabled", void 0);
    __decorate$1a([
        n$j({ type: String })
    ], WuiInputAmount.prototype, "value", void 0);
    __decorate$1a([
        n$j({ type: String })
    ], WuiInputAmount.prototype, "placeholder", void 0);
    WuiInputAmount = __decorate$1a([
        customElement('wui-input-amount')
    ], WuiInputAmount);

    var styles$M = i$h `
  :host {
    display: block;
  }

  :host > button {
    gap: var(--wui-spacing-xxs);
    padding: var(--wui-spacing-xs);
    padding-right: var(--wui-spacing-1xs);
    height: 40px;
    border-radius: var(--wui-border-radius-3xl);
    background: var(--wui-gray-glass-002);
    box-shadow: inset 0 0 0 1px var(--wui-gray-glass-002);
  }

  :host > button wui-image {
    width: 24px;
    height: 24px;
    border-radius: var(--wui-border-radius-s);
    box-shadow: inset 0 0 0 1px var(--wui-gray-glass-010);
  }
`;

    var __decorate$19 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let WuiTokenButton = class WuiTokenButton extends s$e {
        constructor() {
            super(...arguments);
            this.text = '';
        }
        render() {
            return x$5 `
      <button ontouchstart>
        ${this.tokenTemplate()}
        <wui-text variant="paragraph-600" color="fg-100">${this.text}</wui-text>
      </button>
    `;
        }
        tokenTemplate() {
            if (this.imageSrc) {
                return x$5 `<wui-image src=${this.imageSrc}></wui-image>`;
            }
            return x$5 `
      <wui-icon-box
        size="sm"
        iconColor="fg-200"
        backgroundColor="fg-300"
        icon="networkPlaceholder"
      ></wui-icon-box>
    `;
        }
    };
    WuiTokenButton.styles = [resetStyles, elementStyles, styles$M];
    __decorate$19([
        n$j()
    ], WuiTokenButton.prototype, "imageSrc", void 0);
    __decorate$19([
        n$j()
    ], WuiTokenButton.prototype, "text", void 0);
    WuiTokenButton = __decorate$19([
        customElement('wui-token-button')
    ], WuiTokenButton);

    var styles$L = i$h `
  :host {
    display: flex;
    gap: var(--wui-spacing-xs);
    border-radius: var(--wui-border-radius-3xl);
    border: 1px solid var(--wui-gray-glass-002);
    background: var(--wui-gray-glass-002);
    padding: var(--wui-spacing-2xs) var(--wui-spacing-xs) var(--wui-spacing-2xs)
      var(--wui-spacing-s);
    align-items: center;
  }

  wui-avatar,
  wui-icon,
  wui-image {
    width: 32px;
    height: 32px;
    border: 1px solid var(--wui-gray-glass-002);
    border-radius: var(--wui-border-radius-3xl);
    box-shadow: 0 0 0 2px var(--wui-gray-glass-002);
  }
`;

    var __decorate$18 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let WuiPreviewItem = class WuiPreviewItem extends s$e {
        constructor() {
            super(...arguments);
            this.text = '';
            this.address = '';
            this.isAddress = false;
        }
        render() {
            return x$5 `<wui-text variant="large-500" color="fg-100">${this.text}</wui-text>
      ${this.imageTemplate()}`;
        }
        imageTemplate() {
            if (this.isAddress) {
                return x$5 `<wui-avatar address=${this.address} .imageSrc=${this.imageSrc}></wui-avatar>`;
            }
            else if (this.imageSrc) {
                return x$5 `<wui-image src=${this.imageSrc}></wui-image>`;
            }
            return x$5 `<wui-icon size="inherit" color="fg-200" name="networkPlaceholder"></wui-icon>`;
        }
    };
    WuiPreviewItem.styles = [resetStyles, elementStyles, styles$L];
    __decorate$18([
        n$j()
    ], WuiPreviewItem.prototype, "text", void 0);
    __decorate$18([
        n$j()
    ], WuiPreviewItem.prototype, "address", void 0);
    __decorate$18([
        n$j()
    ], WuiPreviewItem.prototype, "imageSrc", void 0);
    __decorate$18([
        n$j({ type: Boolean })
    ], WuiPreviewItem.prototype, "isAddress", void 0);
    WuiPreviewItem = __decorate$18([
        customElement('wui-preview-item')
    ], WuiPreviewItem);

    var styles$K = i$h `
  :host {
    display: grid;
    width: inherit;
    height: inherit;
  }
`;

    var __decorate$17 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let WuiGrid = class WuiGrid extends s$e {
        render() {
            this.style.cssText = `
      grid-template-rows: ${this.gridTemplateRows};
      grid-template-columns: ${this.gridTemplateColumns};
      justify-items: ${this.justifyItems};
      align-items: ${this.alignItems};
      justify-content: ${this.justifyContent};
      align-content: ${this.alignContent};
      column-gap: ${this.columnGap && `var(--wui-spacing-${this.columnGap})`};
      row-gap: ${this.rowGap && `var(--wui-spacing-${this.rowGap})`};
      gap: ${this.gap && `var(--wui-spacing-${this.gap})`};
      padding-top: ${this.padding && UiHelperUtil.getSpacingStyles(this.padding, 0)};
      padding-right: ${this.padding && UiHelperUtil.getSpacingStyles(this.padding, 1)};
      padding-bottom: ${this.padding && UiHelperUtil.getSpacingStyles(this.padding, 2)};
      padding-left: ${this.padding && UiHelperUtil.getSpacingStyles(this.padding, 3)};
      margin-top: ${this.margin && UiHelperUtil.getSpacingStyles(this.margin, 0)};
      margin-right: ${this.margin && UiHelperUtil.getSpacingStyles(this.margin, 1)};
      margin-bottom: ${this.margin && UiHelperUtil.getSpacingStyles(this.margin, 2)};
      margin-left: ${this.margin && UiHelperUtil.getSpacingStyles(this.margin, 3)};
    `;
            return x$5 `<slot></slot>`;
        }
    };
    WuiGrid.styles = [resetStyles, styles$K];
    __decorate$17([
        n$j()
    ], WuiGrid.prototype, "gridTemplateRows", void 0);
    __decorate$17([
        n$j()
    ], WuiGrid.prototype, "gridTemplateColumns", void 0);
    __decorate$17([
        n$j()
    ], WuiGrid.prototype, "justifyItems", void 0);
    __decorate$17([
        n$j()
    ], WuiGrid.prototype, "alignItems", void 0);
    __decorate$17([
        n$j()
    ], WuiGrid.prototype, "justifyContent", void 0);
    __decorate$17([
        n$j()
    ], WuiGrid.prototype, "alignContent", void 0);
    __decorate$17([
        n$j()
    ], WuiGrid.prototype, "columnGap", void 0);
    __decorate$17([
        n$j()
    ], WuiGrid.prototype, "rowGap", void 0);
    __decorate$17([
        n$j()
    ], WuiGrid.prototype, "gap", void 0);
    __decorate$17([
        n$j()
    ], WuiGrid.prototype, "padding", void 0);
    __decorate$17([
        n$j()
    ], WuiGrid.prototype, "margin", void 0);
    WuiGrid = __decorate$17([
        customElement('wui-grid')
    ], WuiGrid);

    var styles$J = i$h `
  :host {
    position: relative;
    display: flex;
    width: 100%;
    height: 1px;
    background-color: var(--wui-gray-glass-005);
    justify-content: center;
    align-items: center;
  }

  :host > wui-text {
    position: absolute;
    padding: 0px 10px;
    background-color: var(--wui-color-modal-bg);
  }
`;

    var __decorate$16 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let WuiSeparator = class WuiSeparator extends s$e {
        constructor() {
            super(...arguments);
            this.text = '';
        }
        render() {
            return x$5 `${this.template()}`;
        }
        template() {
            if (this.text) {
                return x$5 `<wui-text variant="small-500" color="fg-200">${this.text}</wui-text>`;
            }
            return null;
        }
    };
    WuiSeparator.styles = [resetStyles, styles$J];
    __decorate$16([
        n$j()
    ], WuiSeparator.prototype, "text", void 0);
    WuiSeparator = __decorate$16([
        customElement('wui-separator')
    ], WuiSeparator);

    var dayjs_min = {exports: {}};

    (function (module, exports) {
    	!function(t,e){module.exports=e();}(commonjsGlobal,(function(){var t=1e3,e=6e4,n=36e5,r="millisecond",i="second",s="minute",u="hour",a="day",o="week",c="month",f="quarter",h="year",d="date",l="Invalid Date",$=/^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/,y=/\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,M={name:"en",weekdays:"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),months:"January_February_March_April_May_June_July_August_September_October_November_December".split("_"),ordinal:function(t){var e=["th","st","nd","rd"],n=t%100;return "["+t+(e[(n-20)%10]||e[n]||e[0])+"]"}},m=function(t,e,n){var r=String(t);return !r||r.length>=e?t:""+Array(e+1-r.length).join(n)+t},v={s:m,z:function(t){var e=-t.utcOffset(),n=Math.abs(e),r=Math.floor(n/60),i=n%60;return (e<=0?"+":"-")+m(r,2,"0")+":"+m(i,2,"0")},m:function t(e,n){if(e.date()<n.date())return -t(n,e);var r=12*(n.year()-e.year())+(n.month()-e.month()),i=e.clone().add(r,c),s=n-i<0,u=e.clone().add(r+(s?-1:1),c);return +(-(r+(n-i)/(s?i-u:u-i))||0)},a:function(t){return t<0?Math.ceil(t)||0:Math.floor(t)},p:function(t){return {M:c,y:h,w:o,d:a,D:d,h:u,m:s,s:i,ms:r,Q:f}[t]||String(t||"").toLowerCase().replace(/s$/,"")},u:function(t){return void 0===t}},g="en",D={};D[g]=M;var p="$isDayjsObject",S=function(t){return t instanceof _||!(!t||!t[p])},w=function t(e,n,r){var i;if(!e)return g;if("string"==typeof e){var s=e.toLowerCase();D[s]&&(i=s),n&&(D[s]=n,i=s);var u=e.split("-");if(!i&&u.length>1)return t(u[0])}else {var a=e.name;D[a]=e,i=a;}return !r&&i&&(g=i),i||!r&&g},O=function(t,e){if(S(t))return t.clone();var n="object"==typeof e?e:{};return n.date=t,n.args=arguments,new _(n)},b=v;b.l=w,b.i=S,b.w=function(t,e){return O(t,{locale:e.$L,utc:e.$u,x:e.$x,$offset:e.$offset})};var _=function(){function M(t){this.$L=w(t.locale,null,!0),this.parse(t),this.$x=this.$x||t.x||{},this[p]=!0;}var m=M.prototype;return m.parse=function(t){this.$d=function(t){var e=t.date,n=t.utc;if(null===e)return new Date(NaN);if(b.u(e))return new Date;if(e instanceof Date)return new Date(e);if("string"==typeof e&&!/Z$/i.test(e)){var r=e.match($);if(r){var i=r[2]-1||0,s=(r[7]||"0").substring(0,3);return n?new Date(Date.UTC(r[1],i,r[3]||1,r[4]||0,r[5]||0,r[6]||0,s)):new Date(r[1],i,r[3]||1,r[4]||0,r[5]||0,r[6]||0,s)}}return new Date(e)}(t),this.init();},m.init=function(){var t=this.$d;this.$y=t.getFullYear(),this.$M=t.getMonth(),this.$D=t.getDate(),this.$W=t.getDay(),this.$H=t.getHours(),this.$m=t.getMinutes(),this.$s=t.getSeconds(),this.$ms=t.getMilliseconds();},m.$utils=function(){return b},m.isValid=function(){return !(this.$d.toString()===l)},m.isSame=function(t,e){var n=O(t);return this.startOf(e)<=n&&n<=this.endOf(e)},m.isAfter=function(t,e){return O(t)<this.startOf(e)},m.isBefore=function(t,e){return this.endOf(e)<O(t)},m.$g=function(t,e,n){return b.u(t)?this[e]:this.set(n,t)},m.unix=function(){return Math.floor(this.valueOf()/1e3)},m.valueOf=function(){return this.$d.getTime()},m.startOf=function(t,e){var n=this,r=!!b.u(e)||e,f=b.p(t),l=function(t,e){var i=b.w(n.$u?Date.UTC(n.$y,e,t):new Date(n.$y,e,t),n);return r?i:i.endOf(a)},$=function(t,e){return b.w(n.toDate()[t].apply(n.toDate("s"),(r?[0,0,0,0]:[23,59,59,999]).slice(e)),n)},y=this.$W,M=this.$M,m=this.$D,v="set"+(this.$u?"UTC":"");switch(f){case h:return r?l(1,0):l(31,11);case c:return r?l(1,M):l(0,M+1);case o:var g=this.$locale().weekStart||0,D=(y<g?y+7:y)-g;return l(r?m-D:m+(6-D),M);case a:case d:return $(v+"Hours",0);case u:return $(v+"Minutes",1);case s:return $(v+"Seconds",2);case i:return $(v+"Milliseconds",3);default:return this.clone()}},m.endOf=function(t){return this.startOf(t,!1)},m.$set=function(t,e){var n,o=b.p(t),f="set"+(this.$u?"UTC":""),l=(n={},n[a]=f+"Date",n[d]=f+"Date",n[c]=f+"Month",n[h]=f+"FullYear",n[u]=f+"Hours",n[s]=f+"Minutes",n[i]=f+"Seconds",n[r]=f+"Milliseconds",n)[o],$=o===a?this.$D+(e-this.$W):e;if(o===c||o===h){var y=this.clone().set(d,1);y.$d[l]($),y.init(),this.$d=y.set(d,Math.min(this.$D,y.daysInMonth())).$d;}else l&&this.$d[l]($);return this.init(),this},m.set=function(t,e){return this.clone().$set(t,e)},m.get=function(t){return this[b.p(t)]()},m.add=function(r,f){var d,l=this;r=Number(r);var $=b.p(f),y=function(t){var e=O(l);return b.w(e.date(e.date()+Math.round(t*r)),l)};if($===c)return this.set(c,this.$M+r);if($===h)return this.set(h,this.$y+r);if($===a)return y(1);if($===o)return y(7);var M=(d={},d[s]=e,d[u]=n,d[i]=t,d)[$]||1,m=this.$d.getTime()+r*M;return b.w(m,this)},m.subtract=function(t,e){return this.add(-1*t,e)},m.format=function(t){var e=this,n=this.$locale();if(!this.isValid())return n.invalidDate||l;var r=t||"YYYY-MM-DDTHH:mm:ssZ",i=b.z(this),s=this.$H,u=this.$m,a=this.$M,o=n.weekdays,c=n.months,f=n.meridiem,h=function(t,n,i,s){return t&&(t[n]||t(e,r))||i[n].slice(0,s)},d=function(t){return b.s(s%12||12,t,"0")},$=f||function(t,e,n){var r=t<12?"AM":"PM";return n?r.toLowerCase():r};return r.replace(y,(function(t,r){return r||function(t){switch(t){case"YY":return String(e.$y).slice(-2);case"YYYY":return b.s(e.$y,4,"0");case"M":return a+1;case"MM":return b.s(a+1,2,"0");case"MMM":return h(n.monthsShort,a,c,3);case"MMMM":return h(c,a);case"D":return e.$D;case"DD":return b.s(e.$D,2,"0");case"d":return String(e.$W);case"dd":return h(n.weekdaysMin,e.$W,o,2);case"ddd":return h(n.weekdaysShort,e.$W,o,3);case"dddd":return o[e.$W];case"H":return String(s);case"HH":return b.s(s,2,"0");case"h":return d(1);case"hh":return d(2);case"a":return $(s,u,!0);case"A":return $(s,u,!1);case"m":return String(u);case"mm":return b.s(u,2,"0");case"s":return String(e.$s);case"ss":return b.s(e.$s,2,"0");case"SSS":return b.s(e.$ms,3,"0");case"Z":return i}return null}(t)||i.replace(":","")}))},m.utcOffset=function(){return 15*-Math.round(this.$d.getTimezoneOffset()/15)},m.diff=function(r,d,l){var $,y=this,M=b.p(d),m=O(r),v=(m.utcOffset()-this.utcOffset())*e,g=this-m,D=function(){return b.m(y,m)};switch(M){case h:$=D()/12;break;case c:$=D();break;case f:$=D()/3;break;case o:$=(g-v)/6048e5;break;case a:$=(g-v)/864e5;break;case u:$=g/n;break;case s:$=g/e;break;case i:$=g/t;break;default:$=g;}return l?$:b.a($)},m.daysInMonth=function(){return this.endOf(c).$D},m.$locale=function(){return D[this.$L]},m.locale=function(t,e){if(!t)return this.$L;var n=this.clone(),r=w(t,e,!0);return r&&(n.$L=r),n},m.clone=function(){return b.w(this.$d,this)},m.toDate=function(){return new Date(this.valueOf())},m.toJSON=function(){return this.isValid()?this.toISOString():null},m.toISOString=function(){return this.$d.toISOString()},m.toString=function(){return this.$d.toUTCString()},M}(),k=_.prototype;return O.prototype=k,[["$ms",r],["$s",i],["$m",s],["$H",u],["$W",a],["$M",c],["$y",h],["$D",d]].forEach((function(t){k[t[1]]=function(e){return this.$g(e,t[0],t[1])};})),O.extend=function(t,e){return t.$i||(t(e,_,O),t.$i=!0),O},O.locale=w,O.isDayjs=S,O.unix=function(t){return O(1e3*t)},O.en=D[g],O.Ls=D,O.p={},O})); 
    } (dayjs_min));

    var dayjs_minExports = dayjs_min.exports;
    var dayjs = /*@__PURE__*/getDefaultExportFromCjs(dayjs_minExports);

    var updateLocale$1 = {exports: {}};

    (function (module, exports) {
    	!function(e,n){module.exports=n();}(commonjsGlobal,(function(){return function(e,n,t){t.updateLocale=function(e,n){var o=t.Ls[e];if(o)return (n?Object.keys(n):[]).forEach((function(e){o[e]=n[e];})),o};}})); 
    } (updateLocale$1));

    var updateLocaleExports = updateLocale$1.exports;
    var updateLocale = /*@__PURE__*/getDefaultExportFromCjs(updateLocaleExports);

    var relativeTime$1 = {exports: {}};

    (function (module, exports) {
    	!function(r,e){module.exports=e();}(commonjsGlobal,(function(){return function(r,e,t){r=r||{};var n=e.prototype,o={future:"in %s",past:"%s ago",s:"a few seconds",m:"a minute",mm:"%d minutes",h:"an hour",hh:"%d hours",d:"a day",dd:"%d days",M:"a month",MM:"%d months",y:"a year",yy:"%d years"};function i(r,e,t,o){return n.fromToBase(r,e,t,o)}t.en.relativeTime=o,n.fromToBase=function(e,n,i,d,u){for(var f,a,s,l=i.$locale().relativeTime||o,h=r.thresholds||[{l:"s",r:44,d:"second"},{l:"m",r:89},{l:"mm",r:44,d:"minute"},{l:"h",r:89},{l:"hh",r:21,d:"hour"},{l:"d",r:35},{l:"dd",r:25,d:"day"},{l:"M",r:45},{l:"MM",r:10,d:"month"},{l:"y",r:17},{l:"yy",d:"year"}],m=h.length,c=0;c<m;c+=1){var y=h[c];y.d&&(f=d?t(e).diff(i,y.d,!0):i.diff(e,y.d,!0));var p=(r.rounding||Math.round)(Math.abs(f));if(s=f>0,p<=y.r||!y.r){p<=1&&c>0&&(y=h[c-1]);var v=l[y.l];u&&(p=u(""+p)),a="string"==typeof v?v.replace("%d",p):v(p,n,y.l,s);break}}if(n)return a;var M=s?l.future:l.past;return "function"==typeof M?M(a):M.replace("%s",a)},n.to=function(r,e){return i(r,e,this,!0)},n.from=function(r,e){return i(r,e,this)};var d=function(r){return r.$u?t.utc():t()};n.toNow=function(r){return this.to(d(this),r)},n.fromNow=function(r){return this.from(d(this),r)};}})); 
    } (relativeTime$1));

    var relativeTimeExports = relativeTime$1.exports;
    var relativeTime = /*@__PURE__*/getDefaultExportFromCjs(relativeTimeExports);

    dayjs.extend(relativeTime);
    dayjs.extend(updateLocale);
    dayjs.updateLocale('en', {
        relativeTime: {
            future: 'in %s',
            past: '%s ago',
            s: '%s sec',
            m: '1 min',
            mm: '%d min',
            h: '1 hr',
            hh: '%d hrs',
            d: '1 d',
            dd: '%d d',
            M: '1 mo',
            MM: '%d mo',
            y: '1 yr',
            yy: '%d yr'
        }
    });
    const DateUtil = {
        getYear(date = new Date().toISOString()) {
            return dayjs(date).year();
        },
        getRelativeDateFromNow(date) {
            return dayjs(date).fromNow(true);
        },
        formatDate(date, format = 'DD MMM') {
            return dayjs(date).format(format);
        }
    };

    const FLOAT_FIXED_VALUE = 3;
    const plusTypes = ['receive', 'deposit', 'borrow', 'claim'];
    const minusTypes = ['withdraw', 'repay', 'burn'];
    const TransactionUtil = {
        getMonthName(monthNumber) {
            const date = new Date();
            date.setMonth(monthNumber);
            return date.toLocaleString('en-US', {
                month: 'long'
            });
        },
        getTransactionGroupTitle(year, month) {
            const currentYear = DateUtil.getYear();
            const monthName = this.getMonthName(month);
            const isCurrentYear = year === currentYear;
            const groupTitle = isCurrentYear ? monthName : `${monthName} ${year}`;
            return groupTitle;
        },
        getTransactionImages(transfers) {
            const [transfer, secondTransfer] = transfers;
            const isAllNFT = Boolean(transfer) && transfers?.every(item => Boolean(item.nft_info));
            const haveMultipleTransfers = transfers?.length > 1;
            const haveTwoTransfers = transfers?.length === 2;
            if (haveTwoTransfers && !isAllNFT) {
                return [this.getTransactionImage(transfer), this.getTransactionImage(secondTransfer)];
            }
            if (haveMultipleTransfers) {
                return transfers.map(item => this.getTransactionImage(item));
            }
            return [this.getTransactionImage(transfer)];
        },
        getTransactionImage(transfer) {
            return {
                type: TransactionUtil.getTransactionTransferTokenType(transfer),
                url: TransactionUtil.getTransactionImageURL(transfer)
            };
        },
        getTransactionImageURL(transfer) {
            let imageURL = undefined;
            const isNFT = Boolean(transfer?.nft_info);
            const isFungible = Boolean(transfer?.fungible_info);
            if (transfer && isNFT) {
                imageURL = transfer?.nft_info?.content?.preview?.url;
            }
            else if (transfer && isFungible) {
                imageURL = transfer?.fungible_info?.icon?.url;
            }
            return imageURL;
        },
        getTransactionTransferTokenType(transfer) {
            if (transfer?.fungible_info) {
                return 'FUNGIBLE';
            }
            else if (transfer?.nft_info) {
                return 'NFT';
            }
            return undefined;
        },
        getTransactionDescriptions(transaction) {
            const type = transaction?.metadata?.operationType;
            const transfers = transaction?.transfers;
            const haveTransfer = transaction?.transfers?.length > 0;
            const haveMultipleTransfers = transaction?.transfers?.length > 1;
            const isFungible = haveTransfer && transfers?.every(transfer => Boolean(transfer?.fungible_info));
            const [firstTransfer, secondTransfer] = transfers;
            let firstDescription = this.getTransferDescription(firstTransfer);
            let secondDescription = this.getTransferDescription(secondTransfer);
            if (!haveTransfer) {
                const isSendOrReceive = type === 'send' || type === 'receive';
                if (isSendOrReceive && isFungible) {
                    firstDescription = UiHelperUtil.getTruncateString({
                        string: transaction?.metadata.sentFrom,
                        charsStart: 4,
                        charsEnd: 6,
                        truncate: 'middle'
                    });
                    secondDescription = UiHelperUtil.getTruncateString({
                        string: transaction?.metadata.sentTo,
                        charsStart: 4,
                        charsEnd: 6,
                        truncate: 'middle'
                    });
                    return [firstDescription, secondDescription];
                }
                return [transaction.metadata.status];
            }
            if (haveMultipleTransfers) {
                return transfers.map(item => this.getTransferDescription(item));
            }
            let prefix = '';
            if (plusTypes.includes(type)) {
                prefix = '+';
            }
            else if (minusTypes.includes(type)) {
                prefix = '-';
            }
            firstDescription = prefix.concat(firstDescription);
            return [firstDescription];
        },
        getTransferDescription(transfer) {
            let description = '';
            if (!transfer) {
                return description;
            }
            if (transfer?.nft_info) {
                description = transfer?.nft_info?.name || '-';
            }
            else if (transfer?.fungible_info) {
                description = this.getFungibleTransferDescription(transfer) || '-';
            }
            return description;
        },
        getFungibleTransferDescription(transfer) {
            if (!transfer) {
                return null;
            }
            const quantity = this.getQuantityFixedValue(transfer?.quantity.numeric);
            const description = [quantity, transfer?.fungible_info?.symbol].join(' ').trim();
            return description;
        },
        getQuantityFixedValue(value) {
            if (!value) {
                return null;
            }
            const parsedValue = parseFloat(value);
            return parsedValue.toFixed(FLOAT_FIXED_VALUE);
        }
    };

    var index$6 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        TransactionUtil: TransactionUtil,
        UiHelperUtil: UiHelperUtil,
        get WuiAccountButton () { return WuiAccountButton; },
        get WuiAllWalletsImage () { return WuiAllWalletsImage; },
        get WuiAvatar () { return WuiAvatar; },
        get WuiBalance () { return WuiBalance; },
        get WuiBanner () { return WuiBanner; },
        get WuiButton () { return WuiButton; },
        get WuiCard () { return WuiCard; },
        get WuiCardSelect () { return WuiCardSelect; },
        get WuiCardSelectLoader () { return WuiCardSelectLoader; },
        get WuiChip () { return WuiChip; },
        get WuiChipButton () { return WuiChipButton; },
        get WuiCompatibleNetwork () { return WuiCompatibleNetwork; },
        get WuiConnectButton () { return WuiConnectButton; },
        get WuiCtaButton () { return WuiCtaButton; },
        get WuiEmailInput () { return WuiEmailInput; },
        get WuiFlex () { return WuiFlex; },
        get WuiGrid () { return WuiGrid; },
        get WuiIcon () { return WuiIcon; },
        get WuiIconBox () { return WuiIconBox; },
        get WuiIconLink () { return WuiIconLink; },
        get WuiImage () { return WuiImage; },
        get WuiInputAmount () { return WuiInputAmount; },
        get WuiInputElement () { return WuiInputElement; },
        get WuiInputNumeric () { return WuiInputNumeric; },
        get WuiInputText () { return WuiInputText; },
        get WuiLink () { return WuiLink; },
        get WuiListAccordion () { return WuiListAccordion; },
        get WuiListContent () { return WuiListContent; },
        get WuiListDescription () { return WuiListDescription; },
        get WuiListItem () { return WuiListItem; },
        get WuiListNetwork () { return WuiListNetwork; },
        get WuiListToken () { return WuiListToken; },
        get WuiListWallet () { return WuiListWallet; },
        get WuiListWalletTransaction () { return WuiListWalletTransaction; },
        get WuiLoadingHexagon () { return WuiLoadingHexagon; },
        get WuiLoadingSpinner () { return WuiLoadingSpinner; },
        get WuiLoadingThumbnail () { return WuiLoadingThumbnail; },
        get WuiLogo () { return WuiLogo; },
        get WuiLogoSelect () { return WuiLogoSelect; },
        get WuiNetworkButton () { return WuiNetworkButton; },
        get WuiNetworkImage () { return WuiNetworkImage; },
        get WuiNoticeCard () { return WuiNoticeCard; },
        get WuiOnRampActivityItem () { return WuiOnRampActivityItem; },
        get WuiOnRampProviderItem () { return WuiOnRampProviderItem; },
        get WuiOtp () { return WuiOtp; },
        get WuiPreviewItem () { return WuiPreviewItem; },
        get WuiProfileButton () { return WuiProfileButton; },
        get WuiPromo () { return WuiPromo; },
        get WuiQrCode () { return WuiQrCode; },
        get WuiSearchBar () { return WuiSearchBar; },
        get WuiSeparator () { return WuiSeparator; },
        get WuiShimmer () { return WuiShimmer; },
        get WuiSnackbar () { return WuiSnackbar; },
        get WuiTabs () { return WuiTabs; },
        get WuiTag () { return WuiTag; },
        get WuiText () { return WuiText; },
        get WuiTokenButton () { return WuiTokenButton; },
        get WuiTooltip () { return WuiTooltip; },
        get WuiTooltipSelect () { return WuiTooltipSelect; },
        get WuiTransactionListItem () { return WuiTransactionListItem; },
        get WuiTransactionListItemLoader () { return WuiTransactionListItemLoader; },
        get WuiTransactionVisual () { return WuiTransactionVisual; },
        get WuiVisual () { return WuiVisual; },
        get WuiVisualThumbnail () { return WuiVisualThumbnail; },
        get WuiWalletImage () { return WuiWalletImage; },
        customElement: customElement,
        initializeTheming: initializeTheming,
        setColorTheme: setColorTheme,
        setThemeVariables: setThemeVariables
    });

    /**
     * @license
     * Copyright 2019 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */
    const t$c=globalThis,e$f=t$c.ShadowRoot&&(void 0===t$c.ShadyCSS||t$c.ShadyCSS.nativeShadow)&&"adoptedStyleSheets"in Document.prototype&&"replace"in CSSStyleSheet.prototype,s$c=Symbol(),o$i=new WeakMap;let n$g = class n{constructor(t,e,o){if(this._$cssResult$=!0,o!==s$c)throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");this.cssText=t,this.t=e;}get styleSheet(){let t=this.o;const s=this.t;if(e$f&&void 0===t){const e=void 0!==s&&1===s.length;e&&(t=o$i.get(s)),void 0===t&&((this.o=t=new CSSStyleSheet).replaceSync(this.cssText),e&&o$i.set(s,t));}return t}toString(){return this.cssText}};const r$j=t=>new n$g("string"==typeof t?t:t+"",void 0,s$c),i$d=(t,...e)=>{const o=1===t.length?t[0]:e.reduce(((e,s,o)=>e+(t=>{if(!0===t._$cssResult$)return t.cssText;if("number"==typeof t)return t;throw Error("Value passed to 'css' function must be a 'css' function result: "+t+". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.")})(s)+t[o+1]),t[0]);return new n$g(o,t,s$c)},S$8=(s,o)=>{if(e$f)s.adoptedStyleSheets=o.map((t=>t instanceof CSSStyleSheet?t:t.styleSheet));else for(const e of o){const o=document.createElement("style"),n=t$c.litNonce;void 0!==n&&o.setAttribute("nonce",n),o.textContent=e.cssText,s.appendChild(o);}},c$c=e$f?t=>t:t=>t instanceof CSSStyleSheet?(t=>{let e="";for(const s of t.cssRules)e+=s.cssText;return r$j(e)})(t):t;

    /**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */const{is:i$c,defineProperty:e$e,getOwnPropertyDescriptor:r$i,getOwnPropertyNames:h$a,getOwnPropertySymbols:o$h,getPrototypeOf:n$f}=Object,a$8=globalThis,c$b=a$8.trustedTypes,l$9=c$b?c$b.emptyScript:"",p$7=a$8.reactiveElementPolyfillSupport,d$9=(t,s)=>t,u$7={toAttribute(t,s){switch(s){case Boolean:t=t?l$9:null;break;case Object:case Array:t=null==t?t:JSON.stringify(t);}return t},fromAttribute(t,s){let i=t;switch(s){case Boolean:i=null!==t;break;case Number:i=null===t?null:Number(t);break;case Object:case Array:try{i=JSON.parse(t);}catch(t){i=null;}}return i}},f$8=(t,s)=>!i$c(t,s),y$7={attribute:!0,type:String,converter:u$7,reflect:!1,hasChanged:f$8};Symbol.metadata??=Symbol("metadata"),a$8.litPropertyMetadata??=new WeakMap;let b$4 = class b extends HTMLElement{static addInitializer(t){this._$Ei(),(this.l??=[]).push(t);}static get observedAttributes(){return this.finalize(),this._$Eh&&[...this._$Eh.keys()]}static createProperty(t,s=y$7){if(s.state&&(s.attribute=!1),this._$Ei(),this.elementProperties.set(t,s),!s.noAccessor){const i=Symbol(),r=this.getPropertyDescriptor(t,i,s);void 0!==r&&e$e(this.prototype,t,r);}}static getPropertyDescriptor(t,s,i){const{get:e,set:h}=r$i(this.prototype,t)??{get(){return this[s]},set(t){this[s]=t;}};return {get(){return e?.call(this)},set(s){const r=e?.call(this);h.call(this,s),this.requestUpdate(t,r,i);},configurable:!0,enumerable:!0}}static getPropertyOptions(t){return this.elementProperties.get(t)??y$7}static _$Ei(){if(this.hasOwnProperty(d$9("elementProperties")))return;const t=n$f(this);t.finalize(),void 0!==t.l&&(this.l=[...t.l]),this.elementProperties=new Map(t.elementProperties);}static finalize(){if(this.hasOwnProperty(d$9("finalized")))return;if(this.finalized=!0,this._$Ei(),this.hasOwnProperty(d$9("properties"))){const t=this.properties,s=[...h$a(t),...o$h(t)];for(const i of s)this.createProperty(i,t[i]);}const t=this[Symbol.metadata];if(null!==t){const s=litPropertyMetadata.get(t);if(void 0!==s)for(const[t,i]of s)this.elementProperties.set(t,i);}this._$Eh=new Map;for(const[t,s]of this.elementProperties){const i=this._$Eu(t,s);void 0!==i&&this._$Eh.set(i,t);}this.elementStyles=this.finalizeStyles(this.styles);}static finalizeStyles(s){const i=[];if(Array.isArray(s)){const e=new Set(s.flat(1/0).reverse());for(const s of e)i.unshift(c$c(s));}else void 0!==s&&i.push(c$c(s));return i}static _$Eu(t,s){const i=s.attribute;return !1===i?void 0:"string"==typeof i?i:"string"==typeof t?t.toLowerCase():void 0}constructor(){super(),this._$Ep=void 0,this.isUpdatePending=!1,this.hasUpdated=!1,this._$Em=null,this._$Ev();}_$Ev(){this._$ES=new Promise((t=>this.enableUpdating=t)),this._$AL=new Map,this._$E_(),this.requestUpdate(),this.constructor.l?.forEach((t=>t(this)));}addController(t){(this._$EO??=new Set).add(t),void 0!==this.renderRoot&&this.isConnected&&t.hostConnected?.();}removeController(t){this._$EO?.delete(t);}_$E_(){const t=new Map,s=this.constructor.elementProperties;for(const i of s.keys())this.hasOwnProperty(i)&&(t.set(i,this[i]),delete this[i]);t.size>0&&(this._$Ep=t);}createRenderRoot(){const t=this.shadowRoot??this.attachShadow(this.constructor.shadowRootOptions);return S$8(t,this.constructor.elementStyles),t}connectedCallback(){this.renderRoot??=this.createRenderRoot(),this.enableUpdating(!0),this._$EO?.forEach((t=>t.hostConnected?.()));}enableUpdating(t){}disconnectedCallback(){this._$EO?.forEach((t=>t.hostDisconnected?.()));}attributeChangedCallback(t,s,i){this._$AK(t,i);}_$EC(t,s){const i=this.constructor.elementProperties.get(t),e=this.constructor._$Eu(t,i);if(void 0!==e&&!0===i.reflect){const r=(void 0!==i.converter?.toAttribute?i.converter:u$7).toAttribute(s,i.type);this._$Em=t,null==r?this.removeAttribute(e):this.setAttribute(e,r),this._$Em=null;}}_$AK(t,s){const i=this.constructor,e=i._$Eh.get(t);if(void 0!==e&&this._$Em!==e){const t=i.getPropertyOptions(e),r="function"==typeof t.converter?{fromAttribute:t.converter}:void 0!==t.converter?.fromAttribute?t.converter:u$7;this._$Em=e,this[e]=r.fromAttribute(s,t.type),this._$Em=null;}}requestUpdate(t,s,i){if(void 0!==t){if(i??=this.constructor.getPropertyOptions(t),!(i.hasChanged??f$8)(this[t],s))return;this.P(t,s,i);}!1===this.isUpdatePending&&(this._$ES=this._$ET());}P(t,s,i){this._$AL.has(t)||this._$AL.set(t,s),!0===i.reflect&&this._$Em!==t&&(this._$Ej??=new Set).add(t);}async _$ET(){this.isUpdatePending=!0;try{await this._$ES;}catch(t){Promise.reject(t);}const t=this.scheduleUpdate();return null!=t&&await t,!this.isUpdatePending}scheduleUpdate(){return this.performUpdate()}performUpdate(){if(!this.isUpdatePending)return;if(!this.hasUpdated){if(this.renderRoot??=this.createRenderRoot(),this._$Ep){for(const[t,s]of this._$Ep)this[t]=s;this._$Ep=void 0;}const t=this.constructor.elementProperties;if(t.size>0)for(const[s,i]of t)!0!==i.wrapped||this._$AL.has(s)||void 0===this[s]||this.P(s,this[s],i);}let t=!1;const s=this._$AL;try{t=this.shouldUpdate(s),t?(this.willUpdate(s),this._$EO?.forEach((t=>t.hostUpdate?.())),this.update(s)):this._$EU();}catch(s){throw t=!1,this._$EU(),s}t&&this._$AE(s);}willUpdate(t){}_$AE(t){this._$EO?.forEach((t=>t.hostUpdated?.())),this.hasUpdated||(this.hasUpdated=!0,this.firstUpdated(t)),this.updated(t);}_$EU(){this._$AL=new Map,this.isUpdatePending=!1;}get updateComplete(){return this.getUpdateComplete()}getUpdateComplete(){return this._$ES}shouldUpdate(t){return !0}update(t){this._$Ej&&=this._$Ej.forEach((t=>this._$EC(t,this[t]))),this._$EU();}updated(t){}firstUpdated(t){}};b$4.elementStyles=[],b$4.shadowRootOptions={mode:"open"},b$4[d$9("elementProperties")]=new Map,b$4[d$9("finalized")]=new Map,p$7?.({ReactiveElement:b$4}),(a$8.reactiveElementVersions??=[]).push("2.0.4");

    /**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */
    const t$b=globalThis,i$b=t$b.trustedTypes,s$b=i$b?i$b.createPolicy("lit-html",{createHTML:t=>t}):void 0,e$d="$lit$",h$9=`lit$${(Math.random()+"").slice(9)}$`,o$g="?"+h$9,n$e=`<${o$g}>`,r$h=document,l$8=()=>r$h.createComment(""),c$a=t=>null===t||"object"!=typeof t&&"function"!=typeof t,a$7=Array.isArray,u$6=t=>a$7(t)||"function"==typeof t?.[Symbol.iterator],d$8="[ \t\n\f\r]",f$7=/<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g,v$5=/-->/g,_$6=/>/g,m$5=RegExp(`>|${d$8}(?:([^\\s"'>=/]+)(${d$8}*=${d$8}*(?:[^ \t\n\f\r"'\`<>=]|("|')|))|$)`,"g"),p$6=/'/g,g$5=/"/g,$$4=/^(?:script|style|textarea|title)$/i,y$6=t=>(i,...s)=>({_$litType$:t,strings:i,values:s}),x$4=y$6(1),w$5=Symbol.for("lit-noChange"),T$6=Symbol.for("lit-nothing"),A$5=new WeakMap,E$4=r$h.createTreeWalker(r$h,129);function C$5(t,i){if(!Array.isArray(t)||!t.hasOwnProperty("raw"))throw Error("invalid template strings array");return void 0!==s$b?s$b.createHTML(i):i}const P$4=(t,i)=>{const s=t.length-1,o=[];let r,l=2===i?"<svg>":"",c=f$7;for(let i=0;i<s;i++){const s=t[i];let a,u,d=-1,y=0;for(;y<s.length&&(c.lastIndex=y,u=c.exec(s),null!==u);)y=c.lastIndex,c===f$7?"!--"===u[1]?c=v$5:void 0!==u[1]?c=_$6:void 0!==u[2]?($$4.test(u[2])&&(r=RegExp("</"+u[2],"g")),c=m$5):void 0!==u[3]&&(c=m$5):c===m$5?">"===u[0]?(c=r??f$7,d=-1):void 0===u[1]?d=-2:(d=c.lastIndex-u[2].length,a=u[1],c=void 0===u[3]?m$5:'"'===u[3]?g$5:p$6):c===g$5||c===p$6?c=m$5:c===v$5||c===_$6?c=f$7:(c=m$5,r=void 0);const x=c===m$5&&t[i+1].startsWith("/>")?" ":"";l+=c===f$7?s+n$e:d>=0?(o.push(a),s.slice(0,d)+e$d+s.slice(d)+h$9+x):s+h$9+(-2===d?i:x);}return [C$5(t,l+(t[s]||"<?>")+(2===i?"</svg>":"")),o]};let V$4 = class V{constructor({strings:t,_$litType$:s},n){let r;this.parts=[];let c=0,a=0;const u=t.length-1,d=this.parts,[f,v]=P$4(t,s);if(this.el=V.createElement(f,n),E$4.currentNode=this.el.content,2===s){const t=this.el.content.firstChild;t.replaceWith(...t.childNodes);}for(;null!==(r=E$4.nextNode())&&d.length<u;){if(1===r.nodeType){if(r.hasAttributes())for(const t of r.getAttributeNames())if(t.endsWith(e$d)){const i=v[a++],s=r.getAttribute(t).split(h$9),e=/([.?@])?(.*)/.exec(i);d.push({type:1,index:c,name:e[2],strings:s,ctor:"."===e[1]?k$5:"?"===e[1]?H$4:"@"===e[1]?I$4:R$3}),r.removeAttribute(t);}else t.startsWith(h$9)&&(d.push({type:6,index:c}),r.removeAttribute(t));if($$4.test(r.tagName)){const t=r.textContent.split(h$9),s=t.length-1;if(s>0){r.textContent=i$b?i$b.emptyScript:"";for(let i=0;i<s;i++)r.append(t[i],l$8()),E$4.nextNode(),d.push({type:2,index:++c});r.append(t[s],l$8());}}}else if(8===r.nodeType)if(r.data===o$g)d.push({type:2,index:c});else {let t=-1;for(;-1!==(t=r.data.indexOf(h$9,t+1));)d.push({type:7,index:c}),t+=h$9.length-1;}c++;}}static createElement(t,i){const s=r$h.createElement("template");return s.innerHTML=t,s}};function N$4(t,i,s=t,e){if(i===w$5)return i;let h=void 0!==e?s._$Co?.[e]:s._$Cl;const o=c$a(i)?void 0:i._$litDirective$;return h?.constructor!==o&&(h?._$AO?.(!1),void 0===o?h=void 0:(h=new o(t),h._$AT(t,s,e)),void 0!==e?(s._$Co??=[])[e]=h:s._$Cl=h),void 0!==h&&(i=N$4(t,h._$AS(t,i.values),h,e)),i}let S$7 = class S{constructor(t,i){this._$AV=[],this._$AN=void 0,this._$AD=t,this._$AM=i;}get parentNode(){return this._$AM.parentNode}get _$AU(){return this._$AM._$AU}u(t){const{el:{content:i},parts:s}=this._$AD,e=(t?.creationScope??r$h).importNode(i,!0);E$4.currentNode=e;let h=E$4.nextNode(),o=0,n=0,l=s[0];for(;void 0!==l;){if(o===l.index){let i;2===l.type?i=new M$4(h,h.nextSibling,this,t):1===l.type?i=new l.ctor(h,l.name,l.strings,this,t):6===l.type&&(i=new L$5(h,this,t)),this._$AV.push(i),l=s[++n];}o!==l?.index&&(h=E$4.nextNode(),o++);}return E$4.currentNode=r$h,e}p(t){let i=0;for(const s of this._$AV)void 0!==s&&(void 0!==s.strings?(s._$AI(t,s,i),i+=s.strings.length-2):s._$AI(t[i])),i++;}};let M$4 = class M{get _$AU(){return this._$AM?._$AU??this._$Cv}constructor(t,i,s,e){this.type=2,this._$AH=T$6,this._$AN=void 0,this._$AA=t,this._$AB=i,this._$AM=s,this.options=e,this._$Cv=e?.isConnected??!0;}get parentNode(){let t=this._$AA.parentNode;const i=this._$AM;return void 0!==i&&11===t?.nodeType&&(t=i.parentNode),t}get startNode(){return this._$AA}get endNode(){return this._$AB}_$AI(t,i=this){t=N$4(this,t,i),c$a(t)?t===T$6||null==t||""===t?(this._$AH!==T$6&&this._$AR(),this._$AH=T$6):t!==this._$AH&&t!==w$5&&this._(t):void 0!==t._$litType$?this.$(t):void 0!==t.nodeType?this.T(t):u$6(t)?this.k(t):this._(t);}S(t){return this._$AA.parentNode.insertBefore(t,this._$AB)}T(t){this._$AH!==t&&(this._$AR(),this._$AH=this.S(t));}_(t){this._$AH!==T$6&&c$a(this._$AH)?this._$AA.nextSibling.data=t:this.T(r$h.createTextNode(t)),this._$AH=t;}$(t){const{values:i,_$litType$:s}=t,e="number"==typeof s?this._$AC(t):(void 0===s.el&&(s.el=V$4.createElement(C$5(s.h,s.h[0]),this.options)),s);if(this._$AH?._$AD===e)this._$AH.p(i);else {const t=new S$7(e,this),s=t.u(this.options);t.p(i),this.T(s),this._$AH=t;}}_$AC(t){let i=A$5.get(t.strings);return void 0===i&&A$5.set(t.strings,i=new V$4(t)),i}k(t){a$7(this._$AH)||(this._$AH=[],this._$AR());const i=this._$AH;let s,e=0;for(const h of t)e===i.length?i.push(s=new M(this.S(l$8()),this.S(l$8()),this,this.options)):s=i[e],s._$AI(h),e++;e<i.length&&(this._$AR(s&&s._$AB.nextSibling,e),i.length=e);}_$AR(t=this._$AA.nextSibling,i){for(this._$AP?.(!1,!0,i);t&&t!==this._$AB;){const i=t.nextSibling;t.remove(),t=i;}}setConnected(t){void 0===this._$AM&&(this._$Cv=t,this._$AP?.(t));}};let R$3 = class R{get tagName(){return this.element.tagName}get _$AU(){return this._$AM._$AU}constructor(t,i,s,e,h){this.type=1,this._$AH=T$6,this._$AN=void 0,this.element=t,this.name=i,this._$AM=e,this.options=h,s.length>2||""!==s[0]||""!==s[1]?(this._$AH=Array(s.length-1).fill(new String),this.strings=s):this._$AH=T$6;}_$AI(t,i=this,s,e){const h=this.strings;let o=!1;if(void 0===h)t=N$4(this,t,i,0),o=!c$a(t)||t!==this._$AH&&t!==w$5,o&&(this._$AH=t);else {const e=t;let n,r;for(t=h[0],n=0;n<h.length-1;n++)r=N$4(this,e[s+n],i,n),r===w$5&&(r=this._$AH[n]),o||=!c$a(r)||r!==this._$AH[n],r===T$6?t=T$6:t!==T$6&&(t+=(r??"")+h[n+1]),this._$AH[n]=r;}o&&!e&&this.j(t);}j(t){t===T$6?this.element.removeAttribute(this.name):this.element.setAttribute(this.name,t??"");}};let k$5 = class k extends R$3{constructor(){super(...arguments),this.type=3;}j(t){this.element[this.name]=t===T$6?void 0:t;}};let H$4 = class H extends R$3{constructor(){super(...arguments),this.type=4;}j(t){this.element.toggleAttribute(this.name,!!t&&t!==T$6);}};let I$4 = class I extends R$3{constructor(t,i,s,e,h){super(t,i,s,e,h),this.type=5;}_$AI(t,i=this){if((t=N$4(this,t,i,0)??T$6)===w$5)return;const s=this._$AH,e=t===T$6&&s!==T$6||t.capture!==s.capture||t.once!==s.once||t.passive!==s.passive,h=t!==T$6&&(s===T$6||e);e&&this.element.removeEventListener(this.name,this,s),h&&this.element.addEventListener(this.name,this,t),this._$AH=t;}handleEvent(t){"function"==typeof this._$AH?this._$AH.call(this.options?.host??this.element,t):this._$AH.handleEvent(t);}};let L$5 = class L{constructor(t,i,s){this.element=t,this.type=6,this._$AN=void 0,this._$AM=i,this.options=s;}get _$AU(){return this._$AM._$AU}_$AI(t){N$4(this,t);}};const Z$4=t$b.litHtmlPolyfillSupport;Z$4?.(V$4,M$4),(t$b.litHtmlVersions??=[]).push("3.1.2");const j$5=(t,i,s)=>{const e=s?.renderBefore??i;let h=e._$litPart$;if(void 0===h){const t=s?.renderBefore??null;e._$litPart$=h=new M$4(i.insertBefore(l$8(),t),t,void 0,s??{});}return h._$AI(t),h};

    /**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */let s$a = class s extends b$4{constructor(){super(...arguments),this.renderOptions={host:this},this._$Do=void 0;}createRenderRoot(){const t=super.createRenderRoot();return this.renderOptions.renderBefore??=t.firstChild,t}update(t){const i=this.render();this.hasUpdated||(this.renderOptions.isConnected=this.isConnected),super.update(t),this._$Do=j$5(i,this.renderRoot,this.renderOptions);}connectedCallback(){super.connectedCallback(),this._$Do?.setConnected(!0);}disconnectedCallback(){super.disconnectedCallback(),this._$Do?.setConnected(!1);}render(){return w$5}};s$a._$litElement$=!0,s$a[("finalized")]=!0,globalThis.litElementHydrateSupport?.({LitElement:s$a});const r$g=globalThis.litElementPolyfillSupport;r$g?.({LitElement:s$a});(globalThis.litElementVersions??=[]).push("4.0.4");

    /**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */const o$f={attribute:!0,type:String,converter:u$7,reflect:!1,hasChanged:f$8},r$f=(t=o$f,e,r)=>{const{kind:n,metadata:i}=r;let s=globalThis.litPropertyMetadata.get(i);if(void 0===s&&globalThis.litPropertyMetadata.set(i,s=new Map),s.set(r.name,t),"accessor"===n){const{name:o}=r;return {set(r){const n=e.get.call(this);e.set.call(this,r),this.requestUpdate(o,n,t);},init(e){return void 0!==e&&this.P(o,void 0,t),e}}}if("setter"===n){const{name:o}=r;return function(r){const n=this[o];e.call(this,r),this.requestUpdate(o,n,t);}}throw Error("Unsupported decorator location: "+n)};function n$d(t){return (e,o)=>"object"==typeof o?r$f(t,e,o):((t,e,o)=>{const r=e.hasOwnProperty(o);return e.constructor.createProperty(o,r?{...t,wrapped:!0}:t),r?Object.getOwnPropertyDescriptor(e,o):void 0})(t,e,o)}

    /**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */function r$e(r){return n$d({...r,state:!0,attribute:!1})}

    /**
     * @license
     * Copyright 2018 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */const o$e=o=>o??T$6;

    var __decorate$15 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let W3mAccountButton = class W3mAccountButton extends s$a {
        constructor() {
            super();
            this.unsubscribe = [];
            this.disabled = false;
            this.balance = 'show';
            this.charsStart = 4;
            this.charsEnd = 6;
            this.address = AccountController.state.address;
            this.balanceVal = AccountController.state.balance;
            this.balanceSymbol = AccountController.state.balanceSymbol;
            this.profileName = AccountController.state.profileName;
            this.profileImage = AccountController.state.profileImage;
            this.network = NetworkController.state.caipNetwork;
            this.isUnsupportedChain = NetworkController.state.isUnsupportedChain;
            this.unsubscribe.push(...[
                AccountController.subscribe(val => {
                    if (val.isConnected) {
                        this.address = val.address;
                        this.balanceVal = val.balance;
                        this.profileName = val.profileName;
                        this.profileImage = val.profileImage;
                        this.balanceSymbol = val.balanceSymbol;
                    }
                    else {
                        this.address = '';
                        this.balanceVal = '';
                        this.profileName = '';
                        this.profileImage = '';
                        this.balanceSymbol = '';
                    }
                }),
                NetworkController.subscribeKey('caipNetwork', val => (this.network = val)),
                NetworkController.subscribeKey('isUnsupportedChain', val => (this.isUnsupportedChain = val))
            ]);
        }
        disconnectedCallback() {
            this.unsubscribe.forEach(unsubscribe => unsubscribe());
        }
        render() {
            const networkImage = AssetUtil.getNetworkImage(this.network);
            const showBalance = this.balance === 'show';
            return x$4 `
      <wui-account-button
        .disabled=${Boolean(this.disabled)}
        .isUnsupportedChain=${this.isUnsupportedChain}
        address=${o$e(this.address)}
        profileName=${o$e(this.profileName)}
        ?isProfileName=${Boolean(this.profileName)}
        networkSrc=${o$e(networkImage)}
        avatarSrc=${o$e(this.profileImage)}
        balance=${showBalance
            ? CoreHelperUtil.formatBalance(this.balanceVal, this.balanceSymbol)
            : ''}
        @click=${this.onClick.bind(this)}
        data-testid="account-button"
        .charsStart=${this.charsStart}
        .charsEnd=${this.charsEnd}
      >
      </wui-account-button>
    `;
        }
        onClick() {
            if (this.isUnsupportedChain) {
                ModalController.open({ view: 'UnsupportedChain' });
            }
            else {
                ModalController.open();
            }
        }
    };
    __decorate$15([
        n$d({ type: Boolean })
    ], W3mAccountButton.prototype, "disabled", void 0);
    __decorate$15([
        n$d()
    ], W3mAccountButton.prototype, "balance", void 0);
    __decorate$15([
        n$d()
    ], W3mAccountButton.prototype, "charsStart", void 0);
    __decorate$15([
        n$d()
    ], W3mAccountButton.prototype, "charsEnd", void 0);
    __decorate$15([
        r$e()
    ], W3mAccountButton.prototype, "address", void 0);
    __decorate$15([
        r$e()
    ], W3mAccountButton.prototype, "balanceVal", void 0);
    __decorate$15([
        r$e()
    ], W3mAccountButton.prototype, "balanceSymbol", void 0);
    __decorate$15([
        r$e()
    ], W3mAccountButton.prototype, "profileName", void 0);
    __decorate$15([
        r$e()
    ], W3mAccountButton.prototype, "profileImage", void 0);
    __decorate$15([
        r$e()
    ], W3mAccountButton.prototype, "network", void 0);
    __decorate$15([
        r$e()
    ], W3mAccountButton.prototype, "isUnsupportedChain", void 0);
    W3mAccountButton = __decorate$15([
        customElement('w3m-account-button')
    ], W3mAccountButton);

    var styles$I = i$d `
  :host {
    display: block;
    width: max-content;
  }
`;

    var __decorate$14 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let W3mButton = class W3mButton extends s$a {
        constructor() {
            super();
            this.unsubscribe = [];
            this.disabled = false;
            this.balance = undefined;
            this.size = undefined;
            this.label = undefined;
            this.loadingLabel = undefined;
            this.charsStart = 4;
            this.charsEnd = 6;
            this.isAccount = AccountController.state.isConnected;
            this.unsubscribe.push(AccountController.subscribeKey('isConnected', val => {
                this.isAccount = val;
            }));
        }
        disconnectedCallback() {
            this.unsubscribe.forEach(unsubscribe => unsubscribe());
        }
        render() {
            return this.isAccount
                ? x$4 `
          <w3m-account-button
            .disabled=${Boolean(this.disabled)}
            balance=${o$e(this.balance)}
            .charsStart=${o$e(this.charsStart)}
            .charsEnd=${o$e(this.charsEnd)}
          >
          </w3m-account-button>
        `
                : x$4 `
          <w3m-connect-button
            size=${o$e(this.size)}
            label=${o$e(this.label)}
            loadingLabel=${o$e(this.loadingLabel)}
          ></w3m-connect-button>
        `;
        }
    };
    W3mButton.styles = styles$I;
    __decorate$14([
        n$d({ type: Boolean })
    ], W3mButton.prototype, "disabled", void 0);
    __decorate$14([
        n$d()
    ], W3mButton.prototype, "balance", void 0);
    __decorate$14([
        n$d()
    ], W3mButton.prototype, "size", void 0);
    __decorate$14([
        n$d()
    ], W3mButton.prototype, "label", void 0);
    __decorate$14([
        n$d()
    ], W3mButton.prototype, "loadingLabel", void 0);
    __decorate$14([
        n$d()
    ], W3mButton.prototype, "charsStart", void 0);
    __decorate$14([
        n$d()
    ], W3mButton.prototype, "charsEnd", void 0);
    __decorate$14([
        r$e()
    ], W3mButton.prototype, "isAccount", void 0);
    W3mButton = __decorate$14([
        customElement('w3m-button')
    ], W3mButton);

    var __decorate$13 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let W3mConnectButton = class W3mConnectButton extends s$a {
        constructor() {
            super();
            this.unsubscribe = [];
            this.size = 'md';
            this.label = 'Connect Wallet';
            this.loadingLabel = 'Connecting...';
            this.open = ModalController.state.open;
            this.loading = ModalController.state.loading;
            this.unsubscribe.push(ModalController.subscribe(val => {
                this.open = val.open;
                this.loading = val.loading;
            }));
        }
        disconnectedCallback() {
            this.unsubscribe.forEach(unsubscribe => unsubscribe());
        }
        render() {
            const isLoading = this.loading || this.open;
            return x$4 `
      <wui-connect-button
        size=${o$e(this.size)}
        .loading=${isLoading}
        @click=${this.onClick.bind(this)}
        data-testid="connect-button"
      >
        ${isLoading ? this.loadingLabel : this.label}
      </wui-connect-button>
    `;
        }
        onClick() {
            if (this.open) {
                ModalController.close();
            }
            else if (!this.loading) {
                ModalController.open();
            }
        }
    };
    __decorate$13([
        n$d()
    ], W3mConnectButton.prototype, "size", void 0);
    __decorate$13([
        n$d()
    ], W3mConnectButton.prototype, "label", void 0);
    __decorate$13([
        n$d()
    ], W3mConnectButton.prototype, "loadingLabel", void 0);
    __decorate$13([
        r$e()
    ], W3mConnectButton.prototype, "open", void 0);
    __decorate$13([
        r$e()
    ], W3mConnectButton.prototype, "loading", void 0);
    W3mConnectButton = __decorate$13([
        customElement('w3m-connect-button')
    ], W3mConnectButton);

    var styles$H = i$d `
  :host {
    z-index: var(--w3m-z-index);
    display: block;
    backface-visibility: hidden;
    will-change: opacity;
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    pointer-events: none;
    opacity: 0;
    background-color: var(--wui-cover);
  }

  @keyframes zoom-in {
    0% {
      transform: scale(0.95) translateY(0);
    }
    100% {
      transform: scale(1) translateY(0);
    }
  }

  @keyframes slide-in {
    0% {
      transform: scale(1) translateY(50px);
    }
    100% {
      transform: scale(1) translateY(0);
    }
  }

  wui-card {
    max-width: 360px;
    width: 100%;
    position: relative;
    animation-delay: 0.3s;
    animation-duration: 0.2s;
    animation-name: zoom-in;
    animation-fill-mode: backwards;
    animation-timing-function: var(--wui-ease-out-power-2);
    outline: none;
  }

  wui-flex {
    overflow-x: hidden;
    overflow-y: auto;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 100%;
    height: 100%;
  }

  @media (max-height: 700px) and (min-width: 431px) {
    wui-flex {
      align-items: flex-start;
    }

    wui-card {
      margin: var(--wui-spacing-xxl) 0px;
    }
  }

  @media (max-width: 430px) {
    wui-flex {
      align-items: flex-end;
    }

    wui-card {
      max-width: 100%;
      border-bottom-left-radius: 0;
      border-bottom-right-radius: 0;
      border-bottom: none;
      animation-name: slide-in;
    }
  }
`;

    var __decorate$12 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    const SCROLL_LOCK = 'scroll-lock';
    let W3mModal = class W3mModal extends s$a {
        constructor() {
            super();
            this.unsubscribe = [];
            this.abortController = undefined;
            this.open = ModalController.state.open;
            this.caipAddress = AccountController.state.caipAddress;
            this.isSiweEnabled = OptionsController.state.isSiweEnabled;
            this.initializeTheming();
            ApiController.prefetch();
            this.unsubscribe.push(ModalController.subscribeKey('open', val => (val ? this.onOpen() : this.onClose())), AccountController.subscribe(newAccountState => this.onNewAccountState(newAccountState)));
            EventsController.sendEvent({ type: 'track', event: 'MODAL_LOADED' });
        }
        disconnectedCallback() {
            this.unsubscribe.forEach(unsubscribe => unsubscribe());
            this.onRemoveKeyboardListener();
        }
        render() {
            return this.open
                ? x$4 `
          <wui-flex @click=${this.onOverlayClick.bind(this)}>
            <wui-card role="alertdialog" aria-modal="true" tabindex="0">
              <w3m-header></w3m-header>
              <w3m-router></w3m-router>
              <w3m-snackbar></w3m-snackbar>
            </wui-card>
          </wui-flex>
        `
                : null;
        }
        async onOverlayClick(event) {
            if (event.target === event.currentTarget) {
                await this.handleClose();
            }
        }
        async handleClose() {
            if (this.isSiweEnabled) {
                const { SIWEController } = await Promise.resolve().then(function () { return index$1; });
                if (SIWEController.state.status !== 'success') {
                    await ConnectionController.disconnect();
                }
            }
            ModalController.close();
        }
        initializeTheming() {
            const { themeVariables, themeMode } = ThemeController.state;
            const defaultThemeMode = UiHelperUtil.getColorTheme(themeMode);
            initializeTheming(themeVariables, defaultThemeMode);
        }
        async onClose() {
            this.onScrollUnlock();
            await this.animate([{ opacity: 1 }, { opacity: 0 }], {
                duration: 200,
                easing: 'ease',
                fill: 'forwards'
            }).finished;
            SnackController.hide();
            this.open = false;
            this.onRemoveKeyboardListener();
        }
        async onOpen() {
            this.onScrollLock();
            this.open = true;
            await this.animate([{ opacity: 0 }, { opacity: 1 }], {
                duration: 200,
                easing: 'ease',
                fill: 'forwards',
                delay: 300
            }).finished;
            this.onAddKeyboardListener();
        }
        onScrollLock() {
            const styleTag = document.createElement('style');
            styleTag.dataset['w3m'] = SCROLL_LOCK;
            styleTag.textContent = `
      html, body {
        touch-action: none;
        overflow: hidden;
        overscroll-behavior: contain;
      }
      w3m-modal {
        pointer-events: auto;
      }
    `;
            document.head.appendChild(styleTag);
        }
        onScrollUnlock() {
            const styleTag = document.head.querySelector(`style[data-w3m="${SCROLL_LOCK}"]`);
            if (styleTag) {
                styleTag.remove();
            }
        }
        onAddKeyboardListener() {
            this.abortController = new AbortController();
            const card = this.shadowRoot?.querySelector('wui-card');
            card?.focus();
            window.addEventListener('keydown', event => {
                if (event.key === 'Escape') {
                    this.handleClose();
                }
                else if (event.key === 'Tab') {
                    const { tagName } = event.target;
                    if (tagName && !tagName.includes('W3M-') && !tagName.includes('WUI-')) {
                        card?.focus();
                    }
                }
            }, this.abortController);
        }
        onRemoveKeyboardListener() {
            this.abortController?.abort();
            this.abortController = undefined;
        }
        async onNewAccountState(newState) {
            const { isConnected, caipAddress: newCaipAddress } = newState;
            if (this.isSiweEnabled) {
                const { SIWEController } = await Promise.resolve().then(function () { return index$1; });
                if (isConnected && !this.caipAddress) {
                    this.caipAddress = newCaipAddress;
                }
                if (isConnected && newCaipAddress && this.caipAddress !== newCaipAddress) {
                    await SIWEController.signOut();
                    this.onSiweNavigation();
                    this.caipAddress = newCaipAddress;
                }
                try {
                    const session = await SIWEController.getSession();
                    if (session && !isConnected) {
                        await SIWEController.signOut();
                    }
                    else if (isConnected && !session) {
                        this.onSiweNavigation();
                    }
                }
                catch (error) {
                    if (isConnected) {
                        this.onSiweNavigation();
                    }
                }
            }
        }
        onSiweNavigation() {
            if (this.open) {
                RouterController.push('ConnectingSiwe');
            }
            else {
                ModalController.open({
                    view: 'ConnectingSiwe'
                });
            }
        }
    };
    W3mModal.styles = styles$H;
    __decorate$12([
        r$e()
    ], W3mModal.prototype, "open", void 0);
    __decorate$12([
        r$e()
    ], W3mModal.prototype, "caipAddress", void 0);
    __decorate$12([
        r$e()
    ], W3mModal.prototype, "isSiweEnabled", void 0);
    W3mModal = __decorate$12([
        customElement('w3m-modal')
    ], W3mModal);

    var index$5 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        get W3mModal () { return W3mModal; }
    });

    var styles$G = i$d `
  :host {
    display: block;
    width: max-content;
  }
`;

    var __decorate$11 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let W3mNetworkButton = class W3mNetworkButton extends s$a {
        constructor() {
            super();
            this.unsubscribe = [];
            this.disabled = false;
            this.network = NetworkController.state.caipNetwork;
            this.connected = AccountController.state.isConnected;
            this.loading = ModalController.state.loading;
            this.isUnsupportedChain = NetworkController.state.isUnsupportedChain;
            this.unsubscribe.push(...[
                NetworkController.subscribeKey('caipNetwork', val => (this.network = val)),
                AccountController.subscribeKey('isConnected', val => (this.connected = val)),
                ModalController.subscribeKey('loading', val => (this.loading = val)),
                NetworkController.subscribeKey('isUnsupportedChain', val => (this.isUnsupportedChain = val))
            ]);
        }
        disconnectedCallback() {
            this.unsubscribe.forEach(unsubscribe => unsubscribe());
        }
        render() {
            return x$4 `
      <wui-network-button
        .disabled=${Boolean(this.disabled || this.loading)}
        .isUnsupportedChain=${this.isUnsupportedChain}
        imageSrc=${o$e(AssetUtil.getNetworkImage(this.network))}
        @click=${this.onClick.bind(this)}
      >
        ${this.isUnsupportedChain
            ? 'Switch Network'
            : this.network?.name ?? (this.connected ? 'Unknown Network' : 'Select Network')}
      </wui-network-button>
    `;
        }
        onClick() {
            if (!this.loading) {
                EventsController.sendEvent({ type: 'track', event: 'CLICK_NETWORKS' });
                ModalController.open({ view: 'Networks' });
            }
        }
    };
    W3mNetworkButton.styles = styles$G;
    __decorate$11([
        n$d({ type: Boolean })
    ], W3mNetworkButton.prototype, "disabled", void 0);
    __decorate$11([
        r$e()
    ], W3mNetworkButton.prototype, "network", void 0);
    __decorate$11([
        r$e()
    ], W3mNetworkButton.prototype, "connected", void 0);
    __decorate$11([
        r$e()
    ], W3mNetworkButton.prototype, "loading", void 0);
    __decorate$11([
        r$e()
    ], W3mNetworkButton.prototype, "isUnsupportedChain", void 0);
    W3mNetworkButton = __decorate$11([
        customElement('w3m-network-button')
    ], W3mNetworkButton);

    var styles$F = i$d `
  :host {
    display: block;
    will-change: transform, opacity;
  }
`;

    var __decorate$10 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let W3mRouter = class W3mRouter extends s$a {
        constructor() {
            super();
            this.resizeObserver = undefined;
            this.prevHeight = '0px';
            this.prevHistoryLength = 1;
            this.unsubscribe = [];
            this.view = RouterController.state.view;
            this.unsubscribe.push(RouterController.subscribeKey('view', val => this.onViewChange(val)));
        }
        firstUpdated() {
            this.resizeObserver = new ResizeObserver(async ([content]) => {
                const height = `${content?.contentRect.height}px`;
                if (this.prevHeight !== '0px') {
                    await this.animate([{ height: this.prevHeight }, { height }], {
                        duration: 150,
                        easing: 'ease',
                        fill: 'forwards'
                    }).finished;
                    this.style.height = 'auto';
                }
                this.prevHeight = height;
            });
            this.resizeObserver.observe(this.getWrapper());
        }
        disconnectedCallback() {
            this.resizeObserver?.unobserve(this.getWrapper());
            this.unsubscribe.forEach(unsubscribe => unsubscribe());
        }
        render() {
            return x$4 `<div>${this.viewTemplate()}</div>`;
        }
        viewTemplate() {
            switch (this.view) {
                case 'Connect':
                    return x$4 `<w3m-connect-view></w3m-connect-view>`;
                case 'ConnectingWalletConnect':
                    return x$4 `<w3m-connecting-wc-view></w3m-connecting-wc-view>`;
                case 'ConnectingExternal':
                    return x$4 `<w3m-connecting-external-view></w3m-connecting-external-view>`;
                case 'ConnectingSiwe':
                    return x$4 `<w3m-connecting-siwe-view></w3m-connecting-siwe-view>`;
                case 'AllWallets':
                    return x$4 `<w3m-all-wallets-view></w3m-all-wallets-view>`;
                case 'Networks':
                    return x$4 `<w3m-networks-view></w3m-networks-view>`;
                case 'SwitchNetwork':
                    return x$4 `<w3m-network-switch-view></w3m-network-switch-view>`;
                case 'Account':
                    return x$4 `<w3m-account-view></w3m-account-view>`;
                case 'AccountSettings':
                    return x$4 `<w3m-account-settings-view></w3m-account-settings-view>`;
                case 'WhatIsAWallet':
                    return x$4 `<w3m-what-is-a-wallet-view></w3m-what-is-a-wallet-view>`;
                case 'WhatIsANetwork':
                    return x$4 `<w3m-what-is-a-network-view></w3m-what-is-a-network-view>`;
                case 'GetWallet':
                    return x$4 `<w3m-get-wallet-view></w3m-get-wallet-view>`;
                case 'Downloads':
                    return x$4 `<w3m-downloads-view></w3m-downloads-view>`;
                case 'EmailVerifyOtp':
                    return x$4 `<w3m-email-verify-otp-view></w3m-email-verify-otp-view>`;
                case 'EmailVerifyDevice':
                    return x$4 `<w3m-email-verify-device-view></w3m-email-verify-device-view>`;
                case 'ApproveTransaction':
                    return x$4 `<w3m-approve-transaction-view></w3m-approve-transaction-view>`;
                case 'Transactions':
                    return x$4 `<w3m-transactions-view></w3m-transactions-view>`;
                case 'UpgradeEmailWallet':
                    return x$4 `<w3m-upgrade-wallet-view></w3m-upgrade-wallet-view>`;
                case 'UpgradeToSmartAccount':
                    return x$4 `<w3m-upgrade-to-smart-account-view></w3m-upgrade-to-smart-account-view>`;
                case 'UpdateEmailWallet':
                    return x$4 `<w3m-update-email-wallet-view></w3m-update-email-wallet-view>`;
                case 'UpdateEmailPrimaryOtp':
                    return x$4 `<w3m-update-email-primary-otp-view></w3m-update-email-primary-otp-view>`;
                case 'UpdateEmailSecondaryOtp':
                    return x$4 `<w3m-update-email-secondary-otp-view></w3m-update-email-secondary-otp-view>`;
                case 'UnsupportedChain':
                    return x$4 `<w3m-unsupported-chain-view></w3m-unsupported-chain-view>`;
                case 'OnRampProviders':
                    return x$4 `<w3m-onramp-providers-view></w3m-onramp-providers-view>`;
                case 'OnRampActivity':
                    return x$4 `<w3m-onramp-activity-view></w3m-onramp-activity-view>`;
                case 'OnRampTokenSelect':
                    return x$4 `<w3m-onramp-token-select-view></w3m-onramp-token-select-view>`;
                case 'OnRampFiatSelect':
                    return x$4 `<w3m-onramp-fiat-select-view></w3m-onramp-fiat-select-view>`;
                case 'WhatIsABuy':
                    return x$4 `<w3m-what-is-a-buy-view></w3m-what-is-a-buy-view>`;
                case 'BuyInProgress':
                    return x$4 `<w3m-buy-in-progress-view></w3m-buy-in-progress-view>`;
                case 'WalletReceive':
                    return x$4 `<w3m-wallet-receive-view></w3m-wallet-receive-view>`;
                case 'WalletCompatibleNetworks':
                    return x$4 `<w3m-wallet-compatible-networks-view></w3m-wallet-compatible-networks-view>`;
                case 'WalletSend':
                    return x$4 `<w3m-wallet-send-view></w3m-wallet-send-view>`;
                case 'WalletSendSelectToken':
                    return x$4 `<w3m-wallet-send-select-token-view></w3m-wallet-send-select-token-view>`;
                case 'WalletSendPreview':
                    return x$4 `<w3m-wallet-send-preview-view></w3m-wallet-send-preview-view>`;
                default:
                    return x$4 `<w3m-connect-view></w3m-connect-view>`;
            }
        }
        async onViewChange(newView) {
            const { history } = RouterController.state;
            let xOut = -10;
            let xIn = 10;
            if (history.length < this.prevHistoryLength) {
                xOut = 10;
                xIn = -10;
            }
            this.prevHistoryLength = history.length;
            await this.animate([
                { opacity: 1, transform: 'translateX(0px)' },
                { opacity: 0, transform: `translateX(${xOut}px)` }
            ], { duration: 150, easing: 'ease', fill: 'forwards' }).finished;
            this.view = newView;
            await this.animate([
                { opacity: 0, transform: `translateX(${xIn}px)` },
                { opacity: 1, transform: 'translateX(0px)' }
            ], { duration: 150, easing: 'ease', fill: 'forwards', delay: 50 }).finished;
        }
        getWrapper() {
            return this.shadowRoot?.querySelector('div');
        }
    };
    W3mRouter.styles = styles$F;
    __decorate$10([
        r$e()
    ], W3mRouter.prototype, "view", void 0);
    W3mRouter = __decorate$10([
        customElement('w3m-router')
    ], W3mRouter);

    var styles$E = i$d `
  :host > wui-flex {
    width: 100%;
    max-width: 360px;
  }

  :host > wui-flex > wui-flex {
    border-radius: var(--wui-border-radius-l);
    width: 100%;
  }

  .amounts-container {
    width: 100%;
  }
`;

    var __decorate$$ = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    const PAYMENT_CURRENCY_SYMBOLS = {
        USD: '$',
        EUR: '€',
        GBP: '£'
    };
    const BUY_PRESET_AMOUNTS = [100, 250, 500, 1000];
    let W3mOnrampWidget = class W3mOnrampWidget extends s$a {
        constructor() {
            super();
            this.unsubscribe = [];
            this.disabled = false;
            this.connected = AccountController.state.isConnected;
            this.loading = ModalController.state.loading;
            this.paymentCurrency = OnRampController.state.paymentCurrency;
            this.paymentAmount = OnRampController.state.paymentAmount;
            this.purchaseAmount = OnRampController.state.purchaseAmount;
            this.quoteLoading = OnRampController.state.quotesLoading;
            this.unsubscribe.push(...[
                AccountController.subscribeKey('isConnected', val => {
                    this.connected = val;
                }),
                ModalController.subscribeKey('loading', val => {
                    this.loading = val;
                }),
                OnRampController.subscribe(val => {
                    this.paymentCurrency = val.paymentCurrency;
                    this.paymentAmount = val.paymentAmount;
                    this.purchaseAmount = val.purchaseAmount;
                    this.quoteLoading = val.quotesLoading;
                })
            ]);
        }
        disconnectedCallback() {
            this.unsubscribe.forEach(unsubscribe => unsubscribe());
        }
        render() {
            return x$4 `
      <wui-flex flexDirection="column" justifyContent="center" alignItems="center">
        <wui-flex flexDirection="column" alignItems="center" gap="xs">
          <w3m-swap-input
            type="Fiat"
            @inputChange=${this.onPaymentAmountChange.bind(this)}
            .value=${this.paymentAmount || 0}
          ></w3m-swap-input>
          <w3m-swap-input
            type="Token"
            .value=${this.purchaseAmount || 0}
            .loading=${this.quoteLoading}
          ></w3m-swap-input>
          <wui-flex justifyContent="space-evenly" class="amounts-container" gap="xs">
            ${BUY_PRESET_AMOUNTS.map(amount => x$4 `<wui-button
                  variant=${this.paymentAmount === amount ? 'accentBg' : 'shade'}
                  size="xs"
                  textVariant="paragraph-600"
                  fullWidth
                  @click=${() => this.selectPresetAmount(amount)}
                  >${`${PAYMENT_CURRENCY_SYMBOLS[this.paymentCurrency?.id || 'USD']} ${amount}`}</wui-button
                >`)}
          </wui-flex>
          ${this.templateButton()}
        </wui-flex>
      </wui-flex>
    `;
        }
        templateButton() {
            return this.connected
                ? x$4 `<wui-button
          @click=${this.getQuotes.bind(this)}
          variant="fill"
          fullWidth
          size="lg"
          borderRadius="xs"
        >
          Get quotes
        </wui-button>`
                : x$4 `<wui-button
          @click=${this.openModal.bind(this)}
          variant="accentBg"
          fullWidth
          size="lg"
          borderRadius="xs"
        >
          Connect wallet
        </wui-button>`;
        }
        getQuotes() {
            if (!this.loading) {
                ModalController.open({ view: 'OnRampProviders' });
            }
        }
        openModal() {
            ModalController.open({ view: 'Connect' });
        }
        async onPaymentAmountChange(event) {
            OnRampController.setPaymentAmount(Number(event.detail));
            await OnRampController.getQuote();
        }
        async selectPresetAmount(amount) {
            OnRampController.setPaymentAmount(amount);
            await OnRampController.getQuote();
        }
    };
    W3mOnrampWidget.styles = styles$E;
    __decorate$$([
        n$d({ type: Boolean })
    ], W3mOnrampWidget.prototype, "disabled", void 0);
    __decorate$$([
        r$e()
    ], W3mOnrampWidget.prototype, "connected", void 0);
    __decorate$$([
        r$e()
    ], W3mOnrampWidget.prototype, "loading", void 0);
    __decorate$$([
        r$e()
    ], W3mOnrampWidget.prototype, "paymentCurrency", void 0);
    __decorate$$([
        r$e()
    ], W3mOnrampWidget.prototype, "paymentAmount", void 0);
    __decorate$$([
        r$e()
    ], W3mOnrampWidget.prototype, "purchaseAmount", void 0);
    __decorate$$([
        r$e()
    ], W3mOnrampWidget.prototype, "quoteLoading", void 0);
    W3mOnrampWidget = __decorate$$([
        customElement('w3m-onramp-widget')
    ], W3mOnrampWidget);

    var styles$D = i$d `
  wui-flex {
    width: 100%;
  }

  wui-icon-link {
    margin-right: calc(var(--wui-icon-box-size-md) * -1);
  }

  .account-links {
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .account-links wui-flex {
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    flex: 1;
    background: red;
    align-items: center;
    justify-content: center;
    height: 48px;
    padding: 10px;
    flex: 1 0 0;

    border-radius: var(--XS, 16px);
    border: 1px solid var(--dark-accent-glass-010, rgba(71, 161, 255, 0.1));
    background: var(--dark-accent-glass-010, rgba(71, 161, 255, 0.1));
    transition: background 0.2s linear;
  }

  .account-links wui-flex:hover {
    background: var(--dark-accent-glass-015, rgba(71, 161, 255, 0.15));
  }

  .account-links wui-flex wui-icon {
    width: var(--S, 20px);
    height: var(--S, 20px);
  }

  .account-links wui-flex wui-icon svg path {
    stroke: #47a1ff;
  }
`;

    var __decorate$_ = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let W3mAccountSettingsView = class W3mAccountSettingsView extends s$a {
        constructor() {
            super();
            this.usubscribe = [];
            this.networkImages = AssetController.state.networkImages;
            this.address = AccountController.state.address;
            this.profileImage = AccountController.state.profileImage;
            this.profileName = AccountController.state.profileName;
            this.network = NetworkController.state.caipNetwork;
            this.disconnecting = false;
            this.usubscribe.push(...[
                AccountController.subscribe(val => {
                    if (val.address) {
                        this.address = val.address;
                        this.profileImage = val.profileImage;
                        this.profileName = val.profileName;
                    }
                    else {
                        ModalController.close();
                    }
                })
            ], NetworkController.subscribeKey('caipNetwork', val => {
                if (val?.id) {
                    this.network = val;
                }
            }));
        }
        disconnectedCallback() {
            this.usubscribe.forEach(unsubscribe => unsubscribe());
        }
        render() {
            if (!this.address) {
                throw new Error('w3m-account-settings-view: No account provided');
            }
            const networkImage = this.networkImages[this.network?.imageId ?? ''];
            return x$4 `
      <wui-flex
        flexDirection="column"
        .padding=${['0', 'xl', 'm', 'xl']}
        alignItems="center"
        gap="l"
      >
        <wui-avatar
          alt=${this.address}
          address=${this.address}
          imageSrc=${o$e(this.profileImage)}
        ></wui-avatar>
        <wui-flex flexDirection="column" alignItems="center">
          <wui-flex gap="3xs" alignItems="center" justifyContent="center">
            <wui-text variant="large-600" color="fg-100">
              ${this.profileName
            ? UiHelperUtil.getTruncateString({
                string: this.profileName,
                charsStart: 20,
                charsEnd: 0,
                truncate: 'end'
            })
            : UiHelperUtil.getTruncateString({
                string: this.address,
                charsStart: 4,
                charsEnd: 6,
                truncate: 'middle'
            })}
            </wui-text>
            <wui-icon-link
              size="md"
              icon="copy"
              iconColor="fg-200"
              @click=${this.onCopyAddress}
            ></wui-icon-link>
          </wui-flex>
        </wui-flex>
      </wui-flex>

      <wui-flex flexDirection="column" gap="m">
        <wui-flex flexDirection="column" gap="xs" .padding=${['0', 'xl', 'm', 'xl']}>
          ${this.emailBtnTemplate()}
          <wui-list-item
            .variant=${networkImage ? 'image' : 'icon'}
            iconVariant="overlay"
            icon="networkPlaceholder"
            imageSrc=${o$e(networkImage)}
            ?chevron=${this.isAllowedNetworkSwitch()}
            @click=${this.onNetworks.bind(this)}
          >
            <wui-text variant="paragraph-500" color="fg-100">
              ${this.network?.name ?? 'Unknown'}
            </wui-text>
          </wui-list-item>
          <wui-list-item
            variant="icon"
            iconVariant="overlay"
            icon="disconnect"
            ?chevron=${false}
            .loading=${this.disconnecting}
            @click=${this.onDisconnect.bind(this)}
            data-testid="disconnect-button"
          >
            <wui-text variant="paragraph-500" color="fg-200">Disconnect</wui-text>
          </wui-list-item>
        </wui-flex>
      </wui-flex>
    `;
        }
        isAllowedNetworkSwitch() {
            const { requestedCaipNetworks } = NetworkController.state;
            const isMultiNetwork = requestedCaipNetworks ? requestedCaipNetworks.length > 1 : false;
            const isValidNetwork = requestedCaipNetworks?.find(({ id }) => id === this.network?.id);
            return isMultiNetwork || !isValidNetwork;
        }
        onCopyAddress() {
            try {
                if (this.address) {
                    CoreHelperUtil.copyToClopboard(this.address);
                    SnackController.showSuccess('Address copied');
                }
            }
            catch {
                SnackController.showError('Failed to copy');
            }
        }
        emailBtnTemplate() {
            const type = StorageUtil.getConnectedConnector();
            const emailConnector = ConnectorController.getEmailConnector();
            if (!emailConnector || type !== 'EMAIL') {
                return null;
            }
            const email = emailConnector.provider.getEmail() ?? '';
            return x$4 `
      <wui-list-item
        variant="icon"
        iconVariant="overlay"
        icon="mail"
        iconSize="sm"
        ?chevron=${true}
        @click=${() => this.onGoToUpdateEmail(email)}
      >
        <wui-text variant="paragraph-500" color="fg-100">${email}</wui-text>
      </wui-list-item>
    `;
        }
        onGoToUpdateEmail(email) {
            RouterController.push('UpdateEmailWallet', { email });
        }
        onNetworks() {
            if (this.isAllowedNetworkSwitch()) {
                RouterController.push('Networks');
            }
        }
        async onDisconnect() {
            try {
                this.disconnecting = true;
                await ConnectionController.disconnect();
                EventsController.sendEvent({ type: 'track', event: 'DISCONNECT_SUCCESS' });
                ModalController.close();
            }
            catch {
                EventsController.sendEvent({ type: 'track', event: 'DISCONNECT_ERROR' });
                SnackController.showError('Failed to disconnect');
            }
            finally {
                this.disconnecting = false;
            }
        }
    };
    W3mAccountSettingsView.styles = styles$D;
    __decorate$_([
        r$e()
    ], W3mAccountSettingsView.prototype, "address", void 0);
    __decorate$_([
        r$e()
    ], W3mAccountSettingsView.prototype, "profileImage", void 0);
    __decorate$_([
        r$e()
    ], W3mAccountSettingsView.prototype, "profileName", void 0);
    __decorate$_([
        r$e()
    ], W3mAccountSettingsView.prototype, "network", void 0);
    __decorate$_([
        r$e()
    ], W3mAccountSettingsView.prototype, "disconnecting", void 0);
    W3mAccountSettingsView = __decorate$_([
        customElement('w3m-account-settings-view')
    ], W3mAccountSettingsView);

    var __decorate$Z = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let W3mAccountView = class W3mAccountView extends s$a {
        render() {
            const type = StorageUtil.getConnectedConnector();
            return x$4 `
      ${OptionsController.state.enableWalletFeatures && type === 'EMAIL'
            ? this.walletFeaturesTemplate()
            : this.defaultTemplate()}
    `;
        }
        walletFeaturesTemplate() {
            return x$4 `<w3m-account-wallet-features-widget></w3m-account-wallet-features-widget>`;
        }
        defaultTemplate() {
            return x$4 `<w3m-account-default-widget></w3m-account-default-widget>`;
        }
    };
    W3mAccountView = __decorate$Z([
        customElement('w3m-account-view')
    ], W3mAccountView);

    var __decorate$Y = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let W3mAllWalletsView = class W3mAllWalletsView extends s$a {
        constructor() {
            super(...arguments);
            this.search = '';
            this.onDebouncedSearch = CoreHelperUtil.debounce((value) => {
                this.search = value;
            });
        }
        render() {
            const isSearch = this.search.length >= 2;
            return x$4 `
      <wui-flex padding="s" gap="s">
        <wui-search-bar @inputChange=${this.onInputChange.bind(this)}></wui-search-bar>
        ${this.qrButtonTemplate()}
      </wui-flex>
      ${isSearch
            ? x$4 `<w3m-all-wallets-search query=${this.search}></w3m-all-wallets-search>`
            : x$4 `<w3m-all-wallets-list></w3m-all-wallets-list>`}
    `;
        }
        onInputChange(event) {
            this.onDebouncedSearch(event.detail);
        }
        qrButtonTemplate() {
            if (CoreHelperUtil.isMobile()) {
                return x$4 `
        <wui-icon-box
          size="lg"
          iconSize="xl"
          iconColor="accent-100"
          backgroundColor="accent-100"
          icon="qrCode"
          background="transparent"
          border
          borderColor="wui-accent-glass-010"
          @click=${this.onWalletConnectQr.bind(this)}
        ></wui-icon-box>
      `;
            }
            return null;
        }
        onWalletConnectQr() {
            RouterController.push('ConnectingWalletConnect');
        }
    };
    __decorate$Y([
        r$e()
    ], W3mAllWalletsView.prototype, "search", void 0);
    W3mAllWalletsView = __decorate$Y([
        customElement('w3m-all-wallets-view')
    ], W3mAllWalletsView);

    var styles$C = i$d `
  @keyframes shake {
    0% {
      transform: translateX(0);
    }
    25% {
      transform: translateX(3px);
    }
    50% {
      transform: translateX(-3px);
    }
    75% {
      transform: translateX(3px);
    }
    100% {
      transform: translateX(0);
    }
  }

  wui-flex:first-child:not(:only-child) {
    position: relative;
  }

  wui-loading-thumbnail {
    position: absolute;
  }

  wui-visual {
    width: var(--wui-wallet-image-size-lg);
    height: var(--wui-wallet-image-size-lg);
    border-radius: calc(var(--wui-border-radius-5xs) * 9 - var(--wui-border-radius-xxs));
    position: relative;
    overflow: hidden;
  }

  wui-visual::after {
    content: '';
    display: block;
    width: 100%;
    height: 100%;
    position: absolute;
    inset: 0;
    border-radius: calc(var(--wui-border-radius-5xs) * 9 - var(--wui-border-radius-xxs));
    box-shadow: inset 0 0 0 1px var(--wui-gray-glass-005);
  }

  wui-icon-box {
    position: absolute;
    right: calc(var(--wui-spacing-3xs) * -1);
    bottom: calc(var(--wui-spacing-3xs) * -1);
    opacity: 0;
    transform: scale(0.5);
    transition: all var(--wui-ease-out-power-2) var(--wui-duration-lg);
  }

  wui-text[align='center'] {
    width: 100%;
    padding: 0px var(--wui-spacing-l);
  }

  [data-error='true'] wui-icon-box {
    opacity: 1;
    transform: scale(1);
  }

  [data-error='true'] > wui-flex:first-child {
    animation: shake 250ms cubic-bezier(0.36, 0.07, 0.19, 0.97) both;
  }

  [data-retry='false'] wui-link {
    display: none;
  }

  [data-retry='true'] wui-link {
    display: block;
    opacity: 1;
  }

  wui-link {
    padding: var(--wui-spacing-4xs) var(--wui-spacing-xxs);
  }
`;

    var __decorate$X = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let W3mBuyInProgressView = class W3mBuyInProgressView extends s$a {
        constructor() {
            super();
            this.unsubscribe = [];
            this.selectedOnRampProvider = OnRampController.state.selectedProvider;
            this.uri = ConnectionController.state.wcUri;
            this.ready = false;
            this.showRetry = false;
            this.buffering = false;
            this.error = false;
            this.startTime = null;
            this.isMobile = false;
            this.onRetry = undefined;
            this.unsubscribe.push(...[
                OnRampController.subscribeKey('selectedProvider', val => {
                    this.selectedOnRampProvider = val;
                })
            ]);
            this.watchTransactions();
        }
        disconnectedCallback() {
            if (this.intervalId) {
                clearInterval(this.intervalId);
            }
        }
        render() {
            let label = 'Continue in external window';
            if (this.error) {
                label = 'Buy failed';
            }
            else if (this.selectedOnRampProvider) {
                label = `Buy in ${this.selectedOnRampProvider?.label}`;
            }
            const subLabel = this.error
                ? 'Buy can be declined from your side or due to and error on the provider app'
                : `We’ll notify you once your Buy is processed`;
            return x$4 `
      <wui-flex
        data-error=${o$e(this.error)}
        data-retry=${this.showRetry}
        flexDirection="column"
        alignItems="center"
        .padding=${['3xl', 'xl', 'xl', 'xl']}
        gap="xl"
      >
        <wui-flex justifyContent="center" alignItems="center">
          <wui-visual
            name=${o$e(this.selectedOnRampProvider?.name)}
            size="lg"
            class="provider-image"
          >
          </wui-visual>

          ${this.error ? null : this.loaderTemplate()}

          <wui-icon-box
            backgroundColor="error-100"
            background="opaque"
            iconColor="error-100"
            icon="close"
            size="sm"
            border
            borderColor="wui-color-bg-125"
          ></wui-icon-box>
        </wui-flex>

        <wui-flex flexDirection="column" alignItems="center" gap="xs">
          <wui-text variant="paragraph-500" color=${this.error ? 'error-100' : 'fg-100'}>
            ${label}
          </wui-text>
          <wui-text align="center" variant="small-500" color="fg-200">${subLabel}</wui-text>
        </wui-flex>

        ${this.error ? this.tryAgainTemplate() : null}
      </wui-flex>

      <wui-flex .padding=${['0', 'xl', 'xl', 'xl']} justifyContent="center">
        <wui-link @click=${this.onCopyUri} color="fg-200">
          <wui-icon size="xs" color="fg-200" slot="iconLeft" name="copy"></wui-icon>
          Copy link
        </wui-link>
      </wui-flex>
    `;
        }
        watchTransactions() {
            if (!this.selectedOnRampProvider) {
                return;
            }
            switch (this.selectedOnRampProvider.name) {
                case 'coinbase':
                    this.startTime = Date.now();
                    this.initializeCoinbaseTransactions();
                    break;
            }
        }
        async initializeCoinbaseTransactions() {
            await this.watchCoinbaseTransactions();
            this.intervalId = setInterval(() => this.watchCoinbaseTransactions(), 4000);
        }
        async watchCoinbaseTransactions() {
            try {
                const address = AccountController.state.address;
                const projectId = OptionsController.state.projectId;
                if (!address) {
                    throw new Error('No address found');
                }
                const coinbaseResponse = await BlockchainApiController.fetchTransactions({
                    account: address,
                    onramp: 'coinbase',
                    projectId
                });
                const newTransactions = coinbaseResponse.data.filter(tx => new Date(tx.metadata.minedAt) > new Date(this.startTime) ||
                    tx.metadata.status === 'ONRAMP_TRANSACTION_STATUS_IN_PROGRESS');
                if (newTransactions.length) {
                    clearInterval(this.intervalId);
                    RouterController.replace('OnRampActivity');
                }
                else if (this.startTime && Date.now() - this.startTime >= 180000) {
                    clearInterval(this.intervalId);
                    this.error = true;
                }
            }
            catch (error) {
                SnackController.showError(error);
            }
        }
        onTryAgain() {
            if (!this.selectedOnRampProvider) {
                return;
            }
            this.error = false;
            CoreHelperUtil.openHref(this.selectedOnRampProvider.url, 'popupWindow', 'width=600,height=800,scrollbars=yes');
        }
        tryAgainTemplate() {
            if (!this.selectedOnRampProvider?.url) {
                return null;
            }
            return x$4 `<wui-button variant="accent" @click=${this.onTryAgain.bind(this)}>
      <wui-icon color="inherit" slot="iconLeft" name="refresh"></wui-icon>
      Try again
    </wui-button>`;
        }
        loaderTemplate() {
            const borderRadiusMaster = ThemeController.state.themeVariables['--w3m-border-radius-master'];
            const radius = borderRadiusMaster ? parseInt(borderRadiusMaster.replace('px', ''), 10) : 4;
            return x$4 `<wui-loading-thumbnail radius=${radius * 9}></wui-loading-thumbnail>`;
        }
        onCopyUri() {
            if (!this.selectedOnRampProvider?.url) {
                SnackController.showError('No link found');
                RouterController.goBack();
                return;
            }
            try {
                CoreHelperUtil.copyToClopboard(this.selectedOnRampProvider.url);
                SnackController.showSuccess('Link copied');
            }
            catch {
                SnackController.showError('Failed to copy');
            }
        }
    };
    W3mBuyInProgressView.styles = styles$C;
    __decorate$X([
        r$e()
    ], W3mBuyInProgressView.prototype, "selectedOnRampProvider", void 0);
    __decorate$X([
        r$e()
    ], W3mBuyInProgressView.prototype, "uri", void 0);
    __decorate$X([
        r$e()
    ], W3mBuyInProgressView.prototype, "ready", void 0);
    __decorate$X([
        r$e()
    ], W3mBuyInProgressView.prototype, "showRetry", void 0);
    __decorate$X([
        r$e()
    ], W3mBuyInProgressView.prototype, "buffering", void 0);
    __decorate$X([
        r$e()
    ], W3mBuyInProgressView.prototype, "error", void 0);
    __decorate$X([
        r$e()
    ], W3mBuyInProgressView.prototype, "intervalId", void 0);
    __decorate$X([
        r$e()
    ], W3mBuyInProgressView.prototype, "startTime", void 0);
    __decorate$X([
        n$d({ type: Boolean })
    ], W3mBuyInProgressView.prototype, "isMobile", void 0);
    __decorate$X([
        n$d()
    ], W3mBuyInProgressView.prototype, "onRetry", void 0);
    W3mBuyInProgressView = __decorate$X([
        customElement('w3m-buy-in-progress-view')
    ], W3mBuyInProgressView);

    var styles$B = i$d `
  wui-flex {
    max-height: clamp(360px, 540px, 80vh);
    overflow: scroll;
    scrollbar-width: none;
  }

  wui-flex::-webkit-scrollbar {
    display: none;
  }
`;

    var __decorate$W = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let W3mConnectView = class W3mConnectView extends s$a {
        constructor() {
            super();
            this.unsubscribe = [];
            this.connectors = ConnectorController.state.connectors;
            this.count = ApiController.state.count;
            this.unsubscribe.push(ConnectorController.subscribeKey('connectors', val => (this.connectors = val)), ApiController.subscribeKey('count', val => (this.count = val)));
        }
        disconnectedCallback() {
            this.unsubscribe.forEach(unsubscribe => unsubscribe());
        }
        render() {
            return x$4 `
      <wui-flex flexDirection="column" padding="s" gap="xs">
        <w3m-email-login-widget></w3m-email-login-widget>

        ${this.walletConnectConnectorTemplate()} ${this.recentTemplate()}
        ${this.announcedTemplate()} ${this.injectedTemplate()} ${this.featuredTemplate()}
        ${this.customTemplate()} ${this.recommendedTemplate()} ${this.externalTemplate()}
        ${this.allWalletsTemplate()}
      </wui-flex>
      <w3m-legal-footer></w3m-legal-footer>
    `;
        }
        walletConnectConnectorTemplate() {
            if (CoreHelperUtil.isMobile()) {
                return null;
            }
            const connector = this.connectors.find(c => c.type === 'WALLET_CONNECT');
            if (!connector) {
                return null;
            }
            return x$4 `
      <wui-list-wallet
        imageSrc=${o$e(AssetUtil.getConnectorImage(connector))}
        name=${connector.name ?? 'Unknown'}
        @click=${() => this.onConnector(connector)}
        tagLabel="qr code"
        tagVariant="main"
        data-testid="wallet-selector-walletconnect"
      >
      </wui-list-wallet>
    `;
        }
        customTemplate() {
            const { customWallets } = OptionsController.state;
            if (!customWallets?.length) {
                return null;
            }
            const wallets = this.filterOutDuplicateWallets(customWallets);
            return wallets.map(wallet => x$4 `
        <wui-list-wallet
          imageSrc=${o$e(AssetUtil.getWalletImage(wallet))}
          name=${wallet.name ?? 'Unknown'}
          @click=${() => this.onConnectWallet(wallet)}
          data-testid=${`wallet-selector-${wallet.id}`}
        >
        </wui-list-wallet>
      `);
        }
        featuredTemplate() {
            const connector = this.connectors.find(c => c.type === 'WALLET_CONNECT');
            if (!connector) {
                return null;
            }
            const { featured } = ApiController.state;
            if (!featured.length) {
                return null;
            }
            const wallets = this.filterOutDuplicateWallets(featured);
            return wallets.map(wallet => x$4 `
        <wui-list-wallet
          imageSrc=${o$e(AssetUtil.getWalletImage(wallet))}
          name=${wallet.name ?? 'Unknown'}
          @click=${() => this.onConnectWallet(wallet)}
        >
        </wui-list-wallet>
      `);
        }
        recentTemplate() {
            const recent = StorageUtil.getRecentWallets();
            return recent.map(wallet => x$4 `
        <wui-list-wallet
          imageSrc=${o$e(AssetUtil.getWalletImage(wallet))}
          name=${wallet.name ?? 'Unknown'}
          @click=${() => this.onConnectWallet(wallet)}
          tagLabel="recent"
          tagVariant="shade"
        >
        </wui-list-wallet>
      `);
        }
        announcedTemplate() {
            return this.connectors.map(connector => {
                if (connector.type !== 'ANNOUNCED') {
                    return null;
                }
                return x$4 `
        <wui-list-wallet
          imageSrc=${o$e(AssetUtil.getConnectorImage(connector))}
          name=${connector.name ?? 'Unknown'}
          @click=${() => this.onConnector(connector)}
          tagVariant="success"
          .installed=${true}
        >
        </wui-list-wallet>
      `;
            });
        }
        injectedTemplate() {
            return this.connectors.map(connector => {
                if (connector.type !== 'INJECTED') {
                    return null;
                }
                if (!ConnectionController.checkInstalled()) {
                    return null;
                }
                return x$4 `
        <wui-list-wallet
          imageSrc=${o$e(AssetUtil.getConnectorImage(connector))}
          .installed=${true}
          name=${connector.name ?? 'Unknown'}
          @click=${() => this.onConnector(connector)}
        >
        </wui-list-wallet>
      `;
            });
        }
        externalTemplate() {
            const announcedRdns = ConnectorController.getAnnouncedConnectorRdns();
            return this.connectors.map(connector => {
                if (['WALLET_CONNECT', 'INJECTED', 'ANNOUNCED', 'EMAIL'].includes(connector.type)) {
                    return null;
                }
                if (announcedRdns.includes(ConstantsUtil$2.CONNECTOR_RDNS_MAP[connector.id])) {
                    return null;
                }
                return x$4 `
        <wui-list-wallet
          imageSrc=${o$e(AssetUtil.getConnectorImage(connector))}
          name=${connector.name ?? 'Unknown'}
          @click=${() => this.onConnector(connector)}
        >
        </wui-list-wallet>
      `;
            });
        }
        allWalletsTemplate() {
            const connector = this.connectors.find(c => c.type === 'WALLET_CONNECT');
            const { allWallets } = OptionsController.state;
            if (!connector || allWallets === 'HIDE') {
                return null;
            }
            if (allWallets === 'ONLY_MOBILE' && !CoreHelperUtil.isMobile()) {
                return null;
            }
            const featuredCount = ApiController.state.featured.length;
            const rawCount = this.count + featuredCount;
            const roundedCount = rawCount < 10 ? rawCount : Math.floor(rawCount / 10) * 10;
            const tagLabel = roundedCount < rawCount ? `${roundedCount}+` : `${roundedCount}`;
            return x$4 `
      <wui-list-wallet
        name="All Wallets"
        walletIcon="allWallets"
        showAllWallets
        @click=${this.onAllWallets.bind(this)}
        tagLabel=${tagLabel}
        tagVariant="shade"
        data-testid="all-wallets"
      ></wui-list-wallet>
    `;
        }
        recommendedTemplate() {
            const connector = this.connectors.find(c => c.type === 'WALLET_CONNECT');
            if (!connector) {
                return null;
            }
            const { recommended } = ApiController.state;
            const { customWallets, featuredWalletIds } = OptionsController.state;
            const { connectors } = ConnectorController.state;
            const recent = StorageUtil.getRecentWallets();
            const injected = connectors.filter(c => c.type === 'INJECTED');
            const filteredInjected = injected.filter(i => i.name !== 'Browser Wallet');
            if (featuredWalletIds || customWallets || !recommended.length) {
                return null;
            }
            const overrideLength = filteredInjected.length + recent.length;
            const maxRecommended = Math.max(0, 2 - overrideLength);
            const wallets = this.filterOutDuplicateWallets(recommended).slice(0, maxRecommended);
            return wallets.map(wallet => x$4 `
        <wui-list-wallet
          imageSrc=${o$e(AssetUtil.getWalletImage(wallet))}
          name=${wallet?.name ?? 'Unknown'}
          @click=${() => this.onConnectWallet(wallet)}
        >
        </wui-list-wallet>
      `);
        }
        onConnector(connector) {
            if (connector.type === 'WALLET_CONNECT') {
                if (CoreHelperUtil.isMobile()) {
                    RouterController.push('AllWallets');
                }
                else {
                    RouterController.push('ConnectingWalletConnect');
                }
            }
            else {
                RouterController.push('ConnectingExternal', { connector });
            }
        }
        filterOutDuplicateWallets(wallets) {
            const recent = StorageUtil.getRecentWallets();
            const connectorRDNSs = this.connectors
                .map(connector => connector.info?.rdns)
                .filter(Boolean);
            const recentRDNSs = recent.map(wallet => wallet.rdns).filter(Boolean);
            const allRDNSs = connectorRDNSs.concat(recentRDNSs);
            const filtered = wallets.filter(wallet => !allRDNSs.includes(String(wallet?.rdns)));
            return filtered;
        }
        onAllWallets() {
            EventsController.sendEvent({ type: 'track', event: 'CLICK_ALL_WALLETS' });
            RouterController.push('AllWallets');
        }
        onConnectWallet(wallet) {
            RouterController.push('ConnectingWalletConnect', { wallet });
        }
    };
    W3mConnectView.styles = styles$B;
    __decorate$W([
        r$e()
    ], W3mConnectView.prototype, "connectors", void 0);
    __decorate$W([
        r$e()
    ], W3mConnectView.prototype, "count", void 0);
    W3mConnectView = __decorate$W([
        customElement('w3m-connect-view')
    ], W3mConnectView);

    var styles$A = i$d `
  @keyframes shake {
    0% {
      transform: translateX(0);
    }
    25% {
      transform: translateX(3px);
    }
    50% {
      transform: translateX(-3px);
    }
    75% {
      transform: translateX(3px);
    }
    100% {
      transform: translateX(0);
    }
  }

  wui-flex:first-child:not(:only-child) {
    position: relative;
  }

  wui-loading-thumbnail {
    position: absolute;
  }

  wui-icon-box {
    position: absolute;
    right: calc(var(--wui-spacing-3xs) * -1);
    bottom: calc(var(--wui-spacing-3xs) * -1);
    opacity: 0;
    transform: scale(0.5);
    transition: all var(--wui-ease-out-power-2) var(--wui-duration-lg);
  }

  wui-text[align='center'] {
    width: 100%;
    padding: 0px var(--wui-spacing-l);
  }

  [data-error='true'] wui-icon-box {
    opacity: 1;
    transform: scale(1);
  }

  [data-error='true'] > wui-flex:first-child {
    animation: shake 250ms cubic-bezier(0.36, 0.07, 0.19, 0.97) both;
  }

  [data-retry='false'] wui-link {
    display: none;
  }

  [data-retry='true'] wui-link {
    display: block;
    opacity: 1;
  }
`;

    var __decorate$V = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    class W3mConnectingWidget extends s$a {
        constructor() {
            super();
            this.wallet = RouterController.state.data?.wallet;
            this.connector = RouterController.state.data?.connector;
            this.timeout = undefined;
            this.secondaryBtnLabel = 'Try again';
            this.secondaryBtnIcon = 'refresh';
            this.secondaryLabel = 'Accept connection request in the wallet';
            this.onConnect = undefined;
            this.onRender = undefined;
            this.onAutoConnect = undefined;
            this.isWalletConnect = true;
            this.unsubscribe = [];
            this.imageSrc = AssetUtil.getWalletImage(this.wallet) ?? AssetUtil.getConnectorImage(this.connector);
            this.name = this.wallet?.name ?? this.connector?.name ?? 'Wallet';
            this.isRetrying = false;
            this.uri = ConnectionController.state.wcUri;
            this.error = ConnectionController.state.wcError;
            this.ready = false;
            this.showRetry = false;
            this.buffering = false;
            this.isMobile = false;
            this.onRetry = undefined;
            this.unsubscribe.push(...[
                ConnectionController.subscribeKey('wcUri', val => {
                    this.uri = val;
                    if (this.isRetrying && this.onRetry) {
                        this.isRetrying = false;
                        this.onConnect?.();
                    }
                }),
                ConnectionController.subscribeKey('wcError', val => (this.error = val)),
                ConnectionController.subscribeKey('buffering', val => (this.buffering = val))
            ]);
        }
        firstUpdated() {
            this.onAutoConnect?.();
            this.showRetry = !this.onAutoConnect;
        }
        disconnectedCallback() {
            this.unsubscribe.forEach(unsubscribe => unsubscribe());
            clearTimeout(this.timeout);
        }
        render() {
            this.onRender?.();
            this.onShowRetry();
            const subLabel = this.error
                ? 'Connection can be declined if a previous request is still active'
                : this.secondaryLabel;
            let label = `Continue in ${this.name}`;
            if (this.buffering) {
                label = 'Connecting...';
            }
            if (this.error) {
                label = 'Connection declined';
            }
            return x$4 `
      <wui-flex
        data-error=${o$e(this.error)}
        data-retry=${this.showRetry}
        flexDirection="column"
        alignItems="center"
        .padding=${['3xl', 'xl', 'xl', 'xl']}
        gap="xl"
      >
        <wui-flex justifyContent="center" alignItems="center">
          <wui-wallet-image size="lg" imageSrc=${o$e(this.imageSrc)}></wui-wallet-image>

          ${this.error ? null : this.loaderTemplate()}

          <wui-icon-box
            backgroundColor="error-100"
            background="opaque"
            iconColor="error-100"
            icon="close"
            size="sm"
            border
            borderColor="wui-color-bg-125"
          ></wui-icon-box>
        </wui-flex>

        <wui-flex flexDirection="column" alignItems="center" gap="xs">
          <wui-text variant="paragraph-500" color=${this.error ? 'error-100' : 'fg-100'}>
            ${label}
          </wui-text>
          <wui-text align="center" variant="small-500" color="fg-200">${subLabel}</wui-text>
        </wui-flex>

        <wui-button
          variant="accent"
          ?disabled=${!this.error && this.buffering}
          @click=${this.onTryAgain.bind(this)}
        >
          <wui-icon color="inherit" slot="iconLeft" name=${this.secondaryBtnIcon}></wui-icon>
          ${this.secondaryBtnLabel}
        </wui-button>
      </wui-flex>

      ${this.isWalletConnect
            ? x$4 `
            <wui-flex .padding=${['0', 'xl', 'xl', 'xl']} justifyContent="center">
              <wui-link @click=${this.onCopyUri} color="fg-200">
                <wui-icon size="xs" color="fg-200" slot="iconLeft" name="copy"></wui-icon>
                Copy link
              </wui-link>
            </wui-flex>
          `
            : null}

      <w3m-mobile-download-links .wallet=${this.wallet}></w3m-mobile-download-links>
    `;
        }
        onShowRetry() {
            if (this.error && !this.showRetry) {
                this.showRetry = true;
                const retryButton = this.shadowRoot?.querySelector('wui-button');
                retryButton?.animate([{ opacity: 0 }, { opacity: 1 }], {
                    fill: 'forwards',
                    easing: 'ease'
                });
            }
        }
        onTryAgain() {
            if (!this.buffering) {
                ConnectionController.setWcError(false);
                if (this.onRetry) {
                    this.isRetrying = true;
                    this.onRetry?.();
                }
                else {
                    this.onConnect?.();
                }
            }
        }
        loaderTemplate() {
            const borderRadiusMaster = ThemeController.state.themeVariables['--w3m-border-radius-master'];
            const radius = borderRadiusMaster ? parseInt(borderRadiusMaster.replace('px', ''), 10) : 4;
            return x$4 `<wui-loading-thumbnail radius=${radius * 9}></wui-loading-thumbnail>`;
        }
        onCopyUri() {
            try {
                if (this.uri) {
                    CoreHelperUtil.copyToClopboard(this.uri);
                    SnackController.showSuccess('Link copied');
                }
            }
            catch {
                SnackController.showError('Failed to copy');
            }
        }
    }
    W3mConnectingWidget.styles = styles$A;
    __decorate$V([
        r$e()
    ], W3mConnectingWidget.prototype, "uri", void 0);
    __decorate$V([
        r$e()
    ], W3mConnectingWidget.prototype, "error", void 0);
    __decorate$V([
        r$e()
    ], W3mConnectingWidget.prototype, "ready", void 0);
    __decorate$V([
        r$e()
    ], W3mConnectingWidget.prototype, "showRetry", void 0);
    __decorate$V([
        r$e()
    ], W3mConnectingWidget.prototype, "buffering", void 0);
    __decorate$V([
        n$d({ type: Boolean })
    ], W3mConnectingWidget.prototype, "isMobile", void 0);
    __decorate$V([
        n$d()
    ], W3mConnectingWidget.prototype, "onRetry", void 0);

    var __decorate$U = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let W3mConnectingExternalView = class W3mConnectingExternalView extends W3mConnectingWidget {
        constructor() {
            super();
            if (!this.connector) {
                throw new Error('w3m-connecting-view: No connector provided');
            }
            EventsController.sendEvent({
                type: 'track',
                event: 'SELECT_WALLET',
                properties: {
                    name: this.connector.name ?? 'Unknown',
                    platform: 'browser'
                }
            });
            this.onConnect = this.onConnectProxy.bind(this);
            this.onAutoConnect = this.onConnectProxy.bind(this);
            this.isWalletConnect = false;
        }
        async onConnectProxy() {
            try {
                this.error = false;
                if (this.connector) {
                    if (this.connector.imageUrl) {
                        StorageUtil.setConnectedWalletImageUrl(this.connector.imageUrl);
                    }
                    await ConnectionController.connectExternal(this.connector);
                    if (OptionsController.state.isSiweEnabled) {
                        RouterController.push('ConnectingSiwe');
                    }
                    else {
                        ModalController.close();
                    }
                    EventsController.sendEvent({
                        type: 'track',
                        event: 'CONNECT_SUCCESS',
                        properties: { method: 'browser', name: this.connector.name || 'Unknown' }
                    });
                }
            }
            catch (error) {
                EventsController.sendEvent({
                    type: 'track',
                    event: 'CONNECT_ERROR',
                    properties: { message: error?.message ?? 'Unknown' }
                });
                this.error = true;
            }
        }
    };
    W3mConnectingExternalView = __decorate$U([
        customElement('w3m-connecting-external-view')
    ], W3mConnectingExternalView);

    var __decorate$T = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let W3mConnectingWcView = class W3mConnectingWcView extends s$a {
        constructor() {
            super();
            this.interval = undefined;
            this.lastRetry = Date.now();
            this.wallet = RouterController.state.data?.wallet;
            this.platform = undefined;
            this.platforms = [];
            this.initializeConnection();
            this.interval = setInterval(this.initializeConnection.bind(this), ConstantsUtil$2.TEN_SEC_MS);
        }
        disconnectedCallback() {
            clearTimeout(this.interval);
        }
        render() {
            if (!this.wallet) {
                return x$4 `<w3m-connecting-wc-qrcode></w3m-connecting-wc-qrcode>`;
            }
            this.determinePlatforms();
            return x$4 `
      ${this.headerTemplate()}
      <div>${this.platformTemplate()}</div>
    `;
        }
        async initializeConnection(retry = false) {
            try {
                const { wcPairingExpiry } = ConnectionController.state;
                if (retry || CoreHelperUtil.isPairingExpired(wcPairingExpiry)) {
                    ConnectionController.connectWalletConnect();
                    if (this.wallet) {
                        const url = AssetUtil.getWalletImage(this.wallet);
                        if (url) {
                            StorageUtil.setConnectedWalletImageUrl(url);
                        }
                    }
                    else {
                        const connectors = ConnectorController.state.connectors;
                        const connector = connectors.find(c => c.type === 'WALLET_CONNECT');
                        const url = AssetUtil.getConnectorImage(connector);
                        if (url) {
                            StorageUtil.setConnectedWalletImageUrl(url);
                        }
                    }
                    await ConnectionController.state.wcPromise;
                    this.finalizeConnection();
                    if (OptionsController.state.isSiweEnabled) {
                        RouterController.push('ConnectingSiwe');
                    }
                    else {
                        ModalController.close();
                    }
                }
            }
            catch (error) {
                EventsController.sendEvent({
                    type: 'track',
                    event: 'CONNECT_ERROR',
                    properties: { message: error?.message ?? 'Unknown' }
                });
                ConnectionController.setWcError(true);
                if (CoreHelperUtil.isAllowedRetry(this.lastRetry)) {
                    SnackController.showError('Declined');
                    this.lastRetry = Date.now();
                    this.initializeConnection(true);
                }
            }
        }
        finalizeConnection() {
            const { wcLinking, recentWallet } = ConnectionController.state;
            if (wcLinking) {
                StorageUtil.setWalletConnectDeepLink(wcLinking);
            }
            if (recentWallet) {
                StorageUtil.setWeb3ModalRecent(recentWallet);
            }
            EventsController.sendEvent({
                type: 'track',
                event: 'CONNECT_SUCCESS',
                properties: {
                    method: wcLinking ? 'mobile' : 'qrcode',
                    name: this.wallet?.name || 'Unknown'
                }
            });
        }
        determinePlatforms() {
            if (!this.wallet) {
                throw new Error('w3m-connecting-wc-view:determinePlatforms No wallet');
            }
            if (this.platform) {
                return;
            }
            const { mobile_link, desktop_link, webapp_link, injected, rdns } = this.wallet;
            const injectedIds = injected?.map(({ injected_id }) => injected_id).filter(Boolean);
            const browserIds = rdns ? [rdns] : injectedIds ?? [];
            const isBrowser = browserIds.length;
            const isMobileWc = mobile_link;
            const isWebWc = webapp_link;
            const isBrowserInstalled = ConnectionController.checkInstalled(browserIds);
            const isBrowserWc = isBrowser && isBrowserInstalled;
            const isDesktopWc = desktop_link && !CoreHelperUtil.isMobile();
            if (isBrowserWc) {
                this.platforms.push('browser');
            }
            if (isMobileWc) {
                this.platforms.push(CoreHelperUtil.isMobile() ? 'mobile' : 'qrcode');
            }
            if (isWebWc) {
                this.platforms.push('web');
            }
            if (isDesktopWc) {
                this.platforms.push('desktop');
            }
            if (!isBrowserWc && isBrowser) {
                this.platforms.push('unsupported');
            }
            this.platform = this.platforms[0];
        }
        platformTemplate() {
            switch (this.platform) {
                case 'browser':
                    return x$4 `<w3m-connecting-wc-browser></w3m-connecting-wc-browser>`;
                case 'desktop':
                    return x$4 `
          <w3m-connecting-wc-desktop .onRetry=${() => this.initializeConnection(true)}>
          </w3m-connecting-wc-desktop>
        `;
                case 'web':
                    return x$4 `
          <w3m-connecting-wc-web .onRetry=${() => this.initializeConnection(true)}>
          </w3m-connecting-wc-web>
        `;
                case 'mobile':
                    return x$4 `
          <w3m-connecting-wc-mobile isMobile .onRetry=${() => this.initializeConnection(true)}>
          </w3m-connecting-wc-mobile>
        `;
                case 'qrcode':
                    return x$4 `<w3m-connecting-wc-qrcode></w3m-connecting-wc-qrcode>`;
                default:
                    return x$4 `<w3m-connecting-wc-unsupported></w3m-connecting-wc-unsupported>`;
            }
        }
        headerTemplate() {
            const multiPlatform = this.platforms.length > 1;
            if (!multiPlatform) {
                return null;
            }
            return x$4 `
      <w3m-connecting-header
        .platforms=${this.platforms}
        .onSelectPlatfrom=${this.onSelectPlatform.bind(this)}
      >
      </w3m-connecting-header>
    `;
        }
        async onSelectPlatform(platform) {
            const container = this.shadowRoot?.querySelector('div');
            if (container) {
                await container.animate([{ opacity: 1 }, { opacity: 0 }], {
                    duration: 200,
                    fill: 'forwards',
                    easing: 'ease'
                }).finished;
                this.platform = platform;
                container.animate([{ opacity: 0 }, { opacity: 1 }], {
                    duration: 200,
                    fill: 'forwards',
                    easing: 'ease'
                });
            }
        }
    };
    __decorate$T([
        r$e()
    ], W3mConnectingWcView.prototype, "platform", void 0);
    __decorate$T([
        r$e()
    ], W3mConnectingWcView.prototype, "platforms", void 0);
    W3mConnectingWcView = __decorate$T([
        customElement('w3m-connecting-wc-view')
    ], W3mConnectingWcView);

    var __decorate$S = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let W3mDownloadsView = class W3mDownloadsView extends s$a {
        constructor() {
            super(...arguments);
            this.wallet = RouterController.state.data?.wallet;
        }
        render() {
            if (!this.wallet) {
                throw new Error('w3m-downloads-view');
            }
            return x$4 `
      <wui-flex gap="xs" flexDirection="column" .padding=${['s', 's', 'l', 's']}>
        ${this.chromeTemplate()} ${this.iosTemplate()} ${this.androidTemplate()}
        ${this.homepageTemplate()}
      </wui-flex>
    `;
        }
        chromeTemplate() {
            if (!this.wallet?.chrome_store) {
                return null;
            }
            return x$4 `<wui-list-item
      variant="icon"
      icon="chromeStore"
      iconVariant="square"
      @click=${this.onChromeStore.bind(this)}
      chevron
    >
      <wui-text variant="paragraph-500" color="fg-100">Chrome Extension</wui-text>
    </wui-list-item>`;
        }
        iosTemplate() {
            if (!this.wallet?.app_store) {
                return null;
            }
            return x$4 `<wui-list-item
      variant="icon"
      icon="appStore"
      iconVariant="square"
      @click=${this.onAppStore.bind(this)}
      chevron
    >
      <wui-text variant="paragraph-500" color="fg-100">iOS App</wui-text>
    </wui-list-item>`;
        }
        androidTemplate() {
            if (!this.wallet?.play_store) {
                return null;
            }
            return x$4 `<wui-list-item
      variant="icon"
      icon="playStore"
      iconVariant="square"
      @click=${this.onPlayStore.bind(this)}
      chevron
    >
      <wui-text variant="paragraph-500" color="fg-100">Android App</wui-text>
    </wui-list-item>`;
        }
        homepageTemplate() {
            if (!this.wallet?.homepage) {
                return null;
            }
            return x$4 `
      <wui-list-item
        variant="icon"
        icon="browser"
        iconVariant="square-blue"
        @click=${this.onHomePage.bind(this)}
        chevron
      >
        <wui-text variant="paragraph-500" color="fg-100">Website</wui-text>
      </wui-list-item>
    `;
        }
        onChromeStore() {
            if (this.wallet?.chrome_store) {
                CoreHelperUtil.openHref(this.wallet.chrome_store, '_blank');
            }
        }
        onAppStore() {
            if (this.wallet?.app_store) {
                CoreHelperUtil.openHref(this.wallet.app_store, '_blank');
            }
        }
        onPlayStore() {
            if (this.wallet?.play_store) {
                CoreHelperUtil.openHref(this.wallet.play_store, '_blank');
            }
        }
        onHomePage() {
            if (this.wallet?.homepage) {
                CoreHelperUtil.openHref(this.wallet.homepage, '_blank');
            }
        }
    };
    W3mDownloadsView = __decorate$S([
        customElement('w3m-downloads-view')
    ], W3mDownloadsView);

    var __decorate$R = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    const EXPLORER = 'https://walletconnect.com/explorer';
    let W3mGetWalletView = class W3mGetWalletView extends s$a {
        render() {
            return x$4 `
      <wui-flex flexDirection="column" padding="s" gap="xs">
        ${this.recommendedWalletsTemplate()}
        <wui-list-wallet
          name="Explore all"
          showAllWallets
          walletIcon="allWallets"
          icon="externalLink"
          @click=${() => {
            CoreHelperUtil.openHref('https://walletconnect.com/explorer?type=wallet', '_blank');
        }}
        ></wui-list-wallet>
      </wui-flex>
    `;
        }
        recommendedWalletsTemplate() {
            const { recommended, featured } = ApiController.state;
            const { customWallets } = OptionsController.state;
            const wallets = [...featured, ...(customWallets ?? []), ...recommended].slice(0, 4);
            return wallets.map(wallet => x$4 `
        <wui-list-wallet
          name=${wallet.name ?? 'Unknown'}
          tagVariant="main"
          imageSrc=${o$e(AssetUtil.getWalletImage(wallet))}
          @click=${() => {
            CoreHelperUtil.openHref(wallet.homepage ?? EXPLORER, '_blank');
        }}
        ></wui-list-wallet>
      `);
        }
    };
    W3mGetWalletView = __decorate$R([
        customElement('w3m-get-wallet-view')
    ], W3mGetWalletView);

    var styles$z = i$d `
  @keyframes shake {
    0% {
      transform: translateX(0);
    }
    25% {
      transform: translateX(3px);
    }
    50% {
      transform: translateX(-3px);
    }
    75% {
      transform: translateX(3px);
    }
    100% {
      transform: translateX(0);
    }
  }

  wui-flex:first-child:not(:only-child) {
    position: relative;
  }

  wui-loading-hexagon {
    position: absolute;
  }

  wui-icon-box {
    position: absolute;
    right: 4px;
    bottom: 0;
    opacity: 0;
    transform: scale(0.5);
    z-index: 1;
    transition: all var(--wui-ease-out-power-2) var(--wui-duration-lg);
  }

  wui-button {
    display: none;
  }

  [data-error='true'] wui-icon-box {
    opacity: 1;
    transform: scale(1);
  }

  [data-error='true'] > wui-flex:first-child {
    animation: shake 250ms cubic-bezier(0.36, 0.07, 0.19, 0.97) both;
  }

  wui-button[data-retry='true'] {
    display: block;
    opacity: 1;
  }
`;

    var __decorate$Q = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let W3mNetworkSwitchView = class W3mNetworkSwitchView extends s$a {
        constructor() {
            super();
            this.network = RouterController.state.data?.network;
            this.unsubscribe = [];
            this.showRetry = false;
            this.error = false;
        }
        disconnectedCallback() {
            this.unsubscribe.forEach(unsubscribe => unsubscribe());
        }
        firstUpdated() {
            this.onSwitchNetwork();
        }
        render() {
            if (!this.network) {
                throw new Error('w3m-network-switch-view: No network provided');
            }
            this.onShowRetry();
            const label = this.error ? 'Switch declined' : 'Approve in wallet';
            const subLabel = this.error
                ? 'Switch can be declined if chain is not supported by a wallet or previous request is still active'
                : 'Accept connection request in your wallet';
            return x$4 `
      <wui-flex
        data-error=${this.error}
        flexDirection="column"
        alignItems="center"
        .padding=${['3xl', 'xl', '3xl', 'xl']}
        gap="xl"
      >
        <wui-flex justifyContent="center" alignItems="center">
          <wui-network-image
            size="lg"
            imageSrc=${o$e(AssetUtil.getNetworkImage(this.network))}
          ></wui-network-image>

          ${this.error ? null : x$4 `<wui-loading-hexagon></wui-loading-hexagon>`}

          <wui-icon-box
            backgroundColor="error-100"
            background="opaque"
            iconColor="error-100"
            icon="close"
            size="sm"
            ?border=${true}
            borderColor="wui-color-bg-125"
          ></wui-icon-box>
        </wui-flex>

        <wui-flex flexDirection="column" alignItems="center" gap="xs">
          <wui-text align="center" variant="paragraph-500" color="fg-100">${label}</wui-text>
          <wui-text align="center" variant="small-500" color="fg-200">${subLabel}</wui-text>
        </wui-flex>

        <wui-button
          data-retry=${this.showRetry}
          variant="fill"
          .disabled=${!this.error}
          @click=${this.onSwitchNetwork.bind(this)}
        >
          <wui-icon color="inherit" slot="iconLeft" name="refresh"></wui-icon>
          Try again
        </wui-button>
      </wui-flex>
    `;
        }
        onShowRetry() {
            if (this.error && !this.showRetry) {
                this.showRetry = true;
                const retryButton = this.shadowRoot?.querySelector('wui-button');
                retryButton?.animate([{ opacity: 0 }, { opacity: 1 }], {
                    fill: 'forwards',
                    easing: 'ease'
                });
            }
        }
        async onSwitchNetwork() {
            try {
                this.error = false;
                if (this.network) {
                    await NetworkController.switchActiveNetwork(this.network);
                    if (!OptionsController.state.isSiweEnabled) {
                        RouterUtil.navigateAfterNetworkSwitch();
                    }
                }
            }
            catch {
                this.error = true;
            }
        }
    };
    W3mNetworkSwitchView.styles = styles$z;
    __decorate$Q([
        r$e()
    ], W3mNetworkSwitchView.prototype, "showRetry", void 0);
    __decorate$Q([
        r$e()
    ], W3mNetworkSwitchView.prototype, "error", void 0);
    W3mNetworkSwitchView = __decorate$Q([
        customElement('w3m-network-switch-view')
    ], W3mNetworkSwitchView);

    var styles$y = i$d `
  :host > wui-grid {
    max-height: 360px;
    overflow: auto;
  }

  wui-grid::-webkit-scrollbar {
    display: none;
  }
`;

    var __decorate$P = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let W3mNetworksView = class W3mNetworksView extends s$a {
        constructor() {
            super();
            this.unsubscribe = [];
            this.caipNetwork = NetworkController.state.caipNetwork;
            this.unsubscribe.push(NetworkController.subscribeKey('caipNetwork', val => (this.caipNetwork = val)));
        }
        disconnectedCallback() {
            this.unsubscribe.forEach(unsubscribe => unsubscribe());
        }
        render() {
            return x$4 `
      <wui-grid padding="s" gridTemplateColumns="repeat(4, 1fr)" rowGap="l" columnGap="xs">
        ${this.networksTemplate()}
      </wui-grid>

      <wui-separator></wui-separator>

      <wui-flex padding="s" flexDirection="column" gap="m" alignItems="center">
        <wui-text variant="small-400" color="fg-300" align="center">
          Your connected wallet may not support some of the networks available for this dApp
        </wui-text>
        <wui-link @click=${this.onNetworkHelp.bind(this)}>
          <wui-icon size="xs" color="accent-100" slot="iconLeft" name="helpCircle"></wui-icon>
          What is a network
        </wui-link>
      </wui-flex>
    `;
        }
        onNetworkHelp() {
            EventsController.sendEvent({ type: 'track', event: 'CLICK_NETWORK_HELP' });
            RouterController.push('WhatIsANetwork');
        }
        networksTemplate() {
            const { approvedCaipNetworkIds, requestedCaipNetworks, supportsAllNetworks } = NetworkController.state;
            const sortedNetworks = CoreHelperUtil.sortRequestedNetworks(approvedCaipNetworkIds, requestedCaipNetworks);
            return sortedNetworks?.map(network => x$4 `
        <wui-card-select
          .selected=${this.caipNetwork?.id === network.id}
          imageSrc=${o$e(AssetUtil.getNetworkImage(network))}
          type="network"
          name=${network.name ?? network.id}
          @click=${() => this.onSwitchNetwork(network)}
          .disabled=${!supportsAllNetworks && !approvedCaipNetworkIds?.includes(network.id)}
          data-testid=${`w3m-network-switch-${network.name ?? network.id}`}
        ></wui-card-select>
      `);
        }
        async onSwitchNetwork(network) {
            const { isConnected } = AccountController.state;
            const { approvedCaipNetworkIds, supportsAllNetworks, caipNetwork } = NetworkController.state;
            const { data } = RouterController.state;
            if (isConnected && caipNetwork?.id !== network.id) {
                if (approvedCaipNetworkIds?.includes(network.id)) {
                    await NetworkController.switchActiveNetwork(network);
                    RouterUtil.navigateAfterNetworkSwitch();
                }
                else if (supportsAllNetworks) {
                    RouterController.push('SwitchNetwork', { ...data, network });
                }
            }
            else if (!isConnected) {
                NetworkController.setCaipNetwork(network);
                RouterController.push('Connect');
            }
        }
    };
    W3mNetworksView.styles = styles$y;
    __decorate$P([
        r$e()
    ], W3mNetworksView.prototype, "caipNetwork", void 0);
    W3mNetworksView = __decorate$P([
        customElement('w3m-networks-view')
    ], W3mNetworksView);

    var styles$x = i$d `
  :host > wui-flex {
    height: 500px;
    overflow-y: auto;
    overflow-x: hidden;
    scrollbar-width: none;
    padding: var(--wui-spacing-m);
    box-sizing: border-box;
    display: flex;
    align-items: center;
    justify-content: flex-start;
  }

  :host > wui-flex > wui-flex {
    width: 100%;
  }

  wui-transaction-list-item-loader {
    width: 100%;
  }
`;

    var __decorate$O = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    const LOADING_ITEM_COUNT$1 = 7;
    let W3mOnRampActivityView = class W3mOnRampActivityView extends s$a {
        constructor() {
            super();
            this.unsubscribe = [];
            this.refetchTimeout = undefined;
            this.selectedOnRampProvider = OnRampController.state.selectedProvider;
            this.loading = false;
            this.coinbaseTransactions = TransactionsController.state.coinbaseTransactions;
            this.tokenImages = AssetController.state.tokenImages;
            this.unsubscribe.push(...[
                OnRampController.subscribeKey('selectedProvider', val => {
                    this.selectedOnRampProvider = val;
                }),
                AssetController.subscribeKey('tokenImages', val => (this.tokenImages = val)),
                () => {
                    clearTimeout(this.refetchTimeout);
                },
                TransactionsController.subscribe(val => {
                    this.coinbaseTransactions = { ...val.coinbaseTransactions };
                })
            ]);
            TransactionsController.clearCursor();
            this.fetchTransactions();
        }
        render() {
            return x$4 `
      <wui-flex flexDirection="column" padding="s" gap="xs">
        ${this.loading ? this.templateLoading() : this.templateTransactionsByYear()}
      </wui-flex>
    `;
        }
        templateTransactions(transactions) {
            return transactions?.map(transaction => {
                const date = DateUtil.formatDate(transaction?.metadata?.minedAt);
                const transfer = transaction.transfers[0];
                const fungibleInfo = transfer?.fungible_info;
                if (!fungibleInfo) {
                    return null;
                }
                const icon = fungibleInfo?.icon?.url || this.tokenImages?.[fungibleInfo.symbol || ''];
                return x$4 `
        <wui-onramp-activity-item
          label="Bought"
          .completed=${transaction.metadata.status === 'ONRAMP_TRANSACTION_STATUS_SUCCESS'}
          .inProgress=${transaction.metadata.status === 'ONRAMP_TRANSACTION_STATUS_IN_PROGRESS'}
          .failed=${transaction.metadata.status === 'ONRAMP_TRANSACTION_STATUS_FAILED'}
          purchaseCurrency=${o$e(fungibleInfo.symbol)}
          purchaseValue=${transfer.quantity.numeric}
          date=${date}
          icon=${o$e(icon)}
          symbol=${o$e(fungibleInfo.symbol)}
        ></wui-onramp-activity-item>
      `;
            });
        }
        templateTransactionsByYear() {
            const sortedYearKeys = Object.keys(this.coinbaseTransactions).sort().reverse();
            return sortedYearKeys.map(year => {
                const yearInt = parseInt(year, 10);
                const sortedMonthIndexes = new Array(12)
                    .fill(null)
                    .map((_, idx) => idx)
                    .reverse();
                return sortedMonthIndexes.map(month => {
                    const groupTitle = TransactionUtil.getTransactionGroupTitle(yearInt, month);
                    const transactions = this.coinbaseTransactions[yearInt]?.[month];
                    if (!transactions) {
                        return null;
                    }
                    return x$4 `
          <wui-flex flexDirection="column">
            <wui-flex
              alignItems="center"
              flexDirection="row"
              .padding=${['xs', 's', 's', 's']}
            >
              <wui-text variant="paragraph-500" color="fg-200">${groupTitle}</wui-text>
            </wui-flex>
            <wui-flex flexDirection="column" gap="xs">
              ${this.templateTransactions(transactions)}
            </wui-flex>
          </wui-flex>
        `;
                });
            });
        }
        async fetchTransactions() {
            {
                await this.fetchCoinbaseTransactions();
            }
        }
        async fetchCoinbaseTransactions() {
            const address = AccountController.state.address;
            const projectId = OptionsController.state.projectId;
            if (!address) {
                throw new Error('No address found');
            }
            if (!projectId) {
                throw new Error('No projectId found');
            }
            this.loading = true;
            await TransactionsController.fetchTransactions(address, 'coinbase');
            this.loading = false;
            this.refetchLoadingTransactions();
        }
        refetchLoadingTransactions() {
            const today = new Date();
            const currentMonthTxs = this.coinbaseTransactions[today.getFullYear()]?.[today.getMonth()] || [];
            const loadingTransactions = currentMonthTxs.filter(transaction => transaction.metadata.status === 'ONRAMP_TRANSACTION_STATUS_IN_PROGRESS');
            if (loadingTransactions.length === 0) {
                clearTimeout(this.refetchTimeout);
                return;
            }
            this.refetchTimeout = setTimeout(async () => {
                const address = AccountController.state.address;
                await TransactionsController.fetchTransactions(address, 'coinbase');
                this.refetchLoadingTransactions();
            }, 3000);
        }
        templateLoading() {
            return Array(LOADING_ITEM_COUNT$1)
                .fill(x$4 ` <wui-transaction-list-item-loader></wui-transaction-list-item-loader> `)
                .map(item => item);
        }
    };
    W3mOnRampActivityView.styles = styles$x;
    __decorate$O([
        r$e()
    ], W3mOnRampActivityView.prototype, "selectedOnRampProvider", void 0);
    __decorate$O([
        r$e()
    ], W3mOnRampActivityView.prototype, "loading", void 0);
    __decorate$O([
        r$e()
    ], W3mOnRampActivityView.prototype, "coinbaseTransactions", void 0);
    __decorate$O([
        r$e()
    ], W3mOnRampActivityView.prototype, "tokenImages", void 0);
    W3mOnRampActivityView = __decorate$O([
        customElement('w3m-onramp-activity-view')
    ], W3mOnRampActivityView);

    var styles$w = i$d `
  :host > wui-grid {
    max-height: 360px;
    overflow: auto;
  }

  wui-grid::-webkit-scrollbar {
    display: none;
  }
`;

    var __decorate$N = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let W3mOnrampFiatSelectView = class W3mOnrampFiatSelectView extends s$a {
        constructor() {
            super();
            this.unsubscribe = [];
            this.selectedCurrency = OnRampController.state.paymentCurrency;
            this.currencies = OnRampController.state.paymentCurrencies;
            this.currencyImages = AssetController.state.currencyImages;
            this.unsubscribe.push(...[
                OnRampController.subscribe(val => {
                    this.selectedCurrency = val.paymentCurrency;
                    this.currencies = val.paymentCurrencies;
                }),
                AssetController.subscribeKey('currencyImages', val => (this.currencyImages = val))
            ]);
        }
        disconnectedCallback() {
            this.unsubscribe.forEach(unsubscribe => unsubscribe());
        }
        render() {
            return x$4 `
      <wui-flex flexDirection="column" padding="s" gap="xs">
        ${this.currenciesTemplate()}
      </wui-flex>
      <w3m-legal-footer></w3m-legal-footer>
    `;
        }
        currenciesTemplate() {
            return this.currencies.map(currency => x$4 `
        <wui-list-item
          imageSrc=${o$e(this.currencyImages?.[currency.id])}
          @click=${() => this.selectCurrency(currency)}
          variant="image"
        >
          <wui-text variant="paragraph-500" color="fg-100">${currency.id}</wui-text>
        </wui-list-item>
      `);
        }
        selectCurrency(currency) {
            if (!currency) {
                return;
            }
            OnRampController.setPaymentCurrency(currency);
            ModalController.close();
        }
    };
    W3mOnrampFiatSelectView.styles = styles$w;
    __decorate$N([
        r$e()
    ], W3mOnrampFiatSelectView.prototype, "selectedCurrency", void 0);
    __decorate$N([
        r$e()
    ], W3mOnrampFiatSelectView.prototype, "currencies", void 0);
    __decorate$N([
        r$e()
    ], W3mOnrampFiatSelectView.prototype, "currencyImages", void 0);
    W3mOnrampFiatSelectView = __decorate$N([
        customElement('w3m-onramp-fiat-select-view')
    ], W3mOnrampFiatSelectView);

    var __decorate$M = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let W3mOnRampProvidersView = class W3mOnRampProvidersView extends s$a {
        constructor() {
            super();
            this.unsubscribe = [];
            this.providers = OnRampController.state.providers;
            this.unsubscribe.push(...[
                OnRampController.subscribeKey('providers', val => {
                    this.providers = val;
                })
            ]);
        }
        firstUpdated() {
            const urlPromises = this.providers.map(async (provider) => {
                if (provider.name === 'coinbase') {
                    return await this.getCoinbaseOnRampURL();
                }
                return Promise.resolve(provider?.url);
            });
            Promise.all(urlPromises).then(urls => {
                this.providers = this.providers.map((provider, index) => ({
                    ...provider,
                    url: urls[index] || ''
                }));
            });
        }
        render() {
            return x$4 `
      <wui-flex flexDirection="column" padding="s" gap="xs">
        ${this.onRampProvidersTemplate()}
      </wui-flex>
      <w3m-onramp-providers-footer></w3m-onramp-providers-footer>
    `;
        }
        onRampProvidersTemplate() {
            return this.providers.map(provider => x$4 `
        <wui-onramp-provider-item
          label=${provider.label}
          name=${provider.name}
          feeRange=${provider.feeRange}
          @click=${() => {
            this.onClickProvider(provider);
        }}
          ?disabled=${!provider.url}
        ></wui-onramp-provider-item>
      `);
        }
        onClickProvider(provider) {
            OnRampController.setSelectedProvider(provider);
            RouterController.push('BuyInProgress');
            CoreHelperUtil.openHref(provider.url, 'popupWindow', 'width=600,height=800,scrollbars=yes');
        }
        async getCoinbaseOnRampURL() {
            const address = AccountController.state.address;
            const network = NetworkController.state.caipNetwork;
            if (!address) {
                throw new Error('No address found');
            }
            if (!network?.name) {
                throw new Error('No network found');
            }
            const defaultNetwork = ConstantsUtil$2.WC_COINBASE_PAY_SDK_CHAIN_NAME_MAP[network.name] ?? ConstantsUtil$2.WC_COINBASE_PAY_SDK_FALLBACK_CHAIN;
            const purchaseCurrency = OnRampController.state.purchaseCurrency;
            const assets = purchaseCurrency
                ? [purchaseCurrency.symbol]
                : OnRampController.state.purchaseCurrencies.map(currency => currency.symbol);
            return await BlockchainApiController.generateOnRampURL({
                defaultNetwork,
                destinationWallets: [
                    { address, blockchains: ConstantsUtil$2.WC_COINBASE_PAY_SDK_CHAINS, assets }
                ],
                partnerUserId: address,
                purchaseAmount: OnRampController.state.purchaseAmount
            });
        }
    };
    __decorate$M([
        r$e()
    ], W3mOnRampProvidersView.prototype, "providers", void 0);
    W3mOnRampProvidersView = __decorate$M([
        customElement('w3m-onramp-providers-view')
    ], W3mOnRampProvidersView);

    var styles$v = i$d `
  :host > wui-grid {
    max-height: 360px;
    overflow: auto;
  }

  wui-grid::-webkit-scrollbar {
    display: none;
  }
`;

    var __decorate$L = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let W3mOnrampTokensView = class W3mOnrampTokensView extends s$a {
        constructor() {
            super();
            this.unsubscribe = [];
            this.selectedCurrency = OnRampController.state.purchaseCurrencies;
            this.tokens = OnRampController.state.purchaseCurrencies;
            this.tokenImages = AssetController.state.tokenImages;
            this.unsubscribe.push(...[
                OnRampController.subscribe(val => {
                    this.selectedCurrency = val.purchaseCurrencies;
                    this.tokens = val.purchaseCurrencies;
                }),
                AssetController.subscribeKey('tokenImages', val => (this.tokenImages = val))
            ]);
        }
        disconnectedCallback() {
            this.unsubscribe.forEach(unsubscribe => unsubscribe());
        }
        render() {
            return x$4 `
      <wui-flex flexDirection="column" padding="s" gap="xs">
        ${this.currenciesTemplate()}
      </wui-flex>
      <w3m-legal-footer></w3m-legal-footer>
    `;
        }
        currenciesTemplate() {
            return this.tokens.map(token => x$4 `
        <wui-list-item
          imageSrc=${o$e(this.tokenImages?.[token.symbol])}
          @click=${() => this.selectToken(token)}
          variant="image"
        >
          <wui-flex gap="3xs" alignItems="center">
            <wui-text variant="paragraph-500" color="fg-100">${token.name}</wui-text>
            <wui-text variant="small-400" color="fg-200">${token.symbol}</wui-text>
          </wui-flex>
        </wui-list-item>
      `);
        }
        selectToken(currency) {
            if (!currency) {
                return;
            }
            OnRampController.setPurchaseCurrency(currency);
            ModalController.close();
        }
    };
    W3mOnrampTokensView.styles = styles$v;
    __decorate$L([
        r$e()
    ], W3mOnrampTokensView.prototype, "selectedCurrency", void 0);
    __decorate$L([
        r$e()
    ], W3mOnrampTokensView.prototype, "tokens", void 0);
    __decorate$L([
        r$e()
    ], W3mOnrampTokensView.prototype, "tokenImages", void 0);
    W3mOnrampTokensView = __decorate$L([
        customElement('w3m-onramp-token-select-view')
    ], W3mOnrampTokensView);

    var styles$u = i$d `
  :host > wui-flex:first-child {
    height: 500px;
    overflow-y: auto;
    overflow-x: hidden;
    scrollbar-width: none;
    padding: var(--wui-spacing-m);
  }

  :host > wui-flex:first-child::-webkit-scrollbar {
    display: none;
  }
`;

    var __decorate$K = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let W3mTransactionsView = class W3mTransactionsView extends s$a {
        render() {
            return x$4 `
      <wui-flex flexDirection="column" gap="s">
        <w3m-activity-list page="activity"></w3m-activity-list>
      </wui-flex>
    `;
        }
    };
    W3mTransactionsView.styles = styles$u;
    W3mTransactionsView = __decorate$K([
        customElement('w3m-transactions-view')
    ], W3mTransactionsView);

    var __decorate$J = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    const data$2 = [
        {
            images: ['network', 'layers', 'system'],
            title: 'The system’s nuts and bolts',
            text: 'A network is what brings the blockchain to life, as this technical infrastructure allows apps to access the ledger and smart contract services.'
        },
        {
            images: ['noun', 'defiAlt', 'dao'],
            title: 'Designed for different uses',
            text: 'Each network is designed differently, and may therefore suit certain apps and experiences.'
        }
    ];
    let W3mWhatIsANetworkView = class W3mWhatIsANetworkView extends s$a {
        render() {
            return x$4 `
      <wui-flex
        flexDirection="column"
        .padding=${['xxl', 'xl', 'xl', 'xl']}
        alignItems="center"
        gap="xl"
      >
        <w3m-help-widget .data=${data$2}></w3m-help-widget>
        <wui-button
          variant="fill"
          size="sm"
          @click=${() => {
            CoreHelperUtil.openHref('https://ethereum.org/en/developers/docs/networks/', '_blank');
        }}
        >
          Learn more
          <wui-icon color="inherit" slot="iconRight" name="externalLink"></wui-icon>
        </wui-button>
      </wui-flex>
    `;
        }
    };
    W3mWhatIsANetworkView = __decorate$J([
        customElement('w3m-what-is-a-network-view')
    ], W3mWhatIsANetworkView);

    var __decorate$I = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    const data$1 = [
        {
            images: ['login', 'profile', 'lock'],
            title: 'One login for all of web3',
            text: 'Log in to any app by connecting your wallet. Say goodbye to countless passwords!'
        },
        {
            images: ['defi', 'nft', 'eth'],
            title: 'A home for your digital assets',
            text: 'A wallet lets you store, send and receive digital assets like cryptocurrencies and NFTs.'
        },
        {
            images: ['browser', 'noun', 'dao'],
            title: 'Your gateway to a new web',
            text: 'With your wallet, you can explore and interact with DeFi, NFTs, DAOs, and much more.'
        }
    ];
    let W3mWhatIsAWalletView = class W3mWhatIsAWalletView extends s$a {
        render() {
            return x$4 `
      <wui-flex
        flexDirection="column"
        .padding=${['xxl', 'xl', 'xl', 'xl']}
        alignItems="center"
        gap="xl"
      >
        <w3m-help-widget .data=${data$1}></w3m-help-widget>
        <wui-button variant="fill" size="sm" @click=${this.onGetWallet.bind(this)}>
          <wui-icon color="inherit" slot="iconLeft" name="wallet"></wui-icon>
          Get a wallet
        </wui-button>
      </wui-flex>
    `;
        }
        onGetWallet() {
            EventsController.sendEvent({ type: 'track', event: 'CLICK_GET_WALLET' });
            RouterController.push('GetWallet');
        }
    };
    W3mWhatIsAWalletView = __decorate$I([
        customElement('w3m-what-is-a-wallet-view')
    ], W3mWhatIsAWalletView);

    var __decorate$H = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let W3mWhatIsABuyView = class W3mWhatIsABuyView extends s$a {
        render() {
            return x$4 `
      <wui-flex
        flexDirection="column"
        .padding=${['xxl', '3xl', 'xl', '3xl']}
        alignItems="center"
        gap="xl"
      >
        <wui-visual name="onrampCard"></wui-visual>
        <wui-flex flexDirection="column" gap="xs" alignItems="center">
          <wui-text align="center" variant="paragraph-500" color="fg-100">
            Quickly and easily buy digital assets!
          </wui-text>
          <wui-text align="center" variant="small-400" color="fg-200">
            Simply select your preferred onramp provider and add digital assets to your account
            using your credit card or bank transfer
          </wui-text>
        </wui-flex>
        <wui-button @click=${RouterController.goBack}>
          <wui-icon size="sm" color="inherit" name="add" slot="iconLeft"></wui-icon>
          Buy
        </wui-button>
      </wui-flex>
    `;
        }
    };
    W3mWhatIsABuyView = __decorate$H([
        customElement('w3m-what-is-a-buy-view')
    ], W3mWhatIsABuyView);

    var styles$t = i$d `
  wui-loading-spinner {
    margin: 9px auto;
  }
`;

    const W3mFrameConstants = {
        SECURE_SITE_SDK: browser$1$1.env['NEXT_PUBLIC_SECURE_SITE_SDK_URL'] || 'https://secure.walletconnect.com/sdk',
        APP_EVENT_KEY: '@w3m-app/',
        FRAME_EVENT_KEY: '@w3m-frame/',
        RPC_METHOD_KEY: 'RPC_',
        STORAGE_KEY: '@w3m-storage/',
        SESSION_TOKEN_KEY: 'SESSION_TOKEN_KEY',
        EMAIL_LOGIN_USED_KEY: 'EMAIL_LOGIN_USED_KEY',
        LAST_USED_CHAIN_KEY: 'LAST_USED_CHAIN_KEY',
        LAST_EMAIL_LOGIN_TIME: 'LAST_EMAIL_LOGIN_TIME',
        EMAIL: 'EMAIL',
        PREFERRED_ACCOUNT_TYPE: 'PREFERRED_ACCOUNT_TYPE',
        APP_SWITCH_NETWORK: '@w3m-app/SWITCH_NETWORK',
        APP_CONNECT_EMAIL: '@w3m-app/CONNECT_EMAIL',
        APP_CONNECT_DEVICE: '@w3m-app/CONNECT_DEVICE',
        APP_CONNECT_OTP: '@w3m-app/CONNECT_OTP',
        APP_GET_USER: '@w3m-app/GET_USER',
        APP_SIGN_OUT: '@w3m-app/SIGN_OUT',
        APP_IS_CONNECTED: '@w3m-app/IS_CONNECTED',
        APP_GET_CHAIN_ID: '@w3m-app/GET_CHAIN_ID',
        APP_RPC_REQUEST: '@w3m-app/RPC_REQUEST',
        APP_UPDATE_EMAIL: '@w3m-app/UPDATE_EMAIL',
        APP_UPDATE_EMAIL_PRIMARY_OTP: '@w3m-app/UPDATE_EMAIL_PRIMARY_OTP',
        APP_UPDATE_EMAIL_SECONDARY_OTP: '@w3m-app/UPDATE_EMAIL_SECONDARY_OTP',
        APP_AWAIT_UPDATE_EMAIL: '@w3m-app/AWAIT_UPDATE_EMAIL',
        APP_SYNC_THEME: '@w3m-app/SYNC_THEME',
        APP_SYNC_DAPP_DATA: '@w3m-app/SYNC_DAPP_DATA',
        APP_GET_SMART_ACCOUNT_ENABLED_NETWORKS: '@w3m-app/GET_SMART_ACCOUNT_ENABLED_NETWORKS',
        APP_INIT_SMART_ACCOUNT: '@w3m-app/INIT_SMART_ACCOUNT',
        APP_SET_PREFERRED_ACCOUNT: '@w3m-app/SET_PREFERRED_ACCOUNT',
        FRAME_SWITCH_NETWORK_ERROR: '@w3m-frame/SWITCH_NETWORK_ERROR',
        FRAME_SWITCH_NETWORK_SUCCESS: '@w3m-frame/SWITCH_NETWORK_SUCCESS',
        FRAME_CONNECT_EMAIL_ERROR: '@w3m-frame/CONNECT_EMAIL_ERROR',
        FRAME_CONNECT_EMAIL_SUCCESS: '@w3m-frame/CONNECT_EMAIL_SUCCESS',
        FRAME_CONNECT_DEVICE_ERROR: '@w3m-frame/CONNECT_DEVICE_ERROR',
        FRAME_CONNECT_DEVICE_SUCCESS: '@w3m-frame/CONNECT_DEVICE_SUCCESS',
        FRAME_CONNECT_OTP_SUCCESS: '@w3m-frame/CONNECT_OTP_SUCCESS',
        FRAME_CONNECT_OTP_ERROR: '@w3m-frame/CONNECT_OTP_ERROR',
        FRAME_GET_USER_SUCCESS: '@w3m-frame/GET_USER_SUCCESS',
        FRAME_GET_USER_ERROR: '@w3m-frame/GET_USER_ERROR',
        FRAME_SIGN_OUT_SUCCESS: '@w3m-frame/SIGN_OUT_SUCCESS',
        FRAME_SIGN_OUT_ERROR: '@w3m-frame/SIGN_OUT_ERROR',
        FRAME_IS_CONNECTED_SUCCESS: '@w3m-frame/IS_CONNECTED_SUCCESS',
        FRAME_IS_CONNECTED_ERROR: '@w3m-frame/IS_CONNECTED_ERROR',
        FRAME_GET_CHAIN_ID_SUCCESS: '@w3m-frame/GET_CHAIN_ID_SUCCESS',
        FRAME_GET_CHAIN_ID_ERROR: '@w3m-frame/GET_CHAIN_ID_ERROR',
        FRAME_RPC_REQUEST_SUCCESS: '@w3m-frame/RPC_REQUEST_SUCCESS',
        FRAME_RPC_REQUEST_ERROR: '@w3m-frame/RPC_REQUEST_ERROR',
        FRAME_SESSION_UPDATE: '@w3m-frame/SESSION_UPDATE',
        FRAME_UPDATE_EMAIL_SUCCESS: '@w3m-frame/UPDATE_EMAIL_SUCCESS',
        FRAME_UPDATE_EMAIL_ERROR: '@w3m-frame/UPDATE_EMAIL_ERROR',
        FRAME_UPDATE_EMAIL_PRIMARY_OTP_SUCCESS: '@w3m-frame/UPDATE_EMAIL_PRIMARY_OTP_SUCCESS',
        FRAME_UPDATE_EMAIL_PRIMARY_OTP_ERROR: '@w3m-frame/UPDATE_EMAIL_PRIMARY_OTP_ERROR',
        FRAME_UPDATE_EMAIL_SECONDARY_OTP_SUCCESS: '@w3m-frame/UPDATE_EMAIL_SECONDARY_OTP_SUCCESS',
        FRAME_UPDATE_EMAIL_SECONDARY_OTP_ERROR: '@w3m-frame/UPDATE_EMAIL_SECONDARY_OTP_ERROR',
        FRAME_SYNC_THEME_SUCCESS: '@w3m-frame/SYNC_THEME_SUCCESS',
        FRAME_SYNC_THEME_ERROR: '@w3m-frame/SYNC_THEME_ERROR',
        FRAME_SYNC_DAPP_DATA_SUCCESS: '@w3m-frame/SYNC_DAPP_DATA_SUCCESS',
        FRAME_SYNC_DAPP_DATA_ERROR: '@w3m-frame/SYNC_DAPP_DATA_ERROR',
        FRAME_GET_SMART_ACCOUNT_ENABLED_NETWORKS_SUCCESS: '@w3m-frame/GET_SMART_ACCOUNT_ENABLED_NETWORKS_SUCCESS',
        FRAME_GET_SMART_ACCOUNT_ENABLED_NETWORKS_ERROR: '@w3m-frame/GET_SMART_ACCOUNT_ENABLED_NETWORKS_ERROR',
        FRAME_INIT_SMART_ACCOUNT_SUCCESS: '@w3m-frame/INIT_SMART_ACCOUNT_SUCCESS',
        FRAME_INIT_SMART_ACCOUNT_ERROR: '@w3m-frame/INIT_SMART_ACCOUNT_ERROR',
        FRAME_SET_PREFERRED_ACCOUNT_SUCCESS: '@w3m-frame/SET_PREFERRED_ACCOUNT_SUCCESS',
        FRAME_SET_PREFERRED_ACCOUNT_ERROR: '@w3m-frame/SET_PREFERRED_ACCOUNT_ERROR'
    };
    const W3mFrameRpcConstants = {
        SAFE_RPC_METHODS: [
            'eth_accounts',
            'eth_blockNumber',
            'eth_call',
            'eth_chainId',
            'eth_estimateGas',
            'eth_feeHistory',
            'eth_gasPrice',
            'eth_getAccount',
            'eth_getBalance',
            'eth_getBlockByHash',
            'eth_getBlockByNumber',
            'eth_getBlockReceipts',
            'eth_getBlockTransactionCountByHash',
            'eth_getBlockTransactionCountByNumber',
            'eth_getCode',
            'eth_getFilterChanges',
            'eth_getFilterLogs',
            'eth_getLogs',
            'eth_getProof',
            'eth_getStorageAt',
            'eth_getTransactionByBlockHashAndIndex',
            'eth_getTransactionByBlockNumberAndIndex',
            'eth_getTransactionByHash',
            'eth_getTransactionCount',
            'eth_getTransactionReceipt',
            'eth_getUncleCountByBlockHash',
            'eth_getUncleCountByBlockNumber',
            'eth_maxPriorityFeePerGas',
            'eth_newBlockFilter',
            'eth_newFilter',
            'eth_newPendingTransactionFilter',
            'eth_sendRawTransaction',
            'eth_syncing',
            'eth_uninstallFilter'
        ],
        NOT_SAFE_RPC_METHODS: ['personal_sign', 'eth_signTypedData_v4', 'eth_sendTransaction'],
        GET_CHAIN_ID: 'eth_chainId',
        RPC_METHOD_NOT_ALLOWED_MESSAGE: 'Requested RPC call is not allowed',
        RPC_METHOD_NOT_ALLOWED_UI_MESSAGE: 'Action not allowed'
    };

    var util$4;
    (function (util) {
        util.assertEqual = (val) => val;
        function assertIs(_arg) { }
        util.assertIs = assertIs;
        function assertNever(_x) {
            throw new Error();
        }
        util.assertNever = assertNever;
        util.arrayToEnum = (items) => {
            const obj = {};
            for (const item of items) {
                obj[item] = item;
            }
            return obj;
        };
        util.getValidEnumValues = (obj) => {
            const validKeys = util.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
            const filtered = {};
            for (const k of validKeys) {
                filtered[k] = obj[k];
            }
            return util.objectValues(filtered);
        };
        util.objectValues = (obj) => {
            return util.objectKeys(obj).map(function (e) {
                return obj[e];
            });
        };
        util.objectKeys = typeof Object.keys === "function" // eslint-disable-line ban/ban
            ? (obj) => Object.keys(obj) // eslint-disable-line ban/ban
            : (object) => {
                const keys = [];
                for (const key in object) {
                    if (Object.prototype.hasOwnProperty.call(object, key)) {
                        keys.push(key);
                    }
                }
                return keys;
            };
        util.find = (arr, checker) => {
            for (const item of arr) {
                if (checker(item))
                    return item;
            }
            return undefined;
        };
        util.isInteger = typeof Number.isInteger === "function"
            ? (val) => Number.isInteger(val) // eslint-disable-line ban/ban
            : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
        function joinValues(array, separator = " | ") {
            return array
                .map((val) => (typeof val === "string" ? `'${val}'` : val))
                .join(separator);
        }
        util.joinValues = joinValues;
        util.jsonStringifyReplacer = (_, value) => {
            if (typeof value === "bigint") {
                return value.toString();
            }
            return value;
        };
    })(util$4 || (util$4 = {}));
    var objectUtil;
    (function (objectUtil) {
        objectUtil.mergeShapes = (first, second) => {
            return {
                ...first,
                ...second, // second overwrites first
            };
        };
    })(objectUtil || (objectUtil = {}));
    const ZodParsedType = util$4.arrayToEnum([
        "string",
        "nan",
        "number",
        "integer",
        "float",
        "boolean",
        "date",
        "bigint",
        "symbol",
        "function",
        "undefined",
        "null",
        "array",
        "object",
        "unknown",
        "promise",
        "void",
        "never",
        "map",
        "set",
    ]);
    const getParsedType = (data) => {
        const t = typeof data;
        switch (t) {
            case "undefined":
                return ZodParsedType.undefined;
            case "string":
                return ZodParsedType.string;
            case "number":
                return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
            case "boolean":
                return ZodParsedType.boolean;
            case "function":
                return ZodParsedType.function;
            case "bigint":
                return ZodParsedType.bigint;
            case "symbol":
                return ZodParsedType.symbol;
            case "object":
                if (Array.isArray(data)) {
                    return ZodParsedType.array;
                }
                if (data === null) {
                    return ZodParsedType.null;
                }
                if (data.then &&
                    typeof data.then === "function" &&
                    data.catch &&
                    typeof data.catch === "function") {
                    return ZodParsedType.promise;
                }
                if (typeof Map !== "undefined" && data instanceof Map) {
                    return ZodParsedType.map;
                }
                if (typeof Set !== "undefined" && data instanceof Set) {
                    return ZodParsedType.set;
                }
                if (typeof Date !== "undefined" && data instanceof Date) {
                    return ZodParsedType.date;
                }
                return ZodParsedType.object;
            default:
                return ZodParsedType.unknown;
        }
    };

    const ZodIssueCode = util$4.arrayToEnum([
        "invalid_type",
        "invalid_literal",
        "custom",
        "invalid_union",
        "invalid_union_discriminator",
        "invalid_enum_value",
        "unrecognized_keys",
        "invalid_arguments",
        "invalid_return_type",
        "invalid_date",
        "invalid_string",
        "too_small",
        "too_big",
        "invalid_intersection_types",
        "not_multiple_of",
        "not_finite",
    ]);
    const quotelessJson = (obj) => {
        const json = JSON.stringify(obj, null, 2);
        return json.replace(/"([^"]+)":/g, "$1:");
    };
    class ZodError extends Error {
        constructor(issues) {
            super();
            this.issues = [];
            this.addIssue = (sub) => {
                this.issues = [...this.issues, sub];
            };
            this.addIssues = (subs = []) => {
                this.issues = [...this.issues, ...subs];
            };
            const actualProto = new.target.prototype;
            if (Object.setPrototypeOf) {
                // eslint-disable-next-line ban/ban
                Object.setPrototypeOf(this, actualProto);
            }
            else {
                this.__proto__ = actualProto;
            }
            this.name = "ZodError";
            this.issues = issues;
        }
        get errors() {
            return this.issues;
        }
        format(_mapper) {
            const mapper = _mapper ||
                function (issue) {
                    return issue.message;
                };
            const fieldErrors = { _errors: [] };
            const processError = (error) => {
                for (const issue of error.issues) {
                    if (issue.code === "invalid_union") {
                        issue.unionErrors.map(processError);
                    }
                    else if (issue.code === "invalid_return_type") {
                        processError(issue.returnTypeError);
                    }
                    else if (issue.code === "invalid_arguments") {
                        processError(issue.argumentsError);
                    }
                    else if (issue.path.length === 0) {
                        fieldErrors._errors.push(mapper(issue));
                    }
                    else {
                        let curr = fieldErrors;
                        let i = 0;
                        while (i < issue.path.length) {
                            const el = issue.path[i];
                            const terminal = i === issue.path.length - 1;
                            if (!terminal) {
                                curr[el] = curr[el] || { _errors: [] };
                                // if (typeof el === "string") {
                                //   curr[el] = curr[el] || { _errors: [] };
                                // } else if (typeof el === "number") {
                                //   const errorArray: any = [];
                                //   errorArray._errors = [];
                                //   curr[el] = curr[el] || errorArray;
                                // }
                            }
                            else {
                                curr[el] = curr[el] || { _errors: [] };
                                curr[el]._errors.push(mapper(issue));
                            }
                            curr = curr[el];
                            i++;
                        }
                    }
                }
            };
            processError(this);
            return fieldErrors;
        }
        toString() {
            return this.message;
        }
        get message() {
            return JSON.stringify(this.issues, util$4.jsonStringifyReplacer, 2);
        }
        get isEmpty() {
            return this.issues.length === 0;
        }
        flatten(mapper = (issue) => issue.message) {
            const fieldErrors = {};
            const formErrors = [];
            for (const sub of this.issues) {
                if (sub.path.length > 0) {
                    fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
                    fieldErrors[sub.path[0]].push(mapper(sub));
                }
                else {
                    formErrors.push(mapper(sub));
                }
            }
            return { formErrors, fieldErrors };
        }
        get formErrors() {
            return this.flatten();
        }
    }
    ZodError.create = (issues) => {
        const error = new ZodError(issues);
        return error;
    };

    const errorMap = (issue, _ctx) => {
        let message;
        switch (issue.code) {
            case ZodIssueCode.invalid_type:
                if (issue.received === ZodParsedType.undefined) {
                    message = "Required";
                }
                else {
                    message = `Expected ${issue.expected}, received ${issue.received}`;
                }
                break;
            case ZodIssueCode.invalid_literal:
                message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util$4.jsonStringifyReplacer)}`;
                break;
            case ZodIssueCode.unrecognized_keys:
                message = `Unrecognized key(s) in object: ${util$4.joinValues(issue.keys, ", ")}`;
                break;
            case ZodIssueCode.invalid_union:
                message = `Invalid input`;
                break;
            case ZodIssueCode.invalid_union_discriminator:
                message = `Invalid discriminator value. Expected ${util$4.joinValues(issue.options)}`;
                break;
            case ZodIssueCode.invalid_enum_value:
                message = `Invalid enum value. Expected ${util$4.joinValues(issue.options)}, received '${issue.received}'`;
                break;
            case ZodIssueCode.invalid_arguments:
                message = `Invalid function arguments`;
                break;
            case ZodIssueCode.invalid_return_type:
                message = `Invalid function return type`;
                break;
            case ZodIssueCode.invalid_date:
                message = `Invalid date`;
                break;
            case ZodIssueCode.invalid_string:
                if (typeof issue.validation === "object") {
                    if ("includes" in issue.validation) {
                        message = `Invalid input: must include "${issue.validation.includes}"`;
                        if (typeof issue.validation.position === "number") {
                            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
                        }
                    }
                    else if ("startsWith" in issue.validation) {
                        message = `Invalid input: must start with "${issue.validation.startsWith}"`;
                    }
                    else if ("endsWith" in issue.validation) {
                        message = `Invalid input: must end with "${issue.validation.endsWith}"`;
                    }
                    else {
                        util$4.assertNever(issue.validation);
                    }
                }
                else if (issue.validation !== "regex") {
                    message = `Invalid ${issue.validation}`;
                }
                else {
                    message = "Invalid";
                }
                break;
            case ZodIssueCode.too_small:
                if (issue.type === "array")
                    message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
                else if (issue.type === "string")
                    message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
                else if (issue.type === "number")
                    message = `Number must be ${issue.exact
                    ? `exactly equal to `
                    : issue.inclusive
                        ? `greater than or equal to `
                        : `greater than `}${issue.minimum}`;
                else if (issue.type === "date")
                    message = `Date must be ${issue.exact
                    ? `exactly equal to `
                    : issue.inclusive
                        ? `greater than or equal to `
                        : `greater than `}${new Date(Number(issue.minimum))}`;
                else
                    message = "Invalid input";
                break;
            case ZodIssueCode.too_big:
                if (issue.type === "array")
                    message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
                else if (issue.type === "string")
                    message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
                else if (issue.type === "number")
                    message = `Number must be ${issue.exact
                    ? `exactly`
                    : issue.inclusive
                        ? `less than or equal to`
                        : `less than`} ${issue.maximum}`;
                else if (issue.type === "bigint")
                    message = `BigInt must be ${issue.exact
                    ? `exactly`
                    : issue.inclusive
                        ? `less than or equal to`
                        : `less than`} ${issue.maximum}`;
                else if (issue.type === "date")
                    message = `Date must be ${issue.exact
                    ? `exactly`
                    : issue.inclusive
                        ? `smaller than or equal to`
                        : `smaller than`} ${new Date(Number(issue.maximum))}`;
                else
                    message = "Invalid input";
                break;
            case ZodIssueCode.custom:
                message = `Invalid input`;
                break;
            case ZodIssueCode.invalid_intersection_types:
                message = `Intersection results could not be merged`;
                break;
            case ZodIssueCode.not_multiple_of:
                message = `Number must be a multiple of ${issue.multipleOf}`;
                break;
            case ZodIssueCode.not_finite:
                message = "Number must be finite";
                break;
            default:
                message = _ctx.defaultError;
                util$4.assertNever(issue);
        }
        return { message };
    };

    let overrideErrorMap = errorMap;
    function setErrorMap(map) {
        overrideErrorMap = map;
    }
    function getErrorMap() {
        return overrideErrorMap;
    }

    const makeIssue = (params) => {
        const { data, path, errorMaps, issueData } = params;
        const fullPath = [...path, ...(issueData.path || [])];
        const fullIssue = {
            ...issueData,
            path: fullPath,
        };
        let errorMessage = "";
        const maps = errorMaps
            .filter((m) => !!m)
            .slice()
            .reverse();
        for (const map of maps) {
            errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
        }
        return {
            ...issueData,
            path: fullPath,
            message: issueData.message || errorMessage,
        };
    };
    const EMPTY_PATH = [];
    function addIssueToContext(ctx, issueData) {
        const issue = makeIssue({
            issueData: issueData,
            data: ctx.data,
            path: ctx.path,
            errorMaps: [
                ctx.common.contextualErrorMap,
                ctx.schemaErrorMap,
                getErrorMap(),
                errorMap, // then global default map
            ].filter((x) => !!x),
        });
        ctx.common.issues.push(issue);
    }
    class ParseStatus {
        constructor() {
            this.value = "valid";
        }
        dirty() {
            if (this.value === "valid")
                this.value = "dirty";
        }
        abort() {
            if (this.value !== "aborted")
                this.value = "aborted";
        }
        static mergeArray(status, results) {
            const arrayValue = [];
            for (const s of results) {
                if (s.status === "aborted")
                    return INVALID;
                if (s.status === "dirty")
                    status.dirty();
                arrayValue.push(s.value);
            }
            return { status: status.value, value: arrayValue };
        }
        static async mergeObjectAsync(status, pairs) {
            const syncPairs = [];
            for (const pair of pairs) {
                syncPairs.push({
                    key: await pair.key,
                    value: await pair.value,
                });
            }
            return ParseStatus.mergeObjectSync(status, syncPairs);
        }
        static mergeObjectSync(status, pairs) {
            const finalObject = {};
            for (const pair of pairs) {
                const { key, value } = pair;
                if (key.status === "aborted")
                    return INVALID;
                if (value.status === "aborted")
                    return INVALID;
                if (key.status === "dirty")
                    status.dirty();
                if (value.status === "dirty")
                    status.dirty();
                if (key.value !== "__proto__" &&
                    (typeof value.value !== "undefined" || pair.alwaysSet)) {
                    finalObject[key.value] = value.value;
                }
            }
            return { status: status.value, value: finalObject };
        }
    }
    const INVALID = Object.freeze({
        status: "aborted",
    });
    const DIRTY = (value) => ({ status: "dirty", value });
    const OK = (value) => ({ status: "valid", value });
    const isAborted = (x) => x.status === "aborted";
    const isDirty = (x) => x.status === "dirty";
    const isValid = (x) => x.status === "valid";
    const isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;

    var errorUtil;
    (function (errorUtil) {
        errorUtil.errToObj = (message) => typeof message === "string" ? { message } : message || {};
        errorUtil.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
    })(errorUtil || (errorUtil = {}));

    class ParseInputLazyPath {
        constructor(parent, value, path, key) {
            this._cachedPath = [];
            this.parent = parent;
            this.data = value;
            this._path = path;
            this._key = key;
        }
        get path() {
            if (!this._cachedPath.length) {
                if (this._key instanceof Array) {
                    this._cachedPath.push(...this._path, ...this._key);
                }
                else {
                    this._cachedPath.push(...this._path, this._key);
                }
            }
            return this._cachedPath;
        }
    }
    const handleResult = (ctx, result) => {
        if (isValid(result)) {
            return { success: true, data: result.value };
        }
        else {
            if (!ctx.common.issues.length) {
                throw new Error("Validation failed but no issues detected.");
            }
            return {
                success: false,
                get error() {
                    if (this._error)
                        return this._error;
                    const error = new ZodError(ctx.common.issues);
                    this._error = error;
                    return this._error;
                },
            };
        }
    };
    function processCreateParams(params) {
        if (!params)
            return {};
        const { errorMap, invalid_type_error, required_error, description } = params;
        if (errorMap && (invalid_type_error || required_error)) {
            throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
        }
        if (errorMap)
            return { errorMap: errorMap, description };
        const customMap = (iss, ctx) => {
            if (iss.code !== "invalid_type")
                return { message: ctx.defaultError };
            if (typeof ctx.data === "undefined") {
                return { message: required_error !== null && required_error !== void 0 ? required_error : ctx.defaultError };
            }
            return { message: invalid_type_error !== null && invalid_type_error !== void 0 ? invalid_type_error : ctx.defaultError };
        };
        return { errorMap: customMap, description };
    }
    class ZodType {
        constructor(def) {
            /** Alias of safeParseAsync */
            this.spa = this.safeParseAsync;
            this._def = def;
            this.parse = this.parse.bind(this);
            this.safeParse = this.safeParse.bind(this);
            this.parseAsync = this.parseAsync.bind(this);
            this.safeParseAsync = this.safeParseAsync.bind(this);
            this.spa = this.spa.bind(this);
            this.refine = this.refine.bind(this);
            this.refinement = this.refinement.bind(this);
            this.superRefine = this.superRefine.bind(this);
            this.optional = this.optional.bind(this);
            this.nullable = this.nullable.bind(this);
            this.nullish = this.nullish.bind(this);
            this.array = this.array.bind(this);
            this.promise = this.promise.bind(this);
            this.or = this.or.bind(this);
            this.and = this.and.bind(this);
            this.transform = this.transform.bind(this);
            this.brand = this.brand.bind(this);
            this.default = this.default.bind(this);
            this.catch = this.catch.bind(this);
            this.describe = this.describe.bind(this);
            this.pipe = this.pipe.bind(this);
            this.readonly = this.readonly.bind(this);
            this.isNullable = this.isNullable.bind(this);
            this.isOptional = this.isOptional.bind(this);
        }
        get description() {
            return this._def.description;
        }
        _getType(input) {
            return getParsedType(input.data);
        }
        _getOrReturnCtx(input, ctx) {
            return (ctx || {
                common: input.parent.common,
                data: input.data,
                parsedType: getParsedType(input.data),
                schemaErrorMap: this._def.errorMap,
                path: input.path,
                parent: input.parent,
            });
        }
        _processInputParams(input) {
            return {
                status: new ParseStatus(),
                ctx: {
                    common: input.parent.common,
                    data: input.data,
                    parsedType: getParsedType(input.data),
                    schemaErrorMap: this._def.errorMap,
                    path: input.path,
                    parent: input.parent,
                },
            };
        }
        _parseSync(input) {
            const result = this._parse(input);
            if (isAsync(result)) {
                throw new Error("Synchronous parse encountered promise.");
            }
            return result;
        }
        _parseAsync(input) {
            const result = this._parse(input);
            return Promise.resolve(result);
        }
        parse(data, params) {
            const result = this.safeParse(data, params);
            if (result.success)
                return result.data;
            throw result.error;
        }
        safeParse(data, params) {
            var _a;
            const ctx = {
                common: {
                    issues: [],
                    async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
                    contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
                },
                path: (params === null || params === void 0 ? void 0 : params.path) || [],
                schemaErrorMap: this._def.errorMap,
                parent: null,
                data,
                parsedType: getParsedType(data),
            };
            const result = this._parseSync({ data, path: ctx.path, parent: ctx });
            return handleResult(ctx, result);
        }
        async parseAsync(data, params) {
            const result = await this.safeParseAsync(data, params);
            if (result.success)
                return result.data;
            throw result.error;
        }
        async safeParseAsync(data, params) {
            const ctx = {
                common: {
                    issues: [],
                    contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
                    async: true,
                },
                path: (params === null || params === void 0 ? void 0 : params.path) || [],
                schemaErrorMap: this._def.errorMap,
                parent: null,
                data,
                parsedType: getParsedType(data),
            };
            const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
            const result = await (isAsync(maybeAsyncResult)
                ? maybeAsyncResult
                : Promise.resolve(maybeAsyncResult));
            return handleResult(ctx, result);
        }
        refine(check, message) {
            const getIssueProperties = (val) => {
                if (typeof message === "string" || typeof message === "undefined") {
                    return { message };
                }
                else if (typeof message === "function") {
                    return message(val);
                }
                else {
                    return message;
                }
            };
            return this._refinement((val, ctx) => {
                const result = check(val);
                const setError = () => ctx.addIssue({
                    code: ZodIssueCode.custom,
                    ...getIssueProperties(val),
                });
                if (typeof Promise !== "undefined" && result instanceof Promise) {
                    return result.then((data) => {
                        if (!data) {
                            setError();
                            return false;
                        }
                        else {
                            return true;
                        }
                    });
                }
                if (!result) {
                    setError();
                    return false;
                }
                else {
                    return true;
                }
            });
        }
        refinement(check, refinementData) {
            return this._refinement((val, ctx) => {
                if (!check(val)) {
                    ctx.addIssue(typeof refinementData === "function"
                        ? refinementData(val, ctx)
                        : refinementData);
                    return false;
                }
                else {
                    return true;
                }
            });
        }
        _refinement(refinement) {
            return new ZodEffects({
                schema: this,
                typeName: ZodFirstPartyTypeKind.ZodEffects,
                effect: { type: "refinement", refinement },
            });
        }
        superRefine(refinement) {
            return this._refinement(refinement);
        }
        optional() {
            return ZodOptional.create(this, this._def);
        }
        nullable() {
            return ZodNullable.create(this, this._def);
        }
        nullish() {
            return this.nullable().optional();
        }
        array() {
            return ZodArray.create(this, this._def);
        }
        promise() {
            return ZodPromise.create(this, this._def);
        }
        or(option) {
            return ZodUnion.create([this, option], this._def);
        }
        and(incoming) {
            return ZodIntersection.create(this, incoming, this._def);
        }
        transform(transform) {
            return new ZodEffects({
                ...processCreateParams(this._def),
                schema: this,
                typeName: ZodFirstPartyTypeKind.ZodEffects,
                effect: { type: "transform", transform },
            });
        }
        default(def) {
            const defaultValueFunc = typeof def === "function" ? def : () => def;
            return new ZodDefault({
                ...processCreateParams(this._def),
                innerType: this,
                defaultValue: defaultValueFunc,
                typeName: ZodFirstPartyTypeKind.ZodDefault,
            });
        }
        brand() {
            return new ZodBranded({
                typeName: ZodFirstPartyTypeKind.ZodBranded,
                type: this,
                ...processCreateParams(this._def),
            });
        }
        catch(def) {
            const catchValueFunc = typeof def === "function" ? def : () => def;
            return new ZodCatch({
                ...processCreateParams(this._def),
                innerType: this,
                catchValue: catchValueFunc,
                typeName: ZodFirstPartyTypeKind.ZodCatch,
            });
        }
        describe(description) {
            const This = this.constructor;
            return new This({
                ...this._def,
                description,
            });
        }
        pipe(target) {
            return ZodPipeline.create(this, target);
        }
        readonly() {
            return ZodReadonly.create(this);
        }
        isOptional() {
            return this.safeParse(undefined).success;
        }
        isNullable() {
            return this.safeParse(null).success;
        }
    }
    const cuidRegex = /^c[^\s-]{8,}$/i;
    const cuid2Regex = /^[a-z][a-z0-9]*$/;
    const ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;
    // const uuidRegex =
    //   /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
    const uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
    // from https://stackoverflow.com/a/46181/1550155
    // old version: too slow, didn't support unicode
    // const emailRegex = /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i;
    //old email regex
    // const emailRegex = /^(([^<>()[\].,;:\s@"]+(\.[^<>()[\].,;:\s@"]+)*)|(".+"))@((?!-)([^<>()[\].,;:\s@"]+\.)+[^<>()[\].,;:\s@"]{1,})[^-<>()[\].,;:\s@"]$/i;
    // eslint-disable-next-line
    // const emailRegex =
    //   /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\])|(\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\.[A-Za-z]{2,})+))$/;
    // const emailRegex =
    //   /^[a-zA-Z0-9\.\!\#\$\%\&\'\*\+\/\=\?\^\_\`\{\|\}\~\-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
    // const emailRegex =
    //   /^(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])$/i;
    const emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
    // const emailRegex =
    //   /^[a-z0-9.!#$%&’*+/=?^_`{|}~-]+@[a-z0-9-]+(?:\.[a-z0-9\-]+)*$/i;
    // from https://thekevinscott.com/emojis-in-javascript/#writing-a-regular-expression
    const _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
    let emojiRegex;
    const ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;
    const ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
    // Adapted from https://stackoverflow.com/a/3143231
    const datetimeRegex = (args) => {
        if (args.precision) {
            if (args.offset) {
                return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
            }
            else {
                return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}Z$`);
            }
        }
        else if (args.precision === 0) {
            if (args.offset) {
                return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
            }
            else {
                return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$`);
            }
        }
        else {
            if (args.offset) {
                return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
            }
            else {
                return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$`);
            }
        }
    };
    function isValidIP(ip, version) {
        if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
            return true;
        }
        if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
            return true;
        }
        return false;
    }
    class ZodString extends ZodType {
        _parse(input) {
            if (this._def.coerce) {
                input.data = String(input.data);
            }
            const parsedType = this._getType(input);
            if (parsedType !== ZodParsedType.string) {
                const ctx = this._getOrReturnCtx(input);
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_type,
                    expected: ZodParsedType.string,
                    received: ctx.parsedType,
                }
                //
                );
                return INVALID;
            }
            const status = new ParseStatus();
            let ctx = undefined;
            for (const check of this._def.checks) {
                if (check.kind === "min") {
                    if (input.data.length < check.value) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.too_small,
                            minimum: check.value,
                            type: "string",
                            inclusive: true,
                            exact: false,
                            message: check.message,
                        });
                        status.dirty();
                    }
                }
                else if (check.kind === "max") {
                    if (input.data.length > check.value) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.too_big,
                            maximum: check.value,
                            type: "string",
                            inclusive: true,
                            exact: false,
                            message: check.message,
                        });
                        status.dirty();
                    }
                }
                else if (check.kind === "length") {
                    const tooBig = input.data.length > check.value;
                    const tooSmall = input.data.length < check.value;
                    if (tooBig || tooSmall) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        if (tooBig) {
                            addIssueToContext(ctx, {
                                code: ZodIssueCode.too_big,
                                maximum: check.value,
                                type: "string",
                                inclusive: true,
                                exact: true,
                                message: check.message,
                            });
                        }
                        else if (tooSmall) {
                            addIssueToContext(ctx, {
                                code: ZodIssueCode.too_small,
                                minimum: check.value,
                                type: "string",
                                inclusive: true,
                                exact: true,
                                message: check.message,
                            });
                        }
                        status.dirty();
                    }
                }
                else if (check.kind === "email") {
                    if (!emailRegex.test(input.data)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            validation: "email",
                            code: ZodIssueCode.invalid_string,
                            message: check.message,
                        });
                        status.dirty();
                    }
                }
                else if (check.kind === "emoji") {
                    if (!emojiRegex) {
                        emojiRegex = new RegExp(_emojiRegex, "u");
                    }
                    if (!emojiRegex.test(input.data)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            validation: "emoji",
                            code: ZodIssueCode.invalid_string,
                            message: check.message,
                        });
                        status.dirty();
                    }
                }
                else if (check.kind === "uuid") {
                    if (!uuidRegex.test(input.data)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            validation: "uuid",
                            code: ZodIssueCode.invalid_string,
                            message: check.message,
                        });
                        status.dirty();
                    }
                }
                else if (check.kind === "cuid") {
                    if (!cuidRegex.test(input.data)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            validation: "cuid",
                            code: ZodIssueCode.invalid_string,
                            message: check.message,
                        });
                        status.dirty();
                    }
                }
                else if (check.kind === "cuid2") {
                    if (!cuid2Regex.test(input.data)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            validation: "cuid2",
                            code: ZodIssueCode.invalid_string,
                            message: check.message,
                        });
                        status.dirty();
                    }
                }
                else if (check.kind === "ulid") {
                    if (!ulidRegex.test(input.data)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            validation: "ulid",
                            code: ZodIssueCode.invalid_string,
                            message: check.message,
                        });
                        status.dirty();
                    }
                }
                else if (check.kind === "url") {
                    try {
                        new URL(input.data);
                    }
                    catch (_a) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            validation: "url",
                            code: ZodIssueCode.invalid_string,
                            message: check.message,
                        });
                        status.dirty();
                    }
                }
                else if (check.kind === "regex") {
                    check.regex.lastIndex = 0;
                    const testResult = check.regex.test(input.data);
                    if (!testResult) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            validation: "regex",
                            code: ZodIssueCode.invalid_string,
                            message: check.message,
                        });
                        status.dirty();
                    }
                }
                else if (check.kind === "trim") {
                    input.data = input.data.trim();
                }
                else if (check.kind === "includes") {
                    if (!input.data.includes(check.value, check.position)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.invalid_string,
                            validation: { includes: check.value, position: check.position },
                            message: check.message,
                        });
                        status.dirty();
                    }
                }
                else if (check.kind === "toLowerCase") {
                    input.data = input.data.toLowerCase();
                }
                else if (check.kind === "toUpperCase") {
                    input.data = input.data.toUpperCase();
                }
                else if (check.kind === "startsWith") {
                    if (!input.data.startsWith(check.value)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.invalid_string,
                            validation: { startsWith: check.value },
                            message: check.message,
                        });
                        status.dirty();
                    }
                }
                else if (check.kind === "endsWith") {
                    if (!input.data.endsWith(check.value)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.invalid_string,
                            validation: { endsWith: check.value },
                            message: check.message,
                        });
                        status.dirty();
                    }
                }
                else if (check.kind === "datetime") {
                    const regex = datetimeRegex(check);
                    if (!regex.test(input.data)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.invalid_string,
                            validation: "datetime",
                            message: check.message,
                        });
                        status.dirty();
                    }
                }
                else if (check.kind === "ip") {
                    if (!isValidIP(input.data, check.version)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            validation: "ip",
                            code: ZodIssueCode.invalid_string,
                            message: check.message,
                        });
                        status.dirty();
                    }
                }
                else {
                    util$4.assertNever(check);
                }
            }
            return { status: status.value, value: input.data };
        }
        _regex(regex, validation, message) {
            return this.refinement((data) => regex.test(data), {
                validation,
                code: ZodIssueCode.invalid_string,
                ...errorUtil.errToObj(message),
            });
        }
        _addCheck(check) {
            return new ZodString({
                ...this._def,
                checks: [...this._def.checks, check],
            });
        }
        email(message) {
            return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
        }
        url(message) {
            return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
        }
        emoji(message) {
            return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
        }
        uuid(message) {
            return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
        }
        cuid(message) {
            return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
        }
        cuid2(message) {
            return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
        }
        ulid(message) {
            return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
        }
        ip(options) {
            return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
        }
        datetime(options) {
            var _a;
            if (typeof options === "string") {
                return this._addCheck({
                    kind: "datetime",
                    precision: null,
                    offset: false,
                    message: options,
                });
            }
            return this._addCheck({
                kind: "datetime",
                precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
                offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,
                ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message),
            });
        }
        regex(regex, message) {
            return this._addCheck({
                kind: "regex",
                regex: regex,
                ...errorUtil.errToObj(message),
            });
        }
        includes(value, options) {
            return this._addCheck({
                kind: "includes",
                value: value,
                position: options === null || options === void 0 ? void 0 : options.position,
                ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message),
            });
        }
        startsWith(value, message) {
            return this._addCheck({
                kind: "startsWith",
                value: value,
                ...errorUtil.errToObj(message),
            });
        }
        endsWith(value, message) {
            return this._addCheck({
                kind: "endsWith",
                value: value,
                ...errorUtil.errToObj(message),
            });
        }
        min(minLength, message) {
            return this._addCheck({
                kind: "min",
                value: minLength,
                ...errorUtil.errToObj(message),
            });
        }
        max(maxLength, message) {
            return this._addCheck({
                kind: "max",
                value: maxLength,
                ...errorUtil.errToObj(message),
            });
        }
        length(len, message) {
            return this._addCheck({
                kind: "length",
                value: len,
                ...errorUtil.errToObj(message),
            });
        }
        /**
         * @deprecated Use z.string().min(1) instead.
         * @see {@link ZodString.min}
         */
        nonempty(message) {
            return this.min(1, errorUtil.errToObj(message));
        }
        trim() {
            return new ZodString({
                ...this._def,
                checks: [...this._def.checks, { kind: "trim" }],
            });
        }
        toLowerCase() {
            return new ZodString({
                ...this._def,
                checks: [...this._def.checks, { kind: "toLowerCase" }],
            });
        }
        toUpperCase() {
            return new ZodString({
                ...this._def,
                checks: [...this._def.checks, { kind: "toUpperCase" }],
            });
        }
        get isDatetime() {
            return !!this._def.checks.find((ch) => ch.kind === "datetime");
        }
        get isEmail() {
            return !!this._def.checks.find((ch) => ch.kind === "email");
        }
        get isURL() {
            return !!this._def.checks.find((ch) => ch.kind === "url");
        }
        get isEmoji() {
            return !!this._def.checks.find((ch) => ch.kind === "emoji");
        }
        get isUUID() {
            return !!this._def.checks.find((ch) => ch.kind === "uuid");
        }
        get isCUID() {
            return !!this._def.checks.find((ch) => ch.kind === "cuid");
        }
        get isCUID2() {
            return !!this._def.checks.find((ch) => ch.kind === "cuid2");
        }
        get isULID() {
            return !!this._def.checks.find((ch) => ch.kind === "ulid");
        }
        get isIP() {
            return !!this._def.checks.find((ch) => ch.kind === "ip");
        }
        get minLength() {
            let min = null;
            for (const ch of this._def.checks) {
                if (ch.kind === "min") {
                    if (min === null || ch.value > min)
                        min = ch.value;
                }
            }
            return min;
        }
        get maxLength() {
            let max = null;
            for (const ch of this._def.checks) {
                if (ch.kind === "max") {
                    if (max === null || ch.value < max)
                        max = ch.value;
                }
            }
            return max;
        }
    }
    ZodString.create = (params) => {
        var _a;
        return new ZodString({
            checks: [],
            typeName: ZodFirstPartyTypeKind.ZodString,
            coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
            ...processCreateParams(params),
        });
    };
    // https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034
    function floatSafeRemainder(val, step) {
        const valDecCount = (val.toString().split(".")[1] || "").length;
        const stepDecCount = (step.toString().split(".")[1] || "").length;
        const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
        const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
        const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
        return (valInt % stepInt) / Math.pow(10, decCount);
    }
    class ZodNumber extends ZodType {
        constructor() {
            super(...arguments);
            this.min = this.gte;
            this.max = this.lte;
            this.step = this.multipleOf;
        }
        _parse(input) {
            if (this._def.coerce) {
                input.data = Number(input.data);
            }
            const parsedType = this._getType(input);
            if (parsedType !== ZodParsedType.number) {
                const ctx = this._getOrReturnCtx(input);
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_type,
                    expected: ZodParsedType.number,
                    received: ctx.parsedType,
                });
                return INVALID;
            }
            let ctx = undefined;
            const status = new ParseStatus();
            for (const check of this._def.checks) {
                if (check.kind === "int") {
                    if (!util$4.isInteger(input.data)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.invalid_type,
                            expected: "integer",
                            received: "float",
                            message: check.message,
                        });
                        status.dirty();
                    }
                }
                else if (check.kind === "min") {
                    const tooSmall = check.inclusive
                        ? input.data < check.value
                        : input.data <= check.value;
                    if (tooSmall) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.too_small,
                            minimum: check.value,
                            type: "number",
                            inclusive: check.inclusive,
                            exact: false,
                            message: check.message,
                        });
                        status.dirty();
                    }
                }
                else if (check.kind === "max") {
                    const tooBig = check.inclusive
                        ? input.data > check.value
                        : input.data >= check.value;
                    if (tooBig) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.too_big,
                            maximum: check.value,
                            type: "number",
                            inclusive: check.inclusive,
                            exact: false,
                            message: check.message,
                        });
                        status.dirty();
                    }
                }
                else if (check.kind === "multipleOf") {
                    if (floatSafeRemainder(input.data, check.value) !== 0) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.not_multiple_of,
                            multipleOf: check.value,
                            message: check.message,
                        });
                        status.dirty();
                    }
                }
                else if (check.kind === "finite") {
                    if (!Number.isFinite(input.data)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.not_finite,
                            message: check.message,
                        });
                        status.dirty();
                    }
                }
                else {
                    util$4.assertNever(check);
                }
            }
            return { status: status.value, value: input.data };
        }
        gte(value, message) {
            return this.setLimit("min", value, true, errorUtil.toString(message));
        }
        gt(value, message) {
            return this.setLimit("min", value, false, errorUtil.toString(message));
        }
        lte(value, message) {
            return this.setLimit("max", value, true, errorUtil.toString(message));
        }
        lt(value, message) {
            return this.setLimit("max", value, false, errorUtil.toString(message));
        }
        setLimit(kind, value, inclusive, message) {
            return new ZodNumber({
                ...this._def,
                checks: [
                    ...this._def.checks,
                    {
                        kind,
                        value,
                        inclusive,
                        message: errorUtil.toString(message),
                    },
                ],
            });
        }
        _addCheck(check) {
            return new ZodNumber({
                ...this._def,
                checks: [...this._def.checks, check],
            });
        }
        int(message) {
            return this._addCheck({
                kind: "int",
                message: errorUtil.toString(message),
            });
        }
        positive(message) {
            return this._addCheck({
                kind: "min",
                value: 0,
                inclusive: false,
                message: errorUtil.toString(message),
            });
        }
        negative(message) {
            return this._addCheck({
                kind: "max",
                value: 0,
                inclusive: false,
                message: errorUtil.toString(message),
            });
        }
        nonpositive(message) {
            return this._addCheck({
                kind: "max",
                value: 0,
                inclusive: true,
                message: errorUtil.toString(message),
            });
        }
        nonnegative(message) {
            return this._addCheck({
                kind: "min",
                value: 0,
                inclusive: true,
                message: errorUtil.toString(message),
            });
        }
        multipleOf(value, message) {
            return this._addCheck({
                kind: "multipleOf",
                value: value,
                message: errorUtil.toString(message),
            });
        }
        finite(message) {
            return this._addCheck({
                kind: "finite",
                message: errorUtil.toString(message),
            });
        }
        safe(message) {
            return this._addCheck({
                kind: "min",
                inclusive: true,
                value: Number.MIN_SAFE_INTEGER,
                message: errorUtil.toString(message),
            })._addCheck({
                kind: "max",
                inclusive: true,
                value: Number.MAX_SAFE_INTEGER,
                message: errorUtil.toString(message),
            });
        }
        get minValue() {
            let min = null;
            for (const ch of this._def.checks) {
                if (ch.kind === "min") {
                    if (min === null || ch.value > min)
                        min = ch.value;
                }
            }
            return min;
        }
        get maxValue() {
            let max = null;
            for (const ch of this._def.checks) {
                if (ch.kind === "max") {
                    if (max === null || ch.value < max)
                        max = ch.value;
                }
            }
            return max;
        }
        get isInt() {
            return !!this._def.checks.find((ch) => ch.kind === "int" ||
                (ch.kind === "multipleOf" && util$4.isInteger(ch.value)));
        }
        get isFinite() {
            let max = null, min = null;
            for (const ch of this._def.checks) {
                if (ch.kind === "finite" ||
                    ch.kind === "int" ||
                    ch.kind === "multipleOf") {
                    return true;
                }
                else if (ch.kind === "min") {
                    if (min === null || ch.value > min)
                        min = ch.value;
                }
                else if (ch.kind === "max") {
                    if (max === null || ch.value < max)
                        max = ch.value;
                }
            }
            return Number.isFinite(min) && Number.isFinite(max);
        }
    }
    ZodNumber.create = (params) => {
        return new ZodNumber({
            checks: [],
            typeName: ZodFirstPartyTypeKind.ZodNumber,
            coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
            ...processCreateParams(params),
        });
    };
    class ZodBigInt extends ZodType {
        constructor() {
            super(...arguments);
            this.min = this.gte;
            this.max = this.lte;
        }
        _parse(input) {
            if (this._def.coerce) {
                input.data = BigInt(input.data);
            }
            const parsedType = this._getType(input);
            if (parsedType !== ZodParsedType.bigint) {
                const ctx = this._getOrReturnCtx(input);
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_type,
                    expected: ZodParsedType.bigint,
                    received: ctx.parsedType,
                });
                return INVALID;
            }
            let ctx = undefined;
            const status = new ParseStatus();
            for (const check of this._def.checks) {
                if (check.kind === "min") {
                    const tooSmall = check.inclusive
                        ? input.data < check.value
                        : input.data <= check.value;
                    if (tooSmall) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.too_small,
                            type: "bigint",
                            minimum: check.value,
                            inclusive: check.inclusive,
                            message: check.message,
                        });
                        status.dirty();
                    }
                }
                else if (check.kind === "max") {
                    const tooBig = check.inclusive
                        ? input.data > check.value
                        : input.data >= check.value;
                    if (tooBig) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.too_big,
                            type: "bigint",
                            maximum: check.value,
                            inclusive: check.inclusive,
                            message: check.message,
                        });
                        status.dirty();
                    }
                }
                else if (check.kind === "multipleOf") {
                    if (input.data % check.value !== BigInt(0)) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.not_multiple_of,
                            multipleOf: check.value,
                            message: check.message,
                        });
                        status.dirty();
                    }
                }
                else {
                    util$4.assertNever(check);
                }
            }
            return { status: status.value, value: input.data };
        }
        gte(value, message) {
            return this.setLimit("min", value, true, errorUtil.toString(message));
        }
        gt(value, message) {
            return this.setLimit("min", value, false, errorUtil.toString(message));
        }
        lte(value, message) {
            return this.setLimit("max", value, true, errorUtil.toString(message));
        }
        lt(value, message) {
            return this.setLimit("max", value, false, errorUtil.toString(message));
        }
        setLimit(kind, value, inclusive, message) {
            return new ZodBigInt({
                ...this._def,
                checks: [
                    ...this._def.checks,
                    {
                        kind,
                        value,
                        inclusive,
                        message: errorUtil.toString(message),
                    },
                ],
            });
        }
        _addCheck(check) {
            return new ZodBigInt({
                ...this._def,
                checks: [...this._def.checks, check],
            });
        }
        positive(message) {
            return this._addCheck({
                kind: "min",
                value: BigInt(0),
                inclusive: false,
                message: errorUtil.toString(message),
            });
        }
        negative(message) {
            return this._addCheck({
                kind: "max",
                value: BigInt(0),
                inclusive: false,
                message: errorUtil.toString(message),
            });
        }
        nonpositive(message) {
            return this._addCheck({
                kind: "max",
                value: BigInt(0),
                inclusive: true,
                message: errorUtil.toString(message),
            });
        }
        nonnegative(message) {
            return this._addCheck({
                kind: "min",
                value: BigInt(0),
                inclusive: true,
                message: errorUtil.toString(message),
            });
        }
        multipleOf(value, message) {
            return this._addCheck({
                kind: "multipleOf",
                value,
                message: errorUtil.toString(message),
            });
        }
        get minValue() {
            let min = null;
            for (const ch of this._def.checks) {
                if (ch.kind === "min") {
                    if (min === null || ch.value > min)
                        min = ch.value;
                }
            }
            return min;
        }
        get maxValue() {
            let max = null;
            for (const ch of this._def.checks) {
                if (ch.kind === "max") {
                    if (max === null || ch.value < max)
                        max = ch.value;
                }
            }
            return max;
        }
    }
    ZodBigInt.create = (params) => {
        var _a;
        return new ZodBigInt({
            checks: [],
            typeName: ZodFirstPartyTypeKind.ZodBigInt,
            coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
            ...processCreateParams(params),
        });
    };
    class ZodBoolean extends ZodType {
        _parse(input) {
            if (this._def.coerce) {
                input.data = Boolean(input.data);
            }
            const parsedType = this._getType(input);
            if (parsedType !== ZodParsedType.boolean) {
                const ctx = this._getOrReturnCtx(input);
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_type,
                    expected: ZodParsedType.boolean,
                    received: ctx.parsedType,
                });
                return INVALID;
            }
            return OK(input.data);
        }
    }
    ZodBoolean.create = (params) => {
        return new ZodBoolean({
            typeName: ZodFirstPartyTypeKind.ZodBoolean,
            coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
            ...processCreateParams(params),
        });
    };
    class ZodDate extends ZodType {
        _parse(input) {
            if (this._def.coerce) {
                input.data = new Date(input.data);
            }
            const parsedType = this._getType(input);
            if (parsedType !== ZodParsedType.date) {
                const ctx = this._getOrReturnCtx(input);
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_type,
                    expected: ZodParsedType.date,
                    received: ctx.parsedType,
                });
                return INVALID;
            }
            if (isNaN(input.data.getTime())) {
                const ctx = this._getOrReturnCtx(input);
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_date,
                });
                return INVALID;
            }
            const status = new ParseStatus();
            let ctx = undefined;
            for (const check of this._def.checks) {
                if (check.kind === "min") {
                    if (input.data.getTime() < check.value) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.too_small,
                            message: check.message,
                            inclusive: true,
                            exact: false,
                            minimum: check.value,
                            type: "date",
                        });
                        status.dirty();
                    }
                }
                else if (check.kind === "max") {
                    if (input.data.getTime() > check.value) {
                        ctx = this._getOrReturnCtx(input, ctx);
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.too_big,
                            message: check.message,
                            inclusive: true,
                            exact: false,
                            maximum: check.value,
                            type: "date",
                        });
                        status.dirty();
                    }
                }
                else {
                    util$4.assertNever(check);
                }
            }
            return {
                status: status.value,
                value: new Date(input.data.getTime()),
            };
        }
        _addCheck(check) {
            return new ZodDate({
                ...this._def,
                checks: [...this._def.checks, check],
            });
        }
        min(minDate, message) {
            return this._addCheck({
                kind: "min",
                value: minDate.getTime(),
                message: errorUtil.toString(message),
            });
        }
        max(maxDate, message) {
            return this._addCheck({
                kind: "max",
                value: maxDate.getTime(),
                message: errorUtil.toString(message),
            });
        }
        get minDate() {
            let min = null;
            for (const ch of this._def.checks) {
                if (ch.kind === "min") {
                    if (min === null || ch.value > min)
                        min = ch.value;
                }
            }
            return min != null ? new Date(min) : null;
        }
        get maxDate() {
            let max = null;
            for (const ch of this._def.checks) {
                if (ch.kind === "max") {
                    if (max === null || ch.value < max)
                        max = ch.value;
                }
            }
            return max != null ? new Date(max) : null;
        }
    }
    ZodDate.create = (params) => {
        return new ZodDate({
            checks: [],
            coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
            typeName: ZodFirstPartyTypeKind.ZodDate,
            ...processCreateParams(params),
        });
    };
    class ZodSymbol extends ZodType {
        _parse(input) {
            const parsedType = this._getType(input);
            if (parsedType !== ZodParsedType.symbol) {
                const ctx = this._getOrReturnCtx(input);
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_type,
                    expected: ZodParsedType.symbol,
                    received: ctx.parsedType,
                });
                return INVALID;
            }
            return OK(input.data);
        }
    }
    ZodSymbol.create = (params) => {
        return new ZodSymbol({
            typeName: ZodFirstPartyTypeKind.ZodSymbol,
            ...processCreateParams(params),
        });
    };
    class ZodUndefined extends ZodType {
        _parse(input) {
            const parsedType = this._getType(input);
            if (parsedType !== ZodParsedType.undefined) {
                const ctx = this._getOrReturnCtx(input);
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_type,
                    expected: ZodParsedType.undefined,
                    received: ctx.parsedType,
                });
                return INVALID;
            }
            return OK(input.data);
        }
    }
    ZodUndefined.create = (params) => {
        return new ZodUndefined({
            typeName: ZodFirstPartyTypeKind.ZodUndefined,
            ...processCreateParams(params),
        });
    };
    class ZodNull extends ZodType {
        _parse(input) {
            const parsedType = this._getType(input);
            if (parsedType !== ZodParsedType.null) {
                const ctx = this._getOrReturnCtx(input);
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_type,
                    expected: ZodParsedType.null,
                    received: ctx.parsedType,
                });
                return INVALID;
            }
            return OK(input.data);
        }
    }
    ZodNull.create = (params) => {
        return new ZodNull({
            typeName: ZodFirstPartyTypeKind.ZodNull,
            ...processCreateParams(params),
        });
    };
    class ZodAny extends ZodType {
        constructor() {
            super(...arguments);
            // to prevent instances of other classes from extending ZodAny. this causes issues with catchall in ZodObject.
            this._any = true;
        }
        _parse(input) {
            return OK(input.data);
        }
    }
    ZodAny.create = (params) => {
        return new ZodAny({
            typeName: ZodFirstPartyTypeKind.ZodAny,
            ...processCreateParams(params),
        });
    };
    class ZodUnknown extends ZodType {
        constructor() {
            super(...arguments);
            // required
            this._unknown = true;
        }
        _parse(input) {
            return OK(input.data);
        }
    }
    ZodUnknown.create = (params) => {
        return new ZodUnknown({
            typeName: ZodFirstPartyTypeKind.ZodUnknown,
            ...processCreateParams(params),
        });
    };
    class ZodNever extends ZodType {
        _parse(input) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.never,
                received: ctx.parsedType,
            });
            return INVALID;
        }
    }
    ZodNever.create = (params) => {
        return new ZodNever({
            typeName: ZodFirstPartyTypeKind.ZodNever,
            ...processCreateParams(params),
        });
    };
    class ZodVoid extends ZodType {
        _parse(input) {
            const parsedType = this._getType(input);
            if (parsedType !== ZodParsedType.undefined) {
                const ctx = this._getOrReturnCtx(input);
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_type,
                    expected: ZodParsedType.void,
                    received: ctx.parsedType,
                });
                return INVALID;
            }
            return OK(input.data);
        }
    }
    ZodVoid.create = (params) => {
        return new ZodVoid({
            typeName: ZodFirstPartyTypeKind.ZodVoid,
            ...processCreateParams(params),
        });
    };
    class ZodArray extends ZodType {
        _parse(input) {
            const { ctx, status } = this._processInputParams(input);
            const def = this._def;
            if (ctx.parsedType !== ZodParsedType.array) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_type,
                    expected: ZodParsedType.array,
                    received: ctx.parsedType,
                });
                return INVALID;
            }
            if (def.exactLength !== null) {
                const tooBig = ctx.data.length > def.exactLength.value;
                const tooSmall = ctx.data.length < def.exactLength.value;
                if (tooBig || tooSmall) {
                    addIssueToContext(ctx, {
                        code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
                        minimum: (tooSmall ? def.exactLength.value : undefined),
                        maximum: (tooBig ? def.exactLength.value : undefined),
                        type: "array",
                        inclusive: true,
                        exact: true,
                        message: def.exactLength.message,
                    });
                    status.dirty();
                }
            }
            if (def.minLength !== null) {
                if (ctx.data.length < def.minLength.value) {
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_small,
                        minimum: def.minLength.value,
                        type: "array",
                        inclusive: true,
                        exact: false,
                        message: def.minLength.message,
                    });
                    status.dirty();
                }
            }
            if (def.maxLength !== null) {
                if (ctx.data.length > def.maxLength.value) {
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_big,
                        maximum: def.maxLength.value,
                        type: "array",
                        inclusive: true,
                        exact: false,
                        message: def.maxLength.message,
                    });
                    status.dirty();
                }
            }
            if (ctx.common.async) {
                return Promise.all([...ctx.data].map((item, i) => {
                    return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
                })).then((result) => {
                    return ParseStatus.mergeArray(status, result);
                });
            }
            const result = [...ctx.data].map((item, i) => {
                return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
            });
            return ParseStatus.mergeArray(status, result);
        }
        get element() {
            return this._def.type;
        }
        min(minLength, message) {
            return new ZodArray({
                ...this._def,
                minLength: { value: minLength, message: errorUtil.toString(message) },
            });
        }
        max(maxLength, message) {
            return new ZodArray({
                ...this._def,
                maxLength: { value: maxLength, message: errorUtil.toString(message) },
            });
        }
        length(len, message) {
            return new ZodArray({
                ...this._def,
                exactLength: { value: len, message: errorUtil.toString(message) },
            });
        }
        nonempty(message) {
            return this.min(1, message);
        }
    }
    ZodArray.create = (schema, params) => {
        return new ZodArray({
            type: schema,
            minLength: null,
            maxLength: null,
            exactLength: null,
            typeName: ZodFirstPartyTypeKind.ZodArray,
            ...processCreateParams(params),
        });
    };
    function deepPartialify(schema) {
        if (schema instanceof ZodObject) {
            const newShape = {};
            for (const key in schema.shape) {
                const fieldSchema = schema.shape[key];
                newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
            }
            return new ZodObject({
                ...schema._def,
                shape: () => newShape,
            });
        }
        else if (schema instanceof ZodArray) {
            return new ZodArray({
                ...schema._def,
                type: deepPartialify(schema.element),
            });
        }
        else if (schema instanceof ZodOptional) {
            return ZodOptional.create(deepPartialify(schema.unwrap()));
        }
        else if (schema instanceof ZodNullable) {
            return ZodNullable.create(deepPartialify(schema.unwrap()));
        }
        else if (schema instanceof ZodTuple) {
            return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
        }
        else {
            return schema;
        }
    }
    class ZodObject extends ZodType {
        constructor() {
            super(...arguments);
            this._cached = null;
            /**
             * @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.
             * If you want to pass through unknown properties, use `.passthrough()` instead.
             */
            this.nonstrict = this.passthrough;
            // extend<
            //   Augmentation extends ZodRawShape,
            //   NewOutput extends util.flatten<{
            //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
            //       ? Augmentation[k]["_output"]
            //       : k extends keyof Output
            //       ? Output[k]
            //       : never;
            //   }>,
            //   NewInput extends util.flatten<{
            //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
            //       ? Augmentation[k]["_input"]
            //       : k extends keyof Input
            //       ? Input[k]
            //       : never;
            //   }>
            // >(
            //   augmentation: Augmentation
            // ): ZodObject<
            //   extendShape<T, Augmentation>,
            //   UnknownKeys,
            //   Catchall,
            //   NewOutput,
            //   NewInput
            // > {
            //   return new ZodObject({
            //     ...this._def,
            //     shape: () => ({
            //       ...this._def.shape(),
            //       ...augmentation,
            //     }),
            //   }) as any;
            // }
            /**
             * @deprecated Use `.extend` instead
             *  */
            this.augment = this.extend;
        }
        _getCached() {
            if (this._cached !== null)
                return this._cached;
            const shape = this._def.shape();
            const keys = util$4.objectKeys(shape);
            return (this._cached = { shape, keys });
        }
        _parse(input) {
            const parsedType = this._getType(input);
            if (parsedType !== ZodParsedType.object) {
                const ctx = this._getOrReturnCtx(input);
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_type,
                    expected: ZodParsedType.object,
                    received: ctx.parsedType,
                });
                return INVALID;
            }
            const { status, ctx } = this._processInputParams(input);
            const { shape, keys: shapeKeys } = this._getCached();
            const extraKeys = [];
            if (!(this._def.catchall instanceof ZodNever &&
                this._def.unknownKeys === "strip")) {
                for (const key in ctx.data) {
                    if (!shapeKeys.includes(key)) {
                        extraKeys.push(key);
                    }
                }
            }
            const pairs = [];
            for (const key of shapeKeys) {
                const keyValidator = shape[key];
                const value = ctx.data[key];
                pairs.push({
                    key: { status: "valid", value: key },
                    value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
                    alwaysSet: key in ctx.data,
                });
            }
            if (this._def.catchall instanceof ZodNever) {
                const unknownKeys = this._def.unknownKeys;
                if (unknownKeys === "passthrough") {
                    for (const key of extraKeys) {
                        pairs.push({
                            key: { status: "valid", value: key },
                            value: { status: "valid", value: ctx.data[key] },
                        });
                    }
                }
                else if (unknownKeys === "strict") {
                    if (extraKeys.length > 0) {
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.unrecognized_keys,
                            keys: extraKeys,
                        });
                        status.dirty();
                    }
                }
                else if (unknownKeys === "strip") ;
                else {
                    throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
                }
            }
            else {
                // run catchall validation
                const catchall = this._def.catchall;
                for (const key of extraKeys) {
                    const value = ctx.data[key];
                    pairs.push({
                        key: { status: "valid", value: key },
                        value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key) //, ctx.child(key), value, getParsedType(value)
                        ),
                        alwaysSet: key in ctx.data,
                    });
                }
            }
            if (ctx.common.async) {
                return Promise.resolve()
                    .then(async () => {
                    const syncPairs = [];
                    for (const pair of pairs) {
                        const key = await pair.key;
                        syncPairs.push({
                            key,
                            value: await pair.value,
                            alwaysSet: pair.alwaysSet,
                        });
                    }
                    return syncPairs;
                })
                    .then((syncPairs) => {
                    return ParseStatus.mergeObjectSync(status, syncPairs);
                });
            }
            else {
                return ParseStatus.mergeObjectSync(status, pairs);
            }
        }
        get shape() {
            return this._def.shape();
        }
        strict(message) {
            errorUtil.errToObj;
            return new ZodObject({
                ...this._def,
                unknownKeys: "strict",
                ...(message !== undefined
                    ? {
                        errorMap: (issue, ctx) => {
                            var _a, _b, _c, _d;
                            const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
                            if (issue.code === "unrecognized_keys")
                                return {
                                    message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError,
                                };
                            return {
                                message: defaultError,
                            };
                        },
                    }
                    : {}),
            });
        }
        strip() {
            return new ZodObject({
                ...this._def,
                unknownKeys: "strip",
            });
        }
        passthrough() {
            return new ZodObject({
                ...this._def,
                unknownKeys: "passthrough",
            });
        }
        // const AugmentFactory =
        //   <Def extends ZodObjectDef>(def: Def) =>
        //   <Augmentation extends ZodRawShape>(
        //     augmentation: Augmentation
        //   ): ZodObject<
        //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
        //     Def["unknownKeys"],
        //     Def["catchall"]
        //   > => {
        //     return new ZodObject({
        //       ...def,
        //       shape: () => ({
        //         ...def.shape(),
        //         ...augmentation,
        //       }),
        //     }) as any;
        //   };
        extend(augmentation) {
            return new ZodObject({
                ...this._def,
                shape: () => ({
                    ...this._def.shape(),
                    ...augmentation,
                }),
            });
        }
        /**
         * Prior to zod@1.0.12 there was a bug in the
         * inferred type of merged objects. Please
         * upgrade if you are experiencing issues.
         */
        merge(merging) {
            const merged = new ZodObject({
                unknownKeys: merging._def.unknownKeys,
                catchall: merging._def.catchall,
                shape: () => ({
                    ...this._def.shape(),
                    ...merging._def.shape(),
                }),
                typeName: ZodFirstPartyTypeKind.ZodObject,
            });
            return merged;
        }
        // merge<
        //   Incoming extends AnyZodObject,
        //   Augmentation extends Incoming["shape"],
        //   NewOutput extends {
        //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
        //       ? Augmentation[k]["_output"]
        //       : k extends keyof Output
        //       ? Output[k]
        //       : never;
        //   },
        //   NewInput extends {
        //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
        //       ? Augmentation[k]["_input"]
        //       : k extends keyof Input
        //       ? Input[k]
        //       : never;
        //   }
        // >(
        //   merging: Incoming
        // ): ZodObject<
        //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
        //   Incoming["_def"]["unknownKeys"],
        //   Incoming["_def"]["catchall"],
        //   NewOutput,
        //   NewInput
        // > {
        //   const merged: any = new ZodObject({
        //     unknownKeys: merging._def.unknownKeys,
        //     catchall: merging._def.catchall,
        //     shape: () =>
        //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
        //     typeName: ZodFirstPartyTypeKind.ZodObject,
        //   }) as any;
        //   return merged;
        // }
        setKey(key, schema) {
            return this.augment({ [key]: schema });
        }
        // merge<Incoming extends AnyZodObject>(
        //   merging: Incoming
        // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
        // ZodObject<
        //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
        //   Incoming["_def"]["unknownKeys"],
        //   Incoming["_def"]["catchall"]
        // > {
        //   // const mergedShape = objectUtil.mergeShapes(
        //   //   this._def.shape(),
        //   //   merging._def.shape()
        //   // );
        //   const merged: any = new ZodObject({
        //     unknownKeys: merging._def.unknownKeys,
        //     catchall: merging._def.catchall,
        //     shape: () =>
        //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
        //     typeName: ZodFirstPartyTypeKind.ZodObject,
        //   }) as any;
        //   return merged;
        // }
        catchall(index) {
            return new ZodObject({
                ...this._def,
                catchall: index,
            });
        }
        pick(mask) {
            const shape = {};
            util$4.objectKeys(mask).forEach((key) => {
                if (mask[key] && this.shape[key]) {
                    shape[key] = this.shape[key];
                }
            });
            return new ZodObject({
                ...this._def,
                shape: () => shape,
            });
        }
        omit(mask) {
            const shape = {};
            util$4.objectKeys(this.shape).forEach((key) => {
                if (!mask[key]) {
                    shape[key] = this.shape[key];
                }
            });
            return new ZodObject({
                ...this._def,
                shape: () => shape,
            });
        }
        /**
         * @deprecated
         */
        deepPartial() {
            return deepPartialify(this);
        }
        partial(mask) {
            const newShape = {};
            util$4.objectKeys(this.shape).forEach((key) => {
                const fieldSchema = this.shape[key];
                if (mask && !mask[key]) {
                    newShape[key] = fieldSchema;
                }
                else {
                    newShape[key] = fieldSchema.optional();
                }
            });
            return new ZodObject({
                ...this._def,
                shape: () => newShape,
            });
        }
        required(mask) {
            const newShape = {};
            util$4.objectKeys(this.shape).forEach((key) => {
                if (mask && !mask[key]) {
                    newShape[key] = this.shape[key];
                }
                else {
                    const fieldSchema = this.shape[key];
                    let newField = fieldSchema;
                    while (newField instanceof ZodOptional) {
                        newField = newField._def.innerType;
                    }
                    newShape[key] = newField;
                }
            });
            return new ZodObject({
                ...this._def,
                shape: () => newShape,
            });
        }
        keyof() {
            return createZodEnum(util$4.objectKeys(this.shape));
        }
    }
    ZodObject.create = (shape, params) => {
        return new ZodObject({
            shape: () => shape,
            unknownKeys: "strip",
            catchall: ZodNever.create(),
            typeName: ZodFirstPartyTypeKind.ZodObject,
            ...processCreateParams(params),
        });
    };
    ZodObject.strictCreate = (shape, params) => {
        return new ZodObject({
            shape: () => shape,
            unknownKeys: "strict",
            catchall: ZodNever.create(),
            typeName: ZodFirstPartyTypeKind.ZodObject,
            ...processCreateParams(params),
        });
    };
    ZodObject.lazycreate = (shape, params) => {
        return new ZodObject({
            shape,
            unknownKeys: "strip",
            catchall: ZodNever.create(),
            typeName: ZodFirstPartyTypeKind.ZodObject,
            ...processCreateParams(params),
        });
    };
    class ZodUnion extends ZodType {
        _parse(input) {
            const { ctx } = this._processInputParams(input);
            const options = this._def.options;
            function handleResults(results) {
                // return first issue-free validation if it exists
                for (const result of results) {
                    if (result.result.status === "valid") {
                        return result.result;
                    }
                }
                for (const result of results) {
                    if (result.result.status === "dirty") {
                        // add issues from dirty option
                        ctx.common.issues.push(...result.ctx.common.issues);
                        return result.result;
                    }
                }
                // return invalid
                const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_union,
                    unionErrors,
                });
                return INVALID;
            }
            if (ctx.common.async) {
                return Promise.all(options.map(async (option) => {
                    const childCtx = {
                        ...ctx,
                        common: {
                            ...ctx.common,
                            issues: [],
                        },
                        parent: null,
                    };
                    return {
                        result: await option._parseAsync({
                            data: ctx.data,
                            path: ctx.path,
                            parent: childCtx,
                        }),
                        ctx: childCtx,
                    };
                })).then(handleResults);
            }
            else {
                let dirty = undefined;
                const issues = [];
                for (const option of options) {
                    const childCtx = {
                        ...ctx,
                        common: {
                            ...ctx.common,
                            issues: [],
                        },
                        parent: null,
                    };
                    const result = option._parseSync({
                        data: ctx.data,
                        path: ctx.path,
                        parent: childCtx,
                    });
                    if (result.status === "valid") {
                        return result;
                    }
                    else if (result.status === "dirty" && !dirty) {
                        dirty = { result, ctx: childCtx };
                    }
                    if (childCtx.common.issues.length) {
                        issues.push(childCtx.common.issues);
                    }
                }
                if (dirty) {
                    ctx.common.issues.push(...dirty.ctx.common.issues);
                    return dirty.result;
                }
                const unionErrors = issues.map((issues) => new ZodError(issues));
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_union,
                    unionErrors,
                });
                return INVALID;
            }
        }
        get options() {
            return this._def.options;
        }
    }
    ZodUnion.create = (types, params) => {
        return new ZodUnion({
            options: types,
            typeName: ZodFirstPartyTypeKind.ZodUnion,
            ...processCreateParams(params),
        });
    };
    /////////////////////////////////////////////////////
    /////////////////////////////////////////////////////
    //////////                                 //////////
    //////////      ZodDiscriminatedUnion      //////////
    //////////                                 //////////
    /////////////////////////////////////////////////////
    /////////////////////////////////////////////////////
    const getDiscriminator = (type) => {
        if (type instanceof ZodLazy) {
            return getDiscriminator(type.schema);
        }
        else if (type instanceof ZodEffects) {
            return getDiscriminator(type.innerType());
        }
        else if (type instanceof ZodLiteral) {
            return [type.value];
        }
        else if (type instanceof ZodEnum) {
            return type.options;
        }
        else if (type instanceof ZodNativeEnum) {
            // eslint-disable-next-line ban/ban
            return Object.keys(type.enum);
        }
        else if (type instanceof ZodDefault) {
            return getDiscriminator(type._def.innerType);
        }
        else if (type instanceof ZodUndefined) {
            return [undefined];
        }
        else if (type instanceof ZodNull) {
            return [null];
        }
        else {
            return null;
        }
    };
    class ZodDiscriminatedUnion extends ZodType {
        _parse(input) {
            const { ctx } = this._processInputParams(input);
            if (ctx.parsedType !== ZodParsedType.object) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_type,
                    expected: ZodParsedType.object,
                    received: ctx.parsedType,
                });
                return INVALID;
            }
            const discriminator = this.discriminator;
            const discriminatorValue = ctx.data[discriminator];
            const option = this.optionsMap.get(discriminatorValue);
            if (!option) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_union_discriminator,
                    options: Array.from(this.optionsMap.keys()),
                    path: [discriminator],
                });
                return INVALID;
            }
            if (ctx.common.async) {
                return option._parseAsync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                });
            }
            else {
                return option._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                });
            }
        }
        get discriminator() {
            return this._def.discriminator;
        }
        get options() {
            return this._def.options;
        }
        get optionsMap() {
            return this._def.optionsMap;
        }
        /**
         * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
         * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
         * have a different value for each object in the union.
         * @param discriminator the name of the discriminator property
         * @param types an array of object schemas
         * @param params
         */
        static create(discriminator, options, params) {
            // Get all the valid discriminator values
            const optionsMap = new Map();
            // try {
            for (const type of options) {
                const discriminatorValues = getDiscriminator(type.shape[discriminator]);
                if (!discriminatorValues) {
                    throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
                }
                for (const value of discriminatorValues) {
                    if (optionsMap.has(value)) {
                        throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
                    }
                    optionsMap.set(value, type);
                }
            }
            return new ZodDiscriminatedUnion({
                typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
                discriminator,
                options,
                optionsMap,
                ...processCreateParams(params),
            });
        }
    }
    function mergeValues(a, b) {
        const aType = getParsedType(a);
        const bType = getParsedType(b);
        if (a === b) {
            return { valid: true, data: a };
        }
        else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
            const bKeys = util$4.objectKeys(b);
            const sharedKeys = util$4
                .objectKeys(a)
                .filter((key) => bKeys.indexOf(key) !== -1);
            const newObj = { ...a, ...b };
            for (const key of sharedKeys) {
                const sharedValue = mergeValues(a[key], b[key]);
                if (!sharedValue.valid) {
                    return { valid: false };
                }
                newObj[key] = sharedValue.data;
            }
            return { valid: true, data: newObj };
        }
        else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
            if (a.length !== b.length) {
                return { valid: false };
            }
            const newArray = [];
            for (let index = 0; index < a.length; index++) {
                const itemA = a[index];
                const itemB = b[index];
                const sharedValue = mergeValues(itemA, itemB);
                if (!sharedValue.valid) {
                    return { valid: false };
                }
                newArray.push(sharedValue.data);
            }
            return { valid: true, data: newArray };
        }
        else if (aType === ZodParsedType.date &&
            bType === ZodParsedType.date &&
            +a === +b) {
            return { valid: true, data: a };
        }
        else {
            return { valid: false };
        }
    }
    class ZodIntersection extends ZodType {
        _parse(input) {
            const { status, ctx } = this._processInputParams(input);
            const handleParsed = (parsedLeft, parsedRight) => {
                if (isAborted(parsedLeft) || isAborted(parsedRight)) {
                    return INVALID;
                }
                const merged = mergeValues(parsedLeft.value, parsedRight.value);
                if (!merged.valid) {
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_intersection_types,
                    });
                    return INVALID;
                }
                if (isDirty(parsedLeft) || isDirty(parsedRight)) {
                    status.dirty();
                }
                return { status: status.value, value: merged.data };
            };
            if (ctx.common.async) {
                return Promise.all([
                    this._def.left._parseAsync({
                        data: ctx.data,
                        path: ctx.path,
                        parent: ctx,
                    }),
                    this._def.right._parseAsync({
                        data: ctx.data,
                        path: ctx.path,
                        parent: ctx,
                    }),
                ]).then(([left, right]) => handleParsed(left, right));
            }
            else {
                return handleParsed(this._def.left._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                }), this._def.right._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                }));
            }
        }
    }
    ZodIntersection.create = (left, right, params) => {
        return new ZodIntersection({
            left: left,
            right: right,
            typeName: ZodFirstPartyTypeKind.ZodIntersection,
            ...processCreateParams(params),
        });
    };
    class ZodTuple extends ZodType {
        _parse(input) {
            const { status, ctx } = this._processInputParams(input);
            if (ctx.parsedType !== ZodParsedType.array) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_type,
                    expected: ZodParsedType.array,
                    received: ctx.parsedType,
                });
                return INVALID;
            }
            if (ctx.data.length < this._def.items.length) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.too_small,
                    minimum: this._def.items.length,
                    inclusive: true,
                    exact: false,
                    type: "array",
                });
                return INVALID;
            }
            const rest = this._def.rest;
            if (!rest && ctx.data.length > this._def.items.length) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.too_big,
                    maximum: this._def.items.length,
                    inclusive: true,
                    exact: false,
                    type: "array",
                });
                status.dirty();
            }
            const items = [...ctx.data]
                .map((item, itemIndex) => {
                const schema = this._def.items[itemIndex] || this._def.rest;
                if (!schema)
                    return null;
                return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
            })
                .filter((x) => !!x); // filter nulls
            if (ctx.common.async) {
                return Promise.all(items).then((results) => {
                    return ParseStatus.mergeArray(status, results);
                });
            }
            else {
                return ParseStatus.mergeArray(status, items);
            }
        }
        get items() {
            return this._def.items;
        }
        rest(rest) {
            return new ZodTuple({
                ...this._def,
                rest,
            });
        }
    }
    ZodTuple.create = (schemas, params) => {
        if (!Array.isArray(schemas)) {
            throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
        }
        return new ZodTuple({
            items: schemas,
            typeName: ZodFirstPartyTypeKind.ZodTuple,
            rest: null,
            ...processCreateParams(params),
        });
    };
    class ZodRecord extends ZodType {
        get keySchema() {
            return this._def.keyType;
        }
        get valueSchema() {
            return this._def.valueType;
        }
        _parse(input) {
            const { status, ctx } = this._processInputParams(input);
            if (ctx.parsedType !== ZodParsedType.object) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_type,
                    expected: ZodParsedType.object,
                    received: ctx.parsedType,
                });
                return INVALID;
            }
            const pairs = [];
            const keyType = this._def.keyType;
            const valueType = this._def.valueType;
            for (const key in ctx.data) {
                pairs.push({
                    key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
                    value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
                });
            }
            if (ctx.common.async) {
                return ParseStatus.mergeObjectAsync(status, pairs);
            }
            else {
                return ParseStatus.mergeObjectSync(status, pairs);
            }
        }
        get element() {
            return this._def.valueType;
        }
        static create(first, second, third) {
            if (second instanceof ZodType) {
                return new ZodRecord({
                    keyType: first,
                    valueType: second,
                    typeName: ZodFirstPartyTypeKind.ZodRecord,
                    ...processCreateParams(third),
                });
            }
            return new ZodRecord({
                keyType: ZodString.create(),
                valueType: first,
                typeName: ZodFirstPartyTypeKind.ZodRecord,
                ...processCreateParams(second),
            });
        }
    }
    class ZodMap extends ZodType {
        get keySchema() {
            return this._def.keyType;
        }
        get valueSchema() {
            return this._def.valueType;
        }
        _parse(input) {
            const { status, ctx } = this._processInputParams(input);
            if (ctx.parsedType !== ZodParsedType.map) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_type,
                    expected: ZodParsedType.map,
                    received: ctx.parsedType,
                });
                return INVALID;
            }
            const keyType = this._def.keyType;
            const valueType = this._def.valueType;
            const pairs = [...ctx.data.entries()].map(([key, value], index) => {
                return {
                    key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
                    value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"])),
                };
            });
            if (ctx.common.async) {
                const finalMap = new Map();
                return Promise.resolve().then(async () => {
                    for (const pair of pairs) {
                        const key = await pair.key;
                        const value = await pair.value;
                        if (key.status === "aborted" || value.status === "aborted") {
                            return INVALID;
                        }
                        if (key.status === "dirty" || value.status === "dirty") {
                            status.dirty();
                        }
                        finalMap.set(key.value, value.value);
                    }
                    return { status: status.value, value: finalMap };
                });
            }
            else {
                const finalMap = new Map();
                for (const pair of pairs) {
                    const key = pair.key;
                    const value = pair.value;
                    if (key.status === "aborted" || value.status === "aborted") {
                        return INVALID;
                    }
                    if (key.status === "dirty" || value.status === "dirty") {
                        status.dirty();
                    }
                    finalMap.set(key.value, value.value);
                }
                return { status: status.value, value: finalMap };
            }
        }
    }
    ZodMap.create = (keyType, valueType, params) => {
        return new ZodMap({
            valueType,
            keyType,
            typeName: ZodFirstPartyTypeKind.ZodMap,
            ...processCreateParams(params),
        });
    };
    class ZodSet extends ZodType {
        _parse(input) {
            const { status, ctx } = this._processInputParams(input);
            if (ctx.parsedType !== ZodParsedType.set) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_type,
                    expected: ZodParsedType.set,
                    received: ctx.parsedType,
                });
                return INVALID;
            }
            const def = this._def;
            if (def.minSize !== null) {
                if (ctx.data.size < def.minSize.value) {
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_small,
                        minimum: def.minSize.value,
                        type: "set",
                        inclusive: true,
                        exact: false,
                        message: def.minSize.message,
                    });
                    status.dirty();
                }
            }
            if (def.maxSize !== null) {
                if (ctx.data.size > def.maxSize.value) {
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_big,
                        maximum: def.maxSize.value,
                        type: "set",
                        inclusive: true,
                        exact: false,
                        message: def.maxSize.message,
                    });
                    status.dirty();
                }
            }
            const valueType = this._def.valueType;
            function finalizeSet(elements) {
                const parsedSet = new Set();
                for (const element of elements) {
                    if (element.status === "aborted")
                        return INVALID;
                    if (element.status === "dirty")
                        status.dirty();
                    parsedSet.add(element.value);
                }
                return { status: status.value, value: parsedSet };
            }
            const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
            if (ctx.common.async) {
                return Promise.all(elements).then((elements) => finalizeSet(elements));
            }
            else {
                return finalizeSet(elements);
            }
        }
        min(minSize, message) {
            return new ZodSet({
                ...this._def,
                minSize: { value: minSize, message: errorUtil.toString(message) },
            });
        }
        max(maxSize, message) {
            return new ZodSet({
                ...this._def,
                maxSize: { value: maxSize, message: errorUtil.toString(message) },
            });
        }
        size(size, message) {
            return this.min(size, message).max(size, message);
        }
        nonempty(message) {
            return this.min(1, message);
        }
    }
    ZodSet.create = (valueType, params) => {
        return new ZodSet({
            valueType,
            minSize: null,
            maxSize: null,
            typeName: ZodFirstPartyTypeKind.ZodSet,
            ...processCreateParams(params),
        });
    };
    class ZodFunction extends ZodType {
        constructor() {
            super(...arguments);
            this.validate = this.implement;
        }
        _parse(input) {
            const { ctx } = this._processInputParams(input);
            if (ctx.parsedType !== ZodParsedType.function) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_type,
                    expected: ZodParsedType.function,
                    received: ctx.parsedType,
                });
                return INVALID;
            }
            function makeArgsIssue(args, error) {
                return makeIssue({
                    data: args,
                    path: ctx.path,
                    errorMaps: [
                        ctx.common.contextualErrorMap,
                        ctx.schemaErrorMap,
                        getErrorMap(),
                        errorMap,
                    ].filter((x) => !!x),
                    issueData: {
                        code: ZodIssueCode.invalid_arguments,
                        argumentsError: error,
                    },
                });
            }
            function makeReturnsIssue(returns, error) {
                return makeIssue({
                    data: returns,
                    path: ctx.path,
                    errorMaps: [
                        ctx.common.contextualErrorMap,
                        ctx.schemaErrorMap,
                        getErrorMap(),
                        errorMap,
                    ].filter((x) => !!x),
                    issueData: {
                        code: ZodIssueCode.invalid_return_type,
                        returnTypeError: error,
                    },
                });
            }
            const params = { errorMap: ctx.common.contextualErrorMap };
            const fn = ctx.data;
            if (this._def.returns instanceof ZodPromise) {
                // Would love a way to avoid disabling this rule, but we need
                // an alias (using an arrow function was what caused 2651).
                // eslint-disable-next-line @typescript-eslint/no-this-alias
                const me = this;
                return OK(async function (...args) {
                    const error = new ZodError([]);
                    const parsedArgs = await me._def.args
                        .parseAsync(args, params)
                        .catch((e) => {
                        error.addIssue(makeArgsIssue(args, e));
                        throw error;
                    });
                    const result = await Reflect.apply(fn, this, parsedArgs);
                    const parsedReturns = await me._def.returns._def.type
                        .parseAsync(result, params)
                        .catch((e) => {
                        error.addIssue(makeReturnsIssue(result, e));
                        throw error;
                    });
                    return parsedReturns;
                });
            }
            else {
                // Would love a way to avoid disabling this rule, but we need
                // an alias (using an arrow function was what caused 2651).
                // eslint-disable-next-line @typescript-eslint/no-this-alias
                const me = this;
                return OK(function (...args) {
                    const parsedArgs = me._def.args.safeParse(args, params);
                    if (!parsedArgs.success) {
                        throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
                    }
                    const result = Reflect.apply(fn, this, parsedArgs.data);
                    const parsedReturns = me._def.returns.safeParse(result, params);
                    if (!parsedReturns.success) {
                        throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
                    }
                    return parsedReturns.data;
                });
            }
        }
        parameters() {
            return this._def.args;
        }
        returnType() {
            return this._def.returns;
        }
        args(...items) {
            return new ZodFunction({
                ...this._def,
                args: ZodTuple.create(items).rest(ZodUnknown.create()),
            });
        }
        returns(returnType) {
            return new ZodFunction({
                ...this._def,
                returns: returnType,
            });
        }
        implement(func) {
            const validatedFunc = this.parse(func);
            return validatedFunc;
        }
        strictImplement(func) {
            const validatedFunc = this.parse(func);
            return validatedFunc;
        }
        static create(args, returns, params) {
            return new ZodFunction({
                args: (args
                    ? args
                    : ZodTuple.create([]).rest(ZodUnknown.create())),
                returns: returns || ZodUnknown.create(),
                typeName: ZodFirstPartyTypeKind.ZodFunction,
                ...processCreateParams(params),
            });
        }
    }
    class ZodLazy extends ZodType {
        get schema() {
            return this._def.getter();
        }
        _parse(input) {
            const { ctx } = this._processInputParams(input);
            const lazySchema = this._def.getter();
            return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
        }
    }
    ZodLazy.create = (getter, params) => {
        return new ZodLazy({
            getter: getter,
            typeName: ZodFirstPartyTypeKind.ZodLazy,
            ...processCreateParams(params),
        });
    };
    class ZodLiteral extends ZodType {
        _parse(input) {
            if (input.data !== this._def.value) {
                const ctx = this._getOrReturnCtx(input);
                addIssueToContext(ctx, {
                    received: ctx.data,
                    code: ZodIssueCode.invalid_literal,
                    expected: this._def.value,
                });
                return INVALID;
            }
            return { status: "valid", value: input.data };
        }
        get value() {
            return this._def.value;
        }
    }
    ZodLiteral.create = (value, params) => {
        return new ZodLiteral({
            value: value,
            typeName: ZodFirstPartyTypeKind.ZodLiteral,
            ...processCreateParams(params),
        });
    };
    function createZodEnum(values, params) {
        return new ZodEnum({
            values,
            typeName: ZodFirstPartyTypeKind.ZodEnum,
            ...processCreateParams(params),
        });
    }
    class ZodEnum extends ZodType {
        _parse(input) {
            if (typeof input.data !== "string") {
                const ctx = this._getOrReturnCtx(input);
                const expectedValues = this._def.values;
                addIssueToContext(ctx, {
                    expected: util$4.joinValues(expectedValues),
                    received: ctx.parsedType,
                    code: ZodIssueCode.invalid_type,
                });
                return INVALID;
            }
            if (this._def.values.indexOf(input.data) === -1) {
                const ctx = this._getOrReturnCtx(input);
                const expectedValues = this._def.values;
                addIssueToContext(ctx, {
                    received: ctx.data,
                    code: ZodIssueCode.invalid_enum_value,
                    options: expectedValues,
                });
                return INVALID;
            }
            return OK(input.data);
        }
        get options() {
            return this._def.values;
        }
        get enum() {
            const enumValues = {};
            for (const val of this._def.values) {
                enumValues[val] = val;
            }
            return enumValues;
        }
        get Values() {
            const enumValues = {};
            for (const val of this._def.values) {
                enumValues[val] = val;
            }
            return enumValues;
        }
        get Enum() {
            const enumValues = {};
            for (const val of this._def.values) {
                enumValues[val] = val;
            }
            return enumValues;
        }
        extract(values) {
            return ZodEnum.create(values);
        }
        exclude(values) {
            return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)));
        }
    }
    ZodEnum.create = createZodEnum;
    class ZodNativeEnum extends ZodType {
        _parse(input) {
            const nativeEnumValues = util$4.getValidEnumValues(this._def.values);
            const ctx = this._getOrReturnCtx(input);
            if (ctx.parsedType !== ZodParsedType.string &&
                ctx.parsedType !== ZodParsedType.number) {
                const expectedValues = util$4.objectValues(nativeEnumValues);
                addIssueToContext(ctx, {
                    expected: util$4.joinValues(expectedValues),
                    received: ctx.parsedType,
                    code: ZodIssueCode.invalid_type,
                });
                return INVALID;
            }
            if (nativeEnumValues.indexOf(input.data) === -1) {
                const expectedValues = util$4.objectValues(nativeEnumValues);
                addIssueToContext(ctx, {
                    received: ctx.data,
                    code: ZodIssueCode.invalid_enum_value,
                    options: expectedValues,
                });
                return INVALID;
            }
            return OK(input.data);
        }
        get enum() {
            return this._def.values;
        }
    }
    ZodNativeEnum.create = (values, params) => {
        return new ZodNativeEnum({
            values: values,
            typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
            ...processCreateParams(params),
        });
    };
    class ZodPromise extends ZodType {
        unwrap() {
            return this._def.type;
        }
        _parse(input) {
            const { ctx } = this._processInputParams(input);
            if (ctx.parsedType !== ZodParsedType.promise &&
                ctx.common.async === false) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_type,
                    expected: ZodParsedType.promise,
                    received: ctx.parsedType,
                });
                return INVALID;
            }
            const promisified = ctx.parsedType === ZodParsedType.promise
                ? ctx.data
                : Promise.resolve(ctx.data);
            return OK(promisified.then((data) => {
                return this._def.type.parseAsync(data, {
                    path: ctx.path,
                    errorMap: ctx.common.contextualErrorMap,
                });
            }));
        }
    }
    ZodPromise.create = (schema, params) => {
        return new ZodPromise({
            type: schema,
            typeName: ZodFirstPartyTypeKind.ZodPromise,
            ...processCreateParams(params),
        });
    };
    class ZodEffects extends ZodType {
        innerType() {
            return this._def.schema;
        }
        sourceType() {
            return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects
                ? this._def.schema.sourceType()
                : this._def.schema;
        }
        _parse(input) {
            const { status, ctx } = this._processInputParams(input);
            const effect = this._def.effect || null;
            const checkCtx = {
                addIssue: (arg) => {
                    addIssueToContext(ctx, arg);
                    if (arg.fatal) {
                        status.abort();
                    }
                    else {
                        status.dirty();
                    }
                },
                get path() {
                    return ctx.path;
                },
            };
            checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
            if (effect.type === "preprocess") {
                const processed = effect.transform(ctx.data, checkCtx);
                if (ctx.common.issues.length) {
                    return {
                        status: "dirty",
                        value: ctx.data,
                    };
                }
                if (ctx.common.async) {
                    return Promise.resolve(processed).then((processed) => {
                        return this._def.schema._parseAsync({
                            data: processed,
                            path: ctx.path,
                            parent: ctx,
                        });
                    });
                }
                else {
                    return this._def.schema._parseSync({
                        data: processed,
                        path: ctx.path,
                        parent: ctx,
                    });
                }
            }
            if (effect.type === "refinement") {
                const executeRefinement = (acc
                // effect: RefinementEffect<any>
                ) => {
                    const result = effect.refinement(acc, checkCtx);
                    if (ctx.common.async) {
                        return Promise.resolve(result);
                    }
                    if (result instanceof Promise) {
                        throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
                    }
                    return acc;
                };
                if (ctx.common.async === false) {
                    const inner = this._def.schema._parseSync({
                        data: ctx.data,
                        path: ctx.path,
                        parent: ctx,
                    });
                    if (inner.status === "aborted")
                        return INVALID;
                    if (inner.status === "dirty")
                        status.dirty();
                    // return value is ignored
                    executeRefinement(inner.value);
                    return { status: status.value, value: inner.value };
                }
                else {
                    return this._def.schema
                        ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })
                        .then((inner) => {
                        if (inner.status === "aborted")
                            return INVALID;
                        if (inner.status === "dirty")
                            status.dirty();
                        return executeRefinement(inner.value).then(() => {
                            return { status: status.value, value: inner.value };
                        });
                    });
                }
            }
            if (effect.type === "transform") {
                if (ctx.common.async === false) {
                    const base = this._def.schema._parseSync({
                        data: ctx.data,
                        path: ctx.path,
                        parent: ctx,
                    });
                    if (!isValid(base))
                        return base;
                    const result = effect.transform(base.value, checkCtx);
                    if (result instanceof Promise) {
                        throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
                    }
                    return { status: status.value, value: result };
                }
                else {
                    return this._def.schema
                        ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })
                        .then((base) => {
                        if (!isValid(base))
                            return base;
                        return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
                    });
                }
            }
            util$4.assertNever(effect);
        }
    }
    ZodEffects.create = (schema, effect, params) => {
        return new ZodEffects({
            schema,
            typeName: ZodFirstPartyTypeKind.ZodEffects,
            effect,
            ...processCreateParams(params),
        });
    };
    ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
        return new ZodEffects({
            schema,
            effect: { type: "preprocess", transform: preprocess },
            typeName: ZodFirstPartyTypeKind.ZodEffects,
            ...processCreateParams(params),
        });
    };
    class ZodOptional extends ZodType {
        _parse(input) {
            const parsedType = this._getType(input);
            if (parsedType === ZodParsedType.undefined) {
                return OK(undefined);
            }
            return this._def.innerType._parse(input);
        }
        unwrap() {
            return this._def.innerType;
        }
    }
    ZodOptional.create = (type, params) => {
        return new ZodOptional({
            innerType: type,
            typeName: ZodFirstPartyTypeKind.ZodOptional,
            ...processCreateParams(params),
        });
    };
    class ZodNullable extends ZodType {
        _parse(input) {
            const parsedType = this._getType(input);
            if (parsedType === ZodParsedType.null) {
                return OK(null);
            }
            return this._def.innerType._parse(input);
        }
        unwrap() {
            return this._def.innerType;
        }
    }
    ZodNullable.create = (type, params) => {
        return new ZodNullable({
            innerType: type,
            typeName: ZodFirstPartyTypeKind.ZodNullable,
            ...processCreateParams(params),
        });
    };
    class ZodDefault extends ZodType {
        _parse(input) {
            const { ctx } = this._processInputParams(input);
            let data = ctx.data;
            if (ctx.parsedType === ZodParsedType.undefined) {
                data = this._def.defaultValue();
            }
            return this._def.innerType._parse({
                data,
                path: ctx.path,
                parent: ctx,
            });
        }
        removeDefault() {
            return this._def.innerType;
        }
    }
    ZodDefault.create = (type, params) => {
        return new ZodDefault({
            innerType: type,
            typeName: ZodFirstPartyTypeKind.ZodDefault,
            defaultValue: typeof params.default === "function"
                ? params.default
                : () => params.default,
            ...processCreateParams(params),
        });
    };
    class ZodCatch extends ZodType {
        _parse(input) {
            const { ctx } = this._processInputParams(input);
            // newCtx is used to not collect issues from inner types in ctx
            const newCtx = {
                ...ctx,
                common: {
                    ...ctx.common,
                    issues: [],
                },
            };
            const result = this._def.innerType._parse({
                data: newCtx.data,
                path: newCtx.path,
                parent: {
                    ...newCtx,
                },
            });
            if (isAsync(result)) {
                return result.then((result) => {
                    return {
                        status: "valid",
                        value: result.status === "valid"
                            ? result.value
                            : this._def.catchValue({
                                get error() {
                                    return new ZodError(newCtx.common.issues);
                                },
                                input: newCtx.data,
                            }),
                    };
                });
            }
            else {
                return {
                    status: "valid",
                    value: result.status === "valid"
                        ? result.value
                        : this._def.catchValue({
                            get error() {
                                return new ZodError(newCtx.common.issues);
                            },
                            input: newCtx.data,
                        }),
                };
            }
        }
        removeCatch() {
            return this._def.innerType;
        }
    }
    ZodCatch.create = (type, params) => {
        return new ZodCatch({
            innerType: type,
            typeName: ZodFirstPartyTypeKind.ZodCatch,
            catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
            ...processCreateParams(params),
        });
    };
    class ZodNaN extends ZodType {
        _parse(input) {
            const parsedType = this._getType(input);
            if (parsedType !== ZodParsedType.nan) {
                const ctx = this._getOrReturnCtx(input);
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_type,
                    expected: ZodParsedType.nan,
                    received: ctx.parsedType,
                });
                return INVALID;
            }
            return { status: "valid", value: input.data };
        }
    }
    ZodNaN.create = (params) => {
        return new ZodNaN({
            typeName: ZodFirstPartyTypeKind.ZodNaN,
            ...processCreateParams(params),
        });
    };
    const BRAND = Symbol("zod_brand");
    class ZodBranded extends ZodType {
        _parse(input) {
            const { ctx } = this._processInputParams(input);
            const data = ctx.data;
            return this._def.type._parse({
                data,
                path: ctx.path,
                parent: ctx,
            });
        }
        unwrap() {
            return this._def.type;
        }
    }
    class ZodPipeline extends ZodType {
        _parse(input) {
            const { status, ctx } = this._processInputParams(input);
            if (ctx.common.async) {
                const handleAsync = async () => {
                    const inResult = await this._def.in._parseAsync({
                        data: ctx.data,
                        path: ctx.path,
                        parent: ctx,
                    });
                    if (inResult.status === "aborted")
                        return INVALID;
                    if (inResult.status === "dirty") {
                        status.dirty();
                        return DIRTY(inResult.value);
                    }
                    else {
                        return this._def.out._parseAsync({
                            data: inResult.value,
                            path: ctx.path,
                            parent: ctx,
                        });
                    }
                };
                return handleAsync();
            }
            else {
                const inResult = this._def.in._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                });
                if (inResult.status === "aborted")
                    return INVALID;
                if (inResult.status === "dirty") {
                    status.dirty();
                    return {
                        status: "dirty",
                        value: inResult.value,
                    };
                }
                else {
                    return this._def.out._parseSync({
                        data: inResult.value,
                        path: ctx.path,
                        parent: ctx,
                    });
                }
            }
        }
        static create(a, b) {
            return new ZodPipeline({
                in: a,
                out: b,
                typeName: ZodFirstPartyTypeKind.ZodPipeline,
            });
        }
    }
    class ZodReadonly extends ZodType {
        _parse(input) {
            const result = this._def.innerType._parse(input);
            if (isValid(result)) {
                result.value = Object.freeze(result.value);
            }
            return result;
        }
    }
    ZodReadonly.create = (type, params) => {
        return new ZodReadonly({
            innerType: type,
            typeName: ZodFirstPartyTypeKind.ZodReadonly,
            ...processCreateParams(params),
        });
    };
    const custom = (check, params = {}, 
    /**
     * @deprecated
     *
     * Pass `fatal` into the params object instead:
     *
     * ```ts
     * z.string().custom((val) => val.length > 5, { fatal: false })
     * ```
     *
     */
    fatal) => {
        if (check)
            return ZodAny.create().superRefine((data, ctx) => {
                var _a, _b;
                if (!check(data)) {
                    const p = typeof params === "function"
                        ? params(data)
                        : typeof params === "string"
                            ? { message: params }
                            : params;
                    const _fatal = (_b = (_a = p.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
                    const p2 = typeof p === "string" ? { message: p } : p;
                    ctx.addIssue({ code: "custom", ...p2, fatal: _fatal });
                }
            });
        return ZodAny.create();
    };
    const late = {
        object: ZodObject.lazycreate,
    };
    var ZodFirstPartyTypeKind;
    (function (ZodFirstPartyTypeKind) {
        ZodFirstPartyTypeKind["ZodString"] = "ZodString";
        ZodFirstPartyTypeKind["ZodNumber"] = "ZodNumber";
        ZodFirstPartyTypeKind["ZodNaN"] = "ZodNaN";
        ZodFirstPartyTypeKind["ZodBigInt"] = "ZodBigInt";
        ZodFirstPartyTypeKind["ZodBoolean"] = "ZodBoolean";
        ZodFirstPartyTypeKind["ZodDate"] = "ZodDate";
        ZodFirstPartyTypeKind["ZodSymbol"] = "ZodSymbol";
        ZodFirstPartyTypeKind["ZodUndefined"] = "ZodUndefined";
        ZodFirstPartyTypeKind["ZodNull"] = "ZodNull";
        ZodFirstPartyTypeKind["ZodAny"] = "ZodAny";
        ZodFirstPartyTypeKind["ZodUnknown"] = "ZodUnknown";
        ZodFirstPartyTypeKind["ZodNever"] = "ZodNever";
        ZodFirstPartyTypeKind["ZodVoid"] = "ZodVoid";
        ZodFirstPartyTypeKind["ZodArray"] = "ZodArray";
        ZodFirstPartyTypeKind["ZodObject"] = "ZodObject";
        ZodFirstPartyTypeKind["ZodUnion"] = "ZodUnion";
        ZodFirstPartyTypeKind["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
        ZodFirstPartyTypeKind["ZodIntersection"] = "ZodIntersection";
        ZodFirstPartyTypeKind["ZodTuple"] = "ZodTuple";
        ZodFirstPartyTypeKind["ZodRecord"] = "ZodRecord";
        ZodFirstPartyTypeKind["ZodMap"] = "ZodMap";
        ZodFirstPartyTypeKind["ZodSet"] = "ZodSet";
        ZodFirstPartyTypeKind["ZodFunction"] = "ZodFunction";
        ZodFirstPartyTypeKind["ZodLazy"] = "ZodLazy";
        ZodFirstPartyTypeKind["ZodLiteral"] = "ZodLiteral";
        ZodFirstPartyTypeKind["ZodEnum"] = "ZodEnum";
        ZodFirstPartyTypeKind["ZodEffects"] = "ZodEffects";
        ZodFirstPartyTypeKind["ZodNativeEnum"] = "ZodNativeEnum";
        ZodFirstPartyTypeKind["ZodOptional"] = "ZodOptional";
        ZodFirstPartyTypeKind["ZodNullable"] = "ZodNullable";
        ZodFirstPartyTypeKind["ZodDefault"] = "ZodDefault";
        ZodFirstPartyTypeKind["ZodCatch"] = "ZodCatch";
        ZodFirstPartyTypeKind["ZodPromise"] = "ZodPromise";
        ZodFirstPartyTypeKind["ZodBranded"] = "ZodBranded";
        ZodFirstPartyTypeKind["ZodPipeline"] = "ZodPipeline";
        ZodFirstPartyTypeKind["ZodReadonly"] = "ZodReadonly";
    })(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
    const instanceOfType = (
    // const instanceOfType = <T extends new (...args: any[]) => any>(
    cls, params = {
        message: `Input not instance of ${cls.name}`,
    }) => custom((data) => data instanceof cls, params);
    const stringType = ZodString.create;
    const numberType = ZodNumber.create;
    const nanType = ZodNaN.create;
    const bigIntType = ZodBigInt.create;
    const booleanType = ZodBoolean.create;
    const dateType = ZodDate.create;
    const symbolType = ZodSymbol.create;
    const undefinedType = ZodUndefined.create;
    const nullType = ZodNull.create;
    const anyType = ZodAny.create;
    const unknownType = ZodUnknown.create;
    const neverType = ZodNever.create;
    const voidType = ZodVoid.create;
    const arrayType = ZodArray.create;
    const objectType = ZodObject.create;
    const strictObjectType = ZodObject.strictCreate;
    const unionType = ZodUnion.create;
    const discriminatedUnionType = ZodDiscriminatedUnion.create;
    const intersectionType = ZodIntersection.create;
    const tupleType = ZodTuple.create;
    const recordType = ZodRecord.create;
    const mapType = ZodMap.create;
    const setType = ZodSet.create;
    const functionType = ZodFunction.create;
    const lazyType = ZodLazy.create;
    const literalType = ZodLiteral.create;
    const enumType = ZodEnum.create;
    const nativeEnumType = ZodNativeEnum.create;
    const promiseType = ZodPromise.create;
    const effectsType = ZodEffects.create;
    const optionalType = ZodOptional.create;
    const nullableType = ZodNullable.create;
    const preprocessType = ZodEffects.createWithPreprocess;
    const pipelineType = ZodPipeline.create;
    const ostring = () => stringType().optional();
    const onumber = () => numberType().optional();
    const oboolean = () => booleanType().optional();
    const coerce$3 = {
        string: ((arg) => ZodString.create({ ...arg, coerce: true })),
        number: ((arg) => ZodNumber.create({ ...arg, coerce: true })),
        boolean: ((arg) => ZodBoolean.create({
            ...arg,
            coerce: true,
        })),
        bigint: ((arg) => ZodBigInt.create({ ...arg, coerce: true })),
        date: ((arg) => ZodDate.create({ ...arg, coerce: true })),
    };
    const NEVER = INVALID;

    var z$4 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        defaultErrorMap: errorMap,
        setErrorMap: setErrorMap,
        getErrorMap: getErrorMap,
        makeIssue: makeIssue,
        EMPTY_PATH: EMPTY_PATH,
        addIssueToContext: addIssueToContext,
        ParseStatus: ParseStatus,
        INVALID: INVALID,
        DIRTY: DIRTY,
        OK: OK,
        isAborted: isAborted,
        isDirty: isDirty,
        isValid: isValid,
        isAsync: isAsync,
        get util () { return util$4; },
        get objectUtil () { return objectUtil; },
        ZodParsedType: ZodParsedType,
        getParsedType: getParsedType,
        ZodType: ZodType,
        ZodString: ZodString,
        ZodNumber: ZodNumber,
        ZodBigInt: ZodBigInt,
        ZodBoolean: ZodBoolean,
        ZodDate: ZodDate,
        ZodSymbol: ZodSymbol,
        ZodUndefined: ZodUndefined,
        ZodNull: ZodNull,
        ZodAny: ZodAny,
        ZodUnknown: ZodUnknown,
        ZodNever: ZodNever,
        ZodVoid: ZodVoid,
        ZodArray: ZodArray,
        ZodObject: ZodObject,
        ZodUnion: ZodUnion,
        ZodDiscriminatedUnion: ZodDiscriminatedUnion,
        ZodIntersection: ZodIntersection,
        ZodTuple: ZodTuple,
        ZodRecord: ZodRecord,
        ZodMap: ZodMap,
        ZodSet: ZodSet,
        ZodFunction: ZodFunction,
        ZodLazy: ZodLazy,
        ZodLiteral: ZodLiteral,
        ZodEnum: ZodEnum,
        ZodNativeEnum: ZodNativeEnum,
        ZodPromise: ZodPromise,
        ZodEffects: ZodEffects,
        ZodTransformer: ZodEffects,
        ZodOptional: ZodOptional,
        ZodNullable: ZodNullable,
        ZodDefault: ZodDefault,
        ZodCatch: ZodCatch,
        ZodNaN: ZodNaN,
        BRAND: BRAND,
        ZodBranded: ZodBranded,
        ZodPipeline: ZodPipeline,
        ZodReadonly: ZodReadonly,
        custom: custom,
        Schema: ZodType,
        ZodSchema: ZodType,
        late: late,
        get ZodFirstPartyTypeKind () { return ZodFirstPartyTypeKind; },
        coerce: coerce$3,
        any: anyType,
        array: arrayType,
        bigint: bigIntType,
        boolean: booleanType,
        date: dateType,
        discriminatedUnion: discriminatedUnionType,
        effect: effectsType,
        'enum': enumType,
        'function': functionType,
        'instanceof': instanceOfType,
        intersection: intersectionType,
        lazy: lazyType,
        literal: literalType,
        map: mapType,
        nan: nanType,
        nativeEnum: nativeEnumType,
        never: neverType,
        'null': nullType,
        nullable: nullableType,
        number: numberType,
        object: objectType,
        oboolean: oboolean,
        onumber: onumber,
        optional: optionalType,
        ostring: ostring,
        pipeline: pipelineType,
        preprocess: preprocessType,
        promise: promiseType,
        record: recordType,
        set: setType,
        strictObject: strictObjectType,
        string: stringType,
        symbol: symbolType,
        transformer: effectsType,
        tuple: tupleType,
        'undefined': undefinedType,
        union: unionType,
        unknown: unknownType,
        'void': voidType,
        NEVER: NEVER,
        ZodIssueCode: ZodIssueCode,
        quotelessJson: quotelessJson,
        ZodError: ZodError
    });

    const zError = z$4.object({ message: z$4.string() });
    function zType(key) {
        return z$4.literal(W3mFrameConstants[key]);
    }
    z$4.object({
        accessList: z$4.array(z$4.string()),
        blockHash: z$4.string().nullable(),
        blockNumber: z$4.string().nullable(),
        chainId: z$4.string(),
        from: z$4.string(),
        gas: z$4.string(),
        hash: z$4.string(),
        input: z$4.string().nullable(),
        maxFeePerGas: z$4.string(),
        maxPriorityFeePerGas: z$4.string(),
        nonce: z$4.string(),
        r: z$4.string(),
        s: z$4.string(),
        to: z$4.string(),
        transactionIndex: z$4.string().nullable(),
        type: z$4.string(),
        v: z$4.string(),
        value: z$4.string()
    });
    const AppSwitchNetworkRequest = z$4.object({ chainId: z$4.number() });
    const AppConnectEmailRequest = z$4.object({ email: z$4.string().email() });
    const AppConnectOtpRequest = z$4.object({ otp: z$4.string() });
    const AppGetUserRequest = z$4.object({
        chainId: z$4.optional(z$4.number()),
        preferredAccountType: z$4.optional(z$4.string())
    });
    const AppUpdateEmailRequest = z$4.object({ email: z$4.string().email() });
    const AppUpdateEmailPrimaryOtpRequest = z$4.object({ otp: z$4.string() });
    const AppUpdateEmailSecondaryOtpRequest = z$4.object({ otp: z$4.string() });
    const AppSyncThemeRequest = z$4.object({
        themeMode: z$4.optional(z$4.enum(['light', 'dark'])),
        themeVariables: z$4.optional(z$4.record(z$4.string(), z$4.string().or(z$4.number())))
    });
    const AppSyncDappDataRequest = z$4.object({
        metadata: z$4
            .object({
            name: z$4.string(),
            description: z$4.string(),
            url: z$4.string(),
            icons: z$4.array(z$4.string())
        })
            .optional(),
        sdkVersion: z$4.string(),
        projectId: z$4.string()
    });
    const AppSetPreferredAccountRequest = z$4.object({ type: z$4.string() });
    const FrameConnectEmailResponse = z$4.object({
        action: z$4.enum(['VERIFY_DEVICE', 'VERIFY_OTP'])
    });
    const FrameGetUserResponse = z$4.object({
        email: z$4.string().email(),
        address: z$4.string(),
        chainId: z$4.number(),
        smartAccountDeployed: z$4.optional(z$4.boolean())
    });
    const FrameIsConnectedResponse = z$4.object({ isConnected: z$4.boolean() });
    const FrameGetChainIdResponse = z$4.object({ chainId: z$4.number() });
    const FrameSwitchNetworkResponse = z$4.object({ chainId: z$4.number() });
    const FrameUpdateEmailSecondaryOtpResolver = z$4.object({ newEmail: z$4.string().email() });
    const FrameGetSmartAccountEnabledNetworksResponse = z$4.object({
        smartAccountEnabledNetworks: z$4.array(z$4.number())
    });
    const FrameInitSmartAccountResponse = z$4.object({
        address: z$4.string(),
        isDeployed: z$4.boolean()
    });
    const FrameSetPreferredAccountResponse = z$4.object({ type: z$4.string(), address: z$4.string() });
    const RpcResponse = z$4.any();
    const RpcEthAccountsRequest = z$4.object({
        method: z$4.literal('eth_accounts')
    });
    const RpcEthBlockNumber = z$4.object({
        method: z$4.literal('eth_blockNumber')
    });
    const RpcEthCall = z$4.object({
        method: z$4.literal('eth_call'),
        params: z$4.array(z$4.any())
    });
    const RpcEthChainId = z$4.object({
        method: z$4.literal('eth_chainId')
    });
    const RpcEthEstimateGas = z$4.object({
        method: z$4.literal('eth_estimateGas'),
        params: z$4.array(z$4.any())
    });
    const RpcEthFeeHistory = z$4.object({
        method: z$4.literal('eth_feeHistory'),
        params: z$4.array(z$4.any())
    });
    const RpcEthGasPrice = z$4.object({
        method: z$4.literal('eth_gasPrice')
    });
    const RpcEthGetAccount = z$4.object({
        method: z$4.literal('eth_getAccount'),
        params: z$4.array(z$4.any())
    });
    const RpcEthGetBalance = z$4.object({
        method: z$4.literal('eth_getBalance'),
        params: z$4.array(z$4.any())
    });
    const RpcEthGetBlockyByHash = z$4.object({
        method: z$4.literal('eth_getBlockByHash'),
        params: z$4.array(z$4.any())
    });
    const RpcEthGetBlockByNumber = z$4.object({
        method: z$4.literal('eth_getBlockByNumber'),
        params: z$4.array(z$4.any())
    });
    const RpcEthGetBlockReceipts = z$4.object({
        method: z$4.literal('eth_getBlockReceipts'),
        params: z$4.array(z$4.any())
    });
    const RcpEthGetBlockTransactionCountByHash = z$4.object({
        method: z$4.literal('eth_getBlockTransactionCountByHash'),
        params: z$4.array(z$4.any())
    });
    const RcpEthGetBlockTransactionCountByNumber = z$4.object({
        method: z$4.literal('eth_getBlockTransactionCountByNumber'),
        params: z$4.array(z$4.any())
    });
    const RpcEthGetCode = z$4.object({
        method: z$4.literal('eth_getCode'),
        params: z$4.array(z$4.any())
    });
    const RpcEthGetFilter = z$4.object({
        method: z$4.literal('eth_getFilterChanges'),
        params: z$4.array(z$4.any())
    });
    const RpcEthGetFilterLogs = z$4.object({
        method: z$4.literal('eth_getFilterLogs'),
        params: z$4.array(z$4.any())
    });
    const RpcEthGetLogs = z$4.object({
        method: z$4.literal('eth_getLogs'),
        params: z$4.array(z$4.any())
    });
    const RpcEthGetProof = z$4.object({
        method: z$4.literal('eth_getProof'),
        params: z$4.array(z$4.any())
    });
    const RpcEthGetStorageAt = z$4.object({
        method: z$4.literal('eth_getStorageAt'),
        params: z$4.array(z$4.any())
    });
    const RpcEthGetTransactionByBlockHashAndIndex = z$4.object({
        method: z$4.literal('eth_getTransactionByBlockHashAndIndex'),
        params: z$4.array(z$4.any())
    });
    const RpcEthGetTransactionByBlockNumberAndIndex = z$4.object({
        method: z$4.literal('eth_getTransactionByBlockNumberAndIndex'),
        params: z$4.array(z$4.any())
    });
    const RpcEthGetTransactionByHash = z$4.object({
        method: z$4.literal('eth_getTransactionByHash'),
        params: z$4.array(z$4.any())
    });
    const RpcEthGetTransactionCount = z$4.object({
        method: z$4.literal('eth_getTransactionCount'),
        params: z$4.array(z$4.any())
    });
    const RpcEthGetTransactionReceipt = z$4.object({
        method: z$4.literal('eth_getTransactionReceipt'),
        params: z$4.array(z$4.any())
    });
    const RpcEthGetUncleCountByBlockHash = z$4.object({
        method: z$4.literal('eth_getUncleCountByBlockHash'),
        params: z$4.array(z$4.any())
    });
    const RpcEthGetUncleCountByBlockNumber = z$4.object({
        method: z$4.literal('eth_getUncleCountByBlockNumber'),
        params: z$4.array(z$4.any())
    });
    const RpcEthMaxPriorityFeePerGas = z$4.object({
        method: z$4.literal('eth_maxPriorityFeePerGas')
    });
    const RpcEthNewBlockFilter = z$4.object({
        method: z$4.literal('eth_newBlockFilter')
    });
    const RpcEthNewFilter = z$4.object({
        method: z$4.literal('eth_newFilter'),
        params: z$4.array(z$4.any())
    });
    const RpcEthNewPendingTransactionFilter = z$4.object({
        method: z$4.literal('eth_newPendingTransactionFilter')
    });
    const RpcEthSendRawTransaction = z$4.object({
        method: z$4.literal('eth_sendRawTransaction'),
        params: z$4.array(z$4.any())
    });
    const RpcEthSyncing = z$4.object({
        method: z$4.literal('eth_syncing'),
        params: z$4.array(z$4.any())
    });
    const RpcUnistallFilter = z$4.object({
        method: z$4.literal('eth_uninstallFilter'),
        params: z$4.array(z$4.any())
    });
    const RpcPersonalSignRequest = z$4.object({
        method: z$4.literal('personal_sign'),
        params: z$4.array(z$4.any())
    });
    const RpcEthSignTypedDataV4 = z$4.object({
        method: z$4.literal('eth_signTypedData_v4'),
        params: z$4.array(z$4.any())
    });
    const RpcEthSendTransactionRequest = z$4.object({
        method: z$4.literal('eth_sendTransaction'),
        params: z$4.array(z$4.any())
    });
    const FrameSession = z$4.object({
        token: z$4.string()
    });
    const W3mFrameSchema = {
        appEvent: z$4
            .object({ type: zType('APP_SWITCH_NETWORK'), payload: AppSwitchNetworkRequest })
            .or(z$4.object({ type: zType('APP_CONNECT_EMAIL'), payload: AppConnectEmailRequest }))
            .or(z$4.object({ type: zType('APP_CONNECT_DEVICE') }))
            .or(z$4.object({ type: zType('APP_CONNECT_OTP'), payload: AppConnectOtpRequest }))
            .or(z$4.object({ type: zType('APP_GET_USER'), payload: z$4.optional(AppGetUserRequest) }))
            .or(z$4.object({ type: zType('APP_SIGN_OUT') }))
            .or(z$4.object({ type: zType('APP_IS_CONNECTED'), payload: z$4.optional(FrameSession) }))
            .or(z$4.object({ type: zType('APP_GET_CHAIN_ID') }))
            .or(z$4.object({ type: zType('APP_GET_SMART_ACCOUNT_ENABLED_NETWORKS') }))
            .or(z$4.object({ type: zType('APP_INIT_SMART_ACCOUNT') }))
            .or(z$4.object({ type: zType('APP_SET_PREFERRED_ACCOUNT'), payload: AppSetPreferredAccountRequest }))
            .or(z$4.object({
            type: zType('APP_RPC_REQUEST'),
            payload: RpcPersonalSignRequest.or(RpcEthSendTransactionRequest)
                .or(RpcEthAccountsRequest)
                .or(RpcEthBlockNumber)
                .or(RpcEthCall)
                .or(RpcEthChainId)
                .or(RpcEthEstimateGas)
                .or(RpcEthFeeHistory)
                .or(RpcEthGasPrice)
                .or(RpcEthGetAccount)
                .or(RpcEthGetBalance)
                .or(RpcEthGetBlockyByHash)
                .or(RpcEthGetBlockByNumber)
                .or(RpcEthGetBlockReceipts)
                .or(RcpEthGetBlockTransactionCountByHash)
                .or(RcpEthGetBlockTransactionCountByNumber)
                .or(RpcEthGetCode)
                .or(RpcEthGetFilter)
                .or(RpcEthGetFilterLogs)
                .or(RpcEthGetLogs)
                .or(RpcEthGetProof)
                .or(RpcEthGetStorageAt)
                .or(RpcEthGetTransactionByBlockHashAndIndex)
                .or(RpcEthGetTransactionByBlockNumberAndIndex)
                .or(RpcEthGetTransactionByHash)
                .or(RpcEthGetTransactionCount)
                .or(RpcEthGetTransactionReceipt)
                .or(RpcEthGetUncleCountByBlockHash)
                .or(RpcEthGetUncleCountByBlockNumber)
                .or(RpcEthMaxPriorityFeePerGas)
                .or(RpcEthNewBlockFilter)
                .or(RpcEthNewFilter)
                .or(RpcEthNewPendingTransactionFilter)
                .or(RpcEthSendRawTransaction)
                .or(RpcEthSyncing)
                .or(RpcUnistallFilter)
                .or(RpcPersonalSignRequest)
                .or(RpcEthSignTypedDataV4)
                .or(RpcEthSendTransactionRequest)
        }))
            .or(z$4.object({ type: zType('APP_UPDATE_EMAIL'), payload: AppUpdateEmailRequest }))
            .or(z$4.object({
            type: zType('APP_UPDATE_EMAIL_PRIMARY_OTP'),
            payload: AppUpdateEmailPrimaryOtpRequest
        }))
            .or(z$4.object({
            type: zType('APP_UPDATE_EMAIL_SECONDARY_OTP'),
            payload: AppUpdateEmailSecondaryOtpRequest
        }))
            .or(z$4.object({ type: zType('APP_SYNC_THEME'), payload: AppSyncThemeRequest }))
            .or(z$4.object({ type: zType('APP_SYNC_DAPP_DATA'), payload: AppSyncDappDataRequest })),
        frameEvent: z$4
            .object({ type: zType('FRAME_SWITCH_NETWORK_ERROR'), payload: zError })
            .or(z$4.object({ type: zType('FRAME_SWITCH_NETWORK_SUCCESS'), payload: FrameSwitchNetworkResponse }))
            .or(z$4.object({ type: zType('FRAME_CONNECT_EMAIL_ERROR'), payload: zError }))
            .or(z$4.object({ type: zType('FRAME_CONNECT_EMAIL_SUCCESS'), payload: FrameConnectEmailResponse }))
            .or(z$4.object({ type: zType('FRAME_CONNECT_OTP_ERROR'), payload: zError }))
            .or(z$4.object({ type: zType('FRAME_CONNECT_OTP_SUCCESS') }))
            .or(z$4.object({ type: zType('FRAME_CONNECT_DEVICE_ERROR'), payload: zError }))
            .or(z$4.object({ type: zType('FRAME_CONNECT_DEVICE_SUCCESS') }))
            .or(z$4.object({ type: zType('FRAME_GET_USER_ERROR'), payload: zError }))
            .or(z$4.object({ type: zType('FRAME_GET_USER_SUCCESS'), payload: FrameGetUserResponse }))
            .or(z$4.object({ type: zType('FRAME_SIGN_OUT_ERROR'), payload: zError }))
            .or(z$4.object({ type: zType('FRAME_SIGN_OUT_SUCCESS') }))
            .or(z$4.object({ type: zType('FRAME_IS_CONNECTED_ERROR'), payload: zError }))
            .or(z$4.object({ type: zType('FRAME_IS_CONNECTED_SUCCESS'), payload: FrameIsConnectedResponse }))
            .or(z$4.object({ type: zType('FRAME_GET_CHAIN_ID_ERROR'), payload: zError }))
            .or(z$4.object({ type: zType('FRAME_GET_CHAIN_ID_SUCCESS'), payload: FrameGetChainIdResponse }))
            .or(z$4.object({ type: zType('FRAME_RPC_REQUEST_ERROR'), payload: zError }))
            .or(z$4.object({ type: zType('FRAME_RPC_REQUEST_SUCCESS'), payload: RpcResponse }))
            .or(z$4.object({ type: zType('FRAME_SESSION_UPDATE'), payload: FrameSession }))
            .or(z$4.object({ type: zType('FRAME_UPDATE_EMAIL_ERROR'), payload: zError }))
            .or(z$4.object({ type: zType('FRAME_UPDATE_EMAIL_SUCCESS') }))
            .or(z$4.object({ type: zType('FRAME_UPDATE_EMAIL_PRIMARY_OTP_ERROR'), payload: zError }))
            .or(z$4.object({ type: zType('FRAME_UPDATE_EMAIL_PRIMARY_OTP_SUCCESS') }))
            .or(z$4.object({ type: zType('FRAME_UPDATE_EMAIL_SECONDARY_OTP_ERROR'), payload: zError }))
            .or(z$4.object({
            type: zType('FRAME_UPDATE_EMAIL_SECONDARY_OTP_SUCCESS'),
            payload: FrameUpdateEmailSecondaryOtpResolver
        }))
            .or(z$4.object({ type: zType('FRAME_SYNC_THEME_ERROR'), payload: zError }))
            .or(z$4.object({ type: zType('FRAME_SYNC_THEME_SUCCESS') }))
            .or(z$4.object({ type: zType('FRAME_SYNC_DAPP_DATA_ERROR'), payload: zError }))
            .or(z$4.object({ type: zType('FRAME_SYNC_DAPP_DATA_SUCCESS') }))
            .or(z$4.object({
            type: zType('FRAME_GET_SMART_ACCOUNT_ENABLED_NETWORKS_SUCCESS'),
            payload: FrameGetSmartAccountEnabledNetworksResponse
        }))
            .or(z$4.object({
            type: zType('FRAME_GET_SMART_ACCOUNT_ENABLED_NETWORKS_ERROR'),
            payload: zError
        }))
            .or(z$4.object({
            type: zType('FRAME_INIT_SMART_ACCOUNT_SUCCESS'),
            payload: FrameInitSmartAccountResponse
        }))
            .or(z$4.object({ type: zType('FRAME_INIT_SMART_ACCOUNT_ERROR'), payload: zError }))
            .or(z$4.object({
            type: zType('FRAME_SET_PREFERRED_ACCOUNT_SUCCESS'),
            payload: FrameSetPreferredAccountResponse
        }))
            .or(z$4.object({ type: zType('FRAME_SET_PREFERRED_ACCOUNT_ERROR'), payload: zError }))
    };

    const W3mFrameStorage = {
        set(key, value) {
            if (W3mFrameHelpers.isClient) {
                localStorage.setItem(`${W3mFrameConstants.STORAGE_KEY}${key}`, value);
            }
        },
        get(key) {
            if (W3mFrameHelpers.isClient) {
                return localStorage.getItem(`${W3mFrameConstants.STORAGE_KEY}${key}`);
            }
            return null;
        },
        delete(key) {
            if (W3mFrameHelpers.isClient) {
                localStorage.removeItem(`${W3mFrameConstants.STORAGE_KEY}${key}`);
            }
        }
    };

    const RESTRICTED_TIMEZONES = [
        'ASIA/SHANGHAI',
        'ASIA/URUMQI',
        'ASIA/CHONGQING',
        'ASIA/HARBIN',
        'ASIA/KASHGAR',
        'ASIA/MACAU',
        'ASIA/HONG_KONG',
        'ASIA/MACAO',
        'ASIA/BEIJING',
        'ASIA/HARBIN'
    ];
    const EMAIL_MINIMUM_TIMEOUT = 30 * 1000;
    const W3mFrameHelpers = {
        getBlockchainApiUrl() {
            try {
                const { timeZone } = new Intl.DateTimeFormat().resolvedOptions();
                const capTimeZone = timeZone.toUpperCase();
                return RESTRICTED_TIMEZONES.includes(capTimeZone)
                    ? 'https://rpc.walletconnect.org'
                    : 'https://rpc.walletconnect.com';
            }
            catch {
                return false;
            }
        },
        checkIfAllowedToTriggerEmail() {
            const lastEmailLoginTime = W3mFrameStorage.get(W3mFrameConstants.LAST_EMAIL_LOGIN_TIME);
            if (lastEmailLoginTime) {
                const difference = Date.now() - Number(lastEmailLoginTime);
                if (difference < EMAIL_MINIMUM_TIMEOUT) {
                    const cooldownSec = Math.ceil((EMAIL_MINIMUM_TIMEOUT - difference) / 1000);
                    throw new Error(`Please try again after ${cooldownSec} seconds`);
                }
            }
        },
        getTimeToNextEmailLogin() {
            const lastEmailLoginTime = W3mFrameStorage.get(W3mFrameConstants.LAST_EMAIL_LOGIN_TIME);
            if (lastEmailLoginTime) {
                const difference = Date.now() - Number(lastEmailLoginTime);
                if (difference < EMAIL_MINIMUM_TIMEOUT) {
                    return Math.ceil((EMAIL_MINIMUM_TIMEOUT - difference) / 1000);
                }
            }
            return 0;
        },
        checkIfRequestExists(request) {
            const method = this.getRequestMethod(request);
            return (W3mFrameRpcConstants.NOT_SAFE_RPC_METHODS.includes(method) ||
                W3mFrameRpcConstants.SAFE_RPC_METHODS.includes(method));
        },
        getRequestMethod(request) {
            return request?.payload?.method;
        },
        checkIfRequestIsAllowed(request) {
            const method = this.getRequestMethod(request);
            return W3mFrameRpcConstants.SAFE_RPC_METHODS.includes(method);
        },
        isClient: typeof window !== 'undefined'
    };

    class W3mFrame {
        constructor(projectId, isAppClient = false) {
            this.iframe = null;
            this.rpcUrl = W3mFrameHelpers.getBlockchainApiUrl();
            this.events = {
                onFrameEvent: (callback) => {
                    if (W3mFrameHelpers.isClient) {
                        window.addEventListener('message', ({ data }) => {
                            if (!data.type?.includes(W3mFrameConstants.FRAME_EVENT_KEY)) {
                                return;
                            }
                            const frameEvent = W3mFrameSchema.frameEvent.parse(data);
                            callback(frameEvent);
                        });
                    }
                },
                onAppEvent: (callback) => {
                    if (W3mFrameHelpers.isClient) {
                        window.addEventListener('message', ({ data }) => {
                            if (!data.type?.includes(W3mFrameConstants.APP_EVENT_KEY)) {
                                return;
                            }
                            const appEvent = W3mFrameSchema.appEvent.parse(data);
                            callback(appEvent);
                        });
                    }
                },
                postAppEvent: (event) => {
                    if (W3mFrameHelpers.isClient) {
                        if (!this.iframe?.contentWindow) {
                            throw new Error('W3mFrame: iframe is not set');
                        }
                        W3mFrameSchema.appEvent.parse(event);
                        window.postMessage(event);
                        this.iframe.contentWindow.postMessage(event, '*');
                    }
                },
                postFrameEvent: (event) => {
                    if (W3mFrameHelpers.isClient) {
                        if (!parent) {
                            throw new Error('W3mFrame: parent is not set');
                        }
                        W3mFrameSchema.frameEvent.parse(event);
                        parent.postMessage(event, '*');
                    }
                }
            };
            this.projectId = projectId;
            this.frameLoadPromise = new Promise((resolve, reject) => {
                this.frameLoadPromiseResolver = { resolve, reject };
            });
            if (isAppClient) {
                this.frameLoadPromise = new Promise((resolve, reject) => {
                    this.frameLoadPromiseResolver = { resolve, reject };
                });
                if (W3mFrameHelpers.isClient) {
                    const iframe = document.createElement('iframe');
                    iframe.id = 'w3m-iframe';
                    iframe.src = `${W3mFrameConstants.SECURE_SITE_SDK}?projectId=${projectId}`;
                    iframe.style.position = 'fixed';
                    iframe.style.zIndex = '999999';
                    iframe.style.display = 'none';
                    iframe.style.opacity = '0';
                    iframe.style.borderRadius = `clamp(0px, var(--wui-border-radius-l), 44px)`;
                    document.body.appendChild(iframe);
                    this.iframe = iframe;
                    this.iframe.onload = () => {
                        this.frameLoadPromiseResolver?.resolve(undefined);
                    };
                    this.iframe.onerror = () => {
                        this.frameLoadPromiseResolver?.reject('Unable to load email login dependency');
                    };
                }
            }
        }
        get networks() {
            const data = [
                1, 5, 11155111, 10, 420, 42161, 421613, 137, 80001, 42220, 1313161554, 1313161555, 56, 97,
                43114, 43113, 324, 280, 100, 8453, 84531, 7777777, 999
            ].map(id => ({
                [id]: {
                    rpcUrl: `${this.rpcUrl}/v1/?chainId=eip155:${id}&projectId=${this.projectId}`,
                    chainId: id
                }
            }));
            return Object.assign({}, ...data);
        }
    }

    class W3mFrameProvider {
        constructor(projectId) {
            this.connectEmailResolver = undefined;
            this.connectDeviceResolver = undefined;
            this.connectOtpResolver = undefined;
            this.connectResolver = undefined;
            this.disconnectResolver = undefined;
            this.isConnectedResolver = undefined;
            this.getChainIdResolver = undefined;
            this.switchChainResolver = undefined;
            this.rpcRequestResolver = undefined;
            this.updateEmailResolver = undefined;
            this.updateEmailPrimaryOtpResolver = undefined;
            this.updateEmailSecondaryOtpResolver = undefined;
            this.syncThemeResolver = undefined;
            this.syncDappDataResolver = undefined;
            this.smartAccountEnabledNetworksResolver = undefined;
            this.initSmartAccountResolver = undefined;
            this.setPreferredAccountResolver = undefined;
            this.w3mFrame = new W3mFrame(projectId, true);
            this.w3mFrame.events.onFrameEvent(event => {
                console.log('💻 received', event);
                switch (event.type) {
                    case W3mFrameConstants.FRAME_CONNECT_EMAIL_SUCCESS:
                        return this.onConnectEmailSuccess(event);
                    case W3mFrameConstants.FRAME_CONNECT_EMAIL_ERROR:
                        return this.onConnectEmailError(event);
                    case W3mFrameConstants.FRAME_CONNECT_DEVICE_SUCCESS:
                        return this.onConnectDeviceSuccess();
                    case W3mFrameConstants.FRAME_CONNECT_DEVICE_ERROR:
                        return this.onConnectDeviceError(event);
                    case W3mFrameConstants.FRAME_CONNECT_OTP_SUCCESS:
                        return this.onConnectOtpSuccess();
                    case W3mFrameConstants.FRAME_CONNECT_OTP_ERROR:
                        return this.onConnectOtpError(event);
                    case W3mFrameConstants.FRAME_GET_USER_SUCCESS:
                        return this.onConnectSuccess(event);
                    case W3mFrameConstants.FRAME_GET_USER_ERROR:
                        return this.onConnectError(event);
                    case W3mFrameConstants.FRAME_IS_CONNECTED_SUCCESS:
                        return this.onIsConnectedSuccess(event);
                    case W3mFrameConstants.FRAME_IS_CONNECTED_ERROR:
                        return this.onIsConnectedError(event);
                    case W3mFrameConstants.FRAME_GET_CHAIN_ID_SUCCESS:
                        return this.onGetChainIdSuccess(event);
                    case W3mFrameConstants.FRAME_GET_CHAIN_ID_ERROR:
                        return this.onGetChainIdError(event);
                    case W3mFrameConstants.FRAME_SIGN_OUT_SUCCESS:
                        return this.onSignOutSuccess();
                    case W3mFrameConstants.FRAME_SIGN_OUT_ERROR:
                        return this.onSignOutError(event);
                    case W3mFrameConstants.FRAME_SWITCH_NETWORK_SUCCESS:
                        return this.onSwitchChainSuccess(event);
                    case W3mFrameConstants.FRAME_SWITCH_NETWORK_ERROR:
                        return this.onSwitchChainError(event);
                    case W3mFrameConstants.FRAME_RPC_REQUEST_SUCCESS:
                        return this.onRpcRequestSuccess(event);
                    case W3mFrameConstants.FRAME_RPC_REQUEST_ERROR:
                        return this.onRpcRequestError(event);
                    case W3mFrameConstants.FRAME_SESSION_UPDATE:
                        return this.onSessionUpdate(event);
                    case W3mFrameConstants.FRAME_UPDATE_EMAIL_SUCCESS:
                        return this.onUpdateEmailSuccess();
                    case W3mFrameConstants.FRAME_UPDATE_EMAIL_ERROR:
                        return this.onUpdateEmailError(event);
                    case W3mFrameConstants.FRAME_UPDATE_EMAIL_PRIMARY_OTP_SUCCESS:
                        return this.onUpdateEmailPrimaryOtpSuccess();
                    case W3mFrameConstants.FRAME_UPDATE_EMAIL_PRIMARY_OTP_ERROR:
                        return this.onUpdateEmailPrimaryOtpError(event);
                    case W3mFrameConstants.FRAME_UPDATE_EMAIL_SECONDARY_OTP_SUCCESS:
                        return this.onUpdateEmailSecondaryOtpSuccess(event);
                    case W3mFrameConstants.FRAME_UPDATE_EMAIL_SECONDARY_OTP_ERROR:
                        return this.onUpdateEmailSecondaryOtpError(event);
                    case W3mFrameConstants.FRAME_SYNC_THEME_SUCCESS:
                        return this.onSyncThemeSuccess();
                    case W3mFrameConstants.FRAME_SYNC_THEME_ERROR:
                        return this.onSyncThemeError(event);
                    case W3mFrameConstants.FRAME_SYNC_DAPP_DATA_SUCCESS:
                        return this.onSyncDappDataSuccess();
                    case W3mFrameConstants.FRAME_SYNC_DAPP_DATA_ERROR:
                        return this.onSyncDappDataError(event);
                    case W3mFrameConstants.FRAME_GET_SMART_ACCOUNT_ENABLED_NETWORKS_SUCCESS:
                        return this.onSmartAccountEnabledNetworksSuccess(event);
                    case W3mFrameConstants.FRAME_GET_SMART_ACCOUNT_ENABLED_NETWORKS_ERROR:
                        return this.onSmartAccountEnabledNetworksError(event);
                    case W3mFrameConstants.FRAME_INIT_SMART_ACCOUNT_SUCCESS:
                        return this.onInitSmartAccountSuccess(event);
                    case W3mFrameConstants.FRAME_INIT_SMART_ACCOUNT_ERROR:
                        return this.onInitSmartAccountError(event);
                    case W3mFrameConstants.FRAME_SET_PREFERRED_ACCOUNT_SUCCESS:
                        return this.onPreferSmartAccountSuccess(event);
                    case W3mFrameConstants.FRAME_SET_PREFERRED_ACCOUNT_ERROR:
                        return this.onPreferSmartAccountError();
                    default:
                        return null;
                }
            });
        }
        getLoginEmailUsed() {
            return Boolean(W3mFrameStorage.get(W3mFrameConstants.EMAIL_LOGIN_USED_KEY));
        }
        getEmail() {
            return W3mFrameStorage.get(W3mFrameConstants.EMAIL);
        }
        rejectRpcRequest() {
            this.rpcRequestResolver?.reject();
        }
        async connectEmail(payload) {
            await this.w3mFrame.frameLoadPromise;
            W3mFrameHelpers.checkIfAllowedToTriggerEmail();
            this.w3mFrame.events.postAppEvent({ type: W3mFrameConstants.APP_CONNECT_EMAIL, payload });
            return new Promise((resolve, reject) => {
                this.connectEmailResolver = { resolve, reject };
            });
        }
        async connectDevice() {
            await this.w3mFrame.frameLoadPromise;
            this.w3mFrame.events.postAppEvent({ type: W3mFrameConstants.APP_CONNECT_DEVICE });
            return new Promise((resolve, reject) => {
                this.connectDeviceResolver = { resolve, reject };
            });
        }
        async connectOtp(payload) {
            await this.w3mFrame.frameLoadPromise;
            this.w3mFrame.events.postAppEvent({ type: W3mFrameConstants.APP_CONNECT_OTP, payload });
            return new Promise((resolve, reject) => {
                this.connectOtpResolver = { resolve, reject };
            });
        }
        async isConnected() {
            await this.w3mFrame.frameLoadPromise;
            this.w3mFrame.events.postAppEvent({
                type: W3mFrameConstants.APP_IS_CONNECTED,
                payload: undefined
            });
            return new Promise((resolve, reject) => {
                this.isConnectedResolver = { resolve, reject };
            });
        }
        async getChainId() {
            await this.w3mFrame.frameLoadPromise;
            this.w3mFrame.events.postAppEvent({ type: W3mFrameConstants.APP_GET_CHAIN_ID });
            return new Promise((resolve, reject) => {
                this.getChainIdResolver = { resolve, reject };
            });
        }
        async updateEmail(payload) {
            await this.w3mFrame.frameLoadPromise;
            W3mFrameHelpers.checkIfAllowedToTriggerEmail();
            this.w3mFrame.events.postAppEvent({ type: W3mFrameConstants.APP_UPDATE_EMAIL, payload });
            return new Promise((resolve, reject) => {
                this.updateEmailResolver = { resolve, reject };
            });
        }
        async updateEmailPrimaryOtp(payload) {
            await this.w3mFrame.frameLoadPromise;
            this.w3mFrame.events.postAppEvent({
                type: W3mFrameConstants.APP_UPDATE_EMAIL_PRIMARY_OTP,
                payload
            });
            return new Promise((resolve, reject) => {
                this.updateEmailPrimaryOtpResolver = { resolve, reject };
            });
        }
        async updateEmailSecondaryOtp(payload) {
            await this.w3mFrame.frameLoadPromise;
            this.w3mFrame.events.postAppEvent({
                type: W3mFrameConstants.APP_UPDATE_EMAIL_SECONDARY_OTP,
                payload
            });
            return new Promise((resolve, reject) => {
                this.updateEmailSecondaryOtpResolver = { resolve, reject };
            });
        }
        async syncTheme(payload) {
            await this.w3mFrame.frameLoadPromise;
            this.w3mFrame.events.postAppEvent({ type: W3mFrameConstants.APP_SYNC_THEME, payload });
            return new Promise((resolve, reject) => {
                this.syncThemeResolver = { resolve, reject };
            });
        }
        async syncDappData(payload) {
            await this.w3mFrame.frameLoadPromise;
            this.w3mFrame.events.postAppEvent({ type: W3mFrameConstants.APP_SYNC_DAPP_DATA, payload });
            return new Promise((resolve, reject) => {
                this.syncDappDataResolver = { resolve, reject };
            });
        }
        async getSmartAccountEnabledNetworks() {
            await this.w3mFrame.frameLoadPromise;
            this.w3mFrame.events.postAppEvent({
                type: W3mFrameConstants.APP_GET_SMART_ACCOUNT_ENABLED_NETWORKS
            });
            return new Promise((resolve, reject) => {
                this.smartAccountEnabledNetworksResolver = { resolve, reject };
            });
        }
        async initSmartAccount() {
            await this.w3mFrame.frameLoadPromise;
            this.w3mFrame.events.postAppEvent({ type: W3mFrameConstants.APP_INIT_SMART_ACCOUNT });
            return new Promise((resolve, reject) => {
                this.initSmartAccountResolver = { resolve, reject };
            });
        }
        async setPreferredAccount(type) {
            await this.w3mFrame.frameLoadPromise;
            this.w3mFrame.events.postAppEvent({
                type: W3mFrameConstants.APP_SET_PREFERRED_ACCOUNT,
                payload: { type }
            });
            return new Promise((resolve, reject) => {
                this.setPreferredAccountResolver = { resolve, reject };
            });
        }
        async connect(payload) {
            const chainId = payload?.chainId ?? this.getLastUsedChainId() ?? 1;
            await this.w3mFrame.frameLoadPromise;
            this.w3mFrame.events.postAppEvent({
                type: W3mFrameConstants.APP_GET_USER,
                payload: { chainId }
            });
            return new Promise((resolve, reject) => {
                this.connectResolver = { resolve, reject };
            });
        }
        async switchNetwork(chainId) {
            await this.w3mFrame.frameLoadPromise;
            this.w3mFrame.events.postAppEvent({
                type: W3mFrameConstants.APP_SWITCH_NETWORK,
                payload: { chainId }
            });
            return new Promise((resolve, reject) => {
                this.switchChainResolver = { resolve, reject };
            });
        }
        async disconnect() {
            await this.w3mFrame.frameLoadPromise;
            this.w3mFrame.events.postAppEvent({ type: W3mFrameConstants.APP_SIGN_OUT });
            return new Promise((resolve, reject) => {
                this.disconnectResolver = { resolve, reject };
            });
        }
        async request(req) {
            await this.w3mFrame.frameLoadPromise;
            if (W3mFrameRpcConstants.GET_CHAIN_ID === req.method) {
                return this.getLastUsedChainId();
            }
            this.w3mFrame.events.postAppEvent({
                type: W3mFrameConstants.APP_RPC_REQUEST,
                payload: req
            });
            return new Promise((resolve, reject) => {
                this.rpcRequestResolver = { resolve, reject };
            });
        }
        onRpcRequest(callback) {
            this.w3mFrame.events.onAppEvent(event => {
                if (event.type.includes(W3mFrameConstants.RPC_METHOD_KEY)) {
                    callback(event);
                }
            });
        }
        onRpcResponse(callback) {
            this.w3mFrame.events.onFrameEvent(event => {
                if (event.type.includes(W3mFrameConstants.RPC_METHOD_KEY)) {
                    callback(event);
                }
            });
        }
        onIsConnected(callback) {
            this.w3mFrame.events.onFrameEvent(event => {
                if (event.type === W3mFrameConstants.FRAME_GET_USER_SUCCESS) {
                    callback();
                }
            });
        }
        onNotConnected(callback) {
            this.w3mFrame.events.onFrameEvent(event => {
                if (event.type === W3mFrameConstants.FRAME_IS_CONNECTED_ERROR) {
                    callback();
                }
                if (event.type === W3mFrameConstants.FRAME_IS_CONNECTED_SUCCESS &&
                    !event.payload.isConnected) {
                    callback();
                }
            });
        }
        onInitSmartAccount(callback) {
            this.w3mFrame.events.onFrameEvent(event => {
                if (event.type === W3mFrameConstants.FRAME_INIT_SMART_ACCOUNT_SUCCESS) {
                    callback(event.payload.isDeployed);
                }
                else if (event.type === W3mFrameConstants.FRAME_INIT_SMART_ACCOUNT_ERROR) {
                    callback(false);
                }
            });
        }
        onConnectEmailSuccess(event) {
            this.connectEmailResolver?.resolve(event.payload);
            this.setNewLastEmailLoginTime();
        }
        onConnectEmailError(event) {
            this.connectEmailResolver?.reject(event.payload.message);
        }
        onConnectDeviceSuccess() {
            this.connectDeviceResolver?.resolve(undefined);
        }
        onConnectDeviceError(event) {
            this.connectDeviceResolver?.reject(event.payload.message);
        }
        onConnectOtpSuccess() {
            this.connectOtpResolver?.resolve(undefined);
        }
        onConnectOtpError(event) {
            this.connectOtpResolver?.reject(event.payload.message);
        }
        onConnectSuccess(event) {
            this.setEmailLoginSuccess(event.payload.email);
            this.setLastUsedChainId(event.payload.chainId);
            this.connectResolver?.resolve(event.payload);
        }
        onConnectError(event) {
            this.connectResolver?.reject(event.payload.message);
        }
        onIsConnectedSuccess(event) {
            if (!event.payload.isConnected) {
                this.deleteEmailLoginCache();
            }
            this.isConnectedResolver?.resolve(event.payload);
        }
        onIsConnectedError(event) {
            this.isConnectedResolver?.reject(event.payload.message);
        }
        onGetChainIdSuccess(event) {
            this.setLastUsedChainId(event.payload.chainId);
            this.getChainIdResolver?.resolve(event.payload);
        }
        onGetChainIdError(event) {
            this.getChainIdResolver?.reject(event.payload.message);
        }
        onSignOutSuccess() {
            this.disconnectResolver?.resolve(undefined);
            this.deleteEmailLoginCache();
        }
        onSignOutError(event) {
            this.disconnectResolver?.reject(event.payload.message);
        }
        onSwitchChainSuccess(event) {
            this.setLastUsedChainId(event.payload.chainId);
            this.switchChainResolver?.resolve(event.payload);
        }
        onSwitchChainError(event) {
            this.switchChainResolver?.reject(event.payload.message);
        }
        onRpcRequestSuccess(event) {
            this.rpcRequestResolver?.resolve(event.payload);
        }
        onRpcRequestError(event) {
            this.rpcRequestResolver?.reject(event.payload.message);
        }
        onSessionUpdate(event) {
        }
        onUpdateEmailSuccess() {
            this.updateEmailResolver?.resolve(undefined);
            this.setNewLastEmailLoginTime();
        }
        onUpdateEmailError(event) {
            this.updateEmailResolver?.reject(event.payload.message);
        }
        onUpdateEmailPrimaryOtpSuccess() {
            this.updateEmailPrimaryOtpResolver?.resolve(undefined);
        }
        onUpdateEmailPrimaryOtpError(event) {
            this.updateEmailPrimaryOtpResolver?.reject(event.payload.message);
        }
        onUpdateEmailSecondaryOtpSuccess(event) {
            const { newEmail } = event.payload;
            this.setEmailLoginSuccess(newEmail);
            this.updateEmailSecondaryOtpResolver?.resolve({ newEmail });
        }
        onUpdateEmailSecondaryOtpError(event) {
            this.updateEmailSecondaryOtpResolver?.reject(event.payload.message);
        }
        onSyncThemeSuccess() {
            this.syncThemeResolver?.resolve(undefined);
        }
        onSyncThemeError(event) {
            this.syncThemeResolver?.reject(event.payload.message);
        }
        onSyncDappDataSuccess() {
            this.syncDappDataResolver?.resolve(undefined);
        }
        onSyncDappDataError(event) {
            this.syncDappDataResolver?.reject(event.payload.message);
        }
        onSmartAccountEnabledNetworksSuccess(event) {
            this.smartAccountEnabledNetworksResolver?.resolve(event.payload);
        }
        onSmartAccountEnabledNetworksError(event) {
            this.smartAccountEnabledNetworksResolver?.reject(event.payload.message);
        }
        onInitSmartAccountSuccess(event) {
            this.initSmartAccountResolver?.resolve(event.payload);
        }
        onInitSmartAccountError(event) {
            this.initSmartAccountResolver?.reject(event.payload.message);
        }
        onPreferSmartAccountSuccess(event) {
            this.persistPreferredAccount(event.payload.type);
            this.setPreferredAccountResolver?.resolve(undefined);
        }
        onPreferSmartAccountError() {
            this.setPreferredAccountResolver?.reject();
        }
        setNewLastEmailLoginTime() {
            W3mFrameStorage.set(W3mFrameConstants.LAST_EMAIL_LOGIN_TIME, Date.now().toString());
        }
        setEmailLoginSuccess(email) {
            W3mFrameStorage.set(W3mFrameConstants.EMAIL, email);
            W3mFrameStorage.set(W3mFrameConstants.EMAIL_LOGIN_USED_KEY, 'true');
            W3mFrameStorage.delete(W3mFrameConstants.LAST_EMAIL_LOGIN_TIME);
        }
        deleteEmailLoginCache() {
            W3mFrameStorage.delete(W3mFrameConstants.EMAIL_LOGIN_USED_KEY);
            W3mFrameStorage.delete(W3mFrameConstants.EMAIL);
            W3mFrameStorage.delete(W3mFrameConstants.LAST_USED_CHAIN_KEY);
        }
        setLastUsedChainId(chainId) {
            W3mFrameStorage.set(W3mFrameConstants.LAST_USED_CHAIN_KEY, String(chainId));
        }
        getLastUsedChainId() {
            return Number(W3mFrameStorage.get(W3mFrameConstants.LAST_USED_CHAIN_KEY));
        }
        persistPreferredAccount(type) {
            W3mFrameStorage.set(W3mFrameConstants.PREFERRED_ACCOUNT_TYPE, type);
        }
    }

    var __decorate$G = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    const OTP_LENGTH = 6;
    let W3mEmailOtpWidget = class W3mEmailOtpWidget extends s$a {
        firstUpdated() {
            this.startOTPTimeout();
        }
        disconnectedCallback() {
            clearTimeout(this.OTPTimeout);
        }
        constructor() {
            super();
            this.loading = false;
            this.timeoutTimeLeft = W3mFrameHelpers.getTimeToNextEmailLogin();
            this.error = '';
            this.otp = '';
            this.email = RouterController.state.data?.email;
            this.emailConnector = ConnectorController.getEmailConnector();
        }
        render() {
            if (!this.email) {
                throw new Error('w3m-email-otp-widget: No email provided');
            }
            const isResendDisabled = Boolean(this.timeoutTimeLeft);
            const footerLabels = this.getFooterLabels(isResendDisabled);
            return x$4 `
      <wui-flex
        flexDirection="column"
        alignItems="center"
        .padding=${['l', '0', 'l', '0']}
        gap="l"
      >
        <wui-flex flexDirection="column" alignItems="center">
          <wui-text variant="paragraph-400" color="fg-100">Enter the code we sent to</wui-text>
          <wui-text variant="paragraph-500" color="fg-100">${this.email}</wui-text>
        </wui-flex>

        <wui-text variant="small-400" color="fg-200">The code expires in 20 minutes</wui-text>

        ${this.loading
            ? x$4 `<wui-loading-spinner size="xl" color="accent-100"></wui-loading-spinner>`
            : x$4 ` <wui-flex flexDirection="column" alignItems="center" gap="xs">
              <wui-otp
                dissabled
                length="6"
                @inputChange=${this.onOtpInputChange.bind(this)}
                .otp=${this.otp}
              ></wui-otp>
              ${this.error
                ? x$4 `
                    <wui-text variant="small-400" align="center" color="error-100">
                      ${this.error}. Try Again
                    </wui-text>
                  `
                : null}
            </wui-flex>`}

        <wui-flex alignItems="center">
          <wui-text variant="small-400" color="fg-200">${footerLabels.title}</wui-text>
          <wui-link @click=${this.onResendCode.bind(this)} .disabled=${isResendDisabled}>
            ${footerLabels.action}
          </wui-link>
        </wui-flex>
      </wui-flex>
    `;
        }
        startOTPTimeout() {
            this.timeoutTimeLeft = W3mFrameHelpers.getTimeToNextEmailLogin();
            this.OTPTimeout = setInterval(() => {
                if (this.timeoutTimeLeft > 0) {
                    this.timeoutTimeLeft = W3mFrameHelpers.getTimeToNextEmailLogin();
                }
                else {
                    clearInterval(this.OTPTimeout);
                }
            }, 1000);
        }
        async onOtpInputChange(event) {
            try {
                if (!this.loading) {
                    this.otp = event.detail;
                    if (this.emailConnector && this.otp.length === OTP_LENGTH) {
                        this.loading = true;
                        await this.onOtpSubmit?.(this.otp);
                    }
                }
            }
            catch (error) {
                this.error = CoreHelperUtil.parseError(error);
                this.loading = false;
            }
        }
        async onResendCode() {
            try {
                if (this.onOtpResend) {
                    if (!this.loading && !this.timeoutTimeLeft) {
                        this.error = '';
                        this.otp = '';
                        const emailConnector = ConnectorController.getEmailConnector();
                        if (!emailConnector || !this.email) {
                            throw new Error('w3m-email-otp-widget: Unable to resend email');
                        }
                        this.loading = true;
                        await this.onOtpResend(this.email);
                        this.startOTPTimeout();
                        SnackController.showSuccess('Code email resent');
                    }
                }
                else if (this.onStartOver) {
                    this.onStartOver();
                }
            }
            catch (error) {
                SnackController.showError(error);
            }
            finally {
                this.loading = false;
            }
        }
        getFooterLabels(isResendDisabled) {
            if (this.onStartOver) {
                return {
                    title: 'Something wrong?',
                    action: `Try again ${isResendDisabled ? `in ${this.timeoutTimeLeft}s` : ''}`
                };
            }
            return {
                title: `Didn't receive it?`,
                action: `Resend ${isResendDisabled ? `in ${this.timeoutTimeLeft}s` : 'Code'}`
            };
        }
    };
    W3mEmailOtpWidget.styles = styles$t;
    __decorate$G([
        r$e()
    ], W3mEmailOtpWidget.prototype, "loading", void 0);
    __decorate$G([
        r$e()
    ], W3mEmailOtpWidget.prototype, "timeoutTimeLeft", void 0);
    __decorate$G([
        r$e()
    ], W3mEmailOtpWidget.prototype, "error", void 0);
    W3mEmailOtpWidget = __decorate$G([
        customElement('w3m-email-otp-widget')
    ], W3mEmailOtpWidget);

    var __decorate$F = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let W3mEmailVerifyOtpView = class W3mEmailVerifyOtpView extends W3mEmailOtpWidget {
        constructor() {
            super();
            this.onOtpSubmit = async (otp) => {
                try {
                    if (this.emailConnector) {
                        await this.emailConnector.provider.connectOtp({ otp });
                        EventsController.sendEvent({ type: 'track', event: 'EMAIL_VERIFICATION_CODE_PASS' });
                        await ConnectionController.connectExternal(this.emailConnector);
                        ModalController.close();
                        EventsController.sendEvent({
                            type: 'track',
                            event: 'CONNECT_SUCCESS',
                            properties: { method: 'email', name: this.emailConnector.name || 'Unknown' }
                        });
                    }
                }
                catch (error) {
                    EventsController.sendEvent({ type: 'track', event: 'EMAIL_VERIFICATION_CODE_FAIL' });
                    throw error;
                }
            };
            this.onOtpResend = async (email) => {
                if (this.emailConnector) {
                    await this.emailConnector.provider.connectEmail({ email });
                    EventsController.sendEvent({ type: 'track', event: 'EMAIL_VERIFICATION_CODE_SENT' });
                }
            };
        }
    };
    W3mEmailVerifyOtpView = __decorate$F([
        customElement('w3m-email-verify-otp-view')
    ], W3mEmailVerifyOtpView);

    var styles$s = i$d `
  wui-icon-box {
    height: var(--wui-icon-box-size-xl);
    width: var(--wui-icon-box-size-xl);
  }
`;

    var __decorate$E = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let W3mEmailVerifyDeviceView = class W3mEmailVerifyDeviceView extends s$a {
        constructor() {
            super();
            this.email = RouterController.state.data?.email;
            this.emailConnector = ConnectorController.getEmailConnector();
            this.loading = false;
            this.listenForDeviceApproval();
        }
        render() {
            if (!this.email) {
                throw new Error('w3m-email-verify-device-view: No email provided');
            }
            if (!this.emailConnector) {
                throw new Error('w3m-email-verify-device-view: No email connector provided');
            }
            return x$4 `
      <wui-flex
        flexDirection="column"
        alignItems="center"
        .padding=${['xxl', 's', 'xxl', 's']}
        gap="l"
      >
        <wui-icon-box
          size="xl"
          iconcolor="accent-100"
          backgroundcolor="accent-100"
          icon="verify"
          background="opaque"
        ></wui-icon-box>

        <wui-flex flexDirection="column" alignItems="center" gap="s">
          <wui-flex flexDirection="column" alignItems="center">
            <wui-text variant="paragraph-400" color="fg-100">
              Approve the login link we sent to
            </wui-text>
            <wui-text variant="paragraph-400" color="fg-100"><b>${this.email}</b></wui-text>
          </wui-flex>

          <wui-text variant="small-400" color="fg-200" align="center">
            The code expires in 20 minutes
          </wui-text>

          <wui-flex alignItems="center" id="w3m-resend-section">
            <wui-text variant="small-400" color="fg-100" align="center">
              Didn't receive it?
            </wui-text>
            <wui-link @click=${this.onResendCode.bind(this)} .disabled=${this.loading}>
              Resend email
            </wui-link>
          </wui-flex>
        </wui-flex>
      </wui-flex>
    `;
        }
        async listenForDeviceApproval() {
            if (this.emailConnector) {
                try {
                    await this.emailConnector.provider.connectDevice();
                    EventsController.sendEvent({ type: 'track', event: 'DEVICE_REGISTERED_FOR_EMAIL' });
                    EventsController.sendEvent({ type: 'track', event: 'EMAIL_VERIFICATION_CODE_SENT' });
                    RouterController.replace('EmailVerifyOtp', { email: this.email });
                }
                catch (error) {
                    RouterController.goBack();
                }
            }
        }
        async onResendCode() {
            try {
                if (!this.loading) {
                    if (!this.emailConnector || !this.email) {
                        throw new Error('w3m-email-login-widget: Unable to resend email');
                    }
                    this.loading = true;
                    await this.emailConnector.provider.connectEmail({ email: this.email });
                    this.listenForDeviceApproval();
                    SnackController.showSuccess('Code email resent');
                }
            }
            catch (error) {
                SnackController.showError(error);
            }
            finally {
                this.loading = false;
            }
        }
    };
    W3mEmailVerifyDeviceView.styles = styles$s;
    __decorate$E([
        r$e()
    ], W3mEmailVerifyDeviceView.prototype, "loading", void 0);
    W3mEmailVerifyDeviceView = __decorate$E([
        customElement('w3m-email-verify-device-view')
    ], W3mEmailVerifyDeviceView);

    var styles$r = i$d `
  div {
    width: 100%;
    height: 400px;
  }

  [data-ready='false'] {
    transform: scale(1.05);
  }

  @media (max-width: 430px) {
    [data-ready='false'] {
      transform: translateY(-50px);
    }
  }
`;

    var __decorate$D = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let W3mApproveTransactionView = class W3mApproveTransactionView extends s$a {
        constructor() {
            super();
            this.bodyObserver = undefined;
            this.unsubscribe = [];
            this.iframe = document.getElementById('w3m-iframe');
            this.ready = false;
            this.unsubscribe.push(ModalController.subscribeKey('open', val => {
                if (!val) {
                    this.onHideIframe();
                }
            }));
        }
        disconnectedCallback() {
            this.unsubscribe.forEach(unsubscribe => unsubscribe());
            this.bodyObserver?.unobserve(window.document.body);
        }
        async firstUpdated() {
            const verticalPadding = 10;
            await this.syncTheme();
            this.iframe.style.display = 'block';
            const blueprint = this.renderRoot.querySelector('div');
            this.bodyObserver = new ResizeObserver(() => {
                const data = blueprint?.getBoundingClientRect();
                const dimensions = data ?? { left: 0, top: 0, width: 0, height: 0 };
                this.iframe.style.width = `${dimensions.width}px`;
                this.iframe.style.height = `${dimensions.height - verticalPadding}px`;
                this.iframe.style.left = `${dimensions.left}px`;
                this.iframe.style.top = `${dimensions.top + verticalPadding / 2}px`;
                this.ready = true;
            });
            this.bodyObserver.observe(window.document.body);
        }
        render() {
            if (this.ready) {
                this.onShowIframe();
            }
            return x$4 `<div data-ready=${this.ready}></div>`;
        }
        onShowIframe() {
            const isMobile = window.innerWidth <= 430;
            this.iframe.animate([
                { opacity: 0, transform: isMobile ? 'translateY(50px)' : 'scale(.95)' },
                { opacity: 1, transform: isMobile ? 'translateY(0)' : 'scale(1)' }
            ], { duration: 200, easing: 'ease', fill: 'forwards', delay: 300 });
        }
        async onHideIframe() {
            await this.iframe.animate([{ opacity: 1 }, { opacity: 0 }], {
                duration: 200,
                easing: 'ease',
                fill: 'forwards'
            }).finished;
            this.iframe.style.display = 'none';
        }
        async syncTheme() {
            const emailConnector = ConnectorController.getEmailConnector();
            if (emailConnector) {
                await emailConnector.provider.syncTheme({
                    themeVariables: ThemeController.getSnapshot().themeVariables
                });
            }
        }
    };
    W3mApproveTransactionView.styles = styles$r;
    __decorate$D([
        r$e()
    ], W3mApproveTransactionView.prototype, "ready", void 0);
    W3mApproveTransactionView = __decorate$D([
        customElement('w3m-approve-transaction-view')
    ], W3mApproveTransactionView);

    var __decorate$C = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let W3mUpgradeWalletView = class W3mUpgradeWalletView extends s$a {
        render() {
            return x$4 `
      <wui-flex flexDirection="column" alignItems="center" gap="xl" padding="xl">
        <wui-text variant="paragraph-400" color="fg-100">Follow the instructions on</wui-text>
        <wui-chip
          icon="externalLink"
          variant="fill"
          href=${ConstantsUtil$2.SECURE_SITE_DASHBOARD}
          imageSrc=${ConstantsUtil$2.SECURE_SITE_FAVICON}
          data-testid="w3m-secure-website-button"
        >
        </wui-chip>
        <wui-text variant="small-400" color="fg-200">
          You will have to reconnect for security reasons
        </wui-text>
      </wui-flex>
    `;
        }
    };
    W3mUpgradeWalletView = __decorate$C([
        customElement('w3m-upgrade-wallet-view')
    ], W3mUpgradeWalletView);

    var __decorate$B = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let W3mUpgradeToSmartAccountView = class W3mUpgradeToSmartAccountView extends s$a {
        render() {
            return x$4 `
      <wui-flex
        flexDirection="column"
        alignItems="center"
        gap="xxl"
        .padding=${['0', '0', 'l', '0']}
      >
        ${this.onboardingTemplate()} ${this.buttonsTemplate()}
        <wui-link>
          Learn more
          <wui-icon color="inherit" slot="iconRight" name="externalLink"></wui-icon>
        </wui-link>
      </wui-flex>
    `;
        }
        onboardingTemplate() {
            return x$4 ` <wui-flex
      flexDirection="column"
      gap="xxl"
      alignItems="center"
      .padding=${['0', 'xxl', '0', 'xxl']}
    >
      <wui-flex gap="s" alignItems="center" justifyContent="center">
        <wui-visual name="onrampCard"></wui-visual>
        <wui-visual name="onrampCard"></wui-visual>
        <wui-visual name="onrampCard"></wui-visual>
      </wui-flex>
      <wui-flex flexDirection="column" alignItems="center" gap="s">
        <wui-text align="center" variant="medium-600" color="fg-100">
          Discover Smart Accounts
        </wui-text>
        <wui-text align="center" variant="paragraph-400" color="fg-100">
          Access advanced features such as username, social login, improved security and a smoother
          user experience!
        </wui-text>
      </wui-flex>
    </wui-flex>`;
        }
        buttonsTemplate() {
            return x$4 `<wui-flex .padding=${['0', '2l', '0', '2l']} gap="s">
      <wui-button variant="accentBg" @click=${RouterController.goBack} size="lg" borderRadius="xs">
        Do it later
      </wui-button>
      <wui-button size="lg" borderRadius="xs"> Continue </wui-button>
    </wui-flex>`;
        }
    };
    W3mUpgradeToSmartAccountView = __decorate$B([
        customElement('w3m-upgrade-to-smart-account-view')
    ], W3mUpgradeToSmartAccountView);

    /**
     * @license
     * Copyright 2020 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */const f$6=o=>void 0===o.strings;

    /**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */
    const t$a={ATTRIBUTE:1,CHILD:2,PROPERTY:3,BOOLEAN_ATTRIBUTE:4,EVENT:5,ELEMENT:6},e$c=t=>(...e)=>({_$litDirective$:t,values:e});let i$a = class i{constructor(t){}get _$AU(){return this._$AM._$AU}_$AT(t,e,i){this._$Ct=t,this._$AM=e,this._$Ci=i;}_$AS(t,e){return this.update(t,e)}update(t,e){return this.render(...e)}};

    /**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */const s$9=(i,t)=>{const e=i._$AN;if(void 0===e)return !1;for(const i of e)i._$AO?.(t,!1),s$9(i,t);return !0},o$d=i=>{let t,e;do{if(void 0===(t=i._$AM))break;e=t._$AN,e.delete(i),i=t;}while(0===e?.size)},r$d=i=>{for(let t;t=i._$AM;i=t){let e=t._$AN;if(void 0===e)t._$AN=e=new Set;else if(e.has(i))break;e.add(i),c$9(t);}};function h$8(i){void 0!==this._$AN?(o$d(this),this._$AM=i,r$d(this)):this._$AM=i;}function n$c(i,t=!1,e=0){const r=this._$AH,h=this._$AN;if(void 0!==h&&0!==h.size)if(t)if(Array.isArray(r))for(let i=e;i<r.length;i++)s$9(r[i],!1),o$d(r[i]);else null!=r&&(s$9(r,!1),o$d(r));else s$9(this,i);}const c$9=i=>{i.type==t$a.CHILD&&(i._$AP??=n$c,i._$AQ??=h$8);};let f$5 = class f extends i$a{constructor(){super(...arguments),this._$AN=void 0;}_$AT(i,t,e){super._$AT(i,t,e),r$d(this),this.isConnected=i._$AU;}_$AO(i,t=!0){i!==this.isConnected&&(this.isConnected=i,i?this.reconnected?.():this.disconnected?.()),t&&(s$9(this,i),o$d(this));}setValue(t){if(f$6(this._$Ct))this._$Ct._$AI(t,this);else {const i=[...this._$Ct._$AH];i[this._$Ci]=t,this._$Ct._$AI(i,this,0);}}disconnected(){}reconnected(){}};

    /**
     * @license
     * Copyright 2020 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */const e$b=()=>new h$7;let h$7 = class h{};const o$c=new WeakMap,n$b=e$c(class extends f$5{render(i){return T$6}update(i,[s]){const e=s!==this.Y;return e&&void 0!==this.Y&&this.rt(void 0),(e||this.lt!==this.ct)&&(this.Y=s,this.ht=i.options?.host,this.rt(this.ct=i.element)),T$6}rt(t){if("function"==typeof this.Y){const i=this.ht??globalThis;let s=o$c.get(i);void 0===s&&(s=new WeakMap,o$c.set(i,s)),void 0!==s.get(this.Y)&&this.Y.call(this.ht,void 0),s.set(this.Y,t),void 0!==t&&this.Y.call(this.ht,t);}else this.Y.value=t;}get lt(){return "function"==typeof this.Y?o$c.get(this.ht??globalThis)?.get(this.Y):this.Y?.value}disconnected(){this.lt===this.ct&&this.rt(void 0);}reconnected(){this.rt(this.ct);}});

    var styles$q = i$d `
  wui-email-input {
    width: 100%;
  }

  form {
    width: 100%;
    display: block;
    position: relative;
  }
`;

    var __decorate$A = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let W3mUpdateEmailWalletView = class W3mUpdateEmailWalletView extends s$a {
        constructor() {
            super(...arguments);
            this.formRef = e$b();
            this.initialEmail = RouterController.state.data?.email ?? '';
            this.email = '';
            this.loading = false;
        }
        firstUpdated() {
            this.formRef.value?.addEventListener('keydown', event => {
                if (event.key === 'Enter') {
                    this.onSubmitEmail(event);
                }
            });
        }
        render() {
            const showSubmit = !this.loading && this.email.length > 3 && this.email !== this.initialEmail;
            return x$4 `
      <wui-flex flexDirection="column" padding="m" gap="m">
        <form ${n$b(this.formRef)} @submit=${this.onSubmitEmail.bind(this)}>
          <wui-email-input
            value=${this.initialEmail}
            .disabled=${this.loading}
            @inputChange=${this.onEmailInputChange.bind(this)}
          >
          </wui-email-input>
          <input type="submit" hidden />
        </form>

        <wui-flex gap="s">
          <wui-button size="md" variant="shade" fullWidth @click=${RouterController.goBack}>
            Cancel
          </wui-button>

          <wui-button
            size="md"
            variant="fill"
            fullWidth
            @click=${this.onSubmitEmail.bind(this)}
            .disabled=${!showSubmit}
            .loading=${this.loading}
          >
            Save
          </wui-button>
        </wui-flex>
      </wui-flex>
    `;
        }
        onEmailInputChange(event) {
            this.email = event.detail;
        }
        async onSubmitEmail(event) {
            try {
                if (this.loading) {
                    return;
                }
                this.loading = true;
                event.preventDefault();
                const emailConnector = ConnectorController.getEmailConnector();
                if (!emailConnector) {
                    throw new Error('w3m-update-email-wallet: Email connector not found');
                }
                await emailConnector.provider.updateEmail({ email: this.email });
                EventsController.sendEvent({ type: 'track', event: 'EMAIL_EDIT' });
                RouterController.replace('UpdateEmailPrimaryOtp', {
                    email: this.initialEmail,
                    newEmail: this.email
                });
            }
            catch (error) {
                SnackController.showError(error);
                this.loading = false;
            }
        }
    };
    W3mUpdateEmailWalletView.styles = styles$q;
    __decorate$A([
        r$e()
    ], W3mUpdateEmailWalletView.prototype, "email", void 0);
    __decorate$A([
        r$e()
    ], W3mUpdateEmailWalletView.prototype, "loading", void 0);
    W3mUpdateEmailWalletView = __decorate$A([
        customElement('w3m-update-email-wallet-view')
    ], W3mUpdateEmailWalletView);

    var __decorate$z = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let W3mUpdateEmailPrimaryOtpView = class W3mUpdateEmailPrimaryOtpView extends W3mEmailOtpWidget {
        constructor() {
            super();
            this.email = RouterController.state.data?.email;
            this.onOtpSubmit = async (otp) => {
                try {
                    if (this.emailConnector) {
                        await this.emailConnector.provider.updateEmailPrimaryOtp({ otp });
                        EventsController.sendEvent({ type: 'track', event: 'EMAIL_VERIFICATION_CODE_PASS' });
                        RouterController.replace('UpdateEmailSecondaryOtp', RouterController.state.data);
                    }
                }
                catch (error) {
                    EventsController.sendEvent({ type: 'track', event: 'EMAIL_VERIFICATION_CODE_FAIL' });
                    throw error;
                }
            };
            this.onStartOver = () => {
                RouterController.replace('UpdateEmailWallet', RouterController.state.data);
            };
        }
    };
    W3mUpdateEmailPrimaryOtpView = __decorate$z([
        customElement('w3m-update-email-primary-otp-view')
    ], W3mUpdateEmailPrimaryOtpView);

    var __decorate$y = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let W3mUpdateEmailSecondaryOtpView = class W3mUpdateEmailSecondaryOtpView extends W3mEmailOtpWidget {
        constructor() {
            super();
            this.email = RouterController.state.data?.newEmail;
            this.onOtpSubmit = async (otp) => {
                try {
                    if (this.emailConnector) {
                        await this.emailConnector.provider.updateEmailSecondaryOtp({ otp });
                        EventsController.sendEvent({ type: 'track', event: 'EMAIL_VERIFICATION_CODE_PASS' });
                        RouterController.reset('Account');
                    }
                }
                catch (error) {
                    EventsController.sendEvent({ type: 'track', event: 'EMAIL_VERIFICATION_CODE_FAIL' });
                    throw error;
                }
            };
            this.onStartOver = () => {
                RouterController.replace('UpdateEmailWallet', RouterController.state.data);
            };
        }
    };
    W3mUpdateEmailSecondaryOtpView = __decorate$y([
        customElement('w3m-update-email-secondary-otp-view')
    ], W3mUpdateEmailSecondaryOtpView);

    var styles$p = i$d `
  :host > wui-flex {
    max-height: clamp(360px, 540px, 80vh);
    overflow: scroll;
    scrollbar-width: none;
  }

  :host > wui-flex::-webkit-scrollbar {
    display: none;
  }
`;

    var __decorate$x = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let W3mUnsupportedChainView = class W3mUnsupportedChainView extends s$a {
        constructor() {
            super(...arguments);
            this.disconecting = false;
        }
        render() {
            return x$4 `
      <wui-flex class="container" flexDirection="column" gap="0">
        <wui-flex
          class="container"
          flexDirection="column"
          .padding=${['m', 'xl', 'xs', 'xl']}
          alignItems="center"
          gap="xl"
        >
          <wui-text variant="small-400" color="fg-200" align="center">
            This app doesn’t support your current network. Switch to an available option following
            to continue.
          </wui-text>
        </wui-flex>

        <wui-flex flexDirection="column" padding="s" gap="xs">
          ${this.networksTemplate()}
        </wui-flex>

        <wui-separator text="or"></wui-separator>
        <wui-flex flexDirection="column" padding="s" gap="xs">
          <wui-list-item
            variant="icon"
            iconVariant="overlay"
            icon="disconnect"
            ?chevron=${false}
            .loading=${this.disconecting}
            @click=${this.onDisconnect.bind(this)}
            data-testid="disconnect-button"
          >
            <wui-text variant="paragraph-500" color="fg-200">Disconnect</wui-text>
          </wui-list-item>
        </wui-flex>
      </wui-flex>
    `;
        }
        networksTemplate() {
            const { approvedCaipNetworkIds, requestedCaipNetworks } = NetworkController.state;
            const sortedNetworks = CoreHelperUtil.sortRequestedNetworks(approvedCaipNetworkIds, requestedCaipNetworks);
            return sortedNetworks.map(network => x$4 `
        <wui-list-network
          imageSrc=${o$e(AssetUtil.getNetworkImage(network))}
          name=${network.name ?? 'Unknown'}
          @click=${() => this.onSwitchNetwork(network)}
        >
        </wui-list-network>
      `);
        }
        async onDisconnect() {
            try {
                this.disconecting = true;
                await ConnectionController.disconnect();
                EventsController.sendEvent({
                    type: 'track',
                    event: 'DISCONNECT_SUCCESS'
                });
                ModalController.close();
            }
            catch {
                EventsController.sendEvent({ type: 'track', event: 'DISCONNECT_ERROR' });
                SnackController.showError('Failed to disconnect');
            }
            finally {
                this.disconecting = false;
            }
        }
        async onSwitchNetwork(network) {
            const { isConnected } = AccountController.state;
            const { approvedCaipNetworkIds, supportsAllNetworks, caipNetwork } = NetworkController.state;
            const { data } = RouterController.state;
            if (isConnected && caipNetwork?.id !== network.id) {
                if (approvedCaipNetworkIds?.includes(network.id)) {
                    await NetworkController.switchActiveNetwork(network);
                    RouterUtil.navigateAfterNetworkSwitch();
                }
                else if (supportsAllNetworks) {
                    RouterController.push('SwitchNetwork', { ...data, network });
                }
            }
            else if (!isConnected) {
                NetworkController.setCaipNetwork(network);
                RouterController.push('Connect');
            }
        }
    };
    W3mUnsupportedChainView.styles = styles$p;
    __decorate$x([
        r$e()
    ], W3mUnsupportedChainView.prototype, "disconecting", void 0);
    W3mUnsupportedChainView = __decorate$x([
        customElement('w3m-unsupported-chain-view')
    ], W3mUnsupportedChainView);

    var styles$o = i$d `
  wui-compatible-network {
    margin-top: var(--wui-spacing-l);
  }
`;

    var __decorate$w = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let W3mWalletReceiveView = class W3mWalletReceiveView extends s$a {
        constructor() {
            super();
            this.unsubscribe = [];
            this.address = AccountController.state.address;
            this.profileName = AccountController.state.profileName;
            this.network = NetworkController.state.caipNetwork;
            this.unsubscribe.push(...[
                AccountController.subscribe(val => {
                    if (val.address) {
                        this.address = val.address;
                        this.profileName = val.profileName;
                    }
                    else {
                        SnackController.showError('Account not found');
                    }
                })
            ], NetworkController.subscribeKey('caipNetwork', val => {
                if (val?.id) {
                    this.network = val;
                }
            }));
        }
        disconnectedCallback() {
            this.unsubscribe.forEach(unsubscribe => unsubscribe());
        }
        render() {
            if (!this.address) {
                throw new Error('w3m-wallet-receive-view: No account provided');
            }
            const networkImage = AssetUtil.getNetworkImage(this.network);
            return x$4 ` <wui-flex
      flexDirection="column"
      .padding=${['xl', 'l', 'l', 'l']}
      alignItems="center"
    >
      <wui-chip-button
        @click=${this.onCopyClick.bind(this)}
        text=${UiHelperUtil.getTruncateString({
            string: this.address ?? '',
            charsStart: this.profileName ? 18 : 4,
            charsEnd: this.profileName ? 0 : 4,
            truncate: this.profileName ? 'end' : 'middle'
        })}
        icon="copy"
        imageSrc=${networkImage ? networkImage : ''}
        variant="shadeSmall"
      ></wui-chip-button>
      <wui-flex
        flexDirection="column"
        .padding=${['l', '0', '0', '0']}
        alignItems="center"
        gap="s"
      >
        <wui-qr-code
          size=${232}
          theme=${ThemeController.state.themeMode}
          uri=${this.address}
          ?arenaClear=${true}
          data-testid="wui-qr-code"
        ></wui-qr-code>
        <wui-text variant="paragraph-500" color="fg-100" align="center">
          Copy your address or scan this QR code
        </wui-text>
      </wui-flex>
      ${this.networkTemplate()}
    </wui-flex>`;
        }
        networkTemplate() {
            const networks = NetworkController.getRequestedCaipNetworks();
            const slicedNetworks = networks?.filter(network => network?.imageId)?.slice(0, 5);
            const imagesArray = slicedNetworks.map(AssetUtil.getNetworkImage).filter(Boolean);
            return x$4 `<wui-compatible-network
      @click=${this.onReceiveClick.bind(this)}
      text="Only receive assets on these networks"
      .networkImages=${imagesArray}
    ></wui-compatible-network>`;
        }
        onReceiveClick() {
            RouterController.push('WalletCompatibleNetworks');
        }
        onCopyClick() {
            try {
                if (this.address) {
                    CoreHelperUtil.copyToClopboard(this.address);
                    SnackController.showSuccess('Address copied');
                }
            }
            catch {
                SnackController.showError('Failed to copy');
            }
        }
    };
    W3mWalletReceiveView.styles = styles$o;
    __decorate$w([
        r$e()
    ], W3mWalletReceiveView.prototype, "address", void 0);
    __decorate$w([
        r$e()
    ], W3mWalletReceiveView.prototype, "profileName", void 0);
    __decorate$w([
        r$e()
    ], W3mWalletReceiveView.prototype, "network", void 0);
    W3mWalletReceiveView = __decorate$w([
        customElement('w3m-wallet-receive-view')
    ], W3mWalletReceiveView);

    var styles$n = i$d `
  :host > wui-flex {
    max-height: clamp(360px, 540px, 80vh);
    overflow: scroll;
    scrollbar-width: none;
  }

  :host > wui-flex::-webkit-scrollbar {
    display: none;
  }
`;

    var __decorate$v = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let W3mWalletCompatibleNetworksView = class W3mWalletCompatibleNetworksView extends s$a {
        render() {
            return x$4 ` <wui-flex
      flexDirection="column"
      .padding=${['xs', 's', 'm', 's']}
      gap="xs"
    >
      <wui-banner
        icon="warningCircle"
        text="You can only receive assets on these networks"
      ></wui-banner>
      ${this.networkTemplate()}
    </wui-flex>`;
        }
        networkTemplate() {
            const { approvedCaipNetworkIds, requestedCaipNetworks } = NetworkController.state;
            const sortedNetworks = CoreHelperUtil.sortRequestedNetworks(approvedCaipNetworkIds, requestedCaipNetworks);
            return sortedNetworks.map(network => x$4 `
        <wui-list-network
          imageSrc=${o$e(AssetUtil.getNetworkImage(network))}
          name=${network.name ?? 'Unknown'}
          ?transparent=${true}
        >
        </wui-list-network>
      `);
        }
    };
    W3mWalletCompatibleNetworksView.styles = styles$n;
    W3mWalletCompatibleNetworksView = __decorate$v([
        customElement('w3m-wallet-compatible-networks-view')
    ], W3mWalletCompatibleNetworksView);

    var styles$m = i$d `
  :host {
    display: block;
  }

  wui-flex {
    position: relative;
  }

  wui-icon-box {
    width: 40px;
    height: 40px;
    border-radius: var(--wui-border-radius-xs) !important;
    border: 5px solid var(--wui-color-bg-125);
    background: var(--wui-color-bg-175);
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    z-index: 1;
  }

  wui-button {
    --local-border-radius: var(--wui-border-radius-xs) !important;
  }

  .inputContainer {
    height: fit-content;
  }
`;

    var __decorate$u = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let W3mWalletSendView = class W3mWalletSendView extends s$a {
        constructor() {
            super();
            this.unsubscribe = [];
            this.token = SendController.state.token;
            this.sendTokenAmount = SendController.state.sendTokenAmount;
            this.receiverAddress = SendController.state.receiverAddress;
            this.message = 'Preview Send';
            this.unsubscribe.push(...[
                SendController.subscribe(val => {
                    this.token = val.token;
                    this.sendTokenAmount = val.sendTokenAmount;
                    this.receiverAddress = val.receiverAddress;
                })
            ]);
        }
        disconnectedCallback() {
            this.unsubscribe.forEach(unsubscribe => unsubscribe());
        }
        render() {
            this.getMessage();
            return x$4 ` <wui-flex flexDirection="column" .padding=${['s', 'l', 'l', 'l']}>
      <wui-flex class="inputContainer" gap="xs" flexDirection="column">
        <w3m-input-token
          .token=${this.token}
          .sendTokenAmount=${this.sendTokenAmount}
        ></w3m-input-token>
        <wui-icon-box
          size="inherit"
          backgroundColor="fg-300"
          iconSize="lg"
          iconColor="fg-250"
          background="opaque"
          icon="arrowBottom"
        ></wui-icon-box>
        <w3m-input-address .receiverAddress=${this.receiverAddress}></w3m-input-address>
      </wui-flex>
      <wui-flex .margin=${['l', '0', '0', '0']}>
        <wui-button
          @click=${this.onButtonClick.bind(this)}
          ?disabled=${!this.message.startsWith('Preview Send')}
          size="lg"
          variant="fill"
          fullWidth
        >
          ${this.message}
        </wui-button>
      </wui-flex>
    </wui-flex>`;
        }
        onButtonClick() {
            RouterController.push('WalletSendPreview');
        }
        getMessage() {
            this.message = 'Preview Send';
            if (this.receiverAddress && !CoreHelperUtil.isAddress(this.receiverAddress)) {
                this.message = 'Invalid Address';
            }
            if (!this.receiverAddress) {
                this.message = 'Add Address';
            }
            if (this.sendTokenAmount &&
                this.token &&
                this.sendTokenAmount > Number(this.token.quantity.numeric)) {
                this.message = 'Insufficient Funds';
            }
            if (!this.sendTokenAmount) {
                this.message = 'Add Amount';
            }
            if (!this.token) {
                this.message = 'Select Token';
            }
        }
    };
    W3mWalletSendView.styles = styles$m;
    __decorate$u([
        r$e()
    ], W3mWalletSendView.prototype, "token", void 0);
    __decorate$u([
        r$e()
    ], W3mWalletSendView.prototype, "sendTokenAmount", void 0);
    __decorate$u([
        r$e()
    ], W3mWalletSendView.prototype, "receiverAddress", void 0);
    __decorate$u([
        r$e()
    ], W3mWalletSendView.prototype, "message", void 0);
    W3mWalletSendView = __decorate$u([
        customElement('w3m-wallet-send-view')
    ], W3mWalletSendView);

    var styles$l = i$d `
  .contentContainer {
    height: 440px;
    overflow: scroll;
    scrollbar-width: none;
  }

  wui-icon-box {
    width: 40px;
    height: 40px;
    border-radius: var(--wui-border-radius-xxs);
  }
`;

    var __decorate$t = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let W3mSendSelectTokenView = class W3mSendSelectTokenView extends s$a {
        constructor() {
            super();
            this.unsubscribe = [];
            this.tokenBalance = AccountController.state.tokenBalance;
            this.search = '';
            this.onDebouncedSearch = CoreHelperUtil.debounce((value) => {
                this.search = value;
            });
            this.unsubscribe.push(...[
                AccountController.subscribe(val => {
                    this.tokenBalance = val.tokenBalance;
                })
            ]);
        }
        disconnectedCallback() {
            this.unsubscribe.forEach(unsubscribe => unsubscribe());
        }
        render() {
            return x$4 `
      <wui-flex flexDirection="column">
        ${this.templateSearchInput()} <wui-separator></wui-separator> ${this.templateTokens()}
      </wui-flex>
    `;
        }
        templateSearchInput() {
            return x$4 `
      <wui-flex gap="xs" padding="s">
        <wui-input-text
          @inputChange=${this.onInputChange.bind(this)}
          class="network-search-input"
          size="sm"
          placeholder="Search token"
          icon="search"
        ></wui-input-text>
      </wui-flex>
    `;
        }
        templateTokens() {
            if (this.search) {
                this.tokens = this.tokenBalance?.filter(token => token.name.toLowerCase().includes(this.search.toLowerCase()));
            }
            else {
                this.tokens = this.tokenBalance;
            }
            return x$4 `
      <wui-flex
        class="contentContainer"
        flexDirection="column"
        .padding=${['0', 's', '0', 's']}
      >
        <wui-flex justifyContent="flex-start" .padding=${['m', 's', 's', 's']}>
          <wui-text variant="paragraph-500" color="fg-200">Your tokens</wui-text>
        </wui-flex>
        <wui-flex flexDirection="column" gap="xs">
          ${this.tokens && this.tokens.length > 0
            ? this.tokens.map(token => x$4 `<wui-list-token
                    @click=${this.handleTokenClick.bind(this, token)}
                    ?clickable=${true}
                    tokenName=${token.name}
                    tokenImageUrl=${token.iconUrl}
                    tokenAmount=${token.quantity.numeric}
                    tokenValue=${token.value}
                    tokenCurrency=${token.symbol}
                  ></wui-list-token>`)
            : x$4 `<wui-flex
                .padding=${['4xl', '0', '0', '0']}
                alignItems="center"
                flexDirection="column"
                gap="l"
              >
                <wui-icon-box
                  icon="coinPlaceholder"
                  size="inherit"
                  iconColor="fg-200"
                  backgroundColor="fg-200"
                  iconSize="lg"
                ></wui-icon-box>
                <wui-flex
                  class="textContent"
                  gap="xs"
                  flexDirection="column"
                  justifyContent="center"
                  flexDirection="column"
                >
                  <wui-text variant="paragraph-500" align="center" color="fg-100"
                    >No tokens found</wui-text
                  >
                  <wui-text variant="small-400" align="center" color="fg-200"
                    >Your tokens will appear here</wui-text
                  >
                </wui-flex>
                <wui-link @click=${this.onBuyClick.bind(this)}>Buy</wui-link>
              </wui-flex>`}
        </wui-flex>
      </wui-flex>
    `;
        }
        onBuyClick() {
            RouterController.push('OnRampProviders');
        }
        onInputChange(event) {
            this.onDebouncedSearch(event.detail);
        }
        handleTokenClick(token) {
            SendController.setToken(token);
            SendController.setTokenAmount(undefined);
            RouterController.goBack();
        }
    };
    W3mSendSelectTokenView.styles = styles$l;
    __decorate$t([
        r$e()
    ], W3mSendSelectTokenView.prototype, "tokenBalance", void 0);
    __decorate$t([
        r$e()
    ], W3mSendSelectTokenView.prototype, "tokens", void 0);
    __decorate$t([
        r$e()
    ], W3mSendSelectTokenView.prototype, "search", void 0);
    W3mSendSelectTokenView = __decorate$t([
        customElement('w3m-wallet-send-select-token-view')
    ], W3mSendSelectTokenView);

    var styles$k = i$d `
  wui-avatar,
  wui-image {
    display: ruby;
    width: 32px;
    height: 32px;
    border-radius: var(--wui-border-radius-3xl);
  }

  .sendButton {
    width: 70%;
    --local-width: 100% !important;
    --local-border-radius: var(--wui-border-radius-xs) !important;
  }

  .cancelButton {
    width: 30%;
    --local-width: 100% !important;
    --local-border-radius: var(--wui-border-radius-xs) !important;
  }
`;

    var __decorate$s = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let W3mWalletSendPreviewView = class W3mWalletSendPreviewView extends s$a {
        constructor() {
            super();
            this.unsubscribe = [];
            this.token = SendController.state.token;
            this.sendTokenAmount = SendController.state.sendTokenAmount;
            this.receiverAddress = SendController.state.receiverAddress;
            this.caipNetwork = NetworkController.state.caipNetwork;
            this.unsubscribe.push(...[
                SendController.subscribe(val => {
                    this.token = val.token;
                    this.sendTokenAmount = val.sendTokenAmount;
                    this.receiverAddress = val.receiverAddress;
                }),
                NetworkController.subscribeKey('caipNetwork', val => (this.caipNetwork = val))
            ]);
        }
        disconnectedCallback() {
            this.unsubscribe.forEach(unsubscribe => unsubscribe());
        }
        render() {
            return x$4 ` <wui-flex flexDirection="column" .padding=${['s', 'l', 'l', 'l']}>
      <wui-flex gap="xs" flexDirection="column" .padding=${['0', 'xs', '0', 'xs']}>
        <wui-flex alignItems="center" justifyContent="space-between">
          <wui-flex flexDirection="column" gap="4xs">
            <wui-text variant="small-400" color="fg-150">Send</wui-text>
            ${this.sendValueTemplate()}
          </wui-flex>
          <wui-preview-item
            text="${Number(this.token?.quantity.numeric).toFixed(2)} ${this.token?.symbol}"
            .imageSrc=${this.token?.iconUrl}
          ></wui-preview-item>
        </wui-flex>
        <wui-flex>
          <wui-icon color="fg-200" size="md" name="arrowBottom"></wui-icon>
        </wui-flex>
        <wui-flex alignItems="center" justifyContent="space-between">
          <wui-text variant="small-400" color="fg-150">To</wui-text>
          <wui-preview-item
            text=${UiHelperUtil.getTruncateString({
            string: this.receiverAddress ?? '',
            charsStart: 4,
            charsEnd: 4,
            truncate: 'middle'
        })}
            address=${this.receiverAddress ?? ''}
            .isAddress=${true}
          ></wui-preview-item>
        </wui-flex>
      </wui-flex>
      <wui-flex flexDirection="column" .padding=${['xxl', '0', '0', '0']}>
        <w3m-wallet-send-details
          .caipNetwork=${this.caipNetwork}
          .receiverAddress=${this.receiverAddress}
        ></w3m-wallet-send-details>
        <wui-flex justifyContent="center" gap="xxs" .padding=${['s', '0', '0', '0']}>
          <wui-icon size="sm" color="fg-200" name="warningCircle"></wui-icon>
          <wui-text variant="small-400" color="fg-200">Review transaction carefully</wui-text>
        </wui-flex>
        <wui-flex justifyContent="center" gap="s" .padding=${['l', '0', '0', '0']}>
          <wui-button
            class="cancelButton"
            @click=${this.onCancelClick.bind(this)}
            size="lg"
            variant="shade"
          >
            Cancel
          </wui-button>
          <wui-button
            class="sendButton"
            @click=${this.onSendClick.bind(this)}
            size="lg"
            variant="fill"
          >
            Send
          </wui-button>
        </wui-flex>
      </wui-flex></wui-flex
    >`;
        }
        sendValueTemplate() {
            if (this.token && this.sendTokenAmount) {
                const price = this.token.price;
                const totalValue = price * this.sendTokenAmount;
                return x$4 `<wui-text variant="paragraph-400" color="fg-100"
        >$${totalValue.toFixed(2)}</wui-text
      >`;
            }
            return null;
        }
        onSendClick() {
            RouterController.reset('Account');
            setTimeout(() => {
                SendController.resetSend();
            }, 200);
        }
        onCancelClick() {
            RouterController.goBack();
        }
    };
    W3mWalletSendPreviewView.styles = styles$k;
    __decorate$s([
        r$e()
    ], W3mWalletSendPreviewView.prototype, "token", void 0);
    __decorate$s([
        r$e()
    ], W3mWalletSendPreviewView.prototype, "sendTokenAmount", void 0);
    __decorate$s([
        r$e()
    ], W3mWalletSendPreviewView.prototype, "receiverAddress", void 0);
    __decorate$s([
        r$e()
    ], W3mWalletSendPreviewView.prototype, "caipNetwork", void 0);
    W3mWalletSendPreviewView = __decorate$s([
        customElement('w3m-wallet-send-preview-view')
    ], W3mWalletSendPreviewView);

    var styles$j = i$d `
  wui-grid {
    max-height: clamp(360px, 400px, 80vh);
    overflow: scroll;
    scrollbar-width: none;
    grid-auto-rows: min-content;
    grid-template-columns: repeat(auto-fill, 76px);
  }

  @media (max-width: 435px) {
    wui-grid {
      grid-template-columns: repeat(auto-fill, 77px);
    }
  }

  wui-grid[data-scroll='false'] {
    overflow: hidden;
  }

  wui-grid::-webkit-scrollbar {
    display: none;
  }

  wui-loading-spinner {
    padding-top: var(--wui-spacing-l);
    padding-bottom: var(--wui-spacing-l);
    justify-content: center;
    grid-column: 1 / span 4;
  }
`;

    function markWalletsAsInstalled(wallets) {
        const { connectors } = ConnectorController.state;
        const installedConnectors = connectors
            .filter(c => c.type === 'ANNOUNCED')
            .reduce((acum, val) => {
            if (!val.info?.rdns) {
                return acum;
            }
            acum[val.info.rdns] = true;
            return acum;
        }, {});
        const walletsWithInstalled = wallets.map(wallet => ({
            ...wallet,
            installed: Boolean(wallet.rdns) && Boolean(installedConnectors[wallet.rdns ?? ''])
        }));
        const sortedWallets = walletsWithInstalled.sort((a, b) => Number(b.installed) - Number(a.installed));
        return sortedWallets;
    }

    var __decorate$r = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    const PAGINATOR_ID$1 = 'local-paginator';
    let W3mAllWalletsList = class W3mAllWalletsList extends s$a {
        constructor() {
            super();
            this.unsubscribe = [];
            this.paginationObserver = undefined;
            this.initial = !ApiController.state.wallets.length;
            this.wallets = ApiController.state.wallets;
            this.recommended = ApiController.state.recommended;
            this.featured = ApiController.state.featured;
            this.unsubscribe.push(...[
                ApiController.subscribeKey('wallets', val => (this.wallets = val)),
                ApiController.subscribeKey('recommended', val => (this.recommended = val)),
                ApiController.subscribeKey('featured', val => (this.featured = val))
            ]);
        }
        firstUpdated() {
            this.initialFetch();
            this.createPaginationObserver();
        }
        disconnectedCallback() {
            this.unsubscribe.forEach(unsubscribe => unsubscribe());
            this.paginationObserver?.disconnect();
        }
        render() {
            return x$4 `
      <wui-grid
        data-scroll=${!this.initial}
        .padding=${['0', 's', 's', 's']}
        columnGap="xxs"
        rowGap="l"
        justifyContent="space-between"
      >
        ${this.initial ? this.shimmerTemplate(16) : this.walletsTemplate()}
        ${this.paginationLoaderTemplate()}
      </wui-grid>
    `;
        }
        async initialFetch() {
            const gridEl = this.shadowRoot?.querySelector('wui-grid');
            if (this.initial && gridEl) {
                await ApiController.fetchWallets({ page: 1 });
                await gridEl.animate([{ opacity: 1 }, { opacity: 0 }], {
                    duration: 200,
                    fill: 'forwards',
                    easing: 'ease'
                }).finished;
                this.initial = false;
                gridEl.animate([{ opacity: 0 }, { opacity: 1 }], {
                    duration: 200,
                    fill: 'forwards',
                    easing: 'ease'
                });
            }
        }
        shimmerTemplate(items, id) {
            return [...Array(items)].map(() => x$4 `
        <wui-card-select-loader type="wallet" id=${o$e(id)}></wui-card-select-loader>
      `);
        }
        walletsTemplate() {
            const wallets = [...this.featured, ...this.recommended, ...this.wallets];
            const walletsWithInstalled = markWalletsAsInstalled(wallets);
            return walletsWithInstalled.map(wallet => x$4 `
        <wui-card-select
          imageSrc=${o$e(AssetUtil.getWalletImage(wallet))}
          type="wallet"
          name=${wallet.name}
          @click=${() => this.onConnectWallet(wallet)}
          .installed=${wallet.installed}
        ></wui-card-select>
      `);
        }
        paginationLoaderTemplate() {
            const { wallets, recommended, featured, count } = ApiController.state;
            const columns = window.innerWidth < 352 ? 3 : 4;
            const currentWallets = wallets.length + recommended.length;
            const minimumRows = Math.ceil(currentWallets / columns);
            let shimmerCount = minimumRows * columns - currentWallets + columns;
            shimmerCount -= wallets.length ? featured.length % columns : 0;
            if (count === 0 && featured.length > 0) {
                return null;
            }
            if (count === 0 || [...featured, ...wallets, ...recommended].length < count) {
                return this.shimmerTemplate(shimmerCount, PAGINATOR_ID$1);
            }
            return null;
        }
        createPaginationObserver() {
            const loaderEl = this.shadowRoot?.querySelector(`#${PAGINATOR_ID$1}`);
            if (loaderEl) {
                this.paginationObserver = new IntersectionObserver(([element]) => {
                    if (element?.isIntersecting && !this.initial) {
                        const { page, count, wallets } = ApiController.state;
                        if (wallets.length < count) {
                            ApiController.fetchWallets({ page: page + 1 });
                        }
                    }
                });
                this.paginationObserver.observe(loaderEl);
            }
        }
        onConnectWallet(wallet) {
            const connector = ConnectorController.getConnector(wallet.id, wallet.rdns);
            if (connector) {
                RouterController.push('ConnectingExternal', { connector });
            }
            else {
                RouterController.push('ConnectingWalletConnect', { wallet });
            }
        }
    };
    W3mAllWalletsList.styles = styles$j;
    __decorate$r([
        r$e()
    ], W3mAllWalletsList.prototype, "initial", void 0);
    __decorate$r([
        r$e()
    ], W3mAllWalletsList.prototype, "wallets", void 0);
    __decorate$r([
        r$e()
    ], W3mAllWalletsList.prototype, "recommended", void 0);
    __decorate$r([
        r$e()
    ], W3mAllWalletsList.prototype, "featured", void 0);
    W3mAllWalletsList = __decorate$r([
        customElement('w3m-all-wallets-list')
    ], W3mAllWalletsList);

    var styles$i = i$d `
  wui-grid,
  wui-loading-spinner,
  wui-flex {
    height: 360px;
  }

  wui-grid {
    overflow: scroll;
    scrollbar-width: none;
    grid-auto-rows: min-content;
  }

  wui-grid[data-scroll='false'] {
    overflow: hidden;
  }

  wui-grid::-webkit-scrollbar {
    display: none;
  }

  wui-loading-spinner {
    justify-content: center;
    align-items: center;
  }
`;

    var __decorate$q = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let W3mAllWalletsSearch = class W3mAllWalletsSearch extends s$a {
        constructor() {
            super(...arguments);
            this.prevQuery = '';
            this.loading = true;
            this.query = '';
        }
        render() {
            this.onSearch();
            return this.loading
                ? x$4 `<wui-loading-spinner color="accent-100"></wui-loading-spinner>`
                : this.walletsTemplate();
        }
        async onSearch() {
            if (this.query !== this.prevQuery) {
                this.prevQuery = this.query;
                this.loading = true;
                await ApiController.searchWallet({ search: this.query });
                this.loading = false;
            }
        }
        walletsTemplate() {
            const { search } = ApiController.state;
            const wallets = markWalletsAsInstalled(search);
            if (!search.length) {
                return x$4 `
        <wui-flex justifyContent="center" alignItems="center" gap="s" flexDirection="column">
          <wui-icon-box
            size="lg"
            iconColor="fg-200"
            backgroundColor="fg-300"
            icon="wallet"
            background="transparent"
          ></wui-icon-box>
          <wui-text color="fg-200" variant="paragraph-500">No Wallet found</wui-text>
        </wui-flex>
      `;
            }
            return x$4 `
      <wui-grid
        .padding=${['0', 's', 's', 's']}
        gridTemplateColumns="repeat(4, 1fr)"
        rowGap="l"
        columnGap="xs"
      >
        ${wallets.map(wallet => x$4 `
            <wui-card-select
              imageSrc=${o$e(AssetUtil.getWalletImage(wallet))}
              type="wallet"
              name=${wallet.name}
              @click=${() => this.onConnectWallet(wallet)}
              .installed=${wallet.installed}
            ></wui-card-select>
          `)}
      </wui-grid>
    `;
        }
        onConnectWallet(wallet) {
            const connector = ConnectorController.getConnector(wallet.id, wallet.rdns);
            if (connector) {
                RouterController.push('ConnectingExternal', { connector });
            }
            else {
                RouterController.push('ConnectingWalletConnect', { wallet });
            }
        }
    };
    W3mAllWalletsSearch.styles = styles$i;
    __decorate$q([
        r$e()
    ], W3mAllWalletsSearch.prototype, "loading", void 0);
    __decorate$q([
        n$d()
    ], W3mAllWalletsSearch.prototype, "query", void 0);
    W3mAllWalletsSearch = __decorate$q([
        customElement('w3m-all-wallets-search')
    ], W3mAllWalletsSearch);

    var __decorate$p = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let W3mConnectingHeader = class W3mConnectingHeader extends s$a {
        constructor() {
            super();
            this.platformTabs = [];
            this.unsubscribe = [];
            this.platforms = [];
            this.onSelectPlatfrom = undefined;
            this.buffering = false;
            this.unsubscribe.push(ConnectionController.subscribeKey('buffering', val => (this.buffering = val)));
        }
        disconnectCallback() {
            this.unsubscribe.forEach(unsubscribe => unsubscribe());
        }
        render() {
            const tabs = this.generateTabs();
            return x$4 `
      <wui-flex justifyContent="center" .padding=${['l', '0', '0', '0']}>
        <wui-tabs
          ?disabled=${this.buffering}
          .tabs=${tabs}
          .onTabChange=${this.onTabChange.bind(this)}
        ></wui-tabs>
      </wui-flex>
    `;
        }
        generateTabs() {
            const tabs = this.platforms.map(platform => {
                if (platform === 'browser') {
                    return { label: 'Browser', icon: 'extension', platform: 'browser' };
                }
                else if (platform === 'mobile') {
                    return { label: 'Mobile', icon: 'mobile', platform: 'mobile' };
                }
                else if (platform === 'qrcode') {
                    return { label: 'Mobile', icon: 'mobile', platform: 'qrcode' };
                }
                else if (platform === 'web') {
                    return { label: 'Webapp', icon: 'browser', platform: 'web' };
                }
                else if (platform === 'desktop') {
                    return { label: 'Desktop', icon: 'desktop', platform: 'desktop' };
                }
                return { label: 'Browser', icon: 'extension', platform: 'unsupported' };
            });
            this.platformTabs = tabs.map(({ platform }) => platform);
            return tabs;
        }
        onTabChange(index) {
            const tab = this.platformTabs[index];
            if (tab) {
                this.onSelectPlatfrom?.(tab);
            }
        }
    };
    __decorate$p([
        n$d({ type: Array })
    ], W3mConnectingHeader.prototype, "platforms", void 0);
    __decorate$p([
        n$d()
    ], W3mConnectingHeader.prototype, "onSelectPlatfrom", void 0);
    __decorate$p([
        r$e()
    ], W3mConnectingHeader.prototype, "buffering", void 0);
    W3mConnectingHeader = __decorate$p([
        customElement('w3m-connecting-header')
    ], W3mConnectingHeader);

    var __decorate$o = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let W3mConnectingWcBrowser = class W3mConnectingWcBrowser extends W3mConnectingWidget {
        constructor() {
            super();
            if (!this.wallet) {
                throw new Error('w3m-connecting-wc-browser: No wallet provided');
            }
            this.onConnect = this.onConnectProxy.bind(this);
            this.onAutoConnect = this.onConnectProxy.bind(this);
            EventsController.sendEvent({
                type: 'track',
                event: 'SELECT_WALLET',
                properties: { name: this.wallet.name, platform: 'browser' }
            });
        }
        async onConnectProxy() {
            try {
                this.error = false;
                const { connectors } = ConnectorController.state;
                const announcedConnector = connectors.find(c => c.type === 'ANNOUNCED' && c.info?.rdns === this.wallet?.rdns);
                const injectedConnector = connectors.find(c => c.type === 'INJECTED');
                if (announcedConnector) {
                    await ConnectionController.connectExternal(announcedConnector);
                }
                else if (injectedConnector) {
                    await ConnectionController.connectExternal(injectedConnector);
                }
                ModalController.close();
                EventsController.sendEvent({
                    type: 'track',
                    event: 'CONNECT_SUCCESS',
                    properties: { method: 'browser', name: this.wallet?.name || 'Unknown' }
                });
            }
            catch (error) {
                EventsController.sendEvent({
                    type: 'track',
                    event: 'CONNECT_ERROR',
                    properties: { message: error?.message ?? 'Unknown' }
                });
                this.error = true;
            }
        }
    };
    W3mConnectingWcBrowser = __decorate$o([
        customElement('w3m-connecting-wc-browser')
    ], W3mConnectingWcBrowser);

    var __decorate$n = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let W3mConnectingWcDesktop = class W3mConnectingWcDesktop extends W3mConnectingWidget {
        constructor() {
            super();
            if (!this.wallet) {
                throw new Error('w3m-connecting-wc-desktop: No wallet provided');
            }
            this.onConnect = this.onConnectProxy.bind(this);
            this.onRender = this.onRenderProxy.bind(this);
            EventsController.sendEvent({
                type: 'track',
                event: 'SELECT_WALLET',
                properties: { name: this.wallet.name, platform: 'desktop' }
            });
        }
        onRenderProxy() {
            if (!this.ready && this.uri) {
                this.ready = true;
                this.timeout = setTimeout(() => {
                    this.onConnect?.();
                }, 200);
            }
        }
        onConnectProxy() {
            if (this.wallet?.desktop_link && this.uri) {
                try {
                    this.error = false;
                    const { desktop_link, name } = this.wallet;
                    const { redirect, href } = CoreHelperUtil.formatNativeUrl(desktop_link, this.uri);
                    ConnectionController.setWcLinking({ name, href });
                    ConnectionController.setRecentWallet(this.wallet);
                    CoreHelperUtil.openHref(redirect, '_blank');
                }
                catch {
                    this.error = true;
                }
            }
        }
    };
    W3mConnectingWcDesktop = __decorate$n([
        customElement('w3m-connecting-wc-desktop')
    ], W3mConnectingWcDesktop);

    var __decorate$m = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let W3mConnectingWcMobile = class W3mConnectingWcMobile extends W3mConnectingWidget {
        constructor() {
            super();
            if (!this.wallet) {
                throw new Error('w3m-connecting-wc-mobile: No wallet provided');
            }
            this.onConnect = this.onConnectProxy.bind(this);
            this.onRender = this.onRenderProxy.bind(this);
            document.addEventListener('visibilitychange', this.onBuffering.bind(this));
            EventsController.sendEvent({
                type: 'track',
                event: 'SELECT_WALLET',
                properties: { name: this.wallet.name, platform: 'mobile' }
            });
        }
        disconnectedCallback() {
            super.disconnectedCallback();
            document.removeEventListener('visibilitychange', this.onBuffering.bind(this));
        }
        onRenderProxy() {
            if (!this.ready && this.uri) {
                this.ready = true;
                this.onConnect?.();
            }
        }
        onConnectProxy() {
            if (this.wallet?.mobile_link && this.uri) {
                try {
                    this.error = false;
                    const { mobile_link, name } = this.wallet;
                    const { redirect, href } = CoreHelperUtil.formatNativeUrl(mobile_link, this.uri);
                    ConnectionController.setWcLinking({ name, href });
                    ConnectionController.setRecentWallet(this.wallet);
                    CoreHelperUtil.openHref(redirect, '_self');
                }
                catch {
                    this.error = true;
                }
            }
        }
        onBuffering() {
            const isIos = CoreHelperUtil.isIos();
            if (document?.visibilityState === 'visible' && !this.error && isIos) {
                ConnectionController.setBuffering(true);
                setTimeout(() => {
                    ConnectionController.setBuffering(false);
                }, 5000);
            }
        }
    };
    W3mConnectingWcMobile = __decorate$m([
        customElement('w3m-connecting-wc-mobile')
    ], W3mConnectingWcMobile);

    var styles$h = i$d `
  @keyframes fadein {
    from {
      opacity: 0;
    }
    to {
      opacity: 1;
    }
  }

  wui-shimmer {
    width: 100%;
    aspect-ratio: 1 / 1;
    border-radius: clamp(0px, var(--wui-border-radius-l), 40px) !important;
  }

  wui-qr-code {
    opacity: 0;
    animation-duration: 200ms;
    animation-timing-function: ease;
    animation-name: fadein;
    animation-fill-mode: forwards;
  }
`;

    var __decorate$l = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let W3mConnectingWcQrcode = class W3mConnectingWcQrcode extends W3mConnectingWidget {
        constructor() {
            super();
            this.forceUpdate = () => {
                this.requestUpdate();
            };
            window.addEventListener('resize', this.forceUpdate);
            EventsController.sendEvent({
                type: 'track',
                event: 'SELECT_WALLET',
                properties: { name: this.wallet?.name ?? 'WalletConnect', platform: 'qrcode' }
            });
        }
        disconnectedCallback() {
            super.disconnectedCallback();
            window.removeEventListener('resize', this.forceUpdate);
        }
        render() {
            this.onRenderProxy();
            return x$4 `
      <wui-flex padding="xl" flexDirection="column" gap="xl" alignItems="center">
        <wui-shimmer borderRadius="l" width="100%"> ${this.qrCodeTemplate()} </wui-shimmer>

        <wui-text variant="paragraph-500" color="fg-100">
          Scan this QR Code with your phone
        </wui-text>
        ${this.copyTemplate()}
      </wui-flex>

      <w3m-mobile-download-links .wallet=${this.wallet}></w3m-mobile-download-links>
    `;
        }
        onRenderProxy() {
            if (!this.ready && this.uri) {
                this.timeout = setTimeout(() => {
                    this.ready = true;
                }, 200);
            }
        }
        qrCodeTemplate() {
            if (!this.uri || !this.ready) {
                return null;
            }
            const size = this.getBoundingClientRect().width - 40;
            const alt = this.wallet ? this.wallet.name : undefined;
            ConnectionController.setWcLinking(undefined);
            ConnectionController.setRecentWallet(this.wallet);
            return x$4 ` <wui-qr-code
      size=${size}
      theme=${ThemeController.state.themeMode}
      uri=${this.uri}
      imageSrc=${o$e(AssetUtil.getWalletImage(this.wallet))}
      alt=${o$e(alt)}
      data-testid="wui-qr-code"
    ></wui-qr-code>`;
        }
        copyTemplate() {
            const inactive = !this.uri || !this.ready;
            return x$4 `<wui-link
      .disabled=${inactive}
      @click=${this.onCopyUri}
      color="fg-200"
      data-testid="copy-wc2-uri"
    >
      <wui-icon size="xs" color="fg-200" slot="iconLeft" name="copy"></wui-icon>
      Copy link
    </wui-link>`;
        }
    };
    W3mConnectingWcQrcode.styles = styles$h;
    W3mConnectingWcQrcode = __decorate$l([
        customElement('w3m-connecting-wc-qrcode')
    ], W3mConnectingWcQrcode);

    var __decorate$k = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let W3mConnectingWcUnsupported = class W3mConnectingWcUnsupported extends s$a {
        constructor() {
            super();
            this.wallet = RouterController.state.data?.wallet;
            if (!this.wallet) {
                throw new Error('w3m-connecting-wc-unsupported: No wallet provided');
            }
            EventsController.sendEvent({
                type: 'track',
                event: 'SELECT_WALLET',
                properties: { name: this.wallet.name, platform: 'browser' }
            });
        }
        render() {
            return x$4 `
      <wui-flex
        flexDirection="column"
        alignItems="center"
        .padding=${['3xl', 'xl', 'xl', 'xl']}
        gap="xl"
      >
        <wui-wallet-image
          size="lg"
          imageSrc=${o$e(AssetUtil.getWalletImage(this.wallet))}
        ></wui-wallet-image>

        <wui-text variant="paragraph-500" color="fg-100">Not Detected</wui-text>
      </wui-flex>

      <w3m-mobile-download-links .wallet=${this.wallet}></w3m-mobile-download-links>
    `;
        }
    };
    W3mConnectingWcUnsupported = __decorate$k([
        customElement('w3m-connecting-wc-unsupported')
    ], W3mConnectingWcUnsupported);

    var __decorate$j = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let W3mConnectingWcWeb = class W3mConnectingWcWeb extends W3mConnectingWidget {
        constructor() {
            super();
            if (!this.wallet) {
                throw new Error('w3m-connecting-wc-web: No wallet provided');
            }
            this.onConnect = this.onConnectProxy.bind(this);
            this.secondaryBtnLabel = 'Open';
            this.secondaryLabel = 'Open and continue in a new browser tab';
            this.secondaryBtnIcon = 'externalLink';
            EventsController.sendEvent({
                type: 'track',
                event: 'SELECT_WALLET',
                properties: { name: this.wallet.name, platform: 'web' }
            });
        }
        onConnectProxy() {
            if (this.wallet?.webapp_link && this.uri) {
                try {
                    this.error = false;
                    const { webapp_link, name } = this.wallet;
                    const { redirect, href } = CoreHelperUtil.formatUniversalUrl(webapp_link, this.uri);
                    ConnectionController.setWcLinking({ name, href });
                    ConnectionController.setRecentWallet(this.wallet);
                    CoreHelperUtil.openHref(redirect, '_blank');
                }
                catch {
                    this.error = true;
                }
            }
        }
    };
    W3mConnectingWcWeb = __decorate$j([
        customElement('w3m-connecting-wc-web')
    ], W3mConnectingWcWeb);

    var styles$g = i$d `
  wui-icon-link[data-hidden='true'] {
    opacity: 0 !important;
    pointer-events: none;
  }
`;

    var __decorate$i = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    function headings() {
        const connectorName = RouterController.state.data?.connector?.name;
        const walletName = RouterController.state.data?.wallet?.name;
        const networkName = RouterController.state.data?.network?.name;
        const name = walletName ?? connectorName;
        const connectors = ConnectorController.getConnectors();
        const isEmail = connectors.length === 1 && connectors[0]?.id === 'w3m-email';
        return {
            Connect: `Connect ${isEmail ? 'Email' : ''} Wallet`,
            Account: undefined,
            AccountSettings: undefined,
            ConnectingExternal: name ?? 'Connect Wallet',
            ConnectingWalletConnect: name ?? 'WalletConnect',
            ConnectingSiwe: 'Sign In',
            Networks: 'Choose Network',
            SwitchNetwork: networkName ?? 'Switch Network',
            AllWallets: 'All Wallets',
            WhatIsANetwork: 'What is a network?',
            WhatIsAWallet: 'What is a wallet?',
            GetWallet: 'Get a wallet',
            Downloads: name ? `Get ${name}` : 'Downloads',
            EmailVerifyOtp: 'Confirm Email',
            EmailVerifyDevice: 'Register Device',
            ApproveTransaction: 'Approve Transaction',
            Transactions: 'Activity',
            UpgradeEmailWallet: 'Upgrade your Wallet',
            UpgradeToSmartAccount: undefined,
            UpdateEmailWallet: 'Edit Email',
            UpdateEmailPrimaryOtp: 'Confirm Current Email',
            UpdateEmailSecondaryOtp: 'Confirm New Email',
            UnsupportedChain: 'Switch Network',
            OnRampProviders: 'Choose Provider',
            OnRampActivity: 'Activity',
            WhatIsABuy: 'What is Buy?',
            BuyInProgress: 'Buy',
            OnRampTokenSelect: 'Select Token',
            OnRampFiatSelect: 'Select Currency',
            WalletReceive: 'Receive',
            WalletCompatibleNetworks: 'Compatible Networks',
            WalletSend: 'Send',
            WalletSendPreview: 'Review send',
            WalletSendSelectToken: 'Select Token'
        };
    }
    let W3mHeader = class W3mHeader extends s$a {
        constructor() {
            super();
            this.unsubscribe = [];
            this.heading = headings()[RouterController.state.view];
            this.buffering = false;
            this.showBack = false;
            this.unsubscribe.push(RouterController.subscribeKey('view', val => {
                this.onViewChange(val);
                this.onHistoryChange();
            }), ConnectionController.subscribeKey('buffering', val => (this.buffering = val)));
        }
        disconnectCallback() {
            this.unsubscribe.forEach(unsubscribe => unsubscribe());
        }
        render() {
            return x$4 `
      <wui-flex .padding=${this.getPadding()} justifyContent="space-between" alignItems="center">
        ${this.dynamicButtonTemplate()} ${this.titleTemplate()}
        <wui-icon-link
          ?disabled=${this.buffering}
          icon="close"
          @click=${this.onClose.bind(this)}
          data-testid="w3m-header-close"
        ></wui-icon-link>
      </wui-flex>
      ${this.separatorTemplate()}
    `;
        }
        onWalletHelp() {
            EventsController.sendEvent({ type: 'track', event: 'CLICK_WALLET_HELP' });
            RouterController.push('WhatIsAWallet');
        }
        async onClose() {
            if (OptionsController.state.isSiweEnabled) {
                const { SIWEController } = await Promise.resolve().then(function () { return index$1; });
                if (SIWEController.state.status !== 'success') {
                    await ConnectionController.disconnect();
                }
            }
            ModalController.close();
        }
        titleTemplate() {
            return x$4 `<wui-text variant="paragraph-700" color="fg-100">${this.heading}</wui-text>`;
        }
        dynamicButtonTemplate() {
            const { view } = RouterController.state;
            const isConnectHelp = view === 'Connect';
            const isApproveTransaction = view === 'ApproveTransaction';
            const isUpgradeToSmartAccounts = view === 'UpgradeToSmartAccount';
            const shouldHideBack = isApproveTransaction || isUpgradeToSmartAccounts;
            if (this.showBack && !shouldHideBack) {
                return x$4 `<wui-icon-link
        id="dynamic"
        icon="chevronLeft"
        ?disabled=${this.buffering}
        @click=${this.onGoBack.bind(this)}
      ></wui-icon-link>`;
            }
            return x$4 `<wui-icon-link
      data-hidden=${!isConnectHelp}
      id="dynamic"
      icon="helpCircle"
      @click=${this.onWalletHelp.bind(this)}
    ></wui-icon-link>`;
        }
        separatorTemplate() {
            if (!this.heading) {
                return null;
            }
            return x$4 `<wui-separator></wui-separator>`;
        }
        getPadding() {
            if (this.heading) {
                return ['l', '2l', 'l', '2l'];
            }
            return ['l', '2l', '0', '2l'];
        }
        async onViewChange(view) {
            const headingEl = this.shadowRoot?.querySelector('wui-text');
            if (headingEl) {
                const preset = headings()[view];
                await headingEl.animate([{ opacity: 1 }, { opacity: 0 }], {
                    duration: 200,
                    fill: 'forwards',
                    easing: 'ease'
                }).finished;
                this.heading = preset;
                headingEl.animate([{ opacity: 0 }, { opacity: 1 }], {
                    duration: 200,
                    fill: 'forwards',
                    easing: 'ease'
                });
            }
        }
        async onHistoryChange() {
            const { history } = RouterController.state;
            const buttonEl = this.shadowRoot?.querySelector('#dynamic');
            if (history.length > 1 && !this.showBack && buttonEl) {
                await buttonEl.animate([{ opacity: 1 }, { opacity: 0 }], {
                    duration: 200,
                    fill: 'forwards',
                    easing: 'ease'
                }).finished;
                this.showBack = true;
                buttonEl.animate([{ opacity: 0 }, { opacity: 1 }], {
                    duration: 200,
                    fill: 'forwards',
                    easing: 'ease'
                });
            }
            else if (history.length <= 1 && this.showBack && buttonEl) {
                await buttonEl.animate([{ opacity: 1 }, { opacity: 0 }], {
                    duration: 200,
                    fill: 'forwards',
                    easing: 'ease'
                }).finished;
                this.showBack = false;
                buttonEl.animate([{ opacity: 0 }, { opacity: 1 }], {
                    duration: 200,
                    fill: 'forwards',
                    easing: 'ease'
                });
            }
        }
        onGoBack() {
            if (RouterController.state.view === 'ConnectingSiwe') {
                RouterController.push('Connect');
            }
            else {
                RouterController.goBack();
            }
        }
    };
    W3mHeader.styles = [styles$g];
    __decorate$i([
        r$e()
    ], W3mHeader.prototype, "heading", void 0);
    __decorate$i([
        r$e()
    ], W3mHeader.prototype, "buffering", void 0);
    __decorate$i([
        r$e()
    ], W3mHeader.prototype, "showBack", void 0);
    W3mHeader = __decorate$i([
        customElement('w3m-header')
    ], W3mHeader);

    var __decorate$h = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let W3mHelpWidget = class W3mHelpWidget extends s$a {
        constructor() {
            super(...arguments);
            this.data = [];
        }
        render() {
            return x$4 `
      <wui-flex flexDirection="column" alignItems="center" gap="l">
        ${this.data.map(item => x$4 `
            <wui-flex flexDirection="column" alignItems="center" gap="xl">
              <wui-flex flexDirection="row" justifyContent="center" gap="1xs">
                ${item.images.map(image => x$4 `<wui-visual name=${image}></wui-visual>`)}
              </wui-flex>
            </wui-flex>
            <wui-flex flexDirection="column" alignItems="center" gap="xxs">
              <wui-text variant="paragraph-500" color="fg-100" align="center">
                ${item.title}
              </wui-text>
              <wui-text variant="small-500" color="fg-200" align="center">${item.text}</wui-text>
            </wui-flex>
          `)}
      </wui-flex>
    `;
        }
    };
    __decorate$h([
        n$d({ type: Array })
    ], W3mHelpWidget.prototype, "data", void 0);
    W3mHelpWidget = __decorate$h([
        customElement('w3m-help-widget')
    ], W3mHelpWidget);

    var styles$f = i$d `
  :host {
    width: 100%;
  }

  wui-loading-spinner {
    position: absolute;
    top: 50%;
    right: 20px;
    transform: translateY(-50%);
  }

  .currency-container {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    transition: all var(--wui-ease-in-power-2) var(--wui-duration-md);
    right: var(--wui-spacing-1xs);
    height: 40px;
    padding: var(--wui-spacing-xs) var(--wui-spacing-1xs) var(--wui-spacing-xs)
      var(--wui-spacing-xs);
    min-width: 95px;
    border-radius: var(--FULL, 1000px);
    border: 1px solid var(--wui-gray-glass-002);
    background: var(--wui-gray-glass-002);
    cursor: pointer;
  }

  .currency-container > wui-image {
    height: 24px;
    width: 24px;
    border-radius: 50%;
  }
`;

    var __decorate$g = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let W3mInputCurrency = class W3mInputCurrency extends s$a {
        constructor() {
            super();
            this.unsubscribe = [];
            this.type = 'Token';
            this.value = 0;
            this.currencies = [];
            this.selectedCurrency = this.currencies?.[0];
            this.currencyImages = AssetController.state.currencyImages;
            this.tokenImages = AssetController.state.tokenImages;
            this.unsubscribe.push(OnRampController.subscribeKey('purchaseCurrency', val => {
                if (!val || this.type === 'Fiat') {
                    return;
                }
                this.selectedCurrency = this.formatPurchaseCurrency(val);
            }), OnRampController.subscribeKey('paymentCurrency', val => {
                if (!val || this.type === 'Token') {
                    return;
                }
                this.selectedCurrency = this.formatPaymentCurrency(val);
            }), OnRampController.subscribe(val => {
                if (this.type === 'Fiat') {
                    this.currencies = val.purchaseCurrencies.map(this.formatPurchaseCurrency);
                }
                else {
                    this.currencies = val.paymentCurrencies.map(this.formatPaymentCurrency);
                }
            }), AssetController.subscribe(val => {
                this.currencyImages = { ...val.currencyImages };
                this.tokenImages = { ...val.tokenImages };
            }));
        }
        firstUpdated() {
            OnRampController.getAvailableCurrencies();
        }
        disconnectedCallback() {
            this.unsubscribe.forEach(unsubscribe => unsubscribe());
        }
        render() {
            const symbol = this.selectedCurrency?.symbol || '';
            const image = this.currencyImages[symbol] || this.tokenImages[symbol];
            return x$4 ` <wui-input-text type="number" size="lg" value=${this.value}>
      ${this.selectedCurrency
            ? x$4 ` <wui-flex
            class="currency-container"
            justifyContent="space-between"
            alignItems="center"
            gap="xxs"
            @click=${() => ModalController.open({ view: `OnRamp${this.type}Select` })}
          >
            <wui-image src=${o$e(image)}></wui-image>
            <wui-text color="fg-100"> ${this.selectedCurrency.symbol} </wui-text>
          </wui-flex>`
            : x$4 `<wui-loading-spinner></wui-loading-spinner>`}
    </wui-input-text>`;
        }
        formatPaymentCurrency(currency) {
            return {
                name: currency.id,
                symbol: currency.id
            };
        }
        formatPurchaseCurrency(currency) {
            return {
                name: currency.name,
                symbol: currency.symbol
            };
        }
    };
    W3mInputCurrency.styles = styles$f;
    __decorate$g([
        n$d({ type: String })
    ], W3mInputCurrency.prototype, "type", void 0);
    __decorate$g([
        n$d({ type: Number })
    ], W3mInputCurrency.prototype, "value", void 0);
    __decorate$g([
        r$e()
    ], W3mInputCurrency.prototype, "currencies", void 0);
    __decorate$g([
        r$e()
    ], W3mInputCurrency.prototype, "selectedCurrency", void 0);
    __decorate$g([
        r$e()
    ], W3mInputCurrency.prototype, "currencyImages", void 0);
    __decorate$g([
        r$e()
    ], W3mInputCurrency.prototype, "tokenImages", void 0);
    W3mInputCurrency = __decorate$g([
        customElement('w3m-swap-input')
    ], W3mInputCurrency);

    var styles$e = i$d `
  wui-flex {
    background-color: var(--wui-gray-glass-005);
  }

  a {
    text-decoration: none;
    color: var(--wui-color-fg-175);
    font-weight: 500;
  }
`;

    var __decorate$f = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let W3mLegalFooter = class W3mLegalFooter extends s$a {
        render() {
            const { termsConditionsUrl, privacyPolicyUrl } = OptionsController.state;
            if (!termsConditionsUrl && !privacyPolicyUrl) {
                return null;
            }
            return x$4 `
      <wui-flex .padding=${['m', 's', 's', 's']} justifyContent="center">
        <wui-text color="fg-250" variant="small-400" align="center">
          By connecting your wallet, you agree to our <br />
          ${this.termsTemplate()} ${this.andTemplate()} ${this.privacyTemplate()}
        </wui-text>
      </wui-flex>
    `;
        }
        andTemplate() {
            const { termsConditionsUrl, privacyPolicyUrl } = OptionsController.state;
            return termsConditionsUrl && privacyPolicyUrl ? 'and' : '';
        }
        termsTemplate() {
            const { termsConditionsUrl } = OptionsController.state;
            if (!termsConditionsUrl) {
                return null;
            }
            return x$4 `<a href=${termsConditionsUrl}>Terms of Service</a>`;
        }
        privacyTemplate() {
            const { privacyPolicyUrl } = OptionsController.state;
            if (!privacyPolicyUrl) {
                return null;
            }
            return x$4 `<a href=${privacyPolicyUrl}>Privacy Policy</a>`;
        }
    };
    W3mLegalFooter.styles = [styles$e];
    W3mLegalFooter = __decorate$f([
        customElement('w3m-legal-footer')
    ], W3mLegalFooter);

    var styles$d = i$d `
  :host {
    display: block;
    padding: 0 var(--wui-spacing-xl) var(--wui-spacing-xl);
  }
`;

    var __decorate$e = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let W3mMobileDownloadLinks = class W3mMobileDownloadLinks extends s$a {
        constructor() {
            super(...arguments);
            this.wallet = undefined;
        }
        render() {
            if (!this.wallet) {
                this.style.display = 'none';
                return null;
            }
            const { name, app_store, play_store, chrome_store, homepage } = this.wallet;
            const isMobile = CoreHelperUtil.isMobile();
            const isIos = CoreHelperUtil.isIos();
            const isAndroid = CoreHelperUtil.isAndroid();
            const isMultiple = [app_store, play_store, homepage, chrome_store].filter(Boolean).length > 1;
            const shortName = UiHelperUtil.getTruncateString({
                string: name,
                charsStart: 12,
                charsEnd: 0,
                truncate: 'end'
            });
            if (isMultiple && !isMobile) {
                return x$4 `
        <wui-cta-button
          label=${`Don't have ${shortName}?`}
          buttonLabel="Get"
          @click=${() => RouterController.push('Downloads', { wallet: this.wallet })}
        ></wui-cta-button>
      `;
            }
            if (!isMultiple && homepage) {
                return x$4 `
        <wui-cta-button
          label=${`Don't have ${shortName}?`}
          buttonLabel="Get"
          @click=${this.onHomePage.bind(this)}
        ></wui-cta-button>
      `;
            }
            if (app_store && isIos) {
                return x$4 `
        <wui-cta-button
          label=${`Don't have ${shortName}?`}
          buttonLabel="Get"
          @click=${this.onAppStore.bind(this)}
        ></wui-cta-button>
      `;
            }
            if (play_store && isAndroid) {
                return x$4 `
        <wui-cta-button
          label=${`Don't have ${shortName}?`}
          buttonLabel="Get"
          @click=${this.onPlayStore.bind(this)}
        ></wui-cta-button>
      `;
            }
            this.style.display = 'none';
            return null;
        }
        onAppStore() {
            if (this.wallet?.app_store) {
                CoreHelperUtil.openHref(this.wallet.app_store, '_blank');
            }
        }
        onPlayStore() {
            if (this.wallet?.play_store) {
                CoreHelperUtil.openHref(this.wallet.play_store, '_blank');
            }
        }
        onHomePage() {
            if (this.wallet?.homepage) {
                CoreHelperUtil.openHref(this.wallet.homepage, '_blank');
            }
        }
    };
    W3mMobileDownloadLinks.styles = [styles$d];
    __decorate$e([
        n$d({ type: Object })
    ], W3mMobileDownloadLinks.prototype, "wallet", void 0);
    W3mMobileDownloadLinks = __decorate$e([
        customElement('w3m-mobile-download-links')
    ], W3mMobileDownloadLinks);

    var styles$c = i$d `
  wui-flex {
    border-top: 1px solid var(--wui-gray-glass-005);
  }

  a {
    text-decoration: none;
    color: var(--wui-color-fg-175);
    font-weight: 500;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: var(--wui-spacing-3xs);
  }
`;

    var __decorate$d = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let W3mOnRampProvidersFooter = class W3mOnRampProvidersFooter extends s$a {
        render() {
            const { termsConditionsUrl, privacyPolicyUrl } = OptionsController.state;
            if (!termsConditionsUrl && !privacyPolicyUrl) {
                return null;
            }
            return x$4 `
      <wui-flex
        .padding=${['m', 's', 's', 's']}
        flexDirection="column"
        alignItems="center"
        justifyContent="center"
        gap="s"
      >
        <wui-text color="fg-250" variant="small-400" align="center">
          We work with the best providers to give you the lowest fees and best support. More options
          coming soon!
        </wui-text>

        ${this.howDoesItWorkTemplate()}
      </wui-flex>
    `;
        }
        howDoesItWorkTemplate() {
            return x$4 ` <wui-link @click=${this.onWhatIsBuy.bind(this)}>
      <wui-icon size="xs" color="accent-100" slot="iconLeft" name="helpCircle"></wui-icon>
      How does it work?
    </wui-link>`;
        }
        onWhatIsBuy() {
            RouterController.push('WhatIsABuy');
        }
    };
    W3mOnRampProvidersFooter.styles = [styles$c];
    W3mOnRampProvidersFooter = __decorate$d([
        customElement('w3m-onramp-providers-footer')
    ], W3mOnRampProvidersFooter);

    var styles$b = i$d `
  :host {
    display: block;
    position: absolute;
    opacity: 0;
    pointer-events: none;
    top: 11px;
    left: 50%;
    width: max-content;
  }
`;

    var __decorate$c = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    const presets = {
        success: {
            backgroundColor: 'success-100',
            iconColor: 'success-100',
            icon: 'checkmark'
        },
        error: {
            backgroundColor: 'error-100',
            iconColor: 'error-100',
            icon: 'close'
        }
    };
    let W3mSnackBar = class W3mSnackBar extends s$a {
        constructor() {
            super();
            this.unsubscribe = [];
            this.timeout = undefined;
            this.open = SnackController.state.open;
            this.unsubscribe.push(SnackController.subscribeKey('open', val => {
                this.open = val;
                this.onOpen();
            }));
        }
        disconnectedCallback() {
            clearTimeout(this.timeout);
            this.unsubscribe.forEach(unsubscribe => unsubscribe());
        }
        render() {
            const { message, variant } = SnackController.state;
            const preset = presets[variant];
            return x$4 `
      <wui-snackbar
        message=${message}
        backgroundColor=${preset.backgroundColor}
        iconColor=${preset.iconColor}
        icon=${preset.icon}
      ></wui-snackbar>
    `;
        }
        onOpen() {
            clearTimeout(this.timeout);
            if (this.open) {
                this.animate([
                    { opacity: 0, transform: 'translateX(-50%) scale(0.85)' },
                    { opacity: 1, transform: 'translateX(-50%) scale(1)' }
                ], {
                    duration: 150,
                    fill: 'forwards',
                    easing: 'ease'
                });
                this.timeout = setTimeout(() => SnackController.hide(), 2500);
            }
            else {
                this.animate([
                    { opacity: 1, transform: 'translateX(-50%) scale(1)' },
                    { opacity: 0, transform: 'translateX(-50%) scale(0.85)' }
                ], {
                    duration: 150,
                    fill: 'forwards',
                    easing: 'ease'
                });
            }
        }
    };
    W3mSnackBar.styles = styles$b;
    __decorate$c([
        r$e()
    ], W3mSnackBar.prototype, "open", void 0);
    W3mSnackBar = __decorate$c([
        customElement('w3m-snackbar')
    ], W3mSnackBar);

    var styles$a = i$d `
  wui-separator {
    margin: var(--wui-spacing-s) calc(var(--wui-spacing-s) * -1);
    width: calc(100% + var(--wui-spacing-s) * 2);
  }

  wui-email-input {
    width: 100%;
  }

  form {
    width: 100%;
    display: block;
    position: relative;
  }

  wui-icon-link,
  wui-loading-spinner {
    position: absolute;
    top: 21px;
    transform: translateY(-50%);
  }

  wui-icon-link {
    right: var(--wui-spacing-xs);
  }

  wui-loading-spinner {
    right: var(--wui-spacing-m);
  }
`;

    var __decorate$b = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let W3mEmailLoginWidget = class W3mEmailLoginWidget extends s$a {
        constructor() {
            super();
            this.unsubscribe = [];
            this.formRef = e$b();
            this.connectors = ConnectorController.state.connectors;
            this.email = '';
            this.loading = false;
            this.error = '';
            this.unsubscribe.push(ConnectorController.subscribeKey('connectors', val => (this.connectors = val)));
        }
        disconnectedCallback() {
            this.unsubscribe.forEach(unsubscribe => unsubscribe());
        }
        firstUpdated() {
            this.formRef.value?.addEventListener('keydown', event => {
                if (event.key === 'Enter') {
                    this.onSubmitEmail(event);
                }
            });
        }
        render() {
            const multipleConnectors = this.connectors.length > 1;
            const connector = this.connectors.find(c => c.type === 'EMAIL');
            if (!connector) {
                return null;
            }
            return x$4 `
      <form ${n$b(this.formRef)} @submit=${this.onSubmitEmail.bind(this)}>
        <wui-email-input
          @focus=${this.onFocusEvent.bind(this)}
          .disabled=${this.loading}
          @inputChange=${this.onEmailInputChange.bind(this)}
          .errorMessage=${this.error}
        >
        </wui-email-input>

        ${this.submitButtonTemplate()}${this.loadingTemplate()}
        <input type="submit" hidden />
      </form>

      ${multipleConnectors ? x$4 `<wui-separator text="or"></wui-separator>` : null}
    `;
        }
        submitButtonTemplate() {
            const showSubmit = !this.loading && this.email.length > 3;
            return showSubmit
                ? x$4 `
          <wui-icon-link
            size="sm"
            icon="chevronRight"
            iconcolor="accent-100"
            @click=${this.onSubmitEmail.bind(this)}
          >
          </wui-icon-link>
        `
                : null;
        }
        loadingTemplate() {
            return this.loading
                ? x$4 `<wui-loading-spinner size="md" color="accent-100"></wui-loading-spinner>`
                : null;
        }
        onEmailInputChange(event) {
            this.email = event.detail;
            this.error = '';
        }
        async onSubmitEmail(event) {
            try {
                if (this.loading) {
                    return;
                }
                this.loading = true;
                event.preventDefault();
                const emailConnector = ConnectorController.getEmailConnector();
                if (!emailConnector) {
                    throw new Error('w3m-email-login-widget: Email connector not found');
                }
                const { action } = await emailConnector.provider.connectEmail({ email: this.email });
                EventsController.sendEvent({ type: 'track', event: 'EMAIL_SUBMITTED' });
                if (action === 'VERIFY_OTP') {
                    EventsController.sendEvent({ type: 'track', event: 'EMAIL_VERIFICATION_CODE_SENT' });
                    RouterController.push('EmailVerifyOtp', { email: this.email });
                }
                else if (action === 'VERIFY_DEVICE') {
                    RouterController.push('EmailVerifyDevice', { email: this.email });
                }
            }
            catch (error) {
                const parsedError = CoreHelperUtil.parseError(error);
                if (parsedError?.includes('Invalid email')) {
                    this.error = 'Invalid email. Try again.';
                }
                else {
                    SnackController.showError(error);
                }
            }
            finally {
                this.loading = false;
            }
        }
        onFocusEvent() {
            EventsController.sendEvent({ type: 'track', event: 'EMAIL_LOGIN_SELECTED' });
        }
    };
    W3mEmailLoginWidget.styles = styles$a;
    __decorate$b([
        r$e()
    ], W3mEmailLoginWidget.prototype, "connectors", void 0);
    __decorate$b([
        r$e()
    ], W3mEmailLoginWidget.prototype, "email", void 0);
    __decorate$b([
        r$e()
    ], W3mEmailLoginWidget.prototype, "loading", void 0);
    __decorate$b([
        r$e()
    ], W3mEmailLoginWidget.prototype, "error", void 0);
    W3mEmailLoginWidget = __decorate$b([
        customElement('w3m-email-login-widget')
    ], W3mEmailLoginWidget);

    var styles$9 = i$d `
  wui-flex {
    width: 100%;
  }

  :host > wui-flex:first-child {
    transform: translateY(calc(var(--wui-spacing-xxs) * -1));
  }

  wui-icon-link {
    margin-right: calc(var(--wui-icon-box-size-md) * -1);
  }

  wui-notice-card {
    margin-bottom: var(--wui-spacing-3xs);
  }

  w3m-transactions-view {
    max-height: 200px;
  }

  .tab-content-container {
    height: 300px;
    overflow-y: auto;
    overflow-x: hidden;
    scrollbar-width: none;
  }

  .account-button {
    width: auto;
    border: none;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: var(--wui-spacing-s);
    height: 48px;
    padding: var(--wui-spacing-xs);
    padding-right: var(--wui-spacing-s);
    box-shadow: inset 0 0 0 1px var(--wui-gray-glass-002);
    background-color: var(--wui-gray-glass-002);
    border-radius: 24px;
    transaction: background-color 0.2s linear;
  }

  .account-button:hover {
    background-color: var(--wui-gray-glass-005);
  }

  .avatar-container {
    position: relative;
  }

  wui-avatar.avatar {
    width: 32px;
    height: 32px;
    box-shadow: 0 0 0 2px var(--wui-gray-glass-005);
  }

  wui-avatar.network-avatar {
    width: 16px;
    height: 16px;
    position: absolute;
    left: 100%;
    top: 100%;
    transform: translate(-75%, -75%);
    box-shadow: 0 0 0 2px var(--wui-gray-glass-005);
  }

  .account-links {
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .account-links wui-flex {
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    flex: 1;
    background: red;
    align-items: center;
    justify-content: center;
    height: 48px;
    padding: 10px;
    flex: 1 0 0;

    border-radius: var(--XS, 16px);
    border: 1px solid var(--dark-accent-glass-010, rgba(71, 161, 255, 0.1));
    background: var(--dark-accent-glass-010, rgba(71, 161, 255, 0.1));
    transition: background 0.2s linear;
  }

  .account-links wui-flex:hover {
    background: var(--dark-accent-glass-015, rgba(71, 161, 255, 0.15));
  }

  .account-links wui-flex wui-icon {
    width: var(--S, 20px);
    height: var(--S, 20px);
  }

  .account-links wui-flex wui-icon svg path {
    stroke: #47a1ff;
  }
`;

    var __decorate$a = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let W3mAccountDefaultWidget = class W3mAccountDefaultWidget extends s$a {
        constructor() {
            super();
            this.unsubscribe = [];
            this.address = AccountController.state.address;
            this.profileImage = AccountController.state.profileImage;
            this.profileName = AccountController.state.profileName;
            this.network = NetworkController.state.caipNetwork;
            this.disconnecting = false;
            this.balance = AccountController.state.balance;
            this.balanceSymbol = AccountController.state.balanceSymbol;
            this.unsubscribe.push(...[
                AccountController.subscribe(val => {
                    if (val.address) {
                        this.address = val.address;
                        this.profileImage = val.profileImage;
                        this.profileName = val.profileName;
                        this.balance = val.balance;
                        this.balanceSymbol = val.balanceSymbol;
                    }
                    else if (!this.disconnecting) {
                        SnackController.showError('Account not found');
                    }
                })
            ], NetworkController.subscribeKey('caipNetwork', val => {
                if (val?.id) {
                    this.network = val;
                }
            }));
        }
        disconnectedCallback() {
            this.unsubscribe.forEach(unsubscribe => unsubscribe());
        }
        render() {
            if (!this.address) {
                throw new Error('w3m-account-view: No account provided');
            }
            const networkImage = AssetUtil.getNetworkImage(this.network);
            return x$4 `<wui-flex
        flexDirection="column"
        .padding=${['0', 'xl', 'm', 'xl']}
        alignItems="center"
        gap="l"
      >
        <wui-avatar
          alt=${o$e(this.address)}
          address=${o$e(this.address)}
          imageSrc=${o$e(this.profileImage === null ? undefined : this.profileImage)}
        ></wui-avatar>
        <wui-flex flexDirection="column" alignItems="center">
          <wui-flex gap="3xs" alignItems="center" justifyContent="center">
            <wui-text variant="medium-title-600" color="fg-100">
              ${this.profileName
            ? UiHelperUtil.getTruncateString({
                string: this.profileName,
                charsStart: 20,
                charsEnd: 0,
                truncate: 'end'
            })
            : UiHelperUtil.getTruncateString({
                string: this.address ? this.address : '',
                charsStart: 4,
                charsEnd: 4,
                truncate: 'middle'
            })}
            </wui-text>
            <wui-icon-link
              size="md"
              icon="copy"
              iconColor="fg-200"
              @click=${this.onCopyAddress}
            ></wui-icon-link>
          </wui-flex>
          <wui-text variant="paragraph-500" color="fg-200"
            >${CoreHelperUtil.formatBalance(this.balance, this.balanceSymbol)}</wui-text
          >
        </wui-flex>
        ${this.explorerBtnTemplate()}
      </wui-flex>

      <wui-flex flexDirection="column" gap="xs" .padding=${['0', 's', 's', 's']}>
        ${this.emailCardTemplate()} ${this.emailBtnTemplate()}

        <wui-list-item
          .variant=${networkImage ? 'image' : 'icon'}
          iconVariant="overlay"
          icon="networkPlaceholder"
          imageSrc=${o$e(networkImage)}
          ?chevron=${this.isAllowedNetworkSwitch()}
          @click=${this.onNetworks.bind(this)}
          data-testid="w3m-account-select-network"
        >
          <wui-text variant="paragraph-500" color="fg-100">
            ${this.network?.name ?? 'Unknown'}
          </wui-text>
        </wui-list-item>
        ${this.onrampTemplate()}
        <wui-list-item
          iconVariant="blue"
          icon="swapHorizontalMedium"
          iconSize="sm"
          ?chevron=${true}
          @click=${this.onTransactions.bind(this)}
        >
          <wui-text variant="paragraph-500" color="fg-100">Activity</wui-text>
        </wui-list-item>
        <wui-list-item
          variant="icon"
          iconVariant="overlay"
          icon="disconnect"
          ?chevron=${false}
          .loading=${this.disconnecting}
          @click=${this.onDisconnect.bind(this)}
          data-testid="disconnect-button"
        >
          <wui-text variant="paragraph-500" color="fg-200">Disconnect</wui-text>
        </wui-list-item>
      </wui-flex>`;
        }
        onrampTemplate() {
            const { enableOnramp } = OptionsController.state;
            if (!enableOnramp) {
                return null;
            }
            return x$4 `
      <wui-list-item
        iconVariant="blue"
        icon="card"
        ?chevron=${true}
        @click=${this.handleClickPay.bind(this)}
      >
        <wui-text variant="paragraph-500" color="fg-100">Buy crypto</wui-text>
      </wui-list-item>
    `;
        }
        emailCardTemplate() {
            const type = StorageUtil.getConnectedConnector();
            const emailConnector = ConnectorController.getEmailConnector();
            const { origin } = location;
            if (!emailConnector || type !== 'EMAIL' || origin.includes(ConstantsUtil$2.SECURE_SITE)) {
                return null;
            }
            return x$4 `
      <wui-notice-card
        @click=${this.onGoToUpgradeView.bind(this)}
        label="Upgrade your wallet"
        description="Transition to a self-custodial wallet"
        icon="wallet"
        data-testid="w3m-wallet-upgrade-card"
      ></wui-notice-card>
    `;
        }
        handleClickPay() {
            RouterController.push('OnRampProviders');
        }
        explorerBtnTemplate() {
            const { addressExplorerUrl } = AccountController.state;
            if (!addressExplorerUrl) {
                return null;
            }
            return x$4 `
      <wui-button size="sm" variant="shade" @click=${this.onExplorer.bind(this)}>
        <wui-icon size="sm" color="inherit" slot="iconLeft" name="compass"></wui-icon>
        Block Explorer
        <wui-icon size="sm" color="inherit" slot="iconRight" name="externalLink"></wui-icon>
      </wui-button>
    `;
        }
        emailBtnTemplate() {
            const type = StorageUtil.getConnectedConnector();
            const emailConnector = ConnectorController.getEmailConnector();
            if (!emailConnector || type !== 'EMAIL') {
                return null;
            }
            const email = emailConnector.provider.getEmail() ?? '';
            return x$4 `
      <wui-list-item
        variant="icon"
        iconVariant="overlay"
        icon="mail"
        iconSize="sm"
        ?chevron=${true}
        @click=${() => this.onGoToUpdateEmail(email)}
      >
        <wui-text variant="paragraph-500" color="fg-100">${email}</wui-text>
      </wui-list-item>
    `;
        }
        isAllowedNetworkSwitch() {
            const { requestedCaipNetworks } = NetworkController.state;
            const isMultiNetwork = requestedCaipNetworks ? requestedCaipNetworks.length > 1 : false;
            const isValidNetwork = requestedCaipNetworks?.find(({ id }) => id === this.network?.id);
            return isMultiNetwork || !isValidNetwork;
        }
        onCopyAddress() {
            try {
                if (this.address) {
                    CoreHelperUtil.copyToClopboard(this.address);
                    SnackController.showSuccess('Address copied');
                }
            }
            catch {
                SnackController.showError('Failed to copy');
            }
        }
        onNetworks() {
            if (this.isAllowedNetworkSwitch()) {
                EventsController.sendEvent({ type: 'track', event: 'CLICK_NETWORKS' });
                RouterController.push('Networks');
            }
        }
        onTransactions() {
            EventsController.sendEvent({ type: 'track', event: 'CLICK_TRANSACTIONS' });
            RouterController.push('Transactions');
        }
        async onDisconnect() {
            try {
                this.disconnecting = true;
                await ConnectionController.disconnect();
                EventsController.sendEvent({ type: 'track', event: 'DISCONNECT_SUCCESS' });
                ModalController.close();
            }
            catch {
                EventsController.sendEvent({ type: 'track', event: 'DISCONNECT_ERROR' });
                SnackController.showError('Failed to disconnect');
            }
            finally {
                this.disconnecting = false;
            }
        }
        onExplorer() {
            const { addressExplorerUrl } = AccountController.state;
            if (addressExplorerUrl) {
                CoreHelperUtil.openHref(addressExplorerUrl, '_blank');
            }
        }
        onGoToUpgradeView() {
            EventsController.sendEvent({ type: 'track', event: 'EMAIL_UPGRADE_FROM_MODAL' });
            RouterController.push('UpgradeEmailWallet');
        }
        onGoToUpdateEmail(email) {
            RouterController.push('UpdateEmailWallet', { email });
        }
    };
    W3mAccountDefaultWidget.styles = styles$9;
    __decorate$a([
        r$e()
    ], W3mAccountDefaultWidget.prototype, "address", void 0);
    __decorate$a([
        r$e()
    ], W3mAccountDefaultWidget.prototype, "profileImage", void 0);
    __decorate$a([
        r$e()
    ], W3mAccountDefaultWidget.prototype, "profileName", void 0);
    __decorate$a([
        r$e()
    ], W3mAccountDefaultWidget.prototype, "network", void 0);
    __decorate$a([
        r$e()
    ], W3mAccountDefaultWidget.prototype, "disconnecting", void 0);
    __decorate$a([
        r$e()
    ], W3mAccountDefaultWidget.prototype, "balance", void 0);
    __decorate$a([
        r$e()
    ], W3mAccountDefaultWidget.prototype, "balanceSymbol", void 0);
    W3mAccountDefaultWidget = __decorate$a([
        customElement('w3m-account-default-widget')
    ], W3mAccountDefaultWidget);

    var styles$8 = i$d `
  wui-flex {
    width: 100%;
  }

  wui-promo {
    position: absolute;
    top: -32px;
  }

  wui-profile-button {
    margin-top: var(--wui-spacing-2l);
  }

  wui-tooltip-select {
    width: 100%;
  }

  wui-tabs {
    width: 100%;
  }

  .contentContainer {
    height: 280px;
  }

  .contentContainer > wui-icon-box {
    width: 40px;
    height: 40px;
    border-radius: var(--wui-border-radius-xxs);
  }

  .contentContainer > .textContent {
    width: 65%;
  }
`;

    const ConstantsUtil$1 = {
        ACCOUNT_TABS: [{ label: 'Tokens' }, { label: 'NFTs' }, { label: 'Activity' }]
    };

    var __decorate$9 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let W3mAccountWalletFeaturesWidget = class W3mAccountWalletFeaturesWidget extends s$a {
        constructor() {
            super();
            this.unsubscribe = [];
            this.address = AccountController.state.address;
            this.profileImage = AccountController.state.profileImage;
            this.profileName = AccountController.state.profileName;
            this.network = NetworkController.state.caipNetwork;
            this.currentTab = AccountController.state.currentTab;
            this.tokenBalance = AccountController.state.tokenBalance;
            this.unsubscribe.push(...[
                AccountController.subscribe(val => {
                    if (val.address) {
                        this.address = val.address;
                        this.profileImage = val.profileImage;
                        this.profileName = val.profileName;
                        this.currentTab = val.currentTab;
                        this.tokenBalance = val.tokenBalance;
                    }
                    else {
                        ModalController.close();
                    }
                })
            ], NetworkController.subscribeKey('caipNetwork', val => {
                if (val?.id) {
                    this.network = val;
                }
            }));
        }
        disconnectedCallback() {
            this.unsubscribe.forEach(unsubscribe => unsubscribe());
        }
        render() {
            if (!this.address) {
                throw new Error('w3m-account-view: No account provided');
            }
            const networkImage = AssetUtil.getNetworkImage(this.network);
            return x$4 `<wui-flex
      flexDirection="column"
      .padding=${['0', 'xl', 'm', 'xl']}
      alignItems="center"
      gap="m"
    >
      <wui-profile-button
        @click=${this.onProfileButtonClick.bind(this)}
        address=${o$e(this.address)}
        networkSrc=${o$e(networkImage)}
        icon="chevronBottom"
        avatarSrc=${o$e(this.profileImage ? this.profileImage : undefined)}
        ?isprofilename=${Boolean(this.profileName)}
      ></wui-profile-button>
      ${this.tokenBalanceTemplate()}
      <wui-flex gap="s">
        <wui-tooltip-select
          @click=${this.onBuyClick.bind(this)}
          text="Buy"
          icon="card"
        ></wui-tooltip-select>
        <wui-tooltip-select text="Convert" icon="recycleHorizontal"></wui-tooltip-select>
        <wui-tooltip-select
          @click=${this.onReceiveClick.bind(this)}
          text="Receive"
          icon="arrowBottomCircle"
        ></wui-tooltip-select>
        <wui-tooltip-select
          @click=${this.onSendClick.bind(this)}
          text="Send"
          icon="send"
        ></wui-tooltip-select>
      </wui-flex>

      <wui-tabs
        .onTabChange=${this.onTabChange.bind(this)}
        .activeTab=${this.currentTab}
        localTabWidth="104px"
        .tabs=${ConstantsUtil$1.ACCOUNT_TABS}
      ></wui-tabs>
      ${this.listContentTemplate()}
    </wui-flex>`;
        }
        listContentTemplate() {
            if (this.currentTab === 0) {
                return x$4 `<w3m-account-tokens-widget></w3m-account-tokens-widget>`;
            }
            if (this.currentTab === 1) {
                return x$4 `<w3m-account-nfts-widget></w3m-account-nfts-widget>`;
            }
            if (this.currentTab === 2) {
                return x$4 `<w3m-account-activity-widget></w3m-account-activity-widget>`;
            }
            return x$4 `<w3m-account-tokens-widget></w3m-account-tokens-widget>`;
        }
        tokenBalanceTemplate() {
            if (this.tokenBalance && this.tokenBalance?.length >= 0) {
                const value = CoreHelperUtil.calculateBalance(this.tokenBalance);
                const { dollars = '0', pennies = '00' } = CoreHelperUtil.formatTokenBalance(value);
                return x$4 `<wui-balance dollars=${dollars} pennies=${pennies}></wui-balance>`;
            }
            return x$4 `<wui-balance dollars="0" pennies="00"></wui-balance>`;
        }
        onTabChange(index) {
            AccountController.setCurrentTab(index);
        }
        onProfileButtonClick() {
            RouterController.push('AccountSettings');
        }
        onBuyClick() {
            RouterController.push('OnRampProviders');
        }
        onReceiveClick() {
            RouterController.push('WalletReceive');
        }
        onSendClick() {
            RouterController.push('WalletSend');
        }
    };
    W3mAccountWalletFeaturesWidget.styles = styles$8;
    __decorate$9([
        r$e()
    ], W3mAccountWalletFeaturesWidget.prototype, "address", void 0);
    __decorate$9([
        r$e()
    ], W3mAccountWalletFeaturesWidget.prototype, "profileImage", void 0);
    __decorate$9([
        r$e()
    ], W3mAccountWalletFeaturesWidget.prototype, "profileName", void 0);
    __decorate$9([
        r$e()
    ], W3mAccountWalletFeaturesWidget.prototype, "network", void 0);
    __decorate$9([
        r$e()
    ], W3mAccountWalletFeaturesWidget.prototype, "currentTab", void 0);
    __decorate$9([
        r$e()
    ], W3mAccountWalletFeaturesWidget.prototype, "tokenBalance", void 0);
    W3mAccountWalletFeaturesWidget = __decorate$9([
        customElement('w3m-account-wallet-features-widget')
    ], W3mAccountWalletFeaturesWidget);

    var styles$7 = i$d `
  :host {
    width: 100%;
    max-height: 280px;
    overflow: scroll;
    scrollbar-width: none;
  }
`;

    var __decorate$8 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let W3mAccountActivityWidget = class W3mAccountActivityWidget extends s$a {
        render() {
            return x$4 `<w3m-activity-list page="account"></w3m-activity-list>`;
        }
    };
    W3mAccountActivityWidget.styles = styles$7;
    W3mAccountActivityWidget = __decorate$8([
        customElement('w3m-account-activity-widget')
    ], W3mAccountActivityWidget);

    var styles$6 = i$d `
  .contentContainer {
    height: 280px;
  }

  .contentContainer > wui-icon-box {
    width: 40px;
    height: 40px;
    border-radius: var(--wui-border-radius-xxs);
  }

  .contentContainer > .textContent {
    width: 65%;
  }
`;

    var __decorate$7 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let W3mAccountNftsWidget = class W3mAccountNftsWidget extends s$a {
        render() {
            return x$4 `${this.nftTemplate()}`;
        }
        nftTemplate() {
            return x$4 ` <wui-flex
      class="contentContainer"
      alignItems="center"
      justifyContent="center"
      flexDirection="column"
      gap="l"
    >
      <wui-icon-box
        icon="wallet"
        size="inherit"
        iconColor="fg-200"
        backgroundColor="fg-200"
        iconSize="lg"
      ></wui-icon-box>
      <wui-flex
        class="textContent"
        gap="xs"
        flexDirection="column"
        justifyContent="center"
        flexDirection="column"
      >
        <wui-text variant="paragraph-500" align="center" color="fg-100">No NFTs yet</wui-text>
        <wui-text variant="small-400" align="center" color="fg-200"
          >Transfer from another wallets to get started</wui-text
        >
      </wui-flex>
      <wui-link @click=${this.onReceiveClick.bind(this)}>Receive NFTs</wui-link>
    </wui-flex>`;
        }
        onReceiveClick() {
            RouterController.push('WalletReceive');
        }
    };
    W3mAccountNftsWidget.styles = styles$6;
    W3mAccountNftsWidget = __decorate$7([
        customElement('w3m-account-nfts-widget')
    ], W3mAccountNftsWidget);

    var styles$5 = i$d `
  :host {
    width: 100%;
  }

  wui-flex {
    width: 100%;
  }

  .contentContainer {
    max-height: 280px;
    overflow: scroll;
    scrollbar-width: none;
  }
`;

    var __decorate$6 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let W3mAccountTokensWidget = class W3mAccountTokensWidget extends s$a {
        constructor() {
            super();
            this.unsubscribe = [];
            this.tokenBalance = AccountController.state.tokenBalance;
            this.unsubscribe.push(...[
                AccountController.subscribe(val => {
                    this.tokenBalance = val.tokenBalance;
                })
            ]);
        }
        disconnectedCallback() {
            this.unsubscribe.forEach(unsubscribe => unsubscribe());
        }
        firstUpdated() {
            AccountController.fetchTokenBalance();
        }
        render() {
            return x$4 `${this.tokenTemplate()}`;
        }
        tokenTemplate() {
            if (this.tokenBalance && this.tokenBalance?.length > 0) {
                return x$4 `<wui-flex class="contentContainer" flexDirection="column" gap="xs">
        ${this.tokenItemTemplate()}
      </wui-flex>`;
            }
            return x$4 ` <wui-flex flexDirection="column" gap="xs"
      ><wui-list-description
        @click=${this.onBuyClick.bind(this)}
        text="Buy Crypto"
        description="Easy with card or bank account"
        icon="card"
        iconColor="success-100"
        iconBackgroundColor="success-100"
        tag="popular"
      ></wui-list-description
      ><wui-list-description
        @click=${this.onReceiveClick.bind(this)}
        text="Receive funds"
        description="Transfer tokens on your wallet"
        icon="arrowBottomCircle"
        iconColor="fg-200"
        iconBackgroundColor="fg-200"
      ></wui-list-description
    ></wui-flex>`;
        }
        tokenItemTemplate() {
            return this.tokenBalance?.map(token => x$4 `<wui-list-token
          tokenName=${token.name}
          tokenImageUrl=${token.iconUrl}
          tokenAmount=${token.quantity.numeric}
          tokenValue=${token.value}
          tokenCurrency=${token.symbol}
        ></wui-list-token>`);
        }
        onReceiveClick() {
            RouterController.push('WalletReceive');
        }
        onBuyClick() {
            RouterController.push('OnRampProviders');
        }
    };
    W3mAccountTokensWidget.styles = styles$5;
    __decorate$6([
        r$e()
    ], W3mAccountTokensWidget.prototype, "tokenBalance", void 0);
    W3mAccountTokensWidget = __decorate$6([
        customElement('w3m-account-tokens-widget')
    ], W3mAccountTokensWidget);

    var styles$4 = i$d `
  :host {
    height: 100%;
  }

  .contentContainer {
    height: 280px;
  }

  .contentContainer > wui-icon-box {
    width: 40px;
    height: 40px;
    border-radius: var(--wui-border-radius-xxs);
  }

  .contentContainer > .textContent {
    width: 65%;
  }
`;

    var __decorate$5 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    const PAGINATOR_ID = 'last-transaction';
    const LOADING_ITEM_COUNT = 7;
    let W3mActivityList = class W3mActivityList extends s$a {
        constructor() {
            super();
            this.unsubscribe = [];
            this.paginationObserver = undefined;
            this.page = 'activity';
            this.address = AccountController.state.address;
            this.transactionsByYear = TransactionsController.state.transactionsByYear;
            this.loading = TransactionsController.state.loading;
            this.empty = TransactionsController.state.empty;
            this.next = TransactionsController.state.next;
            TransactionsController.clearCursor();
            this.unsubscribe.push(...[
                AccountController.subscribe(val => {
                    if (val.isConnected) {
                        if (this.address !== val.address) {
                            this.address = val.address;
                            TransactionsController.resetTransactions();
                            TransactionsController.fetchTransactions(val.address);
                        }
                    }
                }),
                TransactionsController.subscribe(val => {
                    this.transactionsByYear = val.transactionsByYear;
                    this.loading = val.loading;
                    this.empty = val.empty;
                    this.next = val.next;
                })
            ]);
        }
        firstUpdated() {
            TransactionsController.fetchTransactions(this.address);
            this.createPaginationObserver();
        }
        updated() {
            this.setPaginationObserver();
        }
        disconnectedCallback() {
            this.unsubscribe.forEach(unsubscribe => unsubscribe());
        }
        render() {
            return x$4 ` ${this.empty ? null : this.templateTransactionsByYear()}
    ${this.loading ? this.templateLoading() : null}
    ${!this.loading && this.empty ? this.templateEmpty() : null}`;
        }
        templateTransactionsByYear() {
            const sortedYearKeys = Object.keys(this.transactionsByYear).sort().reverse();
            return sortedYearKeys.map((year, index) => {
                const isLastGroup = index === sortedYearKeys.length - 1;
                const yearInt = parseInt(year, 10);
                const sortedMonthIndexes = new Array(12)
                    .fill(null)
                    .map((_, idx) => idx)
                    .reverse();
                return sortedMonthIndexes.map(month => {
                    const groupTitle = TransactionUtil.getTransactionGroupTitle(yearInt, month);
                    const transactions = this.transactionsByYear[yearInt]?.[month];
                    if (!transactions) {
                        return null;
                    }
                    return x$4 `
          <wui-flex flexDirection="column">
            <wui-flex
              alignItems="center"
              flexDirection="row"
              .padding=${['xs', 's', 's', 's']}
            >
              <wui-text variant="paragraph-500" color="fg-200">${groupTitle}</wui-text>
            </wui-flex>
            <wui-flex flexDirection="column" gap="xs">
              ${this.templateTransactions(transactions, isLastGroup)}
            </wui-flex>
          </wui-flex>
        `;
                });
            });
        }
        templateRenderTransaction(transaction, isLastTransaction) {
            const { date, descriptions, direction, isAllNFT, images, status, transfers, type } = this.getTransactionListItemProps(transaction);
            const haveMultipleTransfers = transfers?.length > 1;
            const haveTwoTransfers = transfers?.length === 2;
            if (haveTwoTransfers && !isAllNFT) {
                return x$4 `
        <wui-transaction-list-item
          date=${date}
          .direction=${direction}
          id=${isLastTransaction && this.next ? PAGINATOR_ID : ''}
          status=${status}
          type=${type}
          .images=${images}
          .descriptions=${descriptions}
        ></wui-transaction-list-item>
      `;
            }
            if (haveMultipleTransfers) {
                return transfers.map((transfer, index) => {
                    const description = TransactionUtil.getTransferDescription(transfer);
                    const isLastTransfer = isLastTransaction && index === transfers.length - 1;
                    return x$4 ` <wui-transaction-list-item
          date=${date}
          direction=${transfer.direction}
          id=${isLastTransfer && this.next ? PAGINATOR_ID : ''}
          status=${status}
          type=${type}
          .onlyDirectionIcon=${true}
          .images=${[images[index]]}
          .descriptions=${[description]}
        ></wui-transaction-list-item>`;
                });
            }
            return x$4 `
      <wui-transaction-list-item
        date=${date}
        .direction=${direction}
        id=${isLastTransaction && this.next ? PAGINATOR_ID : ''}
        status=${status}
        type=${type}
        .images=${images}
        .descriptions=${descriptions}
      ></wui-transaction-list-item>
    `;
        }
        templateTransactions(transactions, isLastGroup) {
            return transactions.map((transaction, index) => {
                const isLastTransaction = isLastGroup && index === transactions.length - 1;
                return x$4 `${this.templateRenderTransaction(transaction, isLastTransaction)}`;
            });
        }
        emptyStateActivity() {
            return x$4 `<wui-flex
      flexGrow="1"
      flexDirection="column"
      justifyContent="center"
      alignItems="center"
      .padding=${['3xl', 'xl', '3xl', 'xl']}
      gap="xl"
    >
      <wui-icon-box
        backgroundColor="glass-005"
        background="gray"
        iconColor="fg-200"
        icon="wallet"
        size="lg"
        ?border=${true}
        borderColor="wui-color-bg-125"
      ></wui-icon-box>
      <wui-flex flexDirection="column" alignItems="center" gap="xs">
        <wui-text align="center" variant="paragraph-500" color="fg-100"
          >No Transactions yet</wui-text
        >
        <wui-text align="center" variant="small-500" color="fg-200"
          >Start trading on dApps <br />
          to grow your wallet!</wui-text
        >
      </wui-flex>
    </wui-flex>`;
        }
        emptyStateAccount() {
            return x$4 `<wui-flex
      class="contentContainer"
      alignItems="center"
      justifyContent="center"
      flexDirection="column"
      gap="l"
    >
      <wui-icon-box
        icon="swapHorizontal"
        size="inherit"
        iconColor="fg-200"
        backgroundColor="fg-200"
        iconSize="lg"
      ></wui-icon-box>
      <wui-flex
        class="textContent"
        gap="xs"
        flexDirection="column"
        justifyContent="center"
        flexDirection="column"
      >
        <wui-text variant="paragraph-500" align="center" color="fg-100">No activity yet</wui-text>
        <wui-text variant="small-400" align="center" color="fg-200"
          >Your next transactions will appear here</wui-text
        >
      </wui-flex>
      <wui-link @click=${this.onReceiveClick.bind(this)}>Trade</wui-link>
    </wui-flex>`;
        }
        templateEmpty() {
            if (this.page === 'account') {
                return x$4 `${this.emptyStateAccount()}`;
            }
            return x$4 `${this.emptyStateActivity()}`;
        }
        templateLoading() {
            if (this.page === 'activity') {
                return Array(LOADING_ITEM_COUNT)
                    .fill(x$4 ` <wui-transaction-list-item-loader></wui-transaction-list-item-loader> `)
                    .map(item => item);
            }
            return null;
        }
        onReceiveClick() {
            RouterController.push('WalletReceive');
        }
        createPaginationObserver() {
            const { projectId } = OptionsController.state;
            this.paginationObserver = new IntersectionObserver(([element]) => {
                if (element?.isIntersecting && !this.loading) {
                    TransactionsController.fetchTransactions(this.address);
                    EventsController.sendEvent({
                        type: 'track',
                        event: 'LOAD_MORE_TRANSACTIONS',
                        properties: {
                            address: this.address,
                            projectId,
                            cursor: this.next
                        }
                    });
                }
            }, {});
            this.setPaginationObserver();
        }
        setPaginationObserver() {
            this.paginationObserver?.disconnect();
            const lastItem = this.shadowRoot?.querySelector(`#${PAGINATOR_ID}`);
            if (lastItem) {
                this.paginationObserver?.observe(lastItem);
            }
        }
        getTransactionListItemProps(transaction) {
            const date = DateUtil.formatDate(transaction?.metadata?.minedAt);
            const descriptions = TransactionUtil.getTransactionDescriptions(transaction);
            const transfers = transaction?.transfers;
            const transfer = transaction?.transfers?.[0];
            const isAllNFT = Boolean(transfer) && transaction?.transfers?.every(item => Boolean(item.nft_info));
            const images = TransactionUtil.getTransactionImages(transfers);
            return {
                date,
                direction: transfer?.direction,
                descriptions,
                isAllNFT,
                images,
                status: transaction.metadata?.status,
                transfers,
                type: transaction.metadata?.operationType
            };
        }
    };
    W3mActivityList.styles = styles$4;
    __decorate$5([
        n$d()
    ], W3mActivityList.prototype, "page", void 0);
    __decorate$5([
        r$e()
    ], W3mActivityList.prototype, "address", void 0);
    __decorate$5([
        r$e()
    ], W3mActivityList.prototype, "transactionsByYear", void 0);
    __decorate$5([
        r$e()
    ], W3mActivityList.prototype, "loading", void 0);
    __decorate$5([
        r$e()
    ], W3mActivityList.prototype, "empty", void 0);
    __decorate$5([
        r$e()
    ], W3mActivityList.prototype, "next", void 0);
    W3mActivityList = __decorate$5([
        customElement('w3m-activity-list')
    ], W3mActivityList);

    var styles$3 = i$d `
  :host {
    width: 100%;
    height: 100px;
    border-radius: var(--wui-border-radius-s);
    border: 1px solid var(--wui-gray-glass-002);
    background-color: var(--wui-gray-glass-002);
    transition: all var(--wui-ease-out-power-1) var(--wui-duration-lg);
  }

  :host(:hover) {
    background-color: var(--wui-gray-glass-005);
  }

  wui-flex {
    width: 100%;
    height: fit-content;
  }

  wui-button {
    width: 100%;
    display: flex;
    justify-content: flex-end;
  }
`;

    var __decorate$4 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let W3mInputToken = class W3mInputToken extends s$a {
        render() {
            return x$4 ` <wui-flex
      flexDirection="column"
      gap="4xs"
      .padding=${['xl', 's', 'l', 'l']}
    >
      <wui-flex alignItems="center">
        <wui-input-amount
          @inputChange=${this.onInputChange.bind(this)}
          ?disabled=${!this.token && true}
          .value=${this.sendTokenAmount ? String(this.sendTokenAmount) : ''}
        ></wui-input-amount>
        ${this.buttonTemplate()}
      </wui-flex>
      <wui-flex alignItems="center" justifyContent="space-between">
        ${this.sendValueTemplate()}
        <wui-flex alignItems="center" gap="4xs" justifyContent="flex-end">
          ${this.maxAmountTemplate()} ${this.actionTemplate()}
        </wui-flex>
      </wui-flex>
    </wui-flex>`;
        }
        buttonTemplate() {
            if (this.token) {
                return x$4 `<wui-token-button
        text=${this.token.symbol}
        imageSrc=${this.token.iconUrl}
        @click=${this.handleSelectButtonClick.bind(this)}
        >Select token</wui-token-button
      >`;
            }
            return x$4 `<wui-button
      size="md"
      variant="accentBg"
      @click=${this.handleSelectButtonClick.bind(this)}
      >Select token</wui-button
    >`;
        }
        handleSelectButtonClick() {
            RouterController.push('WalletSendSelectToken');
        }
        sendValueTemplate() {
            if (this.token && this.sendTokenAmount) {
                const price = this.token.price;
                const totalValue = price * this.sendTokenAmount;
                return x$4 `<wui-text variant="small-400" color="fg-200">$${totalValue.toFixed(2)}</wui-text>`;
            }
            return null;
        }
        maxAmountTemplate() {
            if (this.token) {
                if (this.sendTokenAmount && this.sendTokenAmount > Number(this.token.quantity.numeric)) {
                    return x$4 ` <wui-text variant="small-400" color="error-100">
          ${UiHelperUtil.roundNumber(Number(this.token.quantity.numeric), 6, 5)}
        </wui-text>`;
                }
                return x$4 ` <wui-text variant="small-400" color="fg-200">
        ${UiHelperUtil.roundNumber(Number(this.token.quantity.numeric), 6, 5)}
      </wui-text>`;
            }
            return null;
        }
        actionTemplate() {
            if (this.token) {
                if (this.sendTokenAmount && this.sendTokenAmount > Number(this.token.quantity.numeric)) {
                    return x$4 `<wui-link @click=${this.onBuyClick.bind(this)}>Buy</wui-link>`;
                }
                return x$4 `<wui-link @click=${this.onMaxClick.bind(this)}>Max</wui-link>`;
            }
            return null;
        }
        onInputChange(event) {
            SendController.setTokenAmount(event.detail);
        }
        onMaxClick() {
            if (this.token) {
                SendController.setTokenAmount(Number(this.token?.quantity.numeric));
            }
        }
        onBuyClick() {
            RouterController.push('OnRampProviders');
        }
    };
    W3mInputToken.styles = styles$3;
    __decorate$4([
        n$d({ type: Object })
    ], W3mInputToken.prototype, "token", void 0);
    __decorate$4([
        n$d({ type: Number })
    ], W3mInputToken.prototype, "sendTokenAmount", void 0);
    W3mInputToken = __decorate$4([
        customElement('w3m-input-token')
    ], W3mInputToken);

    var styles$2 = i$d `
  :host {
    width: 100%;
    height: 100px;
    border-radius: var(--wui-border-radius-s);
    border: 1px solid var(--wui-gray-glass-002);
    background-color: var(--wui-gray-glass-002);
    transition: all var(--wui-ease-out-power-1) var(--wui-duration-lg);
    position: relative;
  }

  :host(:hover) {
    background-color: var(--wui-gray-glass-005);
  }

  wui-flex {
    width: 100%;
    height: fit-content;
  }

  wui-button {
    display: ruby;
    color: var(--wui-color-fg-100);
    margin: 0 var(--wui-spacing-xs);
  }

  .instruction {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
  }

  textarea {
    background: transparent;
    width: 100%;
    font-family: var(--w3m-font-family);
    font-size: var(--wui-font-size-medium);
    font-style: normal;
    font-weight: var(--wui-font-weight-light);
    line-height: 130%;
    letter-spacing: var(--wui-letter-spacing-medium);
    color: var(--wui-color-fg-100);
    caret-color: var(--wui-color-accent-100);
    box-sizing: border-box;
    -webkit-appearance: none;
    -moz-appearance: textfield;
    padding: 0px;
    border: none;
    outline: none;
    appearance: none;
    resize: none;
    overflow: hidden;
  }
`;

    var __decorate$3 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let W3mInputAddress = class W3mInputAddress extends s$a {
        constructor() {
            super(...arguments);
            this.inputElementRef = e$b();
            this.instructionElementRef = e$b();
            this.instructionHidden = Boolean(this.receiverAddress);
        }
        firstUpdated() {
            if (this.receiverAddress) {
                this.instructionHidden = true;
            }
            this.checkHidden();
        }
        render() {
            return x$4 ` <wui-flex
      @click=${this.onBoxClick.bind(this)}
      flexDirection="column"
      justifyContent="center"
      gap="4xs"
      .padding=${['2xl', 'l', 'xl', 'l']}
    >
      <wui-text
        ${n$b(this.instructionElementRef)}
        class="instruction"
        color="fg-300"
        variant="medium-400"
      >
        Type or
        <wui-button
          size="sm"
          variant="shade"
          iconLeft="copy"
          @click=${this.onPasteClick.bind(this)}
        >
          <wui-icon size="sm" color="inherit" slot="iconLeft" name="copy"></wui-icon>
          Paste
        </wui-button>
        address
      </wui-text>
      <textarea
        ?disabled=${!this.instructionHidden}
        ${n$b(this.inputElementRef)}
        @input=${this.onInputChange.bind(this)}
        @blur=${this.onBlur.bind(this)}
        .value=${this.receiverAddress ?? ''}
        autocomplete="off"
      >
${this.receiverAddress ?? ''}</textarea
      >
    </wui-flex>`;
        }
        async focusInput() {
            if (this.instructionElementRef.value) {
                this.instructionHidden = true;
                await this.toggleInstructionFocus(false);
                this.instructionElementRef.value.style.pointerEvents = 'none';
                this.inputElementRef.value?.focus();
                if (this.inputElementRef.value) {
                    this.inputElementRef.value.selectionStart = this.inputElementRef.value.selectionEnd =
                        this.inputElementRef.value.value.length;
                }
            }
        }
        async focusInstruction() {
            if (this.instructionElementRef.value) {
                this.instructionHidden = false;
                await this.toggleInstructionFocus(true);
                this.instructionElementRef.value.style.pointerEvents = 'auto';
                this.inputElementRef.value?.blur();
            }
        }
        async toggleInstructionFocus(focus) {
            if (this.instructionElementRef.value) {
                await this.instructionElementRef.value.animate([{ opacity: focus ? 0 : 1 }, { opacity: focus ? 1 : 0 }], {
                    duration: 100,
                    easing: 'ease',
                    fill: 'forwards'
                }).finished;
            }
        }
        onBoxClick() {
            if (!this.receiverAddress && !this.instructionHidden) {
                this.focusInput();
            }
        }
        onBlur() {
            if (!this.receiverAddress && this.instructionHidden) {
                this.focusInstruction();
            }
        }
        checkHidden() {
            if (this.instructionHidden) {
                this.focusInput();
            }
        }
        async onPasteClick() {
            const text = await navigator.clipboard.readText();
            SendController.setReceiverAddress(text);
        }
        onInputChange(e) {
            const element = e.target;
            if (element.value && !this.instructionHidden) {
                this.focusInput();
            }
            SendController.setReceiverAddress(element.value);
        }
    };
    W3mInputAddress.styles = styles$2;
    __decorate$3([
        n$d()
    ], W3mInputAddress.prototype, "receiverAddress", void 0);
    __decorate$3([
        r$e()
    ], W3mInputAddress.prototype, "instructionHidden", void 0);
    W3mInputAddress = __decorate$3([
        customElement('w3m-input-address')
    ], W3mInputAddress);

    var styles$1 = i$d `
  :host {
    display: flex;
    width: 100%;
    flex-direction: column;
    gap: var(--wui-border-radius-1xs);
    border-radius: var(--wui-border-radius-s);
    background: var(--wui-gray-glass-002);
    padding: var(--wui-spacing-s) var(--wui-spacing-1xs) var(--wui-spacing-1xs)
      var(--wui-spacing-1xs);
  }

  wui-text {
    padding: 0 var(--wui-spacing-1xs);
  }

  wui-flex {
    margin-top: var(--wui-spacing-1xs);
  }

  .network {
    cursor: pointer;
    transition: all var(--wui-ease-out-power-1) var(--wui-duration-lg);
  }

  .network:focus-visible {
    border: 1px solid var(--wui-color-accent-100);
    background-color: var(--wui-gray-glass-005);
    -webkit-box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
    -moz-box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
    box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
  }

  .network:hover {
    background-color: var(--wui-gray-glass-005);
  }

  .network:active {
    transition: all var(--wui-ease-out-power-2) var(--wui-duration-sm);
    background-color: var(--wui-gray-glass-010);
  }
`;

    var __decorate$2 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let W3mWalletSendDetails = class W3mWalletSendDetails extends s$a {
        render() {
            return x$4 ` <wui-text variant="small-400" color="fg-200">Details</wui-text>
      <wui-flex flexDirection="column" gap="xxs">
        <wui-list-content textTitle="Network cost" textValue="$3.20"></wui-list-content>
        <wui-list-content
          textTitle="Address"
          textValue=${UiHelperUtil.getTruncateString({
            string: this.receiverAddress ?? '',
            charsStart: 4,
            charsEnd: 4,
            truncate: 'middle'
        })}
        >
        </wui-list-content>
        ${this.networkTemplate()}
      </wui-flex>`;
        }
        networkTemplate() {
            if (this.caipNetwork?.name) {
                return x$4 ` <wui-list-content
        @click=${() => this.onNetworkClick(this.caipNetwork)}
        class="network"
        textTitle="Network"
        imageSrc=${o$e(AssetUtil.getNetworkImage(this.caipNetwork))}
      ></wui-list-content>`;
            }
            return null;
        }
        onNetworkClick(network) {
            if (network) {
                RouterController.push('Networks', { network });
            }
        }
    };
    W3mWalletSendDetails.styles = styles$1;
    __decorate$2([
        n$d()
    ], W3mWalletSendDetails.prototype, "receiverAddress", void 0);
    __decorate$2([
        n$d({ type: Object })
    ], W3mWalletSendDetails.prototype, "caipNetwork", void 0);
    W3mWalletSendDetails = __decorate$2([
        customElement('w3m-wallet-send-details')
    ], W3mWalletSendDetails);

    let isInitialized = false;
    class Web3ModalScaffold {
        constructor(options) {
            this.initPromise = undefined;
            this.setIsConnected = isConnected => {
                AccountController.setIsConnected(isConnected);
            };
            this.setCaipAddress = caipAddress => {
                AccountController.setCaipAddress(caipAddress);
            };
            this.setBalance = (balance, balanceSymbol) => {
                AccountController.setBalance(balance, balanceSymbol);
            };
            this.fetchTokenBalance = () => {
                AccountController.fetchTokenBalance();
            };
            this.setProfileName = profileName => {
                AccountController.setProfileName(profileName);
            };
            this.setProfileImage = profileImage => {
                AccountController.setProfileImage(profileImage);
            };
            this.resetAccount = () => {
                AccountController.resetAccount();
            };
            this.setCaipNetwork = caipNetwork => {
                NetworkController.setCaipNetwork(caipNetwork);
            };
            this.getCaipNetwork = () => NetworkController.state.caipNetwork;
            this.setRequestedCaipNetworks = requestedCaipNetworks => {
                NetworkController.setRequestedCaipNetworks(requestedCaipNetworks);
            };
            this.getApprovedCaipNetworksData = () => NetworkController.getApprovedCaipNetworksData();
            this.resetNetwork = () => {
                NetworkController.resetNetwork();
            };
            this.setConnectors = connectors => {
                ConnectorController.setConnectors(connectors);
            };
            this.addConnector = connector => {
                ConnectorController.addConnector(connector);
            };
            this.getConnectors = () => ConnectorController.getConnectors();
            this.resetWcConnection = () => {
                ConnectionController.resetWcConnection();
            };
            this.fetchIdentity = request => BlockchainApiController.fetchIdentity(request);
            this.setAddressExplorerUrl = addressExplorerUrl => {
                AccountController.setAddressExplorerUrl(addressExplorerUrl);
            };
            this.setSmartAccountDeployed = isDeployed => {
                AccountController.setSmartAccountDeployed(isDeployed);
            };
            this.initControllers(options);
            this.initOrContinue();
        }
        async open(options) {
            await this.initOrContinue();
            ModalController.open(options);
        }
        async close() {
            await this.initOrContinue();
            ModalController.close();
        }
        setLoading(loading) {
            ModalController.setLoading(loading);
        }
        getThemeMode() {
            return ThemeController.state.themeMode;
        }
        getThemeVariables() {
            return ThemeController.state.themeVariables;
        }
        setThemeMode(themeMode) {
            ThemeController.setThemeMode(themeMode);
            setColorTheme(ThemeController.state.themeMode);
        }
        setThemeVariables(themeVariables) {
            ThemeController.setThemeVariables(themeVariables);
            setThemeVariables(ThemeController.state.themeVariables);
        }
        subscribeTheme(callback) {
            return ThemeController.subscribe(callback);
        }
        getState() {
            return { ...PublicStateController.state };
        }
        subscribeState(callback) {
            return PublicStateController.subscribe(callback);
        }
        showErrorMessage(message) {
            SnackController.showError(message);
        }
        showSuccessMessage(message) {
            SnackController.showSuccess(message);
        }
        getEvent() {
            return { ...EventsController.state };
        }
        subscribeEvents(callback) {
            return EventsController.subscribe(callback);
        }
        async initControllers(options) {
            NetworkController.setClient(options.networkControllerClient);
            NetworkController.setDefaultCaipNetwork(options.defaultChain);
            OptionsController.setProjectId(options.projectId);
            OptionsController.setAllWallets(options.allWallets);
            OptionsController.setIncludeWalletIds(options.includeWalletIds);
            OptionsController.setExcludeWalletIds(options.excludeWalletIds);
            OptionsController.setFeaturedWalletIds(options.featuredWalletIds);
            OptionsController.setTokens(options.tokens);
            OptionsController.setTermsConditionsUrl(options.termsConditionsUrl);
            OptionsController.setPrivacyPolicyUrl(options.privacyPolicyUrl);
            OptionsController.setCustomWallets(options.customWallets);
            OptionsController.setEnableAnalytics(options.enableAnalytics);
            OptionsController.setSdkVersion(options._sdkVersion);
            ConnectionController.setClient(options.connectionControllerClient);
            if (options.siweControllerClient) {
                const { SIWEController } = await Promise.resolve().then(function () { return index$1; });
                SIWEController.setSIWEClient(options.siweControllerClient);
            }
            if (options.metadata) {
                OptionsController.setMetadata(options.metadata);
            }
            if (options.themeMode) {
                ThemeController.setThemeMode(options.themeMode);
            }
            if (options.themeVariables) {
                ThemeController.setThemeVariables(options.themeVariables);
            }
            if (options.enableOnramp) {
                OptionsController.setOnrampEnabled(Boolean(options.enableOnramp));
            }
            if (options.enableWalletFeatures) {
                OptionsController.setWalletFeaturesEnabled(Boolean(options.enableWalletFeatures));
            }
            if (options.allowUnsupportedChain) {
                NetworkController.setAllowUnsupportedChain(options.allowUnsupportedChain);
            }
        }
        async initOrContinue() {
            if (!this.initPromise && !isInitialized && CoreHelperUtil.isClient()) {
                isInitialized = true;
                this.initPromise = new Promise(async (resolve) => {
                    await Promise.all([Promise.resolve().then(function () { return index$6; }), Promise.resolve().then(function () { return index$5; })]);
                    const modal = document.createElement('w3m-modal');
                    document.body.insertAdjacentElement('beforeend', modal);
                    resolve();
                });
            }
            return this.initPromise;
        }
    }

    const ConstantsUtil = {
        WALLET_CONNECT_CONNECTOR_ID: 'walletConnect',
        INJECTED_CONNECTOR_ID: 'injected',
        COINBASE_CONNECTOR_ID: 'coinbaseWallet',
        COINBASE_SDK_CONNECTOR_ID: 'coinbaseWalletSDK',
        SAFE_CONNECTOR_ID: 'safe',
        LEDGER_CONNECTOR_ID: 'ledger',
        EIP6963_CONNECTOR_ID: 'eip6963',
        EMAIL_CONNECTOR_ID: 'w3mEmail',
        EIP155: 'eip155',
        ADD_CHAIN_METHOD: 'wallet_addEthereumChain',
        EIP6963_ANNOUNCE_EVENT: 'eip6963:announceProvider',
        EIP6963_REQUEST_EVENT: 'eip6963:requestProvider',
        VERSION: '4.1.3'
    };

    const PresetsUtil = {
        ConnectorExplorerIds: {
            [ConstantsUtil.COINBASE_CONNECTOR_ID]: 'fd20dc426fb37566d803205b19bbc1d4096b248ac04548e3cfb6b3a38bd033aa',
            [ConstantsUtil.SAFE_CONNECTOR_ID]: '225affb176778569276e484e1b92637ad061b01e13a048b35a9d280c3b58970f',
            [ConstantsUtil.LEDGER_CONNECTOR_ID]: '19177a98252e07ddfc9af2083ba8e07ef627cb6103467ffebb3f8f4205fd7927'
        },
        EIP155NetworkImageIds: {
            1: '692ed6ba-e569-459a-556a-776476829e00',
            42161: '3bff954d-5cb0-47a0-9a23-d20192e74600',
            43114: '30c46e53-e989-45fb-4549-be3bd4eb3b00',
            56: '93564157-2e8e-4ce7-81df-b264dbee9b00',
            250: '06b26297-fe0c-4733-5d6b-ffa5498aac00',
            10: 'ab9c186a-c52f-464b-2906-ca59d760a400',
            137: '41d04d42-da3b-4453-8506-668cc0727900',
            100: '02b53f6a-e3d4-479e-1cb4-21178987d100',
            9001: 'f926ff41-260d-4028-635e-91913fc28e00',
            324: 'b310f07f-4ef7-49f3-7073-2a0a39685800',
            314: '5a73b3dd-af74-424e-cae0-0de859ee9400',
            4689: '34e68754-e536-40da-c153-6ef2e7188a00',
            1088: '3897a66d-40b9-4833-162f-a2c90531c900',
            1284: '161038da-44ae-4ec7-1208-0ea569454b00',
            1285: 'f1d73bb6-5450-4e18-38f7-fb6484264a00',
            7777777: '845c60df-d429-4991-e687-91ae45791600',
            42220: 'ab781bbc-ccc6-418d-d32d-789b15da1f00',
            8453: '7289c336-3981-4081-c5f4-efc26ac64a00',
            1313161554: '3ff73439-a619-4894-9262-4470c773a100',
            2020: 'b8101fc0-9c19-4b6f-ec65-f6dfff106e00',
            2021: 'b8101fc0-9c19-4b6f-ec65-f6dfff106e00',
            '5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp': 'a1b58899-f671-4276-6a5e-56ca5bd59700',
            '4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z': 'a1b58899-f671-4276-6a5e-56ca5bd59700',
            EtWTRABZaYq6iMfeYKouRu166VU2xqa1: 'a1b58899-f671-4276-6a5e-56ca5bd59700'
        },
        ConnectorImageIds: {
            [ConstantsUtil.COINBASE_CONNECTOR_ID]: '0c2840c3-5b04-4c44-9661-fbd4b49e1800',
            [ConstantsUtil.COINBASE_SDK_CONNECTOR_ID]: '0c2840c3-5b04-4c44-9661-fbd4b49e1800',
            [ConstantsUtil.SAFE_CONNECTOR_ID]: '461db637-8616-43ce-035a-d89b8a1d5800',
            [ConstantsUtil.LEDGER_CONNECTOR_ID]: '54a1aa77-d202-4f8d-0fb2-5d2bb6db0300',
            [ConstantsUtil.WALLET_CONNECT_CONNECTOR_ID]: 'ef1a1fcf-7fe8-4d69-bd6d-fda1345b4400',
            [ConstantsUtil.INJECTED_CONNECTOR_ID]: '07ba87ed-43aa-4adf-4540-9e6a2b9cae00'
        },
        ConnectorNamesMap: {
            [ConstantsUtil.INJECTED_CONNECTOR_ID]: 'Browser Wallet',
            [ConstantsUtil.WALLET_CONNECT_CONNECTOR_ID]: 'WalletConnect',
            [ConstantsUtil.COINBASE_CONNECTOR_ID]: 'Coinbase',
            [ConstantsUtil.COINBASE_SDK_CONNECTOR_ID]: 'Coinbase',
            [ConstantsUtil.LEDGER_CONNECTOR_ID]: 'Ledger',
            [ConstantsUtil.SAFE_CONNECTOR_ID]: 'Safe'
        },
        ConnectorTypesMap: {
            [ConstantsUtil.INJECTED_CONNECTOR_ID]: 'INJECTED',
            [ConstantsUtil.WALLET_CONNECT_CONNECTOR_ID]: 'WALLET_CONNECT',
            [ConstantsUtil.EIP6963_CONNECTOR_ID]: 'ANNOUNCED',
            [ConstantsUtil.EMAIL_CONNECTOR_ID]: 'EMAIL'
        },
        WalletConnectRpcChainIds: [
            1,
            5,
            11155111,
            10,
            420,
            42161,
            421613,
            137,
            80001,
            42220,
            1313161554,
            1313161555,
            56,
            97,
            43114,
            43113,
            100,
            8453,
            84531,
            7777777,
            999,
            324,
            280
        ]
    };

    const HelpersUtil = {
        caipNetworkIdToNumber(caipnetworkId) {
            return caipnetworkId ? Number(caipnetworkId.split(':')[1]) : undefined;
        },
        getCaipTokens(tokens) {
            if (!tokens) {
                return undefined;
            }
            const caipTokens = {};
            Object.entries(tokens).forEach(([id, token]) => {
                caipTokens[`${ConstantsUtil.EIP155}:${id}`] = token;
            });
            return caipTokens;
        }
    };

    function getCaipDefaultChain(chain) {
        if (!chain) {
            return undefined;
        }
        return {
            id: `${ConstantsUtil.EIP155}:${chain.id}`,
            name: chain.name,
            imageId: PresetsUtil.EIP155NetworkImageIds[chain.id]
        };
    }
    async function getWalletConnectCaipNetworks(connector) {
        if (!connector) {
            throw new Error('networkControllerClient:getApprovedCaipNetworks - connector is undefined');
        }
        const provider = (await connector?.getProvider());
        const ns = provider?.signer?.session?.namespaces;
        const nsMethods = ns?.[ConstantsUtil.EIP155]?.methods;
        const nsChains = ns?.[ConstantsUtil.EIP155]?.chains;
        return {
            supportsAllNetworks: Boolean(nsMethods?.includes(ConstantsUtil.ADD_CHAIN_METHOD)),
            approvedCaipNetworkIds: nsChains
        };
    }
    function getEmailCaipNetworks() {
        return {
            supportsAllNetworks: false,
            approvedCaipNetworkIds: PresetsUtil.WalletConnectRpcChainIds.map(id => `${ConstantsUtil.EIP155}:${id}`)
        };
    }
    function getTransport({ chainId, projectId }) {
        const RPC_URL = CoreHelperUtil.getBlockchainApiUrl();
        if (!PresetsUtil.WalletConnectRpcChainIds.includes(chainId)) {
            return http();
        }
        return http(`${RPC_URL}/v1/?chainId=${ConstantsUtil.EIP155}:${chainId}&projectId=${projectId}`);
    }

    class Web3Modal extends Web3ModalScaffold {
        constructor(options) {
            const { wagmiConfig, siweConfig, defaultChain, tokens, _sdkVersion, ...w3mOptions } = options;
            if (!wagmiConfig) {
                throw new Error('web3modal:constructor - wagmiConfig is undefined');
            }
            if (!w3mOptions.projectId) {
                throw new Error('web3modal:constructor - projectId is undefined');
            }
            const networkControllerClient = {
                switchCaipNetwork: async (caipNetwork) => {
                    const chainId = HelpersUtil.caipNetworkIdToNumber(caipNetwork?.id);
                    if (chainId) {
                        await switchChain(this.wagmiConfig, { chainId });
                    }
                },
                getApprovedCaipNetworksData: async () => new Promise(resolve => {
                    const connections = new Map(wagmiConfig.state.connections);
                    const connection = connections.get(wagmiConfig.state.current || '');
                    if (connection?.connector?.id === ConstantsUtil.EMAIL_CONNECTOR_ID) {
                        resolve(getEmailCaipNetworks());
                    }
                    else if (connection?.connector?.id === ConstantsUtil.WALLET_CONNECT_CONNECTOR_ID) {
                        const connector = wagmiConfig.connectors.find(c => c.id === ConstantsUtil.WALLET_CONNECT_CONNECTOR_ID);
                        resolve(getWalletConnectCaipNetworks(connector));
                    }
                    resolve({ approvedCaipNetworkIds: undefined, supportsAllNetworks: true });
                })
            };
            const connectionControllerClient = {
                connectWalletConnect: async (onUri) => {
                    const connector = wagmiConfig.connectors.find(c => c.id === ConstantsUtil.WALLET_CONNECT_CONNECTOR_ID);
                    if (!connector) {
                        throw new Error('connectionControllerClient:getWalletConnectUri - connector is undefined');
                    }
                    const provider = (await connector.getProvider());
                    provider.on('display_uri', data => {
                        onUri(data);
                    });
                    const chainId = HelpersUtil.caipNetworkIdToNumber(this.getCaipNetwork()?.id);
                    await connect(this.wagmiConfig, { connector, chainId });
                },
                connectExternal: async ({ id, provider, info }) => {
                    const connector = wagmiConfig.connectors.find(c => c.id === id);
                    if (!connector) {
                        throw new Error('connectionControllerClient:connectExternal - connector is undefined');
                    }
                    if (provider && info && connector.id === ConstantsUtil.EIP6963_CONNECTOR_ID) {
                        connector.setEip6963Wallet?.({ provider, info });
                    }
                    const chainId = HelpersUtil.caipNetworkIdToNumber(this.getCaipNetwork()?.id);
                    await connect(this.wagmiConfig, { connector, chainId });
                },
                checkInstalled: ids => {
                    const injectedConnector = this.getConnectors().find(c => c.type === 'INJECTED');
                    if (!ids) {
                        return Boolean(window.ethereum);
                    }
                    if (injectedConnector) {
                        if (!window?.ethereum) {
                            return false;
                        }
                        return ids.some(id => Boolean(window.ethereum?.[String(id)]));
                    }
                    return false;
                },
                disconnect: async () => {
                    await disconnect(this.wagmiConfig);
                    if (siweConfig?.options?.signOutOnDisconnect) {
                        await siweConfig.signOut();
                    }
                },
                signMessage: async (message) => signMessage(this.wagmiConfig, { message })
            };
            super({
                networkControllerClient,
                connectionControllerClient,
                siweControllerClient: siweConfig,
                defaultChain: getCaipDefaultChain(defaultChain),
                tokens: HelpersUtil.getCaipTokens(tokens),
                _sdkVersion: _sdkVersion ?? `html-wagmi-${ConstantsUtil.VERSION}`,
                ...w3mOptions
            });
            this.hasSyncedConnectedAccount = false;
            this.options = undefined;
            this.options = options;
            this.wagmiConfig = wagmiConfig;
            this.syncRequestedNetworks([...wagmiConfig.chains]);
            this.syncConnectors([...wagmiConfig.connectors]);
            watchConnectors(this.wagmiConfig, {
                onChange: connectors => this.syncConnectors(connectors)
            });
            watchAccount(this.wagmiConfig, {
                onChange: accountData => this.syncAccount({ ...accountData })
            });
        }
        getState() {
            const state = super.getState();
            return {
                ...state,
                selectedNetworkId: HelpersUtil.caipNetworkIdToNumber(state.selectedNetworkId)
            };
        }
        subscribeState(callback) {
            return super.subscribeState(state => callback({
                ...state,
                selectedNetworkId: HelpersUtil.caipNetworkIdToNumber(state.selectedNetworkId)
            }));
        }
        syncRequestedNetworks(chains) {
            const requestedCaipNetworks = chains?.map(chain => ({
                id: `${ConstantsUtil.EIP155}:${chain.id}`,
                name: chain.name,
                imageId: PresetsUtil.EIP155NetworkImageIds[chain.id],
                imageUrl: this.options?.chainImages?.[chain.id]
            }));
            this.setRequestedCaipNetworks(requestedCaipNetworks ?? []);
        }
        async syncAccount({ address, isConnected, chainId }) {
            this.resetAccount();
            this.syncNetwork();
            if (isConnected && address && chainId) {
                const caipAddress = `${ConstantsUtil.EIP155}:${chainId}:${address}`;
                this.setIsConnected(isConnected);
                this.setCaipAddress(caipAddress);
                await Promise.all([
                    this.syncProfile(address, chainId),
                    this.syncBalance(address, chainId),
                    this.fetchTokenBalance(),
                    this.getApprovedCaipNetworksData()
                ]);
                this.hasSyncedConnectedAccount = true;
            }
            else if (!isConnected && this.hasSyncedConnectedAccount) {
                this.resetWcConnection();
                this.resetNetwork();
            }
        }
        async syncNetwork() {
            const { address, isConnected, chainId } = getAccount(this.wagmiConfig);
            const chain = this.wagmiConfig.chains.find((c) => c.id === chainId);
            if (chain || chainId) {
                const name = chain?.name ?? chainId?.toString();
                const id = Number(chain?.id ?? chainId);
                const caipChainId = `${ConstantsUtil.EIP155}:${id}`;
                this.setCaipNetwork({
                    id: caipChainId,
                    name,
                    imageId: PresetsUtil.EIP155NetworkImageIds[id],
                    imageUrl: this.options?.chainImages?.[id]
                });
                if (isConnected && address && chainId) {
                    const caipAddress = `${ConstantsUtil.EIP155}:${id}:${address}`;
                    this.setCaipAddress(caipAddress);
                    if (chain?.blockExplorers?.default?.url) {
                        const url = `${chain.blockExplorers.default.url}/address/${address}`;
                        this.setAddressExplorerUrl(url);
                    }
                    else {
                        this.setAddressExplorerUrl(undefined);
                    }
                    if (this.hasSyncedConnectedAccount) {
                        await this.syncProfile(address, chainId);
                        await this.syncBalance(address, chainId);
                    }
                }
            }
        }
        async syncProfile(address, chainId) {
            if (chainId !== mainnet.id) {
                this.setProfileName(null);
                this.setProfileImage(null);
                return;
            }
            try {
                const { name, avatar } = await this.fetchIdentity({
                    caipChainId: `${ConstantsUtil.EIP155}:${chainId}`,
                    address
                });
                this.setProfileName(name);
                this.setProfileImage(avatar);
            }
            catch {
                const profileName = await getEnsName(this.wagmiConfig, { address, chainId });
                if (profileName) {
                    this.setProfileName(profileName);
                    const profileImage = await getEnsAvatar(this.wagmiConfig, {
                        name: profileName,
                        chainId
                    });
                    if (profileImage) {
                        this.setProfileImage(profileImage);
                    }
                }
            }
        }
        async syncBalance(address, chainId) {
            const chain = this.wagmiConfig.chains.find((c) => c.id === chainId);
            if (chain) {
                const balance = await getBalance(this.wagmiConfig, {
                    address,
                    chainId: chain.id,
                    token: this.options?.tokens?.[chain.id]?.address
                });
                this.setBalance(balance.formatted, balance.symbol);
                return;
            }
            this.setBalance(undefined, undefined);
        }
        syncConnectors(connectors) {
            const uniqueIds = new Set();
            const filteredConnectors = connectors.filter(item => !uniqueIds.has(item.id) && uniqueIds.add(item.id));
            const w3mConnectors = [];
            const coinbaseSDKId = ConstantsUtil.COINBASE_SDK_CONNECTOR_ID;
            const coinbaseConnector = filteredConnectors.find(c => c.id === ConstantsUtil$2.CONNECTOR_RDNS_MAP[ConstantsUtil.COINBASE_CONNECTOR_ID]);
            filteredConnectors.forEach(({ id, name, type, icon }) => {
                const isCoinbaseRepeated = coinbaseConnector && id === coinbaseSDKId;
                const shouldSkip = isCoinbaseRepeated || ConstantsUtil.EMAIL_CONNECTOR_ID === id;
                if (!shouldSkip) {
                    w3mConnectors.push({
                        id,
                        explorerId: PresetsUtil.ConnectorExplorerIds[id],
                        imageUrl: this.options?.connectorImages?.[id] ?? icon,
                        name: PresetsUtil.ConnectorNamesMap[id] ?? name,
                        imageId: PresetsUtil.ConnectorImageIds[id],
                        type: PresetsUtil.ConnectorTypesMap[type] ?? 'EXTERNAL',
                        info: {
                            rdns: id
                        }
                    });
                }
            });
            this.setConnectors(w3mConnectors);
            this.syncEmailConnector(filteredConnectors);
        }
        async syncEmailConnector(connectors) {
            const emailConnector = connectors.find(({ id }) => id === ConstantsUtil.EMAIL_CONNECTOR_ID);
            if (emailConnector) {
                const provider = await emailConnector.getProvider();
                this.addConnector({
                    id: ConstantsUtil.EMAIL_CONNECTOR_ID,
                    type: 'EMAIL',
                    name: 'Email',
                    provider
                });
                this.listenEmailConnector(emailConnector);
                this.listenModal(emailConnector);
            }
        }
        async listenEmailConnector(connector) {
            if (typeof window !== 'undefined' && connector) {
                super.setLoading(true);
                const provider = (await connector.getProvider());
                const isLoginEmailUsed = provider.getLoginEmailUsed();
                super.setLoading(isLoginEmailUsed);
                if (isLoginEmailUsed) {
                    this.setIsConnected(false);
                }
                provider.onInitSmartAccount((isDeployed) => {
                    this.setSmartAccountDeployed(isDeployed);
                });
                provider.onRpcRequest(request => {
                    if (W3mFrameHelpers.checkIfRequestExists(request)) {
                        if (!W3mFrameHelpers.checkIfRequestIsAllowed(request)) {
                            super.open({ view: 'ApproveTransaction' });
                        }
                    }
                    else {
                        super.open();
                        const method = W3mFrameHelpers.getRequestMethod(request);
                        console.error(W3mFrameRpcConstants.RPC_METHOD_NOT_ALLOWED_MESSAGE, { method });
                        setTimeout(() => {
                            this.showErrorMessage(W3mFrameRpcConstants.RPC_METHOD_NOT_ALLOWED_UI_MESSAGE);
                        }, 300);
                        provider.rejectRpcRequest();
                    }
                });
                provider.onRpcResponse(() => {
                    super.close();
                });
                provider.onNotConnected(() => {
                    this.setIsConnected(false);
                    super.setLoading(false);
                });
                provider.onIsConnected(() => {
                    this.setIsConnected(true);
                    super.setLoading(false);
                });
            }
        }
        async listenModal(connector) {
            const provider = (await connector.getProvider());
            this.subscribeState(val => {
                if (!val.open) {
                    provider.rejectRpcRequest();
                }
            });
        }
    }

    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
    var inited = false;
    function init () {
      inited = true;
      var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
      for (var i = 0, len = code.length; i < len; ++i) {
        lookup[i] = code[i];
        revLookup[code.charCodeAt(i)] = i;
      }

      revLookup['-'.charCodeAt(0)] = 62;
      revLookup['_'.charCodeAt(0)] = 63;
    }

    function toByteArray (b64) {
      if (!inited) {
        init();
      }
      var i, j, l, tmp, placeHolders, arr;
      var len = b64.length;

      if (len % 4 > 0) {
        throw new Error('Invalid string. Length must be a multiple of 4')
      }

      // the number of equal signs (place holders)
      // if there are two placeholders, than the two characters before it
      // represent one byte
      // if there is only one, then the three characters before it represent 2 bytes
      // this is just a cheap hack to not do indexOf twice
      placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;

      // base64 is 4/3 + up to two characters of the original data
      arr = new Arr(len * 3 / 4 - placeHolders);

      // if there are placeholders, only get up to the last complete 4 chars
      l = placeHolders > 0 ? len - 4 : len;

      var L = 0;

      for (i = 0, j = 0; i < l; i += 4, j += 3) {
        tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)];
        arr[L++] = (tmp >> 16) & 0xFF;
        arr[L++] = (tmp >> 8) & 0xFF;
        arr[L++] = tmp & 0xFF;
      }

      if (placeHolders === 2) {
        tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4);
        arr[L++] = tmp & 0xFF;
      } else if (placeHolders === 1) {
        tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2);
        arr[L++] = (tmp >> 8) & 0xFF;
        arr[L++] = tmp & 0xFF;
      }

      return arr
    }

    function tripletToBase64 (num) {
      return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
    }

    function encodeChunk (uint8, start, end) {
      var tmp;
      var output = [];
      for (var i = start; i < end; i += 3) {
        tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
        output.push(tripletToBase64(tmp));
      }
      return output.join('')
    }

    function fromByteArray (uint8) {
      if (!inited) {
        init();
      }
      var tmp;
      var len = uint8.length;
      var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
      var output = '';
      var parts = [];
      var maxChunkLength = 16383; // must be multiple of 3

      // go through the array every three bytes, we'll deal with trailing stuff later
      for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
        parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));
      }

      // pad the end with zeros, but make sure to not forget the extra bytes
      if (extraBytes === 1) {
        tmp = uint8[len - 1];
        output += lookup[tmp >> 2];
        output += lookup[(tmp << 4) & 0x3F];
        output += '==';
      } else if (extraBytes === 2) {
        tmp = (uint8[len - 2] << 8) + (uint8[len - 1]);
        output += lookup[tmp >> 10];
        output += lookup[(tmp >> 4) & 0x3F];
        output += lookup[(tmp << 2) & 0x3F];
        output += '=';
      }

      parts.push(output);

      return parts.join('')
    }

    function read (buffer, offset, isLE, mLen, nBytes) {
      var e, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? (nBytes - 1) : 0;
      var d = isLE ? -1 : 1;
      var s = buffer[offset + i];

      i += d;

      e = s & ((1 << (-nBits)) - 1);
      s >>= (-nBits);
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

      m = e & ((1 << (-nBits)) - 1);
      e >>= (-nBits);
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : ((s ? -1 : 1) * Infinity)
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
    }

    function write (buffer, value, offset, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
      var i = isLE ? 0 : (nBytes - 1);
      var d = isLE ? 1 : -1;
      var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

      value = Math.abs(value);

      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }

        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }

      for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

      e = (e << mLen) | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

      buffer[offset + i - d] |= s * 128;
    }

    var toString = {}.toString;

    var isArray$2 = Array.isArray || function (arr) {
      return toString.call(arr) == '[object Array]';
    };

    /*!
     * The buffer module from node.js, for the browser.
     *
     * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
     * @license  MIT
     */
    /* eslint-disable no-proto */


    var INSPECT_MAX_BYTES = 50;

    /**
     * If `Buffer.TYPED_ARRAY_SUPPORT`:
     *   === true    Use Uint8Array implementation (fastest)
     *   === false   Use Object implementation (most compatible, even IE6)
     *
     * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
     * Opera 11.6+, iOS 4.2+.
     *
     * Due to various browser bugs, sometimes the Object implementation will be used even
     * when the browser supports typed arrays.
     *
     * Note:
     *
     *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
     *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
     *
     *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
     *
     *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
     *     incorrect length in some situations.

     * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
     * get the Object implementation, which is slower but behaves correctly.
     */
    Buffer$8.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== undefined
      ? global$1.TYPED_ARRAY_SUPPORT
      : true;

    /*
     * Export kMaxLength after typed array support is determined.
     */
    var _kMaxLength = kMaxLength();

    function kMaxLength () {
      return Buffer$8.TYPED_ARRAY_SUPPORT
        ? 0x7fffffff
        : 0x3fffffff
    }

    function createBuffer (that, length) {
      if (kMaxLength() < length) {
        throw new RangeError('Invalid typed array length')
      }
      if (Buffer$8.TYPED_ARRAY_SUPPORT) {
        // Return an augmented `Uint8Array` instance, for best performance
        that = new Uint8Array(length);
        that.__proto__ = Buffer$8.prototype;
      } else {
        // Fallback: Return an object instance of the Buffer class
        if (that === null) {
          that = new Buffer$8(length);
        }
        that.length = length;
      }

      return that
    }

    /**
     * The Buffer constructor returns instances of `Uint8Array` that have their
     * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
     * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
     * and the `Uint8Array` methods. Square bracket notation works as expected -- it
     * returns a single octet.
     *
     * The `Uint8Array` prototype remains unmodified.
     */

    function Buffer$8 (arg, encodingOrOffset, length) {
      if (!Buffer$8.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer$8)) {
        return new Buffer$8(arg, encodingOrOffset, length)
      }

      // Common case.
      if (typeof arg === 'number') {
        if (typeof encodingOrOffset === 'string') {
          throw new Error(
            'If encoding is specified then the first argument must be a string'
          )
        }
        return allocUnsafe(this, arg)
      }
      return from(this, arg, encodingOrOffset, length)
    }

    Buffer$8.poolSize = 8192; // not used by this implementation

    // TODO: Legacy, not needed anymore. Remove in next major version.
    Buffer$8._augment = function (arr) {
      arr.__proto__ = Buffer$8.prototype;
      return arr
    };

    function from (that, value, encodingOrOffset, length) {
      if (typeof value === 'number') {
        throw new TypeError('"value" argument must not be a number')
      }

      if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
        return fromArrayBuffer(that, value, encodingOrOffset, length)
      }

      if (typeof value === 'string') {
        return fromString(that, value, encodingOrOffset)
      }

      return fromObject(that, value)
    }

    /**
     * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
     * if value is a number.
     * Buffer.from(str[, encoding])
     * Buffer.from(array)
     * Buffer.from(buffer)
     * Buffer.from(arrayBuffer[, byteOffset[, length]])
     **/
    Buffer$8.from = function (value, encodingOrOffset, length) {
      return from(null, value, encodingOrOffset, length)
    };

    if (Buffer$8.TYPED_ARRAY_SUPPORT) {
      Buffer$8.prototype.__proto__ = Uint8Array.prototype;
      Buffer$8.__proto__ = Uint8Array;
      if (typeof Symbol !== 'undefined' && Symbol.species &&
          Buffer$8[Symbol.species] === Buffer$8) ;
    }

    function assertSize (size) {
      if (typeof size !== 'number') {
        throw new TypeError('"size" argument must be a number')
      } else if (size < 0) {
        throw new RangeError('"size" argument must not be negative')
      }
    }

    function alloc (that, size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(that, size)
      }
      if (fill !== undefined) {
        // Only pay attention to encoding if it's a string. This
        // prevents accidentally sending in a number that would
        // be interpretted as a start offset.
        return typeof encoding === 'string'
          ? createBuffer(that, size).fill(fill, encoding)
          : createBuffer(that, size).fill(fill)
      }
      return createBuffer(that, size)
    }

    /**
     * Creates a new filled Buffer instance.
     * alloc(size[, fill[, encoding]])
     **/
    Buffer$8.alloc = function (size, fill, encoding) {
      return alloc(null, size, fill, encoding)
    };

    function allocUnsafe (that, size) {
      assertSize(size);
      that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
      if (!Buffer$8.TYPED_ARRAY_SUPPORT) {
        for (var i = 0; i < size; ++i) {
          that[i] = 0;
        }
      }
      return that
    }

    /**
     * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
     * */
    Buffer$8.allocUnsafe = function (size) {
      return allocUnsafe(null, size)
    };
    /**
     * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
     */
    Buffer$8.allocUnsafeSlow = function (size) {
      return allocUnsafe(null, size)
    };

    function fromString (that, string, encoding) {
      if (typeof encoding !== 'string' || encoding === '') {
        encoding = 'utf8';
      }

      if (!Buffer$8.isEncoding(encoding)) {
        throw new TypeError('"encoding" must be a valid string encoding')
      }

      var length = byteLength(string, encoding) | 0;
      that = createBuffer(that, length);

      var actual = that.write(string, encoding);

      if (actual !== length) {
        // Writing a hex string, for example, that contains invalid characters will
        // cause everything after the first invalid character to be ignored. (e.g.
        // 'abxxcd' will be treated as 'ab')
        that = that.slice(0, actual);
      }

      return that
    }

    function fromArrayLike (that, array) {
      var length = array.length < 0 ? 0 : checked(array.length) | 0;
      that = createBuffer(that, length);
      for (var i = 0; i < length; i += 1) {
        that[i] = array[i] & 255;
      }
      return that
    }

    function fromArrayBuffer (that, array, byteOffset, length) {
      array.byteLength; // this throws if `array` is not a valid ArrayBuffer

      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('\'offset\' is out of bounds')
      }

      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('\'length\' is out of bounds')
      }

      if (byteOffset === undefined && length === undefined) {
        array = new Uint8Array(array);
      } else if (length === undefined) {
        array = new Uint8Array(array, byteOffset);
      } else {
        array = new Uint8Array(array, byteOffset, length);
      }

      if (Buffer$8.TYPED_ARRAY_SUPPORT) {
        // Return an augmented `Uint8Array` instance, for best performance
        that = array;
        that.__proto__ = Buffer$8.prototype;
      } else {
        // Fallback: Return an object instance of the Buffer class
        that = fromArrayLike(that, array);
      }
      return that
    }

    function fromObject (that, obj) {
      if (internalIsBuffer(obj)) {
        var len = checked(obj.length) | 0;
        that = createBuffer(that, len);

        if (that.length === 0) {
          return that
        }

        obj.copy(that, 0, 0, len);
        return that
      }

      if (obj) {
        if ((typeof ArrayBuffer !== 'undefined' &&
            obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
          if (typeof obj.length !== 'number' || isnan(obj.length)) {
            return createBuffer(that, 0)
          }
          return fromArrayLike(that, obj)
        }

        if (obj.type === 'Buffer' && isArray$2(obj.data)) {
          return fromArrayLike(that, obj.data)
        }
      }

      throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
    }

    function checked (length) {
      // Note: cannot use `length < kMaxLength()` here because that fails when
      // length is NaN (which is otherwise coerced to zero.)
      if (length >= kMaxLength()) {
        throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                             'size: 0x' + kMaxLength().toString(16) + ' bytes')
      }
      return length | 0
    }

    function SlowBuffer (length) {
      if (+length != length) { // eslint-disable-line eqeqeq
        length = 0;
      }
      return Buffer$8.alloc(+length)
    }
    Buffer$8.isBuffer = isBuffer$1;
    function internalIsBuffer (b) {
      return !!(b != null && b._isBuffer)
    }

    Buffer$8.compare = function compare (a, b) {
      if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
        throw new TypeError('Arguments must be Buffers')
      }

      if (a === b) return 0

      var x = a.length;
      var y = b.length;

      for (var i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break
        }
      }

      if (x < y) return -1
      if (y < x) return 1
      return 0
    };

    Buffer$8.isEncoding = function isEncoding (encoding) {
      switch (String(encoding).toLowerCase()) {
        case 'hex':
        case 'utf8':
        case 'utf-8':
        case 'ascii':
        case 'latin1':
        case 'binary':
        case 'base64':
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return true
        default:
          return false
      }
    };

    Buffer$8.concat = function concat (list, length) {
      if (!isArray$2(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers')
      }

      if (list.length === 0) {
        return Buffer$8.alloc(0)
      }

      var i;
      if (length === undefined) {
        length = 0;
        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }

      var buffer = Buffer$8.allocUnsafe(length);
      var pos = 0;
      for (i = 0; i < list.length; ++i) {
        var buf = list[i];
        if (!internalIsBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers')
        }
        buf.copy(buffer, pos);
        pos += buf.length;
      }
      return buffer
    };

    function byteLength (string, encoding) {
      if (internalIsBuffer(string)) {
        return string.length
      }
      if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
          (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
        return string.byteLength
      }
      if (typeof string !== 'string') {
        string = '' + string;
      }

      var len = string.length;
      if (len === 0) return 0

      // Use a for loop to avoid recursion
      var loweredCase = false;
      for (;;) {
        switch (encoding) {
          case 'ascii':
          case 'latin1':
          case 'binary':
            return len
          case 'utf8':
          case 'utf-8':
          case undefined:
            return utf8ToBytes(string).length
          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return len * 2
          case 'hex':
            return len >>> 1
          case 'base64':
            return base64ToBytes(string).length
          default:
            if (loweredCase) return utf8ToBytes(string).length // assume utf8
            encoding = ('' + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer$8.byteLength = byteLength;

    function slowToString (encoding, start, end) {
      var loweredCase = false;

      // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
      // property of a typed array.

      // This behaves neither like String nor Uint8Array in that we set start/end
      // to their upper/lower bounds if the value passed is out of range.
      // undefined is handled specially as per ECMA-262 6th Edition,
      // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
      if (start === undefined || start < 0) {
        start = 0;
      }
      // Return early if start > this.length. Done here to prevent potential uint32
      // coercion fail below.
      if (start > this.length) {
        return ''
      }

      if (end === undefined || end > this.length) {
        end = this.length;
      }

      if (end <= 0) {
        return ''
      }

      // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
      end >>>= 0;
      start >>>= 0;

      if (end <= start) {
        return ''
      }

      if (!encoding) encoding = 'utf8';

      while (true) {
        switch (encoding) {
          case 'hex':
            return hexSlice(this, start, end)

          case 'utf8':
          case 'utf-8':
            return utf8Slice(this, start, end)

          case 'ascii':
            return asciiSlice(this, start, end)

          case 'latin1':
          case 'binary':
            return latin1Slice(this, start, end)

          case 'base64':
            return base64Slice(this, start, end)

          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return utf16leSlice(this, start, end)

          default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
            encoding = (encoding + '').toLowerCase();
            loweredCase = true;
        }
      }
    }

    // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
    // Buffer instances.
    Buffer$8.prototype._isBuffer = true;

    function swap (b, n, m) {
      var i = b[n];
      b[n] = b[m];
      b[m] = i;
    }

    Buffer$8.prototype.swap16 = function swap16 () {
      var len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 16-bits')
      }
      for (var i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this
    };

    Buffer$8.prototype.swap32 = function swap32 () {
      var len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 32-bits')
      }
      for (var i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this
    };

    Buffer$8.prototype.swap64 = function swap64 () {
      var len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 64-bits')
      }
      for (var i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this
    };

    Buffer$8.prototype.toString = function toString () {
      var length = this.length | 0;
      if (length === 0) return ''
      if (arguments.length === 0) return utf8Slice(this, 0, length)
      return slowToString.apply(this, arguments)
    };

    Buffer$8.prototype.equals = function equals (b) {
      if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer')
      if (this === b) return true
      return Buffer$8.compare(this, b) === 0
    };

    Buffer$8.prototype.inspect = function inspect () {
      var str = '';
      var max = INSPECT_MAX_BYTES;
      if (this.length > 0) {
        str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
        if (this.length > max) str += ' ... ';
      }
      return '<Buffer ' + str + '>'
    };

    Buffer$8.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
      if (!internalIsBuffer(target)) {
        throw new TypeError('Argument must be a Buffer')
      }

      if (start === undefined) {
        start = 0;
      }
      if (end === undefined) {
        end = target ? target.length : 0;
      }
      if (thisStart === undefined) {
        thisStart = 0;
      }
      if (thisEnd === undefined) {
        thisEnd = this.length;
      }

      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError('out of range index')
      }

      if (thisStart >= thisEnd && start >= end) {
        return 0
      }
      if (thisStart >= thisEnd) {
        return -1
      }
      if (start >= end) {
        return 1
      }

      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;

      if (this === target) return 0

      var x = thisEnd - thisStart;
      var y = end - start;
      var len = Math.min(x, y);

      var thisCopy = this.slice(thisStart, thisEnd);
      var targetCopy = target.slice(start, end);

      for (var i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break
        }
      }

      if (x < y) return -1
      if (y < x) return 1
      return 0
    };

    // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
    // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
    //
    // Arguments:
    // - buffer - a Buffer to search
    // - val - a string, Buffer, or number
    // - byteOffset - an index into `buffer`; will be clamped to an int32
    // - encoding - an optional encoding, relevant is val is a string
    // - dir - true for indexOf, false for lastIndexOf
    function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
      // Empty buffer means no match
      if (buffer.length === 0) return -1

      // Normalize byteOffset
      if (typeof byteOffset === 'string') {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 0x7fffffff) {
        byteOffset = 0x7fffffff;
      } else if (byteOffset < -0x80000000) {
        byteOffset = -0x80000000;
      }
      byteOffset = +byteOffset;  // Coerce to Number.
      if (isNaN(byteOffset)) {
        // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
        byteOffset = dir ? 0 : (buffer.length - 1);
      }

      // Normalize byteOffset: negative offsets start from the end of the buffer
      if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
      if (byteOffset >= buffer.length) {
        if (dir) return -1
        else byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1
      }

      // Normalize val
      if (typeof val === 'string') {
        val = Buffer$8.from(val, encoding);
      }

      // Finally, search either indexOf (if dir is true) or lastIndexOf
      if (internalIsBuffer(val)) {
        // Special case: looking for empty string/buffer always fails
        if (val.length === 0) {
          return -1
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
      } else if (typeof val === 'number') {
        val = val & 0xFF; // Search for a byte value [0-255]
        if (Buffer$8.TYPED_ARRAY_SUPPORT &&
            typeof Uint8Array.prototype.indexOf === 'function') {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
          }
        }
        return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
      }

      throw new TypeError('val must be string, number or Buffer')
    }

    function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
      var indexSize = 1;
      var arrLength = arr.length;
      var valLength = val.length;

      if (encoding !== undefined) {
        encoding = String(encoding).toLowerCase();
        if (encoding === 'ucs2' || encoding === 'ucs-2' ||
            encoding === 'utf16le' || encoding === 'utf-16le') {
          if (arr.length < 2 || val.length < 2) {
            return -1
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }

      function read (buf, i) {
        if (indexSize === 1) {
          return buf[i]
        } else {
          return buf.readUInt16BE(i * indexSize)
        }
      }

      var i;
      if (dir) {
        var foundIndex = -1;
        for (i = byteOffset; i < arrLength; i++) {
          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
          } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for (i = byteOffset; i >= 0; i--) {
          var found = true;
          for (var j = 0; j < valLength; j++) {
            if (read(arr, i + j) !== read(val, j)) {
              found = false;
              break
            }
          }
          if (found) return i
        }
      }

      return -1
    }

    Buffer$8.prototype.includes = function includes (val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1
    };

    Buffer$8.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
    };

    Buffer$8.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
    };

    function hexWrite (buf, string, offset, length) {
      offset = Number(offset) || 0;
      var remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }

      // must be an even number of digits
      var strLen = string.length;
      if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

      if (length > strLen / 2) {
        length = strLen / 2;
      }
      for (var i = 0; i < length; ++i) {
        var parsed = parseInt(string.substr(i * 2, 2), 16);
        if (isNaN(parsed)) return i
        buf[offset + i] = parsed;
      }
      return i
    }

    function utf8Write (buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
    }

    function asciiWrite (buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length)
    }

    function latin1Write (buf, string, offset, length) {
      return asciiWrite(buf, string, offset, length)
    }

    function base64Write (buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length)
    }

    function ucs2Write (buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
    }

    Buffer$8.prototype.write = function write (string, offset, length, encoding) {
      // Buffer#write(string)
      if (offset === undefined) {
        encoding = 'utf8';
        length = this.length;
        offset = 0;
      // Buffer#write(string, encoding)
      } else if (length === undefined && typeof offset === 'string') {
        encoding = offset;
        length = this.length;
        offset = 0;
      // Buffer#write(string, offset[, length][, encoding])
      } else if (isFinite(offset)) {
        offset = offset | 0;
        if (isFinite(length)) {
          length = length | 0;
          if (encoding === undefined) encoding = 'utf8';
        } else {
          encoding = length;
          length = undefined;
        }
      // legacy write(string, encoding, offset, length) - remove in v0.13
      } else {
        throw new Error(
          'Buffer.write(string, encoding, offset[, length]) is no longer supported'
        )
      }

      var remaining = this.length - offset;
      if (length === undefined || length > remaining) length = remaining;

      if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
        throw new RangeError('Attempt to write outside buffer bounds')
      }

      if (!encoding) encoding = 'utf8';

      var loweredCase = false;
      for (;;) {
        switch (encoding) {
          case 'hex':
            return hexWrite(this, string, offset, length)

          case 'utf8':
          case 'utf-8':
            return utf8Write(this, string, offset, length)

          case 'ascii':
            return asciiWrite(this, string, offset, length)

          case 'latin1':
          case 'binary':
            return latin1Write(this, string, offset, length)

          case 'base64':
            // Warning: maxLength not taken into account in base64Write
            return base64Write(this, string, offset, length)

          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return ucs2Write(this, string, offset, length)

          default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
            encoding = ('' + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };

    Buffer$8.prototype.toJSON = function toJSON () {
      return {
        type: 'Buffer',
        data: Array.prototype.slice.call(this._arr || this, 0)
      }
    };

    function base64Slice (buf, start, end) {
      if (start === 0 && end === buf.length) {
        return fromByteArray(buf)
      } else {
        return fromByteArray(buf.slice(start, end))
      }
    }

    function utf8Slice (buf, start, end) {
      end = Math.min(buf.length, end);
      var res = [];

      var i = start;
      while (i < end) {
        var firstByte = buf[i];
        var codePoint = null;
        var bytesPerSequence = (firstByte > 0xEF) ? 4
          : (firstByte > 0xDF) ? 3
          : (firstByte > 0xBF) ? 2
          : 1;

        if (i + bytesPerSequence <= end) {
          var secondByte, thirdByte, fourthByte, tempCodePoint;

          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 0x80) {
                codePoint = firstByte;
              }
              break
            case 2:
              secondByte = buf[i + 1];
              if ((secondByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
                if (tempCodePoint > 0x7F) {
                  codePoint = tempCodePoint;
                }
              }
              break
            case 3:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
                if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                  codePoint = tempCodePoint;
                }
              }
              break
            case 4:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              fourthByte = buf[i + 3];
              if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
                if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }

        if (codePoint === null) {
          // we did not generate a valid codePoint so insert a
          // replacement char (U+FFFD) and advance only 1 byte
          codePoint = 0xFFFD;
          bytesPerSequence = 1;
        } else if (codePoint > 0xFFFF) {
          // encode to utf16 (surrogate pair dance)
          codePoint -= 0x10000;
          res.push(codePoint >>> 10 & 0x3FF | 0xD800);
          codePoint = 0xDC00 | codePoint & 0x3FF;
        }

        res.push(codePoint);
        i += bytesPerSequence;
      }

      return decodeCodePointsArray(res)
    }

    // Based on http://stackoverflow.com/a/22747272/680742, the browser with
    // the lowest limit is Chrome, with 0x10000 args.
    // We go 1 magnitude less, for safety
    var MAX_ARGUMENTS_LENGTH = 0x1000;

    function decodeCodePointsArray (codePoints) {
      var len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
      }

      // Decode in chunks to avoid "call stack size exceeded".
      var res = '';
      var i = 0;
      while (i < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res
    }

    function asciiSlice (buf, start, end) {
      var ret = '';
      end = Math.min(buf.length, end);

      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 0x7F);
      }
      return ret
    }

    function latin1Slice (buf, start, end) {
      var ret = '';
      end = Math.min(buf.length, end);

      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i]);
      }
      return ret
    }

    function hexSlice (buf, start, end) {
      var len = buf.length;

      if (!start || start < 0) start = 0;
      if (!end || end < 0 || end > len) end = len;

      var out = '';
      for (var i = start; i < end; ++i) {
        out += toHex(buf[i]);
      }
      return out
    }

    function utf16leSlice (buf, start, end) {
      var bytes = buf.slice(start, end);
      var res = '';
      for (var i = 0; i < bytes.length; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
      }
      return res
    }

    Buffer$8.prototype.slice = function slice (start, end) {
      var len = this.length;
      start = ~~start;
      end = end === undefined ? len : ~~end;

      if (start < 0) {
        start += len;
        if (start < 0) start = 0;
      } else if (start > len) {
        start = len;
      }

      if (end < 0) {
        end += len;
        if (end < 0) end = 0;
      } else if (end > len) {
        end = len;
      }

      if (end < start) end = start;

      var newBuf;
      if (Buffer$8.TYPED_ARRAY_SUPPORT) {
        newBuf = this.subarray(start, end);
        newBuf.__proto__ = Buffer$8.prototype;
      } else {
        var sliceLen = end - start;
        newBuf = new Buffer$8(sliceLen, undefined);
        for (var i = 0; i < sliceLen; ++i) {
          newBuf[i] = this[i + start];
        }
      }

      return newBuf
    };

    /*
     * Need to make sure that buffer isn't trying to write out of bounds.
     */
    function checkOffset (offset, ext, length) {
      if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
      if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
    }

    Buffer$8.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
      offset = offset | 0;
      byteLength = byteLength | 0;
      if (!noAssert) checkOffset(offset, byteLength, this.length);

      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength && (mul *= 0x100)) {
        val += this[offset + i] * mul;
      }

      return val
    };

    Buffer$8.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
      offset = offset | 0;
      byteLength = byteLength | 0;
      if (!noAssert) {
        checkOffset(offset, byteLength, this.length);
      }

      var val = this[offset + --byteLength];
      var mul = 1;
      while (byteLength > 0 && (mul *= 0x100)) {
        val += this[offset + --byteLength] * mul;
      }

      return val
    };

    Buffer$8.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 1, this.length);
      return this[offset]
    };

    Buffer$8.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] | (this[offset + 1] << 8)
    };

    Buffer$8.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 2, this.length);
      return (this[offset] << 8) | this[offset + 1]
    };

    Buffer$8.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);

      return ((this[offset]) |
          (this[offset + 1] << 8) |
          (this[offset + 2] << 16)) +
          (this[offset + 3] * 0x1000000)
    };

    Buffer$8.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);

      return (this[offset] * 0x1000000) +
        ((this[offset + 1] << 16) |
        (this[offset + 2] << 8) |
        this[offset + 3])
    };

    Buffer$8.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
      offset = offset | 0;
      byteLength = byteLength | 0;
      if (!noAssert) checkOffset(offset, byteLength, this.length);

      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength && (mul *= 0x100)) {
        val += this[offset + i] * mul;
      }
      mul *= 0x80;

      if (val >= mul) val -= Math.pow(2, 8 * byteLength);

      return val
    };

    Buffer$8.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
      offset = offset | 0;
      byteLength = byteLength | 0;
      if (!noAssert) checkOffset(offset, byteLength, this.length);

      var i = byteLength;
      var mul = 1;
      var val = this[offset + --i];
      while (i > 0 && (mul *= 0x100)) {
        val += this[offset + --i] * mul;
      }
      mul *= 0x80;

      if (val >= mul) val -= Math.pow(2, 8 * byteLength);

      return val
    };

    Buffer$8.prototype.readInt8 = function readInt8 (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 1, this.length);
      if (!(this[offset] & 0x80)) return (this[offset])
      return ((0xff - this[offset] + 1) * -1)
    };

    Buffer$8.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 2, this.length);
      var val = this[offset] | (this[offset + 1] << 8);
      return (val & 0x8000) ? val | 0xFFFF0000 : val
    };

    Buffer$8.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 2, this.length);
      var val = this[offset + 1] | (this[offset] << 8);
      return (val & 0x8000) ? val | 0xFFFF0000 : val
    };

    Buffer$8.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);

      return (this[offset]) |
        (this[offset + 1] << 8) |
        (this[offset + 2] << 16) |
        (this[offset + 3] << 24)
    };

    Buffer$8.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);

      return (this[offset] << 24) |
        (this[offset + 1] << 16) |
        (this[offset + 2] << 8) |
        (this[offset + 3])
    };

    Buffer$8.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);
      return read(this, offset, true, 23, 4)
    };

    Buffer$8.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);
      return read(this, offset, false, 23, 4)
    };

    Buffer$8.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 8, this.length);
      return read(this, offset, true, 52, 8)
    };

    Buffer$8.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 8, this.length);
      return read(this, offset, false, 52, 8)
    };

    function checkInt (buf, value, offset, ext, max, min) {
      if (!internalIsBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
      if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
      if (offset + ext > buf.length) throw new RangeError('Index out of range')
    }

    Buffer$8.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset | 0;
      byteLength = byteLength | 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
      }

      var mul = 1;
      var i = 0;
      this[offset] = value & 0xFF;
      while (++i < byteLength && (mul *= 0x100)) {
        this[offset + i] = (value / mul) & 0xFF;
      }

      return offset + byteLength
    };

    Buffer$8.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset | 0;
      byteLength = byteLength | 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
      }

      var i = byteLength - 1;
      var mul = 1;
      this[offset + i] = value & 0xFF;
      while (--i >= 0 && (mul *= 0x100)) {
        this[offset + i] = (value / mul) & 0xFF;
      }

      return offset + byteLength
    };

    Buffer$8.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
      if (!Buffer$8.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
      this[offset] = (value & 0xff);
      return offset + 1
    };

    function objectWriteUInt16 (buf, value, offset, littleEndian) {
      if (value < 0) value = 0xffff + value + 1;
      for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
        buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
          (littleEndian ? i : 1 - i) * 8;
      }
    }

    Buffer$8.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
      if (Buffer$8.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value & 0xff);
        this[offset + 1] = (value >>> 8);
      } else {
        objectWriteUInt16(this, value, offset, true);
      }
      return offset + 2
    };

    Buffer$8.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
      if (Buffer$8.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value >>> 8);
        this[offset + 1] = (value & 0xff);
      } else {
        objectWriteUInt16(this, value, offset, false);
      }
      return offset + 2
    };

    function objectWriteUInt32 (buf, value, offset, littleEndian) {
      if (value < 0) value = 0xffffffff + value + 1;
      for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
        buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;
      }
    }

    Buffer$8.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
      if (Buffer$8.TYPED_ARRAY_SUPPORT) {
        this[offset + 3] = (value >>> 24);
        this[offset + 2] = (value >>> 16);
        this[offset + 1] = (value >>> 8);
        this[offset] = (value & 0xff);
      } else {
        objectWriteUInt32(this, value, offset, true);
      }
      return offset + 4
    };

    Buffer$8.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
      if (Buffer$8.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value >>> 24);
        this[offset + 1] = (value >>> 16);
        this[offset + 2] = (value >>> 8);
        this[offset + 3] = (value & 0xff);
      } else {
        objectWriteUInt32(this, value, offset, false);
      }
      return offset + 4
    };

    Buffer$8.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength - 1);

        checkInt(this, value, offset, byteLength, limit - 1, -limit);
      }

      var i = 0;
      var mul = 1;
      var sub = 0;
      this[offset] = value & 0xFF;
      while (++i < byteLength && (mul *= 0x100)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
      }

      return offset + byteLength
    };

    Buffer$8.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength - 1);

        checkInt(this, value, offset, byteLength, limit - 1, -limit);
      }

      var i = byteLength - 1;
      var mul = 1;
      var sub = 0;
      this[offset + i] = value & 0xFF;
      while (--i >= 0 && (mul *= 0x100)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
      }

      return offset + byteLength
    };

    Buffer$8.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
      if (!Buffer$8.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
      if (value < 0) value = 0xff + value + 1;
      this[offset] = (value & 0xff);
      return offset + 1
    };

    Buffer$8.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
      if (Buffer$8.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value & 0xff);
        this[offset + 1] = (value >>> 8);
      } else {
        objectWriteUInt16(this, value, offset, true);
      }
      return offset + 2
    };

    Buffer$8.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
      if (Buffer$8.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value >>> 8);
        this[offset + 1] = (value & 0xff);
      } else {
        objectWriteUInt16(this, value, offset, false);
      }
      return offset + 2
    };

    Buffer$8.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
      if (Buffer$8.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value & 0xff);
        this[offset + 1] = (value >>> 8);
        this[offset + 2] = (value >>> 16);
        this[offset + 3] = (value >>> 24);
      } else {
        objectWriteUInt32(this, value, offset, true);
      }
      return offset + 4
    };

    Buffer$8.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
      if (value < 0) value = 0xffffffff + value + 1;
      if (Buffer$8.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value >>> 24);
        this[offset + 1] = (value >>> 16);
        this[offset + 2] = (value >>> 8);
        this[offset + 3] = (value & 0xff);
      } else {
        objectWriteUInt32(this, value, offset, false);
      }
      return offset + 4
    };

    function checkIEEE754 (buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length) throw new RangeError('Index out of range')
      if (offset < 0) throw new RangeError('Index out of range')
    }

    function writeFloat (buf, value, offset, littleEndian, noAssert) {
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4);
      }
      write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4
    }

    Buffer$8.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert)
    };

    Buffer$8.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert)
    };

    function writeDouble (buf, value, offset, littleEndian, noAssert) {
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8);
      }
      write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8
    }

    Buffer$8.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert)
    };

    Buffer$8.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert)
    };

    // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
    Buffer$8.prototype.copy = function copy (target, targetStart, start, end) {
      if (!start) start = 0;
      if (!end && end !== 0) end = this.length;
      if (targetStart >= target.length) targetStart = target.length;
      if (!targetStart) targetStart = 0;
      if (end > 0 && end < start) end = start;

      // Copy 0 bytes; we're done
      if (end === start) return 0
      if (target.length === 0 || this.length === 0) return 0

      // Fatal error conditions
      if (targetStart < 0) {
        throw new RangeError('targetStart out of bounds')
      }
      if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
      if (end < 0) throw new RangeError('sourceEnd out of bounds')

      // Are we oob?
      if (end > this.length) end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }

      var len = end - start;
      var i;

      if (this === target && start < targetStart && targetStart < end) {
        // descending copy from end
        for (i = len - 1; i >= 0; --i) {
          target[i + targetStart] = this[i + start];
        }
      } else if (len < 1000 || !Buffer$8.TYPED_ARRAY_SUPPORT) {
        // ascending copy from start
        for (i = 0; i < len; ++i) {
          target[i + targetStart] = this[i + start];
        }
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, start + len),
          targetStart
        );
      }

      return len
    };

    // Usage:
    //    buffer.fill(number[, offset[, end]])
    //    buffer.fill(buffer[, offset[, end]])
    //    buffer.fill(string[, offset[, end]][, encoding])
    Buffer$8.prototype.fill = function fill (val, start, end, encoding) {
      // Handle string cases:
      if (typeof val === 'string') {
        if (typeof start === 'string') {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === 'string') {
          encoding = end;
          end = this.length;
        }
        if (val.length === 1) {
          var code = val.charCodeAt(0);
          if (code < 256) {
            val = code;
          }
        }
        if (encoding !== undefined && typeof encoding !== 'string') {
          throw new TypeError('encoding must be a string')
        }
        if (typeof encoding === 'string' && !Buffer$8.isEncoding(encoding)) {
          throw new TypeError('Unknown encoding: ' + encoding)
        }
      } else if (typeof val === 'number') {
        val = val & 255;
      }

      // Invalid ranges are not set to a default, so can range check early.
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError('Out of range index')
      }

      if (end <= start) {
        return this
      }

      start = start >>> 0;
      end = end === undefined ? this.length : end >>> 0;

      if (!val) val = 0;

      var i;
      if (typeof val === 'number') {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        var bytes = internalIsBuffer(val)
          ? val
          : utf8ToBytes(new Buffer$8(val, encoding).toString());
        var len = bytes.length;
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }

      return this
    };

    // HELPER FUNCTIONS
    // ================

    var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

    function base64clean (str) {
      // Node strips out invalid characters like \n and \t from the string, base64-js does not
      str = stringtrim(str).replace(INVALID_BASE64_RE, '');
      // Node converts strings with length < 2 to ''
      if (str.length < 2) return ''
      // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
      while (str.length % 4 !== 0) {
        str = str + '=';
      }
      return str
    }

    function stringtrim (str) {
      if (str.trim) return str.trim()
      return str.replace(/^\s+|\s+$/g, '')
    }

    function toHex (n) {
      if (n < 16) return '0' + n.toString(16)
      return n.toString(16)
    }

    function utf8ToBytes (string, units) {
      units = units || Infinity;
      var codePoint;
      var length = string.length;
      var leadSurrogate = null;
      var bytes = [];

      for (var i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i);

        // is surrogate component
        if (codePoint > 0xD7FF && codePoint < 0xE000) {
          // last char was a lead
          if (!leadSurrogate) {
            // no lead yet
            if (codePoint > 0xDBFF) {
              // unexpected trail
              if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
              continue
            } else if (i + 1 === length) {
              // unpaired lead
              if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
              continue
            }

            // valid lead
            leadSurrogate = codePoint;

            continue
          }

          // 2 leads in a row
          if (codePoint < 0xDC00) {
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            leadSurrogate = codePoint;
            continue
          }

          // valid surrogate pair
          codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
        } else if (leadSurrogate) {
          // valid bmp char, but last char was a lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        }

        leadSurrogate = null;

        // encode utf8
        if (codePoint < 0x80) {
          if ((units -= 1) < 0) break
          bytes.push(codePoint);
        } else if (codePoint < 0x800) {
          if ((units -= 2) < 0) break
          bytes.push(
            codePoint >> 0x6 | 0xC0,
            codePoint & 0x3F | 0x80
          );
        } else if (codePoint < 0x10000) {
          if ((units -= 3) < 0) break
          bytes.push(
            codePoint >> 0xC | 0xE0,
            codePoint >> 0x6 & 0x3F | 0x80,
            codePoint & 0x3F | 0x80
          );
        } else if (codePoint < 0x110000) {
          if ((units -= 4) < 0) break
          bytes.push(
            codePoint >> 0x12 | 0xF0,
            codePoint >> 0xC & 0x3F | 0x80,
            codePoint >> 0x6 & 0x3F | 0x80,
            codePoint & 0x3F | 0x80
          );
        } else {
          throw new Error('Invalid code point')
        }
      }

      return bytes
    }

    function asciiToBytes (str) {
      var byteArray = [];
      for (var i = 0; i < str.length; ++i) {
        // Node's code seems to be doing this and not & 0x7F..
        byteArray.push(str.charCodeAt(i) & 0xFF);
      }
      return byteArray
    }

    function utf16leToBytes (str, units) {
      var c, hi, lo;
      var byteArray = [];
      for (var i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0) break

        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }

      return byteArray
    }


    function base64ToBytes (str) {
      return toByteArray(base64clean(str))
    }

    function blitBuffer (src, dst, offset, length) {
      for (var i = 0; i < length; ++i) {
        if ((i + offset >= dst.length) || (i >= src.length)) break
        dst[i + offset] = src[i];
      }
      return i
    }

    function isnan (val) {
      return val !== val // eslint-disable-line no-self-compare
    }


    // the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence
    // The _isBuffer check is for Safari 5-7 support, because it's missing
    // Object.prototype.constructor. Remove this eventually
    function isBuffer$1(obj) {
      return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj))
    }

    function isFastBuffer (obj) {
      return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
    }

    // For Node v0.10 support. Remove this eventually.
    function isSlowBuffer (obj) {
      return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer(obj.slice(0, 0))
    }

    var _polyfillNode_buffer = /*#__PURE__*/Object.freeze({
        __proto__: null,
        Buffer: Buffer$8,
        INSPECT_MAX_BYTES: INSPECT_MAX_BYTES,
        SlowBuffer: SlowBuffer,
        isBuffer: isBuffer$1,
        kMaxLength: _kMaxLength
    });

    if (typeof window !== 'undefined') {
        if (!window.Buffer) {
            window.Buffer = Buffer$8;
        }
        if (!window.global) {
            window.global = window;
        }
        if (!window.process) {
            window.process = {};
        }
        if (!window.process?.env) {
            window.process = { env: {} };
        }
    }

    var dist$5 = {};

    var CoinbaseWalletSDK$1 = {};

    var walletLogo$1 = {};

    Object.defineProperty(walletLogo$1, "__esModule", { value: true });
    walletLogo$1.walletLogo = void 0;
    const walletLogo = (type, width) => {
        let height;
        switch (type) {
            case 'standard':
                height = width;
                return `data:image/svg+xml,%3Csvg width='${width}' height='${height}' viewBox='0 0 1024 1024' fill='none' xmlns='http://www.w3.org/2000/svg'%3E %3Crect width='1024' height='1024' fill='%230052FF'/%3E %3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M152 512C152 710.823 313.177 872 512 872C710.823 872 872 710.823 872 512C872 313.177 710.823 152 512 152C313.177 152 152 313.177 152 512ZM420 396C406.745 396 396 406.745 396 420V604C396 617.255 406.745 628 420 628H604C617.255 628 628 617.255 628 604V420C628 406.745 617.255 396 604 396H420Z' fill='white'/%3E %3C/svg%3E `;
            case 'circle':
                height = width;
                return `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='${width}' height='${height}' viewBox='0 0 999.81 999.81'%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%230052fe;%7D.cls-2%7Bfill:%23fefefe;%7D.cls-3%7Bfill:%230152fe;%7D%3C/style%3E%3C/defs%3E%3Cpath class='cls-1' d='M655-115.9h56c.83,1.59,2.36.88,3.56,1a478,478,0,0,1,75.06,10.42C891.4-81.76,978.33-32.58,1049.19,44q116.7,126,131.94,297.61c.38,4.14-.34,8.53,1.78,12.45v59c-1.58.84-.91,2.35-1,3.56a482.05,482.05,0,0,1-10.38,74.05c-24,106.72-76.64,196.76-158.83,268.93s-178.18,112.82-287.2,122.6c-4.83.43-9.86-.25-14.51,1.77H654c-1-1.68-2.69-.91-4.06-1a496.89,496.89,0,0,1-105.9-18.59c-93.54-27.42-172.78-77.59-236.91-150.94Q199.34,590.1,184.87,426.58c-.47-5.19.25-10.56-1.77-15.59V355c1.68-1,.91-2.7,1-4.06a498.12,498.12,0,0,1,18.58-105.9c26-88.75,72.64-164.9,140.6-227.57q126-116.27,297.21-131.61C645.32-114.57,650.35-113.88,655-115.9Zm377.92,500c0-192.44-156.31-349.49-347.56-350.15-194.13-.68-350.94,155.13-352.29,347.42-1.37,194.55,155.51,352.1,348.56,352.47C876.15,734.23,1032.93,577.84,1032.93,384.11Z' transform='translate(-183.1 115.9)'/%3E%3Cpath class='cls-2' d='M1032.93,384.11c0,193.73-156.78,350.12-351.29,349.74-193-.37-349.93-157.92-348.56-352.47C334.43,189.09,491.24,33.28,685.37,34,876.62,34.62,1032.94,191.67,1032.93,384.11ZM683,496.81q43.74,0,87.48,0c15.55,0,25.32-9.72,25.33-25.21q0-87.48,0-175c0-15.83-9.68-25.46-25.59-25.46H595.77c-15.88,0-25.57,9.64-25.58,25.46q0,87.23,0,174.45c0,16.18,9.59,25.7,25.84,25.71Z' transform='translate(-183.1 115.9)'/%3E%3Cpath class='cls-3' d='M683,496.81H596c-16.25,0-25.84-9.53-25.84-25.71q0-87.23,0-174.45c0-15.82,9.7-25.46,25.58-25.46H770.22c15.91,0,25.59,9.63,25.59,25.46q0,87.47,0,175c0,15.49-9.78,25.2-25.33,25.21Q726.74,496.84,683,496.81Z' transform='translate(-183.1 115.9)'/%3E%3C/svg%3E`;
            case 'text':
                height = (0.1 * width).toFixed(2);
                return `data:image/svg+xml,%3Csvg width='${width}' height='${height}' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 528.15 53.64'%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%230052ff;%7D%3C/style%3E%3C/defs%3E%3Ctitle%3ECoinbase_Wordmark_SubBrands_ALL%3C/title%3E%3Cpath class='cls-1' d='M164.45,15a15,15,0,0,0-11.74,5.4V0h-8.64V52.92h8.5V48a15,15,0,0,0,11.88,5.62c10.37,0,18.21-8.21,18.21-19.3S174.67,15,164.45,15Zm-1.3,30.67c-6.19,0-10.73-4.83-10.73-11.31S157,23,163.22,23s10.66,4.82,10.66,11.37S169.34,45.65,163.15,45.65Zm83.31-14.91-6.34-.93c-3-.43-5.18-1.44-5.18-3.82,0-2.59,2.8-3.89,6.62-3.89,4.18,0,6.84,1.8,7.42,4.76h8.35c-.94-7.49-6.7-11.88-15.55-11.88-9.15,0-15.2,4.68-15.2,11.3,0,6.34,4,10,12,11.16l6.33.94c3.1.43,4.83,1.65,4.83,4,0,2.95-3,4.17-7.2,4.17-5.12,0-8-2.09-8.43-5.25h-8.49c.79,7.27,6.48,12.38,16.84,12.38,9.44,0,15.7-4.32,15.7-11.74C258.12,35.28,253.58,31.82,246.46,30.74Zm-27.65-2.3c0-8.06-4.9-13.46-15.27-13.46-9.79,0-15.26,5-16.34,12.6h8.57c.43-3,2.73-5.4,7.63-5.4,4.39,0,6.55,1.94,6.55,4.32,0,3.09-4,3.88-8.85,4.39-6.63.72-14.84,3-14.84,11.66,0,6.7,5,11,12.89,11,6.19,0,10.08-2.59,12-6.7.28,3.67,3,6.05,6.84,6.05h5v-7.7h-4.25Zm-8.5,9.36c0,5-4.32,8.64-9.57,8.64-3.24,0-6-1.37-6-4.25,0-3.67,4.39-4.68,8.42-5.11s6-1.22,7.13-2.88ZM281.09,15c-11.09,0-19.23,8.35-19.23,19.36,0,11.6,8.72,19.3,19.37,19.3,9,0,16.06-5.33,17.86-12.89h-9c-1.3,3.31-4.47,5.19-8.71,5.19-5.55,0-9.72-3.46-10.66-9.51H299.3V33.12C299.3,22.46,291.53,15,281.09,15Zm-9.87,15.26c1.37-5.18,5.26-7.7,9.72-7.7,4.9,0,8.64,2.8,9.51,7.7ZM19.3,23a9.84,9.84,0,0,1,9.5,7h9.14c-1.65-8.93-9-15-18.57-15A19,19,0,0,0,0,34.34c0,11.09,8.28,19.3,19.37,19.3,9.36,0,16.85-6,18.5-15H28.8a9.75,9.75,0,0,1-9.43,7.06c-6.27,0-10.66-4.83-10.66-11.31S13,23,19.3,23Zm41.11-8A19,19,0,0,0,41,34.34c0,11.09,8.28,19.3,19.37,19.3A19,19,0,0,0,79.92,34.27C79.92,23.33,71.64,15,60.41,15Zm.07,30.67c-6.19,0-10.73-4.83-10.73-11.31S54.22,23,60.41,23s10.8,4.89,10.8,11.37S66.67,45.65,60.48,45.65ZM123.41,15c-5.62,0-9.29,2.3-11.45,5.54V15.7h-8.57V52.92H112V32.69C112,27,115.63,23,121,23c5,0,8.06,3.53,8.06,8.64V52.92h8.64V31C137.66,21.6,132.84,15,123.41,15ZM92,.36a5.36,5.36,0,0,0-5.55,5.47,5.55,5.55,0,0,0,11.09,0A5.35,5.35,0,0,0,92,.36Zm-9.72,23h5.4V52.92h8.64V15.7h-14Zm298.17-7.7L366.2,52.92H372L375.29,44H392l3.33,8.88h6L386.87,15.7ZM377,39.23l6.45-17.56h.1l6.56,17.56ZM362.66,15.7l-7.88,29h-.11l-8.14-29H341l-8,28.93h-.1l-8-28.87H319L329.82,53h5.45l8.19-29.24h.11L352,53h5.66L368.1,15.7Zm135.25,0v4.86h12.32V52.92h5.6V20.56h12.32V15.7ZM467.82,52.92h25.54V48.06H473.43v-12h18.35V31.35H473.43V20.56h19.93V15.7H467.82ZM443,15.7h-5.6V52.92h24.32V48.06H443Zm-30.45,0h-5.61V52.92h24.32V48.06H412.52Z'/%3E%3C/svg%3E`;
            case 'textWithLogo':
                height = (0.25 * width).toFixed(2);
                return `data:image/svg+xml,%3Csvg width='${width}' height='${height}' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 308.44 77.61'%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%230052ff;%7D%3C/style%3E%3C/defs%3E%3Cpath class='cls-1' d='M142.94,20.2l-7.88,29H135l-8.15-29h-5.55l-8,28.93h-.11l-8-28.87H99.27l10.84,37.27h5.44l8.2-29.24h.1l8.41,29.24h5.66L148.39,20.2Zm17.82,0L146.48,57.42h5.82l3.28-8.88h16.65l3.34,8.88h6L167.16,20.2Zm-3.44,23.52,6.45-17.55h.11l6.56,17.55ZM278.2,20.2v4.86h12.32V57.42h5.6V25.06h12.32V20.2ZM248.11,57.42h25.54V52.55H253.71V40.61h18.35V35.85H253.71V25.06h19.94V20.2H248.11ZM223.26,20.2h-5.61V57.42H242V52.55H223.26Zm-30.46,0h-5.6V57.42h24.32V52.55H192.8Zm-154,38A19.41,19.41,0,1,1,57.92,35.57H77.47a38.81,38.81,0,1,0,0,6.47H57.92A19.39,19.39,0,0,1,38.81,58.21Z'/%3E%3C/svg%3E`;
            case 'textLight':
                height = (0.1 * width).toFixed(2);
                return `data:image/svg+xml,%3Csvg width='${width}' height='${height}' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 528.15 53.64'%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%23fefefe;%7D%3C/style%3E%3C/defs%3E%3Ctitle%3ECoinbase_Wordmark_SubBrands_ALL%3C/title%3E%3Cpath class='cls-1' d='M164.45,15a15,15,0,0,0-11.74,5.4V0h-8.64V52.92h8.5V48a15,15,0,0,0,11.88,5.62c10.37,0,18.21-8.21,18.21-19.3S174.67,15,164.45,15Zm-1.3,30.67c-6.19,0-10.73-4.83-10.73-11.31S157,23,163.22,23s10.66,4.82,10.66,11.37S169.34,45.65,163.15,45.65Zm83.31-14.91-6.34-.93c-3-.43-5.18-1.44-5.18-3.82,0-2.59,2.8-3.89,6.62-3.89,4.18,0,6.84,1.8,7.42,4.76h8.35c-.94-7.49-6.7-11.88-15.55-11.88-9.15,0-15.2,4.68-15.2,11.3,0,6.34,4,10,12,11.16l6.33.94c3.1.43,4.83,1.65,4.83,4,0,2.95-3,4.17-7.2,4.17-5.12,0-8-2.09-8.43-5.25h-8.49c.79,7.27,6.48,12.38,16.84,12.38,9.44,0,15.7-4.32,15.7-11.74C258.12,35.28,253.58,31.82,246.46,30.74Zm-27.65-2.3c0-8.06-4.9-13.46-15.27-13.46-9.79,0-15.26,5-16.34,12.6h8.57c.43-3,2.73-5.4,7.63-5.4,4.39,0,6.55,1.94,6.55,4.32,0,3.09-4,3.88-8.85,4.39-6.63.72-14.84,3-14.84,11.66,0,6.7,5,11,12.89,11,6.19,0,10.08-2.59,12-6.7.28,3.67,3,6.05,6.84,6.05h5v-7.7h-4.25Zm-8.5,9.36c0,5-4.32,8.64-9.57,8.64-3.24,0-6-1.37-6-4.25,0-3.67,4.39-4.68,8.42-5.11s6-1.22,7.13-2.88ZM281.09,15c-11.09,0-19.23,8.35-19.23,19.36,0,11.6,8.72,19.3,19.37,19.3,9,0,16.06-5.33,17.86-12.89h-9c-1.3,3.31-4.47,5.19-8.71,5.19-5.55,0-9.72-3.46-10.66-9.51H299.3V33.12C299.3,22.46,291.53,15,281.09,15Zm-9.87,15.26c1.37-5.18,5.26-7.7,9.72-7.7,4.9,0,8.64,2.8,9.51,7.7ZM19.3,23a9.84,9.84,0,0,1,9.5,7h9.14c-1.65-8.93-9-15-18.57-15A19,19,0,0,0,0,34.34c0,11.09,8.28,19.3,19.37,19.3,9.36,0,16.85-6,18.5-15H28.8a9.75,9.75,0,0,1-9.43,7.06c-6.27,0-10.66-4.83-10.66-11.31S13,23,19.3,23Zm41.11-8A19,19,0,0,0,41,34.34c0,11.09,8.28,19.3,19.37,19.3A19,19,0,0,0,79.92,34.27C79.92,23.33,71.64,15,60.41,15Zm.07,30.67c-6.19,0-10.73-4.83-10.73-11.31S54.22,23,60.41,23s10.8,4.89,10.8,11.37S66.67,45.65,60.48,45.65ZM123.41,15c-5.62,0-9.29,2.3-11.45,5.54V15.7h-8.57V52.92H112V32.69C112,27,115.63,23,121,23c5,0,8.06,3.53,8.06,8.64V52.92h8.64V31C137.66,21.6,132.84,15,123.41,15ZM92,.36a5.36,5.36,0,0,0-5.55,5.47,5.55,5.55,0,0,0,11.09,0A5.35,5.35,0,0,0,92,.36Zm-9.72,23h5.4V52.92h8.64V15.7h-14Zm298.17-7.7L366.2,52.92H372L375.29,44H392l3.33,8.88h6L386.87,15.7ZM377,39.23l6.45-17.56h.1l6.56,17.56ZM362.66,15.7l-7.88,29h-.11l-8.14-29H341l-8,28.93h-.1l-8-28.87H319L329.82,53h5.45l8.19-29.24h.11L352,53h5.66L368.1,15.7Zm135.25,0v4.86h12.32V52.92h5.6V20.56h12.32V15.7ZM467.82,52.92h25.54V48.06H473.43v-12h18.35V31.35H473.43V20.56h19.93V15.7H467.82ZM443,15.7h-5.6V52.92h24.32V48.06H443Zm-30.45,0h-5.61V52.92h24.32V48.06H412.52Z'/%3E%3C/svg%3E`;
            case 'textWithLogoLight':
                height = (0.25 * width).toFixed(2);
                return `data:image/svg+xml,%3Csvg width='${width}' height='${height}' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 308.44 77.61'%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%23fefefe;%7D%3C/style%3E%3C/defs%3E%3Cpath class='cls-1' d='M142.94,20.2l-7.88,29H135l-8.15-29h-5.55l-8,28.93h-.11l-8-28.87H99.27l10.84,37.27h5.44l8.2-29.24h.1l8.41,29.24h5.66L148.39,20.2Zm17.82,0L146.48,57.42h5.82l3.28-8.88h16.65l3.34,8.88h6L167.16,20.2Zm-3.44,23.52,6.45-17.55h.11l6.56,17.55ZM278.2,20.2v4.86h12.32V57.42h5.6V25.06h12.32V20.2ZM248.11,57.42h25.54V52.55H253.71V40.61h18.35V35.85H253.71V25.06h19.94V20.2H248.11ZM223.26,20.2h-5.61V57.42H242V52.55H223.26Zm-30.46,0h-5.6V57.42h24.32V52.55H192.8Zm-154,38A19.41,19.41,0,1,1,57.92,35.57H77.47a38.81,38.81,0,1,0,0,6.47H57.92A19.39,19.39,0,0,1,38.81,58.21Z'/%3E%3C/svg%3E`;
            default:
                height = width;
                return `data:image/svg+xml,%3Csvg width='${width}' height='${height}' viewBox='0 0 1024 1024' fill='none' xmlns='http://www.w3.org/2000/svg'%3E %3Crect width='1024' height='1024' fill='%230052FF'/%3E %3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M152 512C152 710.823 313.177 872 512 872C710.823 872 872 710.823 872 512C872 313.177 710.823 152 512 152C313.177 152 152 313.177 152 512ZM420 396C406.745 396 396 406.745 396 420V604C396 617.255 406.745 628 420 628H604C617.255 628 628 617.255 628 604V420C628 406.745 617.255 396 604 396H420Z' fill='white'/%3E %3C/svg%3E `;
        }
    };
    walletLogo$1.walletLogo = walletLogo;

    var constants$3 = {};

    Object.defineProperty(constants$3, "__esModule", { value: true });
    constants$3.LINK_API_URL = void 0;
    constants$3.LINK_API_URL = 'https://www.walletlink.org';

    var util$3 = {};

    var bn = {exports: {}};

    var require$$2$1 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_buffer);

    bn.exports;

    (function (module) {
    	(function (module, exports) {

    	  // Utils
    	  function assert (val, msg) {
    	    if (!val) throw new Error(msg || 'Assertion failed');
    	  }

    	  // Could use `inherits` module, but don't want to move from single file
    	  // architecture yet.
    	  function inherits (ctor, superCtor) {
    	    ctor.super_ = superCtor;
    	    var TempCtor = function () {};
    	    TempCtor.prototype = superCtor.prototype;
    	    ctor.prototype = new TempCtor();
    	    ctor.prototype.constructor = ctor;
    	  }

    	  // BN

    	  function BN (number, base, endian) {
    	    if (BN.isBN(number)) {
    	      return number;
    	    }

    	    this.negative = 0;
    	    this.words = null;
    	    this.length = 0;

    	    // Reduction context
    	    this.red = null;

    	    if (number !== null) {
    	      if (base === 'le' || base === 'be') {
    	        endian = base;
    	        base = 10;
    	      }

    	      this._init(number || 0, base || 10, endian || 'be');
    	    }
    	  }
    	  if (typeof module === 'object') {
    	    module.exports = BN;
    	  } else {
    	    exports.BN = BN;
    	  }

    	  BN.BN = BN;
    	  BN.wordSize = 26;

    	  var Buffer;
    	  try {
    	    if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {
    	      Buffer = window.Buffer;
    	    } else {
    	      Buffer = require$$2$1.Buffer;
    	    }
    	  } catch (e) {
    	  }

    	  BN.isBN = function isBN (num) {
    	    if (num instanceof BN) {
    	      return true;
    	    }

    	    return num !== null && typeof num === 'object' &&
    	      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
    	  };

    	  BN.max = function max (left, right) {
    	    if (left.cmp(right) > 0) return left;
    	    return right;
    	  };

    	  BN.min = function min (left, right) {
    	    if (left.cmp(right) < 0) return left;
    	    return right;
    	  };

    	  BN.prototype._init = function init (number, base, endian) {
    	    if (typeof number === 'number') {
    	      return this._initNumber(number, base, endian);
    	    }

    	    if (typeof number === 'object') {
    	      return this._initArray(number, base, endian);
    	    }

    	    if (base === 'hex') {
    	      base = 16;
    	    }
    	    assert(base === (base | 0) && base >= 2 && base <= 36);

    	    number = number.toString().replace(/\s+/g, '');
    	    var start = 0;
    	    if (number[0] === '-') {
    	      start++;
    	      this.negative = 1;
    	    }

    	    if (start < number.length) {
    	      if (base === 16) {
    	        this._parseHex(number, start, endian);
    	      } else {
    	        this._parseBase(number, base, start);
    	        if (endian === 'le') {
    	          this._initArray(this.toArray(), base, endian);
    	        }
    	      }
    	    }
    	  };

    	  BN.prototype._initNumber = function _initNumber (number, base, endian) {
    	    if (number < 0) {
    	      this.negative = 1;
    	      number = -number;
    	    }
    	    if (number < 0x4000000) {
    	      this.words = [number & 0x3ffffff];
    	      this.length = 1;
    	    } else if (number < 0x10000000000000) {
    	      this.words = [
    	        number & 0x3ffffff,
    	        (number / 0x4000000) & 0x3ffffff
    	      ];
    	      this.length = 2;
    	    } else {
    	      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
    	      this.words = [
    	        number & 0x3ffffff,
    	        (number / 0x4000000) & 0x3ffffff,
    	        1
    	      ];
    	      this.length = 3;
    	    }

    	    if (endian !== 'le') return;

    	    // Reverse the bytes
    	    this._initArray(this.toArray(), base, endian);
    	  };

    	  BN.prototype._initArray = function _initArray (number, base, endian) {
    	    // Perhaps a Uint8Array
    	    assert(typeof number.length === 'number');
    	    if (number.length <= 0) {
    	      this.words = [0];
    	      this.length = 1;
    	      return this;
    	    }

    	    this.length = Math.ceil(number.length / 3);
    	    this.words = new Array(this.length);
    	    for (var i = 0; i < this.length; i++) {
    	      this.words[i] = 0;
    	    }

    	    var j, w;
    	    var off = 0;
    	    if (endian === 'be') {
    	      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
    	        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
    	        this.words[j] |= (w << off) & 0x3ffffff;
    	        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
    	        off += 24;
    	        if (off >= 26) {
    	          off -= 26;
    	          j++;
    	        }
    	      }
    	    } else if (endian === 'le') {
    	      for (i = 0, j = 0; i < number.length; i += 3) {
    	        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
    	        this.words[j] |= (w << off) & 0x3ffffff;
    	        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
    	        off += 24;
    	        if (off >= 26) {
    	          off -= 26;
    	          j++;
    	        }
    	      }
    	    }
    	    return this._strip();
    	  };

    	  function parseHex4Bits (string, index) {
    	    var c = string.charCodeAt(index);
    	    // '0' - '9'
    	    if (c >= 48 && c <= 57) {
    	      return c - 48;
    	    // 'A' - 'F'
    	    } else if (c >= 65 && c <= 70) {
    	      return c - 55;
    	    // 'a' - 'f'
    	    } else if (c >= 97 && c <= 102) {
    	      return c - 87;
    	    } else {
    	      assert(false, 'Invalid character in ' + string);
    	    }
    	  }

    	  function parseHexByte (string, lowerBound, index) {
    	    var r = parseHex4Bits(string, index);
    	    if (index - 1 >= lowerBound) {
    	      r |= parseHex4Bits(string, index - 1) << 4;
    	    }
    	    return r;
    	  }

    	  BN.prototype._parseHex = function _parseHex (number, start, endian) {
    	    // Create possibly bigger array to ensure that it fits the number
    	    this.length = Math.ceil((number.length - start) / 6);
    	    this.words = new Array(this.length);
    	    for (var i = 0; i < this.length; i++) {
    	      this.words[i] = 0;
    	    }

    	    // 24-bits chunks
    	    var off = 0;
    	    var j = 0;

    	    var w;
    	    if (endian === 'be') {
    	      for (i = number.length - 1; i >= start; i -= 2) {
    	        w = parseHexByte(number, start, i) << off;
    	        this.words[j] |= w & 0x3ffffff;
    	        if (off >= 18) {
    	          off -= 18;
    	          j += 1;
    	          this.words[j] |= w >>> 26;
    	        } else {
    	          off += 8;
    	        }
    	      }
    	    } else {
    	      var parseLength = number.length - start;
    	      for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
    	        w = parseHexByte(number, start, i) << off;
    	        this.words[j] |= w & 0x3ffffff;
    	        if (off >= 18) {
    	          off -= 18;
    	          j += 1;
    	          this.words[j] |= w >>> 26;
    	        } else {
    	          off += 8;
    	        }
    	      }
    	    }

    	    this._strip();
    	  };

    	  function parseBase (str, start, end, mul) {
    	    var r = 0;
    	    var b = 0;
    	    var len = Math.min(str.length, end);
    	    for (var i = start; i < len; i++) {
    	      var c = str.charCodeAt(i) - 48;

    	      r *= mul;

    	      // 'a'
    	      if (c >= 49) {
    	        b = c - 49 + 0xa;

    	      // 'A'
    	      } else if (c >= 17) {
    	        b = c - 17 + 0xa;

    	      // '0' - '9'
    	      } else {
    	        b = c;
    	      }
    	      assert(c >= 0 && b < mul, 'Invalid character');
    	      r += b;
    	    }
    	    return r;
    	  }

    	  BN.prototype._parseBase = function _parseBase (number, base, start) {
    	    // Initialize as zero
    	    this.words = [0];
    	    this.length = 1;

    	    // Find length of limb in base
    	    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
    	      limbLen++;
    	    }
    	    limbLen--;
    	    limbPow = (limbPow / base) | 0;

    	    var total = number.length - start;
    	    var mod = total % limbLen;
    	    var end = Math.min(total, total - mod) + start;

    	    var word = 0;
    	    for (var i = start; i < end; i += limbLen) {
    	      word = parseBase(number, i, i + limbLen, base);

    	      this.imuln(limbPow);
    	      if (this.words[0] + word < 0x4000000) {
    	        this.words[0] += word;
    	      } else {
    	        this._iaddn(word);
    	      }
    	    }

    	    if (mod !== 0) {
    	      var pow = 1;
    	      word = parseBase(number, i, number.length, base);

    	      for (i = 0; i < mod; i++) {
    	        pow *= base;
    	      }

    	      this.imuln(pow);
    	      if (this.words[0] + word < 0x4000000) {
    	        this.words[0] += word;
    	      } else {
    	        this._iaddn(word);
    	      }
    	    }

    	    this._strip();
    	  };

    	  BN.prototype.copy = function copy (dest) {
    	    dest.words = new Array(this.length);
    	    for (var i = 0; i < this.length; i++) {
    	      dest.words[i] = this.words[i];
    	    }
    	    dest.length = this.length;
    	    dest.negative = this.negative;
    	    dest.red = this.red;
    	  };

    	  function move (dest, src) {
    	    dest.words = src.words;
    	    dest.length = src.length;
    	    dest.negative = src.negative;
    	    dest.red = src.red;
    	  }

    	  BN.prototype._move = function _move (dest) {
    	    move(dest, this);
    	  };

    	  BN.prototype.clone = function clone () {
    	    var r = new BN(null);
    	    this.copy(r);
    	    return r;
    	  };

    	  BN.prototype._expand = function _expand (size) {
    	    while (this.length < size) {
    	      this.words[this.length++] = 0;
    	    }
    	    return this;
    	  };

    	  // Remove leading `0` from `this`
    	  BN.prototype._strip = function strip () {
    	    while (this.length > 1 && this.words[this.length - 1] === 0) {
    	      this.length--;
    	    }
    	    return this._normSign();
    	  };

    	  BN.prototype._normSign = function _normSign () {
    	    // -0 = 0
    	    if (this.length === 1 && this.words[0] === 0) {
    	      this.negative = 0;
    	    }
    	    return this;
    	  };

    	  // Check Symbol.for because not everywhere where Symbol defined
    	  // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol#Browser_compatibility
    	  if (typeof Symbol !== 'undefined' && typeof Symbol.for === 'function') {
    	    try {
    	      BN.prototype[Symbol.for('nodejs.util.inspect.custom')] = inspect;
    	    } catch (e) {
    	      BN.prototype.inspect = inspect;
    	    }
    	  } else {
    	    BN.prototype.inspect = inspect;
    	  }

    	  function inspect () {
    	    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
    	  }

    	  /*

    	  var zeros = [];
    	  var groupSizes = [];
    	  var groupBases = [];

    	  var s = '';
    	  var i = -1;
    	  while (++i < BN.wordSize) {
    	    zeros[i] = s;
    	    s += '0';
    	  }
    	  groupSizes[0] = 0;
    	  groupSizes[1] = 0;
    	  groupBases[0] = 0;
    	  groupBases[1] = 0;
    	  var base = 2 - 1;
    	  while (++base < 36 + 1) {
    	    var groupSize = 0;
    	    var groupBase = 1;
    	    while (groupBase < (1 << BN.wordSize) / base) {
    	      groupBase *= base;
    	      groupSize += 1;
    	    }
    	    groupSizes[base] = groupSize;
    	    groupBases[base] = groupBase;
    	  }

    	  */

    	  var zeros = [
    	    '',
    	    '0',
    	    '00',
    	    '000',
    	    '0000',
    	    '00000',
    	    '000000',
    	    '0000000',
    	    '00000000',
    	    '000000000',
    	    '0000000000',
    	    '00000000000',
    	    '000000000000',
    	    '0000000000000',
    	    '00000000000000',
    	    '000000000000000',
    	    '0000000000000000',
    	    '00000000000000000',
    	    '000000000000000000',
    	    '0000000000000000000',
    	    '00000000000000000000',
    	    '000000000000000000000',
    	    '0000000000000000000000',
    	    '00000000000000000000000',
    	    '000000000000000000000000',
    	    '0000000000000000000000000'
    	  ];

    	  var groupSizes = [
    	    0, 0,
    	    25, 16, 12, 11, 10, 9, 8,
    	    8, 7, 7, 7, 7, 6, 6,
    	    6, 6, 6, 6, 6, 5, 5,
    	    5, 5, 5, 5, 5, 5, 5,
    	    5, 5, 5, 5, 5, 5, 5
    	  ];

    	  var groupBases = [
    	    0, 0,
    	    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
    	    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
    	    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
    	    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
    	    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
    	  ];

    	  BN.prototype.toString = function toString (base, padding) {
    	    base = base || 10;
    	    padding = padding | 0 || 1;

    	    var out;
    	    if (base === 16 || base === 'hex') {
    	      out = '';
    	      var off = 0;
    	      var carry = 0;
    	      for (var i = 0; i < this.length; i++) {
    	        var w = this.words[i];
    	        var word = (((w << off) | carry) & 0xffffff).toString(16);
    	        carry = (w >>> (24 - off)) & 0xffffff;
    	        off += 2;
    	        if (off >= 26) {
    	          off -= 26;
    	          i--;
    	        }
    	        if (carry !== 0 || i !== this.length - 1) {
    	          out = zeros[6 - word.length] + word + out;
    	        } else {
    	          out = word + out;
    	        }
    	      }
    	      if (carry !== 0) {
    	        out = carry.toString(16) + out;
    	      }
    	      while (out.length % padding !== 0) {
    	        out = '0' + out;
    	      }
    	      if (this.negative !== 0) {
    	        out = '-' + out;
    	      }
    	      return out;
    	    }

    	    if (base === (base | 0) && base >= 2 && base <= 36) {
    	      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
    	      var groupSize = groupSizes[base];
    	      // var groupBase = Math.pow(base, groupSize);
    	      var groupBase = groupBases[base];
    	      out = '';
    	      var c = this.clone();
    	      c.negative = 0;
    	      while (!c.isZero()) {
    	        var r = c.modrn(groupBase).toString(base);
    	        c = c.idivn(groupBase);

    	        if (!c.isZero()) {
    	          out = zeros[groupSize - r.length] + r + out;
    	        } else {
    	          out = r + out;
    	        }
    	      }
    	      if (this.isZero()) {
    	        out = '0' + out;
    	      }
    	      while (out.length % padding !== 0) {
    	        out = '0' + out;
    	      }
    	      if (this.negative !== 0) {
    	        out = '-' + out;
    	      }
    	      return out;
    	    }

    	    assert(false, 'Base should be between 2 and 36');
    	  };

    	  BN.prototype.toNumber = function toNumber () {
    	    var ret = this.words[0];
    	    if (this.length === 2) {
    	      ret += this.words[1] * 0x4000000;
    	    } else if (this.length === 3 && this.words[2] === 0x01) {
    	      // NOTE: at this stage it is known that the top bit is set
    	      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
    	    } else if (this.length > 2) {
    	      assert(false, 'Number can only safely store up to 53 bits');
    	    }
    	    return (this.negative !== 0) ? -ret : ret;
    	  };

    	  BN.prototype.toJSON = function toJSON () {
    	    return this.toString(16, 2);
    	  };

    	  if (Buffer) {
    	    BN.prototype.toBuffer = function toBuffer (endian, length) {
    	      return this.toArrayLike(Buffer, endian, length);
    	    };
    	  }

    	  BN.prototype.toArray = function toArray (endian, length) {
    	    return this.toArrayLike(Array, endian, length);
    	  };

    	  var allocate = function allocate (ArrayType, size) {
    	    if (ArrayType.allocUnsafe) {
    	      return ArrayType.allocUnsafe(size);
    	    }
    	    return new ArrayType(size);
    	  };

    	  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
    	    this._strip();

    	    var byteLength = this.byteLength();
    	    var reqLength = length || Math.max(1, byteLength);
    	    assert(byteLength <= reqLength, 'byte array longer than desired length');
    	    assert(reqLength > 0, 'Requested array length <= 0');

    	    var res = allocate(ArrayType, reqLength);
    	    var postfix = endian === 'le' ? 'LE' : 'BE';
    	    this['_toArrayLike' + postfix](res, byteLength);
    	    return res;
    	  };

    	  BN.prototype._toArrayLikeLE = function _toArrayLikeLE (res, byteLength) {
    	    var position = 0;
    	    var carry = 0;

    	    for (var i = 0, shift = 0; i < this.length; i++) {
    	      var word = (this.words[i] << shift) | carry;

    	      res[position++] = word & 0xff;
    	      if (position < res.length) {
    	        res[position++] = (word >> 8) & 0xff;
    	      }
    	      if (position < res.length) {
    	        res[position++] = (word >> 16) & 0xff;
    	      }

    	      if (shift === 6) {
    	        if (position < res.length) {
    	          res[position++] = (word >> 24) & 0xff;
    	        }
    	        carry = 0;
    	        shift = 0;
    	      } else {
    	        carry = word >>> 24;
    	        shift += 2;
    	      }
    	    }

    	    if (position < res.length) {
    	      res[position++] = carry;

    	      while (position < res.length) {
    	        res[position++] = 0;
    	      }
    	    }
    	  };

    	  BN.prototype._toArrayLikeBE = function _toArrayLikeBE (res, byteLength) {
    	    var position = res.length - 1;
    	    var carry = 0;

    	    for (var i = 0, shift = 0; i < this.length; i++) {
    	      var word = (this.words[i] << shift) | carry;

    	      res[position--] = word & 0xff;
    	      if (position >= 0) {
    	        res[position--] = (word >> 8) & 0xff;
    	      }
    	      if (position >= 0) {
    	        res[position--] = (word >> 16) & 0xff;
    	      }

    	      if (shift === 6) {
    	        if (position >= 0) {
    	          res[position--] = (word >> 24) & 0xff;
    	        }
    	        carry = 0;
    	        shift = 0;
    	      } else {
    	        carry = word >>> 24;
    	        shift += 2;
    	      }
    	    }

    	    if (position >= 0) {
    	      res[position--] = carry;

    	      while (position >= 0) {
    	        res[position--] = 0;
    	      }
    	    }
    	  };

    	  if (Math.clz32) {
    	    BN.prototype._countBits = function _countBits (w) {
    	      return 32 - Math.clz32(w);
    	    };
    	  } else {
    	    BN.prototype._countBits = function _countBits (w) {
    	      var t = w;
    	      var r = 0;
    	      if (t >= 0x1000) {
    	        r += 13;
    	        t >>>= 13;
    	      }
    	      if (t >= 0x40) {
    	        r += 7;
    	        t >>>= 7;
    	      }
    	      if (t >= 0x8) {
    	        r += 4;
    	        t >>>= 4;
    	      }
    	      if (t >= 0x02) {
    	        r += 2;
    	        t >>>= 2;
    	      }
    	      return r + t;
    	    };
    	  }

    	  BN.prototype._zeroBits = function _zeroBits (w) {
    	    // Short-cut
    	    if (w === 0) return 26;

    	    var t = w;
    	    var r = 0;
    	    if ((t & 0x1fff) === 0) {
    	      r += 13;
    	      t >>>= 13;
    	    }
    	    if ((t & 0x7f) === 0) {
    	      r += 7;
    	      t >>>= 7;
    	    }
    	    if ((t & 0xf) === 0) {
    	      r += 4;
    	      t >>>= 4;
    	    }
    	    if ((t & 0x3) === 0) {
    	      r += 2;
    	      t >>>= 2;
    	    }
    	    if ((t & 0x1) === 0) {
    	      r++;
    	    }
    	    return r;
    	  };

    	  // Return number of used bits in a BN
    	  BN.prototype.bitLength = function bitLength () {
    	    var w = this.words[this.length - 1];
    	    var hi = this._countBits(w);
    	    return (this.length - 1) * 26 + hi;
    	  };

    	  function toBitArray (num) {
    	    var w = new Array(num.bitLength());

    	    for (var bit = 0; bit < w.length; bit++) {
    	      var off = (bit / 26) | 0;
    	      var wbit = bit % 26;

    	      w[bit] = (num.words[off] >>> wbit) & 0x01;
    	    }

    	    return w;
    	  }

    	  // Number of trailing zero bits
    	  BN.prototype.zeroBits = function zeroBits () {
    	    if (this.isZero()) return 0;

    	    var r = 0;
    	    for (var i = 0; i < this.length; i++) {
    	      var b = this._zeroBits(this.words[i]);
    	      r += b;
    	      if (b !== 26) break;
    	    }
    	    return r;
    	  };

    	  BN.prototype.byteLength = function byteLength () {
    	    return Math.ceil(this.bitLength() / 8);
    	  };

    	  BN.prototype.toTwos = function toTwos (width) {
    	    if (this.negative !== 0) {
    	      return this.abs().inotn(width).iaddn(1);
    	    }
    	    return this.clone();
    	  };

    	  BN.prototype.fromTwos = function fromTwos (width) {
    	    if (this.testn(width - 1)) {
    	      return this.notn(width).iaddn(1).ineg();
    	    }
    	    return this.clone();
    	  };

    	  BN.prototype.isNeg = function isNeg () {
    	    return this.negative !== 0;
    	  };

    	  // Return negative clone of `this`
    	  BN.prototype.neg = function neg () {
    	    return this.clone().ineg();
    	  };

    	  BN.prototype.ineg = function ineg () {
    	    if (!this.isZero()) {
    	      this.negative ^= 1;
    	    }

    	    return this;
    	  };

    	  // Or `num` with `this` in-place
    	  BN.prototype.iuor = function iuor (num) {
    	    while (this.length < num.length) {
    	      this.words[this.length++] = 0;
    	    }

    	    for (var i = 0; i < num.length; i++) {
    	      this.words[i] = this.words[i] | num.words[i];
    	    }

    	    return this._strip();
    	  };

    	  BN.prototype.ior = function ior (num) {
    	    assert((this.negative | num.negative) === 0);
    	    return this.iuor(num);
    	  };

    	  // Or `num` with `this`
    	  BN.prototype.or = function or (num) {
    	    if (this.length > num.length) return this.clone().ior(num);
    	    return num.clone().ior(this);
    	  };

    	  BN.prototype.uor = function uor (num) {
    	    if (this.length > num.length) return this.clone().iuor(num);
    	    return num.clone().iuor(this);
    	  };

    	  // And `num` with `this` in-place
    	  BN.prototype.iuand = function iuand (num) {
    	    // b = min-length(num, this)
    	    var b;
    	    if (this.length > num.length) {
    	      b = num;
    	    } else {
    	      b = this;
    	    }

    	    for (var i = 0; i < b.length; i++) {
    	      this.words[i] = this.words[i] & num.words[i];
    	    }

    	    this.length = b.length;

    	    return this._strip();
    	  };

    	  BN.prototype.iand = function iand (num) {
    	    assert((this.negative | num.negative) === 0);
    	    return this.iuand(num);
    	  };

    	  // And `num` with `this`
    	  BN.prototype.and = function and (num) {
    	    if (this.length > num.length) return this.clone().iand(num);
    	    return num.clone().iand(this);
    	  };

    	  BN.prototype.uand = function uand (num) {
    	    if (this.length > num.length) return this.clone().iuand(num);
    	    return num.clone().iuand(this);
    	  };

    	  // Xor `num` with `this` in-place
    	  BN.prototype.iuxor = function iuxor (num) {
    	    // a.length > b.length
    	    var a;
    	    var b;
    	    if (this.length > num.length) {
    	      a = this;
    	      b = num;
    	    } else {
    	      a = num;
    	      b = this;
    	    }

    	    for (var i = 0; i < b.length; i++) {
    	      this.words[i] = a.words[i] ^ b.words[i];
    	    }

    	    if (this !== a) {
    	      for (; i < a.length; i++) {
    	        this.words[i] = a.words[i];
    	      }
    	    }

    	    this.length = a.length;

    	    return this._strip();
    	  };

    	  BN.prototype.ixor = function ixor (num) {
    	    assert((this.negative | num.negative) === 0);
    	    return this.iuxor(num);
    	  };

    	  // Xor `num` with `this`
    	  BN.prototype.xor = function xor (num) {
    	    if (this.length > num.length) return this.clone().ixor(num);
    	    return num.clone().ixor(this);
    	  };

    	  BN.prototype.uxor = function uxor (num) {
    	    if (this.length > num.length) return this.clone().iuxor(num);
    	    return num.clone().iuxor(this);
    	  };

    	  // Not ``this`` with ``width`` bitwidth
    	  BN.prototype.inotn = function inotn (width) {
    	    assert(typeof width === 'number' && width >= 0);

    	    var bytesNeeded = Math.ceil(width / 26) | 0;
    	    var bitsLeft = width % 26;

    	    // Extend the buffer with leading zeroes
    	    this._expand(bytesNeeded);

    	    if (bitsLeft > 0) {
    	      bytesNeeded--;
    	    }

    	    // Handle complete words
    	    for (var i = 0; i < bytesNeeded; i++) {
    	      this.words[i] = ~this.words[i] & 0x3ffffff;
    	    }

    	    // Handle the residue
    	    if (bitsLeft > 0) {
    	      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
    	    }

    	    // And remove leading zeroes
    	    return this._strip();
    	  };

    	  BN.prototype.notn = function notn (width) {
    	    return this.clone().inotn(width);
    	  };

    	  // Set `bit` of `this`
    	  BN.prototype.setn = function setn (bit, val) {
    	    assert(typeof bit === 'number' && bit >= 0);

    	    var off = (bit / 26) | 0;
    	    var wbit = bit % 26;

    	    this._expand(off + 1);

    	    if (val) {
    	      this.words[off] = this.words[off] | (1 << wbit);
    	    } else {
    	      this.words[off] = this.words[off] & ~(1 << wbit);
    	    }

    	    return this._strip();
    	  };

    	  // Add `num` to `this` in-place
    	  BN.prototype.iadd = function iadd (num) {
    	    var r;

    	    // negative + positive
    	    if (this.negative !== 0 && num.negative === 0) {
    	      this.negative = 0;
    	      r = this.isub(num);
    	      this.negative ^= 1;
    	      return this._normSign();

    	    // positive + negative
    	    } else if (this.negative === 0 && num.negative !== 0) {
    	      num.negative = 0;
    	      r = this.isub(num);
    	      num.negative = 1;
    	      return r._normSign();
    	    }

    	    // a.length > b.length
    	    var a, b;
    	    if (this.length > num.length) {
    	      a = this;
    	      b = num;
    	    } else {
    	      a = num;
    	      b = this;
    	    }

    	    var carry = 0;
    	    for (var i = 0; i < b.length; i++) {
    	      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
    	      this.words[i] = r & 0x3ffffff;
    	      carry = r >>> 26;
    	    }
    	    for (; carry !== 0 && i < a.length; i++) {
    	      r = (a.words[i] | 0) + carry;
    	      this.words[i] = r & 0x3ffffff;
    	      carry = r >>> 26;
    	    }

    	    this.length = a.length;
    	    if (carry !== 0) {
    	      this.words[this.length] = carry;
    	      this.length++;
    	    // Copy the rest of the words
    	    } else if (a !== this) {
    	      for (; i < a.length; i++) {
    	        this.words[i] = a.words[i];
    	      }
    	    }

    	    return this;
    	  };

    	  // Add `num` to `this`
    	  BN.prototype.add = function add (num) {
    	    var res;
    	    if (num.negative !== 0 && this.negative === 0) {
    	      num.negative = 0;
    	      res = this.sub(num);
    	      num.negative ^= 1;
    	      return res;
    	    } else if (num.negative === 0 && this.negative !== 0) {
    	      this.negative = 0;
    	      res = num.sub(this);
    	      this.negative = 1;
    	      return res;
    	    }

    	    if (this.length > num.length) return this.clone().iadd(num);

    	    return num.clone().iadd(this);
    	  };

    	  // Subtract `num` from `this` in-place
    	  BN.prototype.isub = function isub (num) {
    	    // this - (-num) = this + num
    	    if (num.negative !== 0) {
    	      num.negative = 0;
    	      var r = this.iadd(num);
    	      num.negative = 1;
    	      return r._normSign();

    	    // -this - num = -(this + num)
    	    } else if (this.negative !== 0) {
    	      this.negative = 0;
    	      this.iadd(num);
    	      this.negative = 1;
    	      return this._normSign();
    	    }

    	    // At this point both numbers are positive
    	    var cmp = this.cmp(num);

    	    // Optimization - zeroify
    	    if (cmp === 0) {
    	      this.negative = 0;
    	      this.length = 1;
    	      this.words[0] = 0;
    	      return this;
    	    }

    	    // a > b
    	    var a, b;
    	    if (cmp > 0) {
    	      a = this;
    	      b = num;
    	    } else {
    	      a = num;
    	      b = this;
    	    }

    	    var carry = 0;
    	    for (var i = 0; i < b.length; i++) {
    	      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
    	      carry = r >> 26;
    	      this.words[i] = r & 0x3ffffff;
    	    }
    	    for (; carry !== 0 && i < a.length; i++) {
    	      r = (a.words[i] | 0) + carry;
    	      carry = r >> 26;
    	      this.words[i] = r & 0x3ffffff;
    	    }

    	    // Copy rest of the words
    	    if (carry === 0 && i < a.length && a !== this) {
    	      for (; i < a.length; i++) {
    	        this.words[i] = a.words[i];
    	      }
    	    }

    	    this.length = Math.max(this.length, i);

    	    if (a !== this) {
    	      this.negative = 1;
    	    }

    	    return this._strip();
    	  };

    	  // Subtract `num` from `this`
    	  BN.prototype.sub = function sub (num) {
    	    return this.clone().isub(num);
    	  };

    	  function smallMulTo (self, num, out) {
    	    out.negative = num.negative ^ self.negative;
    	    var len = (self.length + num.length) | 0;
    	    out.length = len;
    	    len = (len - 1) | 0;

    	    // Peel one iteration (compiler can't do it, because of code complexity)
    	    var a = self.words[0] | 0;
    	    var b = num.words[0] | 0;
    	    var r = a * b;

    	    var lo = r & 0x3ffffff;
    	    var carry = (r / 0x4000000) | 0;
    	    out.words[0] = lo;

    	    for (var k = 1; k < len; k++) {
    	      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
    	      // note that ncarry could be >= 0x3ffffff
    	      var ncarry = carry >>> 26;
    	      var rword = carry & 0x3ffffff;
    	      var maxJ = Math.min(k, num.length - 1);
    	      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
    	        var i = (k - j) | 0;
    	        a = self.words[i] | 0;
    	        b = num.words[j] | 0;
    	        r = a * b + rword;
    	        ncarry += (r / 0x4000000) | 0;
    	        rword = r & 0x3ffffff;
    	      }
    	      out.words[k] = rword | 0;
    	      carry = ncarry | 0;
    	    }
    	    if (carry !== 0) {
    	      out.words[k] = carry | 0;
    	    } else {
    	      out.length--;
    	    }

    	    return out._strip();
    	  }

    	  // TODO(indutny): it may be reasonable to omit it for users who don't need
    	  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
    	  // multiplication (like elliptic secp256k1).
    	  var comb10MulTo = function comb10MulTo (self, num, out) {
    	    var a = self.words;
    	    var b = num.words;
    	    var o = out.words;
    	    var c = 0;
    	    var lo;
    	    var mid;
    	    var hi;
    	    var a0 = a[0] | 0;
    	    var al0 = a0 & 0x1fff;
    	    var ah0 = a0 >>> 13;
    	    var a1 = a[1] | 0;
    	    var al1 = a1 & 0x1fff;
    	    var ah1 = a1 >>> 13;
    	    var a2 = a[2] | 0;
    	    var al2 = a2 & 0x1fff;
    	    var ah2 = a2 >>> 13;
    	    var a3 = a[3] | 0;
    	    var al3 = a3 & 0x1fff;
    	    var ah3 = a3 >>> 13;
    	    var a4 = a[4] | 0;
    	    var al4 = a4 & 0x1fff;
    	    var ah4 = a4 >>> 13;
    	    var a5 = a[5] | 0;
    	    var al5 = a5 & 0x1fff;
    	    var ah5 = a5 >>> 13;
    	    var a6 = a[6] | 0;
    	    var al6 = a6 & 0x1fff;
    	    var ah6 = a6 >>> 13;
    	    var a7 = a[7] | 0;
    	    var al7 = a7 & 0x1fff;
    	    var ah7 = a7 >>> 13;
    	    var a8 = a[8] | 0;
    	    var al8 = a8 & 0x1fff;
    	    var ah8 = a8 >>> 13;
    	    var a9 = a[9] | 0;
    	    var al9 = a9 & 0x1fff;
    	    var ah9 = a9 >>> 13;
    	    var b0 = b[0] | 0;
    	    var bl0 = b0 & 0x1fff;
    	    var bh0 = b0 >>> 13;
    	    var b1 = b[1] | 0;
    	    var bl1 = b1 & 0x1fff;
    	    var bh1 = b1 >>> 13;
    	    var b2 = b[2] | 0;
    	    var bl2 = b2 & 0x1fff;
    	    var bh2 = b2 >>> 13;
    	    var b3 = b[3] | 0;
    	    var bl3 = b3 & 0x1fff;
    	    var bh3 = b3 >>> 13;
    	    var b4 = b[4] | 0;
    	    var bl4 = b4 & 0x1fff;
    	    var bh4 = b4 >>> 13;
    	    var b5 = b[5] | 0;
    	    var bl5 = b5 & 0x1fff;
    	    var bh5 = b5 >>> 13;
    	    var b6 = b[6] | 0;
    	    var bl6 = b6 & 0x1fff;
    	    var bh6 = b6 >>> 13;
    	    var b7 = b[7] | 0;
    	    var bl7 = b7 & 0x1fff;
    	    var bh7 = b7 >>> 13;
    	    var b8 = b[8] | 0;
    	    var bl8 = b8 & 0x1fff;
    	    var bh8 = b8 >>> 13;
    	    var b9 = b[9] | 0;
    	    var bl9 = b9 & 0x1fff;
    	    var bh9 = b9 >>> 13;

    	    out.negative = self.negative ^ num.negative;
    	    out.length = 19;
    	    /* k = 0 */
    	    lo = Math.imul(al0, bl0);
    	    mid = Math.imul(al0, bh0);
    	    mid = (mid + Math.imul(ah0, bl0)) | 0;
    	    hi = Math.imul(ah0, bh0);
    	    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    	    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
    	    w0 &= 0x3ffffff;
    	    /* k = 1 */
    	    lo = Math.imul(al1, bl0);
    	    mid = Math.imul(al1, bh0);
    	    mid = (mid + Math.imul(ah1, bl0)) | 0;
    	    hi = Math.imul(ah1, bh0);
    	    lo = (lo + Math.imul(al0, bl1)) | 0;
    	    mid = (mid + Math.imul(al0, bh1)) | 0;
    	    mid = (mid + Math.imul(ah0, bl1)) | 0;
    	    hi = (hi + Math.imul(ah0, bh1)) | 0;
    	    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    	    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
    	    w1 &= 0x3ffffff;
    	    /* k = 2 */
    	    lo = Math.imul(al2, bl0);
    	    mid = Math.imul(al2, bh0);
    	    mid = (mid + Math.imul(ah2, bl0)) | 0;
    	    hi = Math.imul(ah2, bh0);
    	    lo = (lo + Math.imul(al1, bl1)) | 0;
    	    mid = (mid + Math.imul(al1, bh1)) | 0;
    	    mid = (mid + Math.imul(ah1, bl1)) | 0;
    	    hi = (hi + Math.imul(ah1, bh1)) | 0;
    	    lo = (lo + Math.imul(al0, bl2)) | 0;
    	    mid = (mid + Math.imul(al0, bh2)) | 0;
    	    mid = (mid + Math.imul(ah0, bl2)) | 0;
    	    hi = (hi + Math.imul(ah0, bh2)) | 0;
    	    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    	    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
    	    w2 &= 0x3ffffff;
    	    /* k = 3 */
    	    lo = Math.imul(al3, bl0);
    	    mid = Math.imul(al3, bh0);
    	    mid = (mid + Math.imul(ah3, bl0)) | 0;
    	    hi = Math.imul(ah3, bh0);
    	    lo = (lo + Math.imul(al2, bl1)) | 0;
    	    mid = (mid + Math.imul(al2, bh1)) | 0;
    	    mid = (mid + Math.imul(ah2, bl1)) | 0;
    	    hi = (hi + Math.imul(ah2, bh1)) | 0;
    	    lo = (lo + Math.imul(al1, bl2)) | 0;
    	    mid = (mid + Math.imul(al1, bh2)) | 0;
    	    mid = (mid + Math.imul(ah1, bl2)) | 0;
    	    hi = (hi + Math.imul(ah1, bh2)) | 0;
    	    lo = (lo + Math.imul(al0, bl3)) | 0;
    	    mid = (mid + Math.imul(al0, bh3)) | 0;
    	    mid = (mid + Math.imul(ah0, bl3)) | 0;
    	    hi = (hi + Math.imul(ah0, bh3)) | 0;
    	    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    	    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
    	    w3 &= 0x3ffffff;
    	    /* k = 4 */
    	    lo = Math.imul(al4, bl0);
    	    mid = Math.imul(al4, bh0);
    	    mid = (mid + Math.imul(ah4, bl0)) | 0;
    	    hi = Math.imul(ah4, bh0);
    	    lo = (lo + Math.imul(al3, bl1)) | 0;
    	    mid = (mid + Math.imul(al3, bh1)) | 0;
    	    mid = (mid + Math.imul(ah3, bl1)) | 0;
    	    hi = (hi + Math.imul(ah3, bh1)) | 0;
    	    lo = (lo + Math.imul(al2, bl2)) | 0;
    	    mid = (mid + Math.imul(al2, bh2)) | 0;
    	    mid = (mid + Math.imul(ah2, bl2)) | 0;
    	    hi = (hi + Math.imul(ah2, bh2)) | 0;
    	    lo = (lo + Math.imul(al1, bl3)) | 0;
    	    mid = (mid + Math.imul(al1, bh3)) | 0;
    	    mid = (mid + Math.imul(ah1, bl3)) | 0;
    	    hi = (hi + Math.imul(ah1, bh3)) | 0;
    	    lo = (lo + Math.imul(al0, bl4)) | 0;
    	    mid = (mid + Math.imul(al0, bh4)) | 0;
    	    mid = (mid + Math.imul(ah0, bl4)) | 0;
    	    hi = (hi + Math.imul(ah0, bh4)) | 0;
    	    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    	    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
    	    w4 &= 0x3ffffff;
    	    /* k = 5 */
    	    lo = Math.imul(al5, bl0);
    	    mid = Math.imul(al5, bh0);
    	    mid = (mid + Math.imul(ah5, bl0)) | 0;
    	    hi = Math.imul(ah5, bh0);
    	    lo = (lo + Math.imul(al4, bl1)) | 0;
    	    mid = (mid + Math.imul(al4, bh1)) | 0;
    	    mid = (mid + Math.imul(ah4, bl1)) | 0;
    	    hi = (hi + Math.imul(ah4, bh1)) | 0;
    	    lo = (lo + Math.imul(al3, bl2)) | 0;
    	    mid = (mid + Math.imul(al3, bh2)) | 0;
    	    mid = (mid + Math.imul(ah3, bl2)) | 0;
    	    hi = (hi + Math.imul(ah3, bh2)) | 0;
    	    lo = (lo + Math.imul(al2, bl3)) | 0;
    	    mid = (mid + Math.imul(al2, bh3)) | 0;
    	    mid = (mid + Math.imul(ah2, bl3)) | 0;
    	    hi = (hi + Math.imul(ah2, bh3)) | 0;
    	    lo = (lo + Math.imul(al1, bl4)) | 0;
    	    mid = (mid + Math.imul(al1, bh4)) | 0;
    	    mid = (mid + Math.imul(ah1, bl4)) | 0;
    	    hi = (hi + Math.imul(ah1, bh4)) | 0;
    	    lo = (lo + Math.imul(al0, bl5)) | 0;
    	    mid = (mid + Math.imul(al0, bh5)) | 0;
    	    mid = (mid + Math.imul(ah0, bl5)) | 0;
    	    hi = (hi + Math.imul(ah0, bh5)) | 0;
    	    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    	    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
    	    w5 &= 0x3ffffff;
    	    /* k = 6 */
    	    lo = Math.imul(al6, bl0);
    	    mid = Math.imul(al6, bh0);
    	    mid = (mid + Math.imul(ah6, bl0)) | 0;
    	    hi = Math.imul(ah6, bh0);
    	    lo = (lo + Math.imul(al5, bl1)) | 0;
    	    mid = (mid + Math.imul(al5, bh1)) | 0;
    	    mid = (mid + Math.imul(ah5, bl1)) | 0;
    	    hi = (hi + Math.imul(ah5, bh1)) | 0;
    	    lo = (lo + Math.imul(al4, bl2)) | 0;
    	    mid = (mid + Math.imul(al4, bh2)) | 0;
    	    mid = (mid + Math.imul(ah4, bl2)) | 0;
    	    hi = (hi + Math.imul(ah4, bh2)) | 0;
    	    lo = (lo + Math.imul(al3, bl3)) | 0;
    	    mid = (mid + Math.imul(al3, bh3)) | 0;
    	    mid = (mid + Math.imul(ah3, bl3)) | 0;
    	    hi = (hi + Math.imul(ah3, bh3)) | 0;
    	    lo = (lo + Math.imul(al2, bl4)) | 0;
    	    mid = (mid + Math.imul(al2, bh4)) | 0;
    	    mid = (mid + Math.imul(ah2, bl4)) | 0;
    	    hi = (hi + Math.imul(ah2, bh4)) | 0;
    	    lo = (lo + Math.imul(al1, bl5)) | 0;
    	    mid = (mid + Math.imul(al1, bh5)) | 0;
    	    mid = (mid + Math.imul(ah1, bl5)) | 0;
    	    hi = (hi + Math.imul(ah1, bh5)) | 0;
    	    lo = (lo + Math.imul(al0, bl6)) | 0;
    	    mid = (mid + Math.imul(al0, bh6)) | 0;
    	    mid = (mid + Math.imul(ah0, bl6)) | 0;
    	    hi = (hi + Math.imul(ah0, bh6)) | 0;
    	    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    	    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
    	    w6 &= 0x3ffffff;
    	    /* k = 7 */
    	    lo = Math.imul(al7, bl0);
    	    mid = Math.imul(al7, bh0);
    	    mid = (mid + Math.imul(ah7, bl0)) | 0;
    	    hi = Math.imul(ah7, bh0);
    	    lo = (lo + Math.imul(al6, bl1)) | 0;
    	    mid = (mid + Math.imul(al6, bh1)) | 0;
    	    mid = (mid + Math.imul(ah6, bl1)) | 0;
    	    hi = (hi + Math.imul(ah6, bh1)) | 0;
    	    lo = (lo + Math.imul(al5, bl2)) | 0;
    	    mid = (mid + Math.imul(al5, bh2)) | 0;
    	    mid = (mid + Math.imul(ah5, bl2)) | 0;
    	    hi = (hi + Math.imul(ah5, bh2)) | 0;
    	    lo = (lo + Math.imul(al4, bl3)) | 0;
    	    mid = (mid + Math.imul(al4, bh3)) | 0;
    	    mid = (mid + Math.imul(ah4, bl3)) | 0;
    	    hi = (hi + Math.imul(ah4, bh3)) | 0;
    	    lo = (lo + Math.imul(al3, bl4)) | 0;
    	    mid = (mid + Math.imul(al3, bh4)) | 0;
    	    mid = (mid + Math.imul(ah3, bl4)) | 0;
    	    hi = (hi + Math.imul(ah3, bh4)) | 0;
    	    lo = (lo + Math.imul(al2, bl5)) | 0;
    	    mid = (mid + Math.imul(al2, bh5)) | 0;
    	    mid = (mid + Math.imul(ah2, bl5)) | 0;
    	    hi = (hi + Math.imul(ah2, bh5)) | 0;
    	    lo = (lo + Math.imul(al1, bl6)) | 0;
    	    mid = (mid + Math.imul(al1, bh6)) | 0;
    	    mid = (mid + Math.imul(ah1, bl6)) | 0;
    	    hi = (hi + Math.imul(ah1, bh6)) | 0;
    	    lo = (lo + Math.imul(al0, bl7)) | 0;
    	    mid = (mid + Math.imul(al0, bh7)) | 0;
    	    mid = (mid + Math.imul(ah0, bl7)) | 0;
    	    hi = (hi + Math.imul(ah0, bh7)) | 0;
    	    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    	    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
    	    w7 &= 0x3ffffff;
    	    /* k = 8 */
    	    lo = Math.imul(al8, bl0);
    	    mid = Math.imul(al8, bh0);
    	    mid = (mid + Math.imul(ah8, bl0)) | 0;
    	    hi = Math.imul(ah8, bh0);
    	    lo = (lo + Math.imul(al7, bl1)) | 0;
    	    mid = (mid + Math.imul(al7, bh1)) | 0;
    	    mid = (mid + Math.imul(ah7, bl1)) | 0;
    	    hi = (hi + Math.imul(ah7, bh1)) | 0;
    	    lo = (lo + Math.imul(al6, bl2)) | 0;
    	    mid = (mid + Math.imul(al6, bh2)) | 0;
    	    mid = (mid + Math.imul(ah6, bl2)) | 0;
    	    hi = (hi + Math.imul(ah6, bh2)) | 0;
    	    lo = (lo + Math.imul(al5, bl3)) | 0;
    	    mid = (mid + Math.imul(al5, bh3)) | 0;
    	    mid = (mid + Math.imul(ah5, bl3)) | 0;
    	    hi = (hi + Math.imul(ah5, bh3)) | 0;
    	    lo = (lo + Math.imul(al4, bl4)) | 0;
    	    mid = (mid + Math.imul(al4, bh4)) | 0;
    	    mid = (mid + Math.imul(ah4, bl4)) | 0;
    	    hi = (hi + Math.imul(ah4, bh4)) | 0;
    	    lo = (lo + Math.imul(al3, bl5)) | 0;
    	    mid = (mid + Math.imul(al3, bh5)) | 0;
    	    mid = (mid + Math.imul(ah3, bl5)) | 0;
    	    hi = (hi + Math.imul(ah3, bh5)) | 0;
    	    lo = (lo + Math.imul(al2, bl6)) | 0;
    	    mid = (mid + Math.imul(al2, bh6)) | 0;
    	    mid = (mid + Math.imul(ah2, bl6)) | 0;
    	    hi = (hi + Math.imul(ah2, bh6)) | 0;
    	    lo = (lo + Math.imul(al1, bl7)) | 0;
    	    mid = (mid + Math.imul(al1, bh7)) | 0;
    	    mid = (mid + Math.imul(ah1, bl7)) | 0;
    	    hi = (hi + Math.imul(ah1, bh7)) | 0;
    	    lo = (lo + Math.imul(al0, bl8)) | 0;
    	    mid = (mid + Math.imul(al0, bh8)) | 0;
    	    mid = (mid + Math.imul(ah0, bl8)) | 0;
    	    hi = (hi + Math.imul(ah0, bh8)) | 0;
    	    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    	    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
    	    w8 &= 0x3ffffff;
    	    /* k = 9 */
    	    lo = Math.imul(al9, bl0);
    	    mid = Math.imul(al9, bh0);
    	    mid = (mid + Math.imul(ah9, bl0)) | 0;
    	    hi = Math.imul(ah9, bh0);
    	    lo = (lo + Math.imul(al8, bl1)) | 0;
    	    mid = (mid + Math.imul(al8, bh1)) | 0;
    	    mid = (mid + Math.imul(ah8, bl1)) | 0;
    	    hi = (hi + Math.imul(ah8, bh1)) | 0;
    	    lo = (lo + Math.imul(al7, bl2)) | 0;
    	    mid = (mid + Math.imul(al7, bh2)) | 0;
    	    mid = (mid + Math.imul(ah7, bl2)) | 0;
    	    hi = (hi + Math.imul(ah7, bh2)) | 0;
    	    lo = (lo + Math.imul(al6, bl3)) | 0;
    	    mid = (mid + Math.imul(al6, bh3)) | 0;
    	    mid = (mid + Math.imul(ah6, bl3)) | 0;
    	    hi = (hi + Math.imul(ah6, bh3)) | 0;
    	    lo = (lo + Math.imul(al5, bl4)) | 0;
    	    mid = (mid + Math.imul(al5, bh4)) | 0;
    	    mid = (mid + Math.imul(ah5, bl4)) | 0;
    	    hi = (hi + Math.imul(ah5, bh4)) | 0;
    	    lo = (lo + Math.imul(al4, bl5)) | 0;
    	    mid = (mid + Math.imul(al4, bh5)) | 0;
    	    mid = (mid + Math.imul(ah4, bl5)) | 0;
    	    hi = (hi + Math.imul(ah4, bh5)) | 0;
    	    lo = (lo + Math.imul(al3, bl6)) | 0;
    	    mid = (mid + Math.imul(al3, bh6)) | 0;
    	    mid = (mid + Math.imul(ah3, bl6)) | 0;
    	    hi = (hi + Math.imul(ah3, bh6)) | 0;
    	    lo = (lo + Math.imul(al2, bl7)) | 0;
    	    mid = (mid + Math.imul(al2, bh7)) | 0;
    	    mid = (mid + Math.imul(ah2, bl7)) | 0;
    	    hi = (hi + Math.imul(ah2, bh7)) | 0;
    	    lo = (lo + Math.imul(al1, bl8)) | 0;
    	    mid = (mid + Math.imul(al1, bh8)) | 0;
    	    mid = (mid + Math.imul(ah1, bl8)) | 0;
    	    hi = (hi + Math.imul(ah1, bh8)) | 0;
    	    lo = (lo + Math.imul(al0, bl9)) | 0;
    	    mid = (mid + Math.imul(al0, bh9)) | 0;
    	    mid = (mid + Math.imul(ah0, bl9)) | 0;
    	    hi = (hi + Math.imul(ah0, bh9)) | 0;
    	    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    	    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
    	    w9 &= 0x3ffffff;
    	    /* k = 10 */
    	    lo = Math.imul(al9, bl1);
    	    mid = Math.imul(al9, bh1);
    	    mid = (mid + Math.imul(ah9, bl1)) | 0;
    	    hi = Math.imul(ah9, bh1);
    	    lo = (lo + Math.imul(al8, bl2)) | 0;
    	    mid = (mid + Math.imul(al8, bh2)) | 0;
    	    mid = (mid + Math.imul(ah8, bl2)) | 0;
    	    hi = (hi + Math.imul(ah8, bh2)) | 0;
    	    lo = (lo + Math.imul(al7, bl3)) | 0;
    	    mid = (mid + Math.imul(al7, bh3)) | 0;
    	    mid = (mid + Math.imul(ah7, bl3)) | 0;
    	    hi = (hi + Math.imul(ah7, bh3)) | 0;
    	    lo = (lo + Math.imul(al6, bl4)) | 0;
    	    mid = (mid + Math.imul(al6, bh4)) | 0;
    	    mid = (mid + Math.imul(ah6, bl4)) | 0;
    	    hi = (hi + Math.imul(ah6, bh4)) | 0;
    	    lo = (lo + Math.imul(al5, bl5)) | 0;
    	    mid = (mid + Math.imul(al5, bh5)) | 0;
    	    mid = (mid + Math.imul(ah5, bl5)) | 0;
    	    hi = (hi + Math.imul(ah5, bh5)) | 0;
    	    lo = (lo + Math.imul(al4, bl6)) | 0;
    	    mid = (mid + Math.imul(al4, bh6)) | 0;
    	    mid = (mid + Math.imul(ah4, bl6)) | 0;
    	    hi = (hi + Math.imul(ah4, bh6)) | 0;
    	    lo = (lo + Math.imul(al3, bl7)) | 0;
    	    mid = (mid + Math.imul(al3, bh7)) | 0;
    	    mid = (mid + Math.imul(ah3, bl7)) | 0;
    	    hi = (hi + Math.imul(ah3, bh7)) | 0;
    	    lo = (lo + Math.imul(al2, bl8)) | 0;
    	    mid = (mid + Math.imul(al2, bh8)) | 0;
    	    mid = (mid + Math.imul(ah2, bl8)) | 0;
    	    hi = (hi + Math.imul(ah2, bh8)) | 0;
    	    lo = (lo + Math.imul(al1, bl9)) | 0;
    	    mid = (mid + Math.imul(al1, bh9)) | 0;
    	    mid = (mid + Math.imul(ah1, bl9)) | 0;
    	    hi = (hi + Math.imul(ah1, bh9)) | 0;
    	    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    	    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
    	    w10 &= 0x3ffffff;
    	    /* k = 11 */
    	    lo = Math.imul(al9, bl2);
    	    mid = Math.imul(al9, bh2);
    	    mid = (mid + Math.imul(ah9, bl2)) | 0;
    	    hi = Math.imul(ah9, bh2);
    	    lo = (lo + Math.imul(al8, bl3)) | 0;
    	    mid = (mid + Math.imul(al8, bh3)) | 0;
    	    mid = (mid + Math.imul(ah8, bl3)) | 0;
    	    hi = (hi + Math.imul(ah8, bh3)) | 0;
    	    lo = (lo + Math.imul(al7, bl4)) | 0;
    	    mid = (mid + Math.imul(al7, bh4)) | 0;
    	    mid = (mid + Math.imul(ah7, bl4)) | 0;
    	    hi = (hi + Math.imul(ah7, bh4)) | 0;
    	    lo = (lo + Math.imul(al6, bl5)) | 0;
    	    mid = (mid + Math.imul(al6, bh5)) | 0;
    	    mid = (mid + Math.imul(ah6, bl5)) | 0;
    	    hi = (hi + Math.imul(ah6, bh5)) | 0;
    	    lo = (lo + Math.imul(al5, bl6)) | 0;
    	    mid = (mid + Math.imul(al5, bh6)) | 0;
    	    mid = (mid + Math.imul(ah5, bl6)) | 0;
    	    hi = (hi + Math.imul(ah5, bh6)) | 0;
    	    lo = (lo + Math.imul(al4, bl7)) | 0;
    	    mid = (mid + Math.imul(al4, bh7)) | 0;
    	    mid = (mid + Math.imul(ah4, bl7)) | 0;
    	    hi = (hi + Math.imul(ah4, bh7)) | 0;
    	    lo = (lo + Math.imul(al3, bl8)) | 0;
    	    mid = (mid + Math.imul(al3, bh8)) | 0;
    	    mid = (mid + Math.imul(ah3, bl8)) | 0;
    	    hi = (hi + Math.imul(ah3, bh8)) | 0;
    	    lo = (lo + Math.imul(al2, bl9)) | 0;
    	    mid = (mid + Math.imul(al2, bh9)) | 0;
    	    mid = (mid + Math.imul(ah2, bl9)) | 0;
    	    hi = (hi + Math.imul(ah2, bh9)) | 0;
    	    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    	    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
    	    w11 &= 0x3ffffff;
    	    /* k = 12 */
    	    lo = Math.imul(al9, bl3);
    	    mid = Math.imul(al9, bh3);
    	    mid = (mid + Math.imul(ah9, bl3)) | 0;
    	    hi = Math.imul(ah9, bh3);
    	    lo = (lo + Math.imul(al8, bl4)) | 0;
    	    mid = (mid + Math.imul(al8, bh4)) | 0;
    	    mid = (mid + Math.imul(ah8, bl4)) | 0;
    	    hi = (hi + Math.imul(ah8, bh4)) | 0;
    	    lo = (lo + Math.imul(al7, bl5)) | 0;
    	    mid = (mid + Math.imul(al7, bh5)) | 0;
    	    mid = (mid + Math.imul(ah7, bl5)) | 0;
    	    hi = (hi + Math.imul(ah7, bh5)) | 0;
    	    lo = (lo + Math.imul(al6, bl6)) | 0;
    	    mid = (mid + Math.imul(al6, bh6)) | 0;
    	    mid = (mid + Math.imul(ah6, bl6)) | 0;
    	    hi = (hi + Math.imul(ah6, bh6)) | 0;
    	    lo = (lo + Math.imul(al5, bl7)) | 0;
    	    mid = (mid + Math.imul(al5, bh7)) | 0;
    	    mid = (mid + Math.imul(ah5, bl7)) | 0;
    	    hi = (hi + Math.imul(ah5, bh7)) | 0;
    	    lo = (lo + Math.imul(al4, bl8)) | 0;
    	    mid = (mid + Math.imul(al4, bh8)) | 0;
    	    mid = (mid + Math.imul(ah4, bl8)) | 0;
    	    hi = (hi + Math.imul(ah4, bh8)) | 0;
    	    lo = (lo + Math.imul(al3, bl9)) | 0;
    	    mid = (mid + Math.imul(al3, bh9)) | 0;
    	    mid = (mid + Math.imul(ah3, bl9)) | 0;
    	    hi = (hi + Math.imul(ah3, bh9)) | 0;
    	    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    	    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
    	    w12 &= 0x3ffffff;
    	    /* k = 13 */
    	    lo = Math.imul(al9, bl4);
    	    mid = Math.imul(al9, bh4);
    	    mid = (mid + Math.imul(ah9, bl4)) | 0;
    	    hi = Math.imul(ah9, bh4);
    	    lo = (lo + Math.imul(al8, bl5)) | 0;
    	    mid = (mid + Math.imul(al8, bh5)) | 0;
    	    mid = (mid + Math.imul(ah8, bl5)) | 0;
    	    hi = (hi + Math.imul(ah8, bh5)) | 0;
    	    lo = (lo + Math.imul(al7, bl6)) | 0;
    	    mid = (mid + Math.imul(al7, bh6)) | 0;
    	    mid = (mid + Math.imul(ah7, bl6)) | 0;
    	    hi = (hi + Math.imul(ah7, bh6)) | 0;
    	    lo = (lo + Math.imul(al6, bl7)) | 0;
    	    mid = (mid + Math.imul(al6, bh7)) | 0;
    	    mid = (mid + Math.imul(ah6, bl7)) | 0;
    	    hi = (hi + Math.imul(ah6, bh7)) | 0;
    	    lo = (lo + Math.imul(al5, bl8)) | 0;
    	    mid = (mid + Math.imul(al5, bh8)) | 0;
    	    mid = (mid + Math.imul(ah5, bl8)) | 0;
    	    hi = (hi + Math.imul(ah5, bh8)) | 0;
    	    lo = (lo + Math.imul(al4, bl9)) | 0;
    	    mid = (mid + Math.imul(al4, bh9)) | 0;
    	    mid = (mid + Math.imul(ah4, bl9)) | 0;
    	    hi = (hi + Math.imul(ah4, bh9)) | 0;
    	    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    	    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
    	    w13 &= 0x3ffffff;
    	    /* k = 14 */
    	    lo = Math.imul(al9, bl5);
    	    mid = Math.imul(al9, bh5);
    	    mid = (mid + Math.imul(ah9, bl5)) | 0;
    	    hi = Math.imul(ah9, bh5);
    	    lo = (lo + Math.imul(al8, bl6)) | 0;
    	    mid = (mid + Math.imul(al8, bh6)) | 0;
    	    mid = (mid + Math.imul(ah8, bl6)) | 0;
    	    hi = (hi + Math.imul(ah8, bh6)) | 0;
    	    lo = (lo + Math.imul(al7, bl7)) | 0;
    	    mid = (mid + Math.imul(al7, bh7)) | 0;
    	    mid = (mid + Math.imul(ah7, bl7)) | 0;
    	    hi = (hi + Math.imul(ah7, bh7)) | 0;
    	    lo = (lo + Math.imul(al6, bl8)) | 0;
    	    mid = (mid + Math.imul(al6, bh8)) | 0;
    	    mid = (mid + Math.imul(ah6, bl8)) | 0;
    	    hi = (hi + Math.imul(ah6, bh8)) | 0;
    	    lo = (lo + Math.imul(al5, bl9)) | 0;
    	    mid = (mid + Math.imul(al5, bh9)) | 0;
    	    mid = (mid + Math.imul(ah5, bl9)) | 0;
    	    hi = (hi + Math.imul(ah5, bh9)) | 0;
    	    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    	    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
    	    w14 &= 0x3ffffff;
    	    /* k = 15 */
    	    lo = Math.imul(al9, bl6);
    	    mid = Math.imul(al9, bh6);
    	    mid = (mid + Math.imul(ah9, bl6)) | 0;
    	    hi = Math.imul(ah9, bh6);
    	    lo = (lo + Math.imul(al8, bl7)) | 0;
    	    mid = (mid + Math.imul(al8, bh7)) | 0;
    	    mid = (mid + Math.imul(ah8, bl7)) | 0;
    	    hi = (hi + Math.imul(ah8, bh7)) | 0;
    	    lo = (lo + Math.imul(al7, bl8)) | 0;
    	    mid = (mid + Math.imul(al7, bh8)) | 0;
    	    mid = (mid + Math.imul(ah7, bl8)) | 0;
    	    hi = (hi + Math.imul(ah7, bh8)) | 0;
    	    lo = (lo + Math.imul(al6, bl9)) | 0;
    	    mid = (mid + Math.imul(al6, bh9)) | 0;
    	    mid = (mid + Math.imul(ah6, bl9)) | 0;
    	    hi = (hi + Math.imul(ah6, bh9)) | 0;
    	    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    	    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
    	    w15 &= 0x3ffffff;
    	    /* k = 16 */
    	    lo = Math.imul(al9, bl7);
    	    mid = Math.imul(al9, bh7);
    	    mid = (mid + Math.imul(ah9, bl7)) | 0;
    	    hi = Math.imul(ah9, bh7);
    	    lo = (lo + Math.imul(al8, bl8)) | 0;
    	    mid = (mid + Math.imul(al8, bh8)) | 0;
    	    mid = (mid + Math.imul(ah8, bl8)) | 0;
    	    hi = (hi + Math.imul(ah8, bh8)) | 0;
    	    lo = (lo + Math.imul(al7, bl9)) | 0;
    	    mid = (mid + Math.imul(al7, bh9)) | 0;
    	    mid = (mid + Math.imul(ah7, bl9)) | 0;
    	    hi = (hi + Math.imul(ah7, bh9)) | 0;
    	    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    	    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
    	    w16 &= 0x3ffffff;
    	    /* k = 17 */
    	    lo = Math.imul(al9, bl8);
    	    mid = Math.imul(al9, bh8);
    	    mid = (mid + Math.imul(ah9, bl8)) | 0;
    	    hi = Math.imul(ah9, bh8);
    	    lo = (lo + Math.imul(al8, bl9)) | 0;
    	    mid = (mid + Math.imul(al8, bh9)) | 0;
    	    mid = (mid + Math.imul(ah8, bl9)) | 0;
    	    hi = (hi + Math.imul(ah8, bh9)) | 0;
    	    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    	    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
    	    w17 &= 0x3ffffff;
    	    /* k = 18 */
    	    lo = Math.imul(al9, bl9);
    	    mid = Math.imul(al9, bh9);
    	    mid = (mid + Math.imul(ah9, bl9)) | 0;
    	    hi = Math.imul(ah9, bh9);
    	    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    	    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
    	    w18 &= 0x3ffffff;
    	    o[0] = w0;
    	    o[1] = w1;
    	    o[2] = w2;
    	    o[3] = w3;
    	    o[4] = w4;
    	    o[5] = w5;
    	    o[6] = w6;
    	    o[7] = w7;
    	    o[8] = w8;
    	    o[9] = w9;
    	    o[10] = w10;
    	    o[11] = w11;
    	    o[12] = w12;
    	    o[13] = w13;
    	    o[14] = w14;
    	    o[15] = w15;
    	    o[16] = w16;
    	    o[17] = w17;
    	    o[18] = w18;
    	    if (c !== 0) {
    	      o[19] = c;
    	      out.length++;
    	    }
    	    return out;
    	  };

    	  // Polyfill comb
    	  if (!Math.imul) {
    	    comb10MulTo = smallMulTo;
    	  }

    	  function bigMulTo (self, num, out) {
    	    out.negative = num.negative ^ self.negative;
    	    out.length = self.length + num.length;

    	    var carry = 0;
    	    var hncarry = 0;
    	    for (var k = 0; k < out.length - 1; k++) {
    	      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
    	      // note that ncarry could be >= 0x3ffffff
    	      var ncarry = hncarry;
    	      hncarry = 0;
    	      var rword = carry & 0x3ffffff;
    	      var maxJ = Math.min(k, num.length - 1);
    	      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
    	        var i = k - j;
    	        var a = self.words[i] | 0;
    	        var b = num.words[j] | 0;
    	        var r = a * b;

    	        var lo = r & 0x3ffffff;
    	        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
    	        lo = (lo + rword) | 0;
    	        rword = lo & 0x3ffffff;
    	        ncarry = (ncarry + (lo >>> 26)) | 0;

    	        hncarry += ncarry >>> 26;
    	        ncarry &= 0x3ffffff;
    	      }
    	      out.words[k] = rword;
    	      carry = ncarry;
    	      ncarry = hncarry;
    	    }
    	    if (carry !== 0) {
    	      out.words[k] = carry;
    	    } else {
    	      out.length--;
    	    }

    	    return out._strip();
    	  }

    	  function jumboMulTo (self, num, out) {
    	    // Temporary disable, see https://github.com/indutny/bn.js/issues/211
    	    // var fftm = new FFTM();
    	    // return fftm.mulp(self, num, out);
    	    return bigMulTo(self, num, out);
    	  }

    	  BN.prototype.mulTo = function mulTo (num, out) {
    	    var res;
    	    var len = this.length + num.length;
    	    if (this.length === 10 && num.length === 10) {
    	      res = comb10MulTo(this, num, out);
    	    } else if (len < 63) {
    	      res = smallMulTo(this, num, out);
    	    } else if (len < 1024) {
    	      res = bigMulTo(this, num, out);
    	    } else {
    	      res = jumboMulTo(this, num, out);
    	    }

    	    return res;
    	  };

    	  // Multiply `this` by `num`
    	  BN.prototype.mul = function mul (num) {
    	    var out = new BN(null);
    	    out.words = new Array(this.length + num.length);
    	    return this.mulTo(num, out);
    	  };

    	  // Multiply employing FFT
    	  BN.prototype.mulf = function mulf (num) {
    	    var out = new BN(null);
    	    out.words = new Array(this.length + num.length);
    	    return jumboMulTo(this, num, out);
    	  };

    	  // In-place Multiplication
    	  BN.prototype.imul = function imul (num) {
    	    return this.clone().mulTo(num, this);
    	  };

    	  BN.prototype.imuln = function imuln (num) {
    	    var isNegNum = num < 0;
    	    if (isNegNum) num = -num;

    	    assert(typeof num === 'number');
    	    assert(num < 0x4000000);

    	    // Carry
    	    var carry = 0;
    	    for (var i = 0; i < this.length; i++) {
    	      var w = (this.words[i] | 0) * num;
    	      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
    	      carry >>= 26;
    	      carry += (w / 0x4000000) | 0;
    	      // NOTE: lo is 27bit maximum
    	      carry += lo >>> 26;
    	      this.words[i] = lo & 0x3ffffff;
    	    }

    	    if (carry !== 0) {
    	      this.words[i] = carry;
    	      this.length++;
    	    }

    	    return isNegNum ? this.ineg() : this;
    	  };

    	  BN.prototype.muln = function muln (num) {
    	    return this.clone().imuln(num);
    	  };

    	  // `this` * `this`
    	  BN.prototype.sqr = function sqr () {
    	    return this.mul(this);
    	  };

    	  // `this` * `this` in-place
    	  BN.prototype.isqr = function isqr () {
    	    return this.imul(this.clone());
    	  };

    	  // Math.pow(`this`, `num`)
    	  BN.prototype.pow = function pow (num) {
    	    var w = toBitArray(num);
    	    if (w.length === 0) return new BN(1);

    	    // Skip leading zeroes
    	    var res = this;
    	    for (var i = 0; i < w.length; i++, res = res.sqr()) {
    	      if (w[i] !== 0) break;
    	    }

    	    if (++i < w.length) {
    	      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
    	        if (w[i] === 0) continue;

    	        res = res.mul(q);
    	      }
    	    }

    	    return res;
    	  };

    	  // Shift-left in-place
    	  BN.prototype.iushln = function iushln (bits) {
    	    assert(typeof bits === 'number' && bits >= 0);
    	    var r = bits % 26;
    	    var s = (bits - r) / 26;
    	    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
    	    var i;

    	    if (r !== 0) {
    	      var carry = 0;

    	      for (i = 0; i < this.length; i++) {
    	        var newCarry = this.words[i] & carryMask;
    	        var c = ((this.words[i] | 0) - newCarry) << r;
    	        this.words[i] = c | carry;
    	        carry = newCarry >>> (26 - r);
    	      }

    	      if (carry) {
    	        this.words[i] = carry;
    	        this.length++;
    	      }
    	    }

    	    if (s !== 0) {
    	      for (i = this.length - 1; i >= 0; i--) {
    	        this.words[i + s] = this.words[i];
    	      }

    	      for (i = 0; i < s; i++) {
    	        this.words[i] = 0;
    	      }

    	      this.length += s;
    	    }

    	    return this._strip();
    	  };

    	  BN.prototype.ishln = function ishln (bits) {
    	    // TODO(indutny): implement me
    	    assert(this.negative === 0);
    	    return this.iushln(bits);
    	  };

    	  // Shift-right in-place
    	  // NOTE: `hint` is a lowest bit before trailing zeroes
    	  // NOTE: if `extended` is present - it will be filled with destroyed bits
    	  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
    	    assert(typeof bits === 'number' && bits >= 0);
    	    var h;
    	    if (hint) {
    	      h = (hint - (hint % 26)) / 26;
    	    } else {
    	      h = 0;
    	    }

    	    var r = bits % 26;
    	    var s = Math.min((bits - r) / 26, this.length);
    	    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
    	    var maskedWords = extended;

    	    h -= s;
    	    h = Math.max(0, h);

    	    // Extended mode, copy masked part
    	    if (maskedWords) {
    	      for (var i = 0; i < s; i++) {
    	        maskedWords.words[i] = this.words[i];
    	      }
    	      maskedWords.length = s;
    	    }

    	    if (s === 0) ; else if (this.length > s) {
    	      this.length -= s;
    	      for (i = 0; i < this.length; i++) {
    	        this.words[i] = this.words[i + s];
    	      }
    	    } else {
    	      this.words[0] = 0;
    	      this.length = 1;
    	    }

    	    var carry = 0;
    	    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
    	      var word = this.words[i] | 0;
    	      this.words[i] = (carry << (26 - r)) | (word >>> r);
    	      carry = word & mask;
    	    }

    	    // Push carried bits as a mask
    	    if (maskedWords && carry !== 0) {
    	      maskedWords.words[maskedWords.length++] = carry;
    	    }

    	    if (this.length === 0) {
    	      this.words[0] = 0;
    	      this.length = 1;
    	    }

    	    return this._strip();
    	  };

    	  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
    	    // TODO(indutny): implement me
    	    assert(this.negative === 0);
    	    return this.iushrn(bits, hint, extended);
    	  };

    	  // Shift-left
    	  BN.prototype.shln = function shln (bits) {
    	    return this.clone().ishln(bits);
    	  };

    	  BN.prototype.ushln = function ushln (bits) {
    	    return this.clone().iushln(bits);
    	  };

    	  // Shift-right
    	  BN.prototype.shrn = function shrn (bits) {
    	    return this.clone().ishrn(bits);
    	  };

    	  BN.prototype.ushrn = function ushrn (bits) {
    	    return this.clone().iushrn(bits);
    	  };

    	  // Test if n bit is set
    	  BN.prototype.testn = function testn (bit) {
    	    assert(typeof bit === 'number' && bit >= 0);
    	    var r = bit % 26;
    	    var s = (bit - r) / 26;
    	    var q = 1 << r;

    	    // Fast case: bit is much higher than all existing words
    	    if (this.length <= s) return false;

    	    // Check bit and return
    	    var w = this.words[s];

    	    return !!(w & q);
    	  };

    	  // Return only lowers bits of number (in-place)
    	  BN.prototype.imaskn = function imaskn (bits) {
    	    assert(typeof bits === 'number' && bits >= 0);
    	    var r = bits % 26;
    	    var s = (bits - r) / 26;

    	    assert(this.negative === 0, 'imaskn works only with positive numbers');

    	    if (this.length <= s) {
    	      return this;
    	    }

    	    if (r !== 0) {
    	      s++;
    	    }
    	    this.length = Math.min(s, this.length);

    	    if (r !== 0) {
    	      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
    	      this.words[this.length - 1] &= mask;
    	    }

    	    return this._strip();
    	  };

    	  // Return only lowers bits of number
    	  BN.prototype.maskn = function maskn (bits) {
    	    return this.clone().imaskn(bits);
    	  };

    	  // Add plain number `num` to `this`
    	  BN.prototype.iaddn = function iaddn (num) {
    	    assert(typeof num === 'number');
    	    assert(num < 0x4000000);
    	    if (num < 0) return this.isubn(-num);

    	    // Possible sign change
    	    if (this.negative !== 0) {
    	      if (this.length === 1 && (this.words[0] | 0) <= num) {
    	        this.words[0] = num - (this.words[0] | 0);
    	        this.negative = 0;
    	        return this;
    	      }

    	      this.negative = 0;
    	      this.isubn(num);
    	      this.negative = 1;
    	      return this;
    	    }

    	    // Add without checks
    	    return this._iaddn(num);
    	  };

    	  BN.prototype._iaddn = function _iaddn (num) {
    	    this.words[0] += num;

    	    // Carry
    	    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
    	      this.words[i] -= 0x4000000;
    	      if (i === this.length - 1) {
    	        this.words[i + 1] = 1;
    	      } else {
    	        this.words[i + 1]++;
    	      }
    	    }
    	    this.length = Math.max(this.length, i + 1);

    	    return this;
    	  };

    	  // Subtract plain number `num` from `this`
    	  BN.prototype.isubn = function isubn (num) {
    	    assert(typeof num === 'number');
    	    assert(num < 0x4000000);
    	    if (num < 0) return this.iaddn(-num);

    	    if (this.negative !== 0) {
    	      this.negative = 0;
    	      this.iaddn(num);
    	      this.negative = 1;
    	      return this;
    	    }

    	    this.words[0] -= num;

    	    if (this.length === 1 && this.words[0] < 0) {
    	      this.words[0] = -this.words[0];
    	      this.negative = 1;
    	    } else {
    	      // Carry
    	      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
    	        this.words[i] += 0x4000000;
    	        this.words[i + 1] -= 1;
    	      }
    	    }

    	    return this._strip();
    	  };

    	  BN.prototype.addn = function addn (num) {
    	    return this.clone().iaddn(num);
    	  };

    	  BN.prototype.subn = function subn (num) {
    	    return this.clone().isubn(num);
    	  };

    	  BN.prototype.iabs = function iabs () {
    	    this.negative = 0;

    	    return this;
    	  };

    	  BN.prototype.abs = function abs () {
    	    return this.clone().iabs();
    	  };

    	  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
    	    var len = num.length + shift;
    	    var i;

    	    this._expand(len);

    	    var w;
    	    var carry = 0;
    	    for (i = 0; i < num.length; i++) {
    	      w = (this.words[i + shift] | 0) + carry;
    	      var right = (num.words[i] | 0) * mul;
    	      w -= right & 0x3ffffff;
    	      carry = (w >> 26) - ((right / 0x4000000) | 0);
    	      this.words[i + shift] = w & 0x3ffffff;
    	    }
    	    for (; i < this.length - shift; i++) {
    	      w = (this.words[i + shift] | 0) + carry;
    	      carry = w >> 26;
    	      this.words[i + shift] = w & 0x3ffffff;
    	    }

    	    if (carry === 0) return this._strip();

    	    // Subtraction overflow
    	    assert(carry === -1);
    	    carry = 0;
    	    for (i = 0; i < this.length; i++) {
    	      w = -(this.words[i] | 0) + carry;
    	      carry = w >> 26;
    	      this.words[i] = w & 0x3ffffff;
    	    }
    	    this.negative = 1;

    	    return this._strip();
    	  };

    	  BN.prototype._wordDiv = function _wordDiv (num, mode) {
    	    var shift = this.length - num.length;

    	    var a = this.clone();
    	    var b = num;

    	    // Normalize
    	    var bhi = b.words[b.length - 1] | 0;
    	    var bhiBits = this._countBits(bhi);
    	    shift = 26 - bhiBits;
    	    if (shift !== 0) {
    	      b = b.ushln(shift);
    	      a.iushln(shift);
    	      bhi = b.words[b.length - 1] | 0;
    	    }

    	    // Initialize quotient
    	    var m = a.length - b.length;
    	    var q;

    	    if (mode !== 'mod') {
    	      q = new BN(null);
    	      q.length = m + 1;
    	      q.words = new Array(q.length);
    	      for (var i = 0; i < q.length; i++) {
    	        q.words[i] = 0;
    	      }
    	    }

    	    var diff = a.clone()._ishlnsubmul(b, 1, m);
    	    if (diff.negative === 0) {
    	      a = diff;
    	      if (q) {
    	        q.words[m] = 1;
    	      }
    	    }

    	    for (var j = m - 1; j >= 0; j--) {
    	      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
    	        (a.words[b.length + j - 1] | 0);

    	      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
    	      // (0x7ffffff)
    	      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

    	      a._ishlnsubmul(b, qj, j);
    	      while (a.negative !== 0) {
    	        qj--;
    	        a.negative = 0;
    	        a._ishlnsubmul(b, 1, j);
    	        if (!a.isZero()) {
    	          a.negative ^= 1;
    	        }
    	      }
    	      if (q) {
    	        q.words[j] = qj;
    	      }
    	    }
    	    if (q) {
    	      q._strip();
    	    }
    	    a._strip();

    	    // Denormalize
    	    if (mode !== 'div' && shift !== 0) {
    	      a.iushrn(shift);
    	    }

    	    return {
    	      div: q || null,
    	      mod: a
    	    };
    	  };

    	  // NOTE: 1) `mode` can be set to `mod` to request mod only,
    	  //       to `div` to request div only, or be absent to
    	  //       request both div & mod
    	  //       2) `positive` is true if unsigned mod is requested
    	  BN.prototype.divmod = function divmod (num, mode, positive) {
    	    assert(!num.isZero());

    	    if (this.isZero()) {
    	      return {
    	        div: new BN(0),
    	        mod: new BN(0)
    	      };
    	    }

    	    var div, mod, res;
    	    if (this.negative !== 0 && num.negative === 0) {
    	      res = this.neg().divmod(num, mode);

    	      if (mode !== 'mod') {
    	        div = res.div.neg();
    	      }

    	      if (mode !== 'div') {
    	        mod = res.mod.neg();
    	        if (positive && mod.negative !== 0) {
    	          mod.iadd(num);
    	        }
    	      }

    	      return {
    	        div: div,
    	        mod: mod
    	      };
    	    }

    	    if (this.negative === 0 && num.negative !== 0) {
    	      res = this.divmod(num.neg(), mode);

    	      if (mode !== 'mod') {
    	        div = res.div.neg();
    	      }

    	      return {
    	        div: div,
    	        mod: res.mod
    	      };
    	    }

    	    if ((this.negative & num.negative) !== 0) {
    	      res = this.neg().divmod(num.neg(), mode);

    	      if (mode !== 'div') {
    	        mod = res.mod.neg();
    	        if (positive && mod.negative !== 0) {
    	          mod.isub(num);
    	        }
    	      }

    	      return {
    	        div: res.div,
    	        mod: mod
    	      };
    	    }

    	    // Both numbers are positive at this point

    	    // Strip both numbers to approximate shift value
    	    if (num.length > this.length || this.cmp(num) < 0) {
    	      return {
    	        div: new BN(0),
    	        mod: this
    	      };
    	    }

    	    // Very short reduction
    	    if (num.length === 1) {
    	      if (mode === 'div') {
    	        return {
    	          div: this.divn(num.words[0]),
    	          mod: null
    	        };
    	      }

    	      if (mode === 'mod') {
    	        return {
    	          div: null,
    	          mod: new BN(this.modrn(num.words[0]))
    	        };
    	      }

    	      return {
    	        div: this.divn(num.words[0]),
    	        mod: new BN(this.modrn(num.words[0]))
    	      };
    	    }

    	    return this._wordDiv(num, mode);
    	  };

    	  // Find `this` / `num`
    	  BN.prototype.div = function div (num) {
    	    return this.divmod(num, 'div', false).div;
    	  };

    	  // Find `this` % `num`
    	  BN.prototype.mod = function mod (num) {
    	    return this.divmod(num, 'mod', false).mod;
    	  };

    	  BN.prototype.umod = function umod (num) {
    	    return this.divmod(num, 'mod', true).mod;
    	  };

    	  // Find Round(`this` / `num`)
    	  BN.prototype.divRound = function divRound (num) {
    	    var dm = this.divmod(num);

    	    // Fast case - exact division
    	    if (dm.mod.isZero()) return dm.div;

    	    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

    	    var half = num.ushrn(1);
    	    var r2 = num.andln(1);
    	    var cmp = mod.cmp(half);

    	    // Round down
    	    if (cmp < 0 || (r2 === 1 && cmp === 0)) return dm.div;

    	    // Round up
    	    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
    	  };

    	  BN.prototype.modrn = function modrn (num) {
    	    var isNegNum = num < 0;
    	    if (isNegNum) num = -num;

    	    assert(num <= 0x3ffffff);
    	    var p = (1 << 26) % num;

    	    var acc = 0;
    	    for (var i = this.length - 1; i >= 0; i--) {
    	      acc = (p * acc + (this.words[i] | 0)) % num;
    	    }

    	    return isNegNum ? -acc : acc;
    	  };

    	  // WARNING: DEPRECATED
    	  BN.prototype.modn = function modn (num) {
    	    return this.modrn(num);
    	  };

    	  // In-place division by number
    	  BN.prototype.idivn = function idivn (num) {
    	    var isNegNum = num < 0;
    	    if (isNegNum) num = -num;

    	    assert(num <= 0x3ffffff);

    	    var carry = 0;
    	    for (var i = this.length - 1; i >= 0; i--) {
    	      var w = (this.words[i] | 0) + carry * 0x4000000;
    	      this.words[i] = (w / num) | 0;
    	      carry = w % num;
    	    }

    	    this._strip();
    	    return isNegNum ? this.ineg() : this;
    	  };

    	  BN.prototype.divn = function divn (num) {
    	    return this.clone().idivn(num);
    	  };

    	  BN.prototype.egcd = function egcd (p) {
    	    assert(p.negative === 0);
    	    assert(!p.isZero());

    	    var x = this;
    	    var y = p.clone();

    	    if (x.negative !== 0) {
    	      x = x.umod(p);
    	    } else {
    	      x = x.clone();
    	    }

    	    // A * x + B * y = x
    	    var A = new BN(1);
    	    var B = new BN(0);

    	    // C * x + D * y = y
    	    var C = new BN(0);
    	    var D = new BN(1);

    	    var g = 0;

    	    while (x.isEven() && y.isEven()) {
    	      x.iushrn(1);
    	      y.iushrn(1);
    	      ++g;
    	    }

    	    var yp = y.clone();
    	    var xp = x.clone();

    	    while (!x.isZero()) {
    	      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
    	      if (i > 0) {
    	        x.iushrn(i);
    	        while (i-- > 0) {
    	          if (A.isOdd() || B.isOdd()) {
    	            A.iadd(yp);
    	            B.isub(xp);
    	          }

    	          A.iushrn(1);
    	          B.iushrn(1);
    	        }
    	      }

    	      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
    	      if (j > 0) {
    	        y.iushrn(j);
    	        while (j-- > 0) {
    	          if (C.isOdd() || D.isOdd()) {
    	            C.iadd(yp);
    	            D.isub(xp);
    	          }

    	          C.iushrn(1);
    	          D.iushrn(1);
    	        }
    	      }

    	      if (x.cmp(y) >= 0) {
    	        x.isub(y);
    	        A.isub(C);
    	        B.isub(D);
    	      } else {
    	        y.isub(x);
    	        C.isub(A);
    	        D.isub(B);
    	      }
    	    }

    	    return {
    	      a: C,
    	      b: D,
    	      gcd: y.iushln(g)
    	    };
    	  };

    	  // This is reduced incarnation of the binary EEA
    	  // above, designated to invert members of the
    	  // _prime_ fields F(p) at a maximal speed
    	  BN.prototype._invmp = function _invmp (p) {
    	    assert(p.negative === 0);
    	    assert(!p.isZero());

    	    var a = this;
    	    var b = p.clone();

    	    if (a.negative !== 0) {
    	      a = a.umod(p);
    	    } else {
    	      a = a.clone();
    	    }

    	    var x1 = new BN(1);
    	    var x2 = new BN(0);

    	    var delta = b.clone();

    	    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
    	      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
    	      if (i > 0) {
    	        a.iushrn(i);
    	        while (i-- > 0) {
    	          if (x1.isOdd()) {
    	            x1.iadd(delta);
    	          }

    	          x1.iushrn(1);
    	        }
    	      }

    	      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
    	      if (j > 0) {
    	        b.iushrn(j);
    	        while (j-- > 0) {
    	          if (x2.isOdd()) {
    	            x2.iadd(delta);
    	          }

    	          x2.iushrn(1);
    	        }
    	      }

    	      if (a.cmp(b) >= 0) {
    	        a.isub(b);
    	        x1.isub(x2);
    	      } else {
    	        b.isub(a);
    	        x2.isub(x1);
    	      }
    	    }

    	    var res;
    	    if (a.cmpn(1) === 0) {
    	      res = x1;
    	    } else {
    	      res = x2;
    	    }

    	    if (res.cmpn(0) < 0) {
    	      res.iadd(p);
    	    }

    	    return res;
    	  };

    	  BN.prototype.gcd = function gcd (num) {
    	    if (this.isZero()) return num.abs();
    	    if (num.isZero()) return this.abs();

    	    var a = this.clone();
    	    var b = num.clone();
    	    a.negative = 0;
    	    b.negative = 0;

    	    // Remove common factor of two
    	    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
    	      a.iushrn(1);
    	      b.iushrn(1);
    	    }

    	    do {
    	      while (a.isEven()) {
    	        a.iushrn(1);
    	      }
    	      while (b.isEven()) {
    	        b.iushrn(1);
    	      }

    	      var r = a.cmp(b);
    	      if (r < 0) {
    	        // Swap `a` and `b` to make `a` always bigger than `b`
    	        var t = a;
    	        a = b;
    	        b = t;
    	      } else if (r === 0 || b.cmpn(1) === 0) {
    	        break;
    	      }

    	      a.isub(b);
    	    } while (true);

    	    return b.iushln(shift);
    	  };

    	  // Invert number in the field F(num)
    	  BN.prototype.invm = function invm (num) {
    	    return this.egcd(num).a.umod(num);
    	  };

    	  BN.prototype.isEven = function isEven () {
    	    return (this.words[0] & 1) === 0;
    	  };

    	  BN.prototype.isOdd = function isOdd () {
    	    return (this.words[0] & 1) === 1;
    	  };

    	  // And first word and num
    	  BN.prototype.andln = function andln (num) {
    	    return this.words[0] & num;
    	  };

    	  // Increment at the bit position in-line
    	  BN.prototype.bincn = function bincn (bit) {
    	    assert(typeof bit === 'number');
    	    var r = bit % 26;
    	    var s = (bit - r) / 26;
    	    var q = 1 << r;

    	    // Fast case: bit is much higher than all existing words
    	    if (this.length <= s) {
    	      this._expand(s + 1);
    	      this.words[s] |= q;
    	      return this;
    	    }

    	    // Add bit and propagate, if needed
    	    var carry = q;
    	    for (var i = s; carry !== 0 && i < this.length; i++) {
    	      var w = this.words[i] | 0;
    	      w += carry;
    	      carry = w >>> 26;
    	      w &= 0x3ffffff;
    	      this.words[i] = w;
    	    }
    	    if (carry !== 0) {
    	      this.words[i] = carry;
    	      this.length++;
    	    }
    	    return this;
    	  };

    	  BN.prototype.isZero = function isZero () {
    	    return this.length === 1 && this.words[0] === 0;
    	  };

    	  BN.prototype.cmpn = function cmpn (num) {
    	    var negative = num < 0;

    	    if (this.negative !== 0 && !negative) return -1;
    	    if (this.negative === 0 && negative) return 1;

    	    this._strip();

    	    var res;
    	    if (this.length > 1) {
    	      res = 1;
    	    } else {
    	      if (negative) {
    	        num = -num;
    	      }

    	      assert(num <= 0x3ffffff, 'Number is too big');

    	      var w = this.words[0] | 0;
    	      res = w === num ? 0 : w < num ? -1 : 1;
    	    }
    	    if (this.negative !== 0) return -res | 0;
    	    return res;
    	  };

    	  // Compare two numbers and return:
    	  // 1 - if `this` > `num`
    	  // 0 - if `this` == `num`
    	  // -1 - if `this` < `num`
    	  BN.prototype.cmp = function cmp (num) {
    	    if (this.negative !== 0 && num.negative === 0) return -1;
    	    if (this.negative === 0 && num.negative !== 0) return 1;

    	    var res = this.ucmp(num);
    	    if (this.negative !== 0) return -res | 0;
    	    return res;
    	  };

    	  // Unsigned comparison
    	  BN.prototype.ucmp = function ucmp (num) {
    	    // At this point both numbers have the same sign
    	    if (this.length > num.length) return 1;
    	    if (this.length < num.length) return -1;

    	    var res = 0;
    	    for (var i = this.length - 1; i >= 0; i--) {
    	      var a = this.words[i] | 0;
    	      var b = num.words[i] | 0;

    	      if (a === b) continue;
    	      if (a < b) {
    	        res = -1;
    	      } else if (a > b) {
    	        res = 1;
    	      }
    	      break;
    	    }
    	    return res;
    	  };

    	  BN.prototype.gtn = function gtn (num) {
    	    return this.cmpn(num) === 1;
    	  };

    	  BN.prototype.gt = function gt (num) {
    	    return this.cmp(num) === 1;
    	  };

    	  BN.prototype.gten = function gten (num) {
    	    return this.cmpn(num) >= 0;
    	  };

    	  BN.prototype.gte = function gte (num) {
    	    return this.cmp(num) >= 0;
    	  };

    	  BN.prototype.ltn = function ltn (num) {
    	    return this.cmpn(num) === -1;
    	  };

    	  BN.prototype.lt = function lt (num) {
    	    return this.cmp(num) === -1;
    	  };

    	  BN.prototype.lten = function lten (num) {
    	    return this.cmpn(num) <= 0;
    	  };

    	  BN.prototype.lte = function lte (num) {
    	    return this.cmp(num) <= 0;
    	  };

    	  BN.prototype.eqn = function eqn (num) {
    	    return this.cmpn(num) === 0;
    	  };

    	  BN.prototype.eq = function eq (num) {
    	    return this.cmp(num) === 0;
    	  };

    	  //
    	  // A reduce context, could be using montgomery or something better, depending
    	  // on the `m` itself.
    	  //
    	  BN.red = function red (num) {
    	    return new Red(num);
    	  };

    	  BN.prototype.toRed = function toRed (ctx) {
    	    assert(!this.red, 'Already a number in reduction context');
    	    assert(this.negative === 0, 'red works only with positives');
    	    return ctx.convertTo(this)._forceRed(ctx);
    	  };

    	  BN.prototype.fromRed = function fromRed () {
    	    assert(this.red, 'fromRed works only with numbers in reduction context');
    	    return this.red.convertFrom(this);
    	  };

    	  BN.prototype._forceRed = function _forceRed (ctx) {
    	    this.red = ctx;
    	    return this;
    	  };

    	  BN.prototype.forceRed = function forceRed (ctx) {
    	    assert(!this.red, 'Already a number in reduction context');
    	    return this._forceRed(ctx);
    	  };

    	  BN.prototype.redAdd = function redAdd (num) {
    	    assert(this.red, 'redAdd works only with red numbers');
    	    return this.red.add(this, num);
    	  };

    	  BN.prototype.redIAdd = function redIAdd (num) {
    	    assert(this.red, 'redIAdd works only with red numbers');
    	    return this.red.iadd(this, num);
    	  };

    	  BN.prototype.redSub = function redSub (num) {
    	    assert(this.red, 'redSub works only with red numbers');
    	    return this.red.sub(this, num);
    	  };

    	  BN.prototype.redISub = function redISub (num) {
    	    assert(this.red, 'redISub works only with red numbers');
    	    return this.red.isub(this, num);
    	  };

    	  BN.prototype.redShl = function redShl (num) {
    	    assert(this.red, 'redShl works only with red numbers');
    	    return this.red.shl(this, num);
    	  };

    	  BN.prototype.redMul = function redMul (num) {
    	    assert(this.red, 'redMul works only with red numbers');
    	    this.red._verify2(this, num);
    	    return this.red.mul(this, num);
    	  };

    	  BN.prototype.redIMul = function redIMul (num) {
    	    assert(this.red, 'redMul works only with red numbers');
    	    this.red._verify2(this, num);
    	    return this.red.imul(this, num);
    	  };

    	  BN.prototype.redSqr = function redSqr () {
    	    assert(this.red, 'redSqr works only with red numbers');
    	    this.red._verify1(this);
    	    return this.red.sqr(this);
    	  };

    	  BN.prototype.redISqr = function redISqr () {
    	    assert(this.red, 'redISqr works only with red numbers');
    	    this.red._verify1(this);
    	    return this.red.isqr(this);
    	  };

    	  // Square root over p
    	  BN.prototype.redSqrt = function redSqrt () {
    	    assert(this.red, 'redSqrt works only with red numbers');
    	    this.red._verify1(this);
    	    return this.red.sqrt(this);
    	  };

    	  BN.prototype.redInvm = function redInvm () {
    	    assert(this.red, 'redInvm works only with red numbers');
    	    this.red._verify1(this);
    	    return this.red.invm(this);
    	  };

    	  // Return negative clone of `this` % `red modulo`
    	  BN.prototype.redNeg = function redNeg () {
    	    assert(this.red, 'redNeg works only with red numbers');
    	    this.red._verify1(this);
    	    return this.red.neg(this);
    	  };

    	  BN.prototype.redPow = function redPow (num) {
    	    assert(this.red && !num.red, 'redPow(normalNum)');
    	    this.red._verify1(this);
    	    return this.red.pow(this, num);
    	  };

    	  // Prime numbers with efficient reduction
    	  var primes = {
    	    k256: null,
    	    p224: null,
    	    p192: null,
    	    p25519: null
    	  };

    	  // Pseudo-Mersenne prime
    	  function MPrime (name, p) {
    	    // P = 2 ^ N - K
    	    this.name = name;
    	    this.p = new BN(p, 16);
    	    this.n = this.p.bitLength();
    	    this.k = new BN(1).iushln(this.n).isub(this.p);

    	    this.tmp = this._tmp();
    	  }

    	  MPrime.prototype._tmp = function _tmp () {
    	    var tmp = new BN(null);
    	    tmp.words = new Array(Math.ceil(this.n / 13));
    	    return tmp;
    	  };

    	  MPrime.prototype.ireduce = function ireduce (num) {
    	    // Assumes that `num` is less than `P^2`
    	    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
    	    var r = num;
    	    var rlen;

    	    do {
    	      this.split(r, this.tmp);
    	      r = this.imulK(r);
    	      r = r.iadd(this.tmp);
    	      rlen = r.bitLength();
    	    } while (rlen > this.n);

    	    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
    	    if (cmp === 0) {
    	      r.words[0] = 0;
    	      r.length = 1;
    	    } else if (cmp > 0) {
    	      r.isub(this.p);
    	    } else {
    	      if (r.strip !== undefined) {
    	        // r is a BN v4 instance
    	        r.strip();
    	      } else {
    	        // r is a BN v5 instance
    	        r._strip();
    	      }
    	    }

    	    return r;
    	  };

    	  MPrime.prototype.split = function split (input, out) {
    	    input.iushrn(this.n, 0, out);
    	  };

    	  MPrime.prototype.imulK = function imulK (num) {
    	    return num.imul(this.k);
    	  };

    	  function K256 () {
    	    MPrime.call(
    	      this,
    	      'k256',
    	      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
    	  }
    	  inherits(K256, MPrime);

    	  K256.prototype.split = function split (input, output) {
    	    // 256 = 9 * 26 + 22
    	    var mask = 0x3fffff;

    	    var outLen = Math.min(input.length, 9);
    	    for (var i = 0; i < outLen; i++) {
    	      output.words[i] = input.words[i];
    	    }
    	    output.length = outLen;

    	    if (input.length <= 9) {
    	      input.words[0] = 0;
    	      input.length = 1;
    	      return;
    	    }

    	    // Shift by 9 limbs
    	    var prev = input.words[9];
    	    output.words[output.length++] = prev & mask;

    	    for (i = 10; i < input.length; i++) {
    	      var next = input.words[i] | 0;
    	      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
    	      prev = next;
    	    }
    	    prev >>>= 22;
    	    input.words[i - 10] = prev;
    	    if (prev === 0 && input.length > 10) {
    	      input.length -= 10;
    	    } else {
    	      input.length -= 9;
    	    }
    	  };

    	  K256.prototype.imulK = function imulK (num) {
    	    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
    	    num.words[num.length] = 0;
    	    num.words[num.length + 1] = 0;
    	    num.length += 2;

    	    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
    	    var lo = 0;
    	    for (var i = 0; i < num.length; i++) {
    	      var w = num.words[i] | 0;
    	      lo += w * 0x3d1;
    	      num.words[i] = lo & 0x3ffffff;
    	      lo = w * 0x40 + ((lo / 0x4000000) | 0);
    	    }

    	    // Fast length reduction
    	    if (num.words[num.length - 1] === 0) {
    	      num.length--;
    	      if (num.words[num.length - 1] === 0) {
    	        num.length--;
    	      }
    	    }
    	    return num;
    	  };

    	  function P224 () {
    	    MPrime.call(
    	      this,
    	      'p224',
    	      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
    	  }
    	  inherits(P224, MPrime);

    	  function P192 () {
    	    MPrime.call(
    	      this,
    	      'p192',
    	      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
    	  }
    	  inherits(P192, MPrime);

    	  function P25519 () {
    	    // 2 ^ 255 - 19
    	    MPrime.call(
    	      this,
    	      '25519',
    	      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
    	  }
    	  inherits(P25519, MPrime);

    	  P25519.prototype.imulK = function imulK (num) {
    	    // K = 0x13
    	    var carry = 0;
    	    for (var i = 0; i < num.length; i++) {
    	      var hi = (num.words[i] | 0) * 0x13 + carry;
    	      var lo = hi & 0x3ffffff;
    	      hi >>>= 26;

    	      num.words[i] = lo;
    	      carry = hi;
    	    }
    	    if (carry !== 0) {
    	      num.words[num.length++] = carry;
    	    }
    	    return num;
    	  };

    	  // Exported mostly for testing purposes, use plain name instead
    	  BN._prime = function prime (name) {
    	    // Cached version of prime
    	    if (primes[name]) return primes[name];

    	    var prime;
    	    if (name === 'k256') {
    	      prime = new K256();
    	    } else if (name === 'p224') {
    	      prime = new P224();
    	    } else if (name === 'p192') {
    	      prime = new P192();
    	    } else if (name === 'p25519') {
    	      prime = new P25519();
    	    } else {
    	      throw new Error('Unknown prime ' + name);
    	    }
    	    primes[name] = prime;

    	    return prime;
    	  };

    	  //
    	  // Base reduction engine
    	  //
    	  function Red (m) {
    	    if (typeof m === 'string') {
    	      var prime = BN._prime(m);
    	      this.m = prime.p;
    	      this.prime = prime;
    	    } else {
    	      assert(m.gtn(1), 'modulus must be greater than 1');
    	      this.m = m;
    	      this.prime = null;
    	    }
    	  }

    	  Red.prototype._verify1 = function _verify1 (a) {
    	    assert(a.negative === 0, 'red works only with positives');
    	    assert(a.red, 'red works only with red numbers');
    	  };

    	  Red.prototype._verify2 = function _verify2 (a, b) {
    	    assert((a.negative | b.negative) === 0, 'red works only with positives');
    	    assert(a.red && a.red === b.red,
    	      'red works only with red numbers');
    	  };

    	  Red.prototype.imod = function imod (a) {
    	    if (this.prime) return this.prime.ireduce(a)._forceRed(this);

    	    move(a, a.umod(this.m)._forceRed(this));
    	    return a;
    	  };

    	  Red.prototype.neg = function neg (a) {
    	    if (a.isZero()) {
    	      return a.clone();
    	    }

    	    return this.m.sub(a)._forceRed(this);
    	  };

    	  Red.prototype.add = function add (a, b) {
    	    this._verify2(a, b);

    	    var res = a.add(b);
    	    if (res.cmp(this.m) >= 0) {
    	      res.isub(this.m);
    	    }
    	    return res._forceRed(this);
    	  };

    	  Red.prototype.iadd = function iadd (a, b) {
    	    this._verify2(a, b);

    	    var res = a.iadd(b);
    	    if (res.cmp(this.m) >= 0) {
    	      res.isub(this.m);
    	    }
    	    return res;
    	  };

    	  Red.prototype.sub = function sub (a, b) {
    	    this._verify2(a, b);

    	    var res = a.sub(b);
    	    if (res.cmpn(0) < 0) {
    	      res.iadd(this.m);
    	    }
    	    return res._forceRed(this);
    	  };

    	  Red.prototype.isub = function isub (a, b) {
    	    this._verify2(a, b);

    	    var res = a.isub(b);
    	    if (res.cmpn(0) < 0) {
    	      res.iadd(this.m);
    	    }
    	    return res;
    	  };

    	  Red.prototype.shl = function shl (a, num) {
    	    this._verify1(a);
    	    return this.imod(a.ushln(num));
    	  };

    	  Red.prototype.imul = function imul (a, b) {
    	    this._verify2(a, b);
    	    return this.imod(a.imul(b));
    	  };

    	  Red.prototype.mul = function mul (a, b) {
    	    this._verify2(a, b);
    	    return this.imod(a.mul(b));
    	  };

    	  Red.prototype.isqr = function isqr (a) {
    	    return this.imul(a, a.clone());
    	  };

    	  Red.prototype.sqr = function sqr (a) {
    	    return this.mul(a, a);
    	  };

    	  Red.prototype.sqrt = function sqrt (a) {
    	    if (a.isZero()) return a.clone();

    	    var mod3 = this.m.andln(3);
    	    assert(mod3 % 2 === 1);

    	    // Fast case
    	    if (mod3 === 3) {
    	      var pow = this.m.add(new BN(1)).iushrn(2);
    	      return this.pow(a, pow);
    	    }

    	    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
    	    //
    	    // Find Q and S, that Q * 2 ^ S = (P - 1)
    	    var q = this.m.subn(1);
    	    var s = 0;
    	    while (!q.isZero() && q.andln(1) === 0) {
    	      s++;
    	      q.iushrn(1);
    	    }
    	    assert(!q.isZero());

    	    var one = new BN(1).toRed(this);
    	    var nOne = one.redNeg();

    	    // Find quadratic non-residue
    	    // NOTE: Max is such because of generalized Riemann hypothesis.
    	    var lpow = this.m.subn(1).iushrn(1);
    	    var z = this.m.bitLength();
    	    z = new BN(2 * z * z).toRed(this);

    	    while (this.pow(z, lpow).cmp(nOne) !== 0) {
    	      z.redIAdd(nOne);
    	    }

    	    var c = this.pow(z, q);
    	    var r = this.pow(a, q.addn(1).iushrn(1));
    	    var t = this.pow(a, q);
    	    var m = s;
    	    while (t.cmp(one) !== 0) {
    	      var tmp = t;
    	      for (var i = 0; tmp.cmp(one) !== 0; i++) {
    	        tmp = tmp.redSqr();
    	      }
    	      assert(i < m);
    	      var b = this.pow(c, new BN(1).iushln(m - i - 1));

    	      r = r.redMul(b);
    	      c = b.redSqr();
    	      t = t.redMul(c);
    	      m = i;
    	    }

    	    return r;
    	  };

    	  Red.prototype.invm = function invm (a) {
    	    var inv = a._invmp(this.m);
    	    if (inv.negative !== 0) {
    	      inv.negative = 0;
    	      return this.imod(inv).redNeg();
    	    } else {
    	      return this.imod(inv);
    	    }
    	  };

    	  Red.prototype.pow = function pow (a, num) {
    	    if (num.isZero()) return new BN(1).toRed(this);
    	    if (num.cmpn(1) === 0) return a.clone();

    	    var windowSize = 4;
    	    var wnd = new Array(1 << windowSize);
    	    wnd[0] = new BN(1).toRed(this);
    	    wnd[1] = a;
    	    for (var i = 2; i < wnd.length; i++) {
    	      wnd[i] = this.mul(wnd[i - 1], a);
    	    }

    	    var res = wnd[0];
    	    var current = 0;
    	    var currentLen = 0;
    	    var start = num.bitLength() % 26;
    	    if (start === 0) {
    	      start = 26;
    	    }

    	    for (i = num.length - 1; i >= 0; i--) {
    	      var word = num.words[i];
    	      for (var j = start - 1; j >= 0; j--) {
    	        var bit = (word >> j) & 1;
    	        if (res !== wnd[0]) {
    	          res = this.sqr(res);
    	        }

    	        if (bit === 0 && current === 0) {
    	          currentLen = 0;
    	          continue;
    	        }

    	        current <<= 1;
    	        current |= bit;
    	        currentLen++;
    	        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

    	        res = this.mul(res, wnd[current]);
    	        currentLen = 0;
    	        current = 0;
    	      }
    	      start = 26;
    	    }

    	    return res;
    	  };

    	  Red.prototype.convertTo = function convertTo (num) {
    	    var r = num.umod(this.m);

    	    return r === num ? r.clone() : r;
    	  };

    	  Red.prototype.convertFrom = function convertFrom (num) {
    	    var res = num.clone();
    	    res.red = null;
    	    return res;
    	  };

    	  //
    	  // Montgomery method engine
    	  //

    	  BN.mont = function mont (num) {
    	    return new Mont(num);
    	  };

    	  function Mont (m) {
    	    Red.call(this, m);

    	    this.shift = this.m.bitLength();
    	    if (this.shift % 26 !== 0) {
    	      this.shift += 26 - (this.shift % 26);
    	    }

    	    this.r = new BN(1).iushln(this.shift);
    	    this.r2 = this.imod(this.r.sqr());
    	    this.rinv = this.r._invmp(this.m);

    	    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
    	    this.minv = this.minv.umod(this.r);
    	    this.minv = this.r.sub(this.minv);
    	  }
    	  inherits(Mont, Red);

    	  Mont.prototype.convertTo = function convertTo (num) {
    	    return this.imod(num.ushln(this.shift));
    	  };

    	  Mont.prototype.convertFrom = function convertFrom (num) {
    	    var r = this.imod(num.mul(this.rinv));
    	    r.red = null;
    	    return r;
    	  };

    	  Mont.prototype.imul = function imul (a, b) {
    	    if (a.isZero() || b.isZero()) {
    	      a.words[0] = 0;
    	      a.length = 1;
    	      return a;
    	    }

    	    var t = a.imul(b);
    	    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    	    var u = t.isub(c).iushrn(this.shift);
    	    var res = u;

    	    if (u.cmp(this.m) >= 0) {
    	      res = u.isub(this.m);
    	    } else if (u.cmpn(0) < 0) {
    	      res = u.iadd(this.m);
    	    }

    	    return res._forceRed(this);
    	  };

    	  Mont.prototype.mul = function mul (a, b) {
    	    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

    	    var t = a.mul(b);
    	    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    	    var u = t.isub(c).iushrn(this.shift);
    	    var res = u;
    	    if (u.cmp(this.m) >= 0) {
    	      res = u.isub(this.m);
    	    } else if (u.cmpn(0) < 0) {
    	      res = u.iadd(this.m);
    	    }

    	    return res._forceRed(this);
    	  };

    	  Mont.prototype.invm = function invm (a) {
    	    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
    	    var res = this.imod(a._invmp(this.m).mul(this.r2));
    	    return res._forceRed(this);
    	  };
    	})(module, commonjsGlobal); 
    } (bn));

    var bnExports = bn.exports;

    var error = {};

    var constants$2 = {};

    Object.defineProperty(constants$2, "__esModule", { value: true });
    constants$2.errorValues = constants$2.standardErrorCodes = void 0;
    constants$2.standardErrorCodes = {
        rpc: {
            invalidInput: -32000,
            resourceNotFound: -32001,
            resourceUnavailable: -32002,
            transactionRejected: -32003,
            methodNotSupported: -32004,
            limitExceeded: -32005,
            parse: -32700,
            invalidRequest: -32600,
            methodNotFound: -32601,
            invalidParams: -32602,
            internal: -32603,
        },
        provider: {
            userRejectedRequest: 4001,
            unauthorized: 4100,
            unsupportedMethod: 4200,
            disconnected: 4900,
            chainDisconnected: 4901,
            unsupportedChain: 4902,
        },
    };
    constants$2.errorValues = {
        '-32700': {
            standard: 'JSON RPC 2.0',
            message: 'Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text.',
        },
        '-32600': {
            standard: 'JSON RPC 2.0',
            message: 'The JSON sent is not a valid Request object.',
        },
        '-32601': {
            standard: 'JSON RPC 2.0',
            message: 'The method does not exist / is not available.',
        },
        '-32602': {
            standard: 'JSON RPC 2.0',
            message: 'Invalid method parameter(s).',
        },
        '-32603': {
            standard: 'JSON RPC 2.0',
            message: 'Internal JSON-RPC error.',
        },
        '-32000': {
            standard: 'EIP-1474',
            message: 'Invalid input.',
        },
        '-32001': {
            standard: 'EIP-1474',
            message: 'Resource not found.',
        },
        '-32002': {
            standard: 'EIP-1474',
            message: 'Resource unavailable.',
        },
        '-32003': {
            standard: 'EIP-1474',
            message: 'Transaction rejected.',
        },
        '-32004': {
            standard: 'EIP-1474',
            message: 'Method not supported.',
        },
        '-32005': {
            standard: 'EIP-1474',
            message: 'Request limit exceeded.',
        },
        '4001': {
            standard: 'EIP-1193',
            message: 'User rejected the request.',
        },
        '4100': {
            standard: 'EIP-1193',
            message: 'The requested account and/or method has not been authorized by the user.',
        },
        '4200': {
            standard: 'EIP-1193',
            message: 'The requested method is not supported by this Ethereum provider.',
        },
        '4900': {
            standard: 'EIP-1193',
            message: 'The provider is disconnected from all chains.',
        },
        '4901': {
            standard: 'EIP-1193',
            message: 'The provider is disconnected from the specified chain.',
        },
        '4902': {
            standard: 'EIP-3085',
            message: 'Unrecognized chain ID.',
        },
    };

    var errors$1 = {};

    var utils$1 = {};

    (function (exports) {
    	Object.defineProperty(exports, "__esModule", { value: true });
    	exports.serialize = exports.getErrorCode = exports.isValidCode = exports.getMessageFromCode = exports.JSON_RPC_SERVER_ERROR_MESSAGE = void 0;
    	const constants_1 = constants$2;
    	const FALLBACK_MESSAGE = 'Unspecified error message.';
    	exports.JSON_RPC_SERVER_ERROR_MESSAGE = 'Unspecified server error.';
    	/**
    	 * Gets the message for a given code, or a fallback message if the code has
    	 * no corresponding message.
    	 */
    	function getMessageFromCode(code, fallbackMessage = FALLBACK_MESSAGE) {
    	    if (code && Number.isInteger(code)) {
    	        const codeString = code.toString();
    	        if (hasKey(constants_1.errorValues, codeString)) {
    	            return constants_1.errorValues[codeString].message;
    	        }
    	        if (isJsonRpcServerError(code)) {
    	            return exports.JSON_RPC_SERVER_ERROR_MESSAGE;
    	        }
    	    }
    	    return fallbackMessage;
    	}
    	exports.getMessageFromCode = getMessageFromCode;
    	/**
    	 * Returns whether the given code is valid.
    	 * A code is only valid if it has a message.
    	 */
    	function isValidCode(code) {
    	    if (!Number.isInteger(code)) {
    	        return false;
    	    }
    	    const codeString = code.toString();
    	    if (constants_1.errorValues[codeString]) {
    	        return true;
    	    }
    	    if (isJsonRpcServerError(code)) {
    	        return true;
    	    }
    	    return false;
    	}
    	exports.isValidCode = isValidCode;
    	/**
    	 * Returns the error code from an error object.
    	 */
    	function getErrorCode(error) {
    	    var _a;
    	    if (typeof error === 'number') {
    	        return error;
    	    }
    	    else if (isErrorWithCode(error)) {
    	        return (_a = error.code) !== null && _a !== void 0 ? _a : error.errorCode;
    	    }
    	    return undefined;
    	}
    	exports.getErrorCode = getErrorCode;
    	function isErrorWithCode(error) {
    	    return (typeof error === 'object' &&
    	        error !== null &&
    	        (typeof error.code === 'number' ||
    	            typeof error.errorCode === 'number'));
    	}
    	function serialize(error, { shouldIncludeStack = false } = {}) {
    	    const serialized = {};
    	    if (error &&
    	        typeof error === 'object' &&
    	        !Array.isArray(error) &&
    	        hasKey(error, 'code') &&
    	        isValidCode(error.code)) {
    	        const _error = error;
    	        serialized.code = _error.code;
    	        if (_error.message && typeof _error.message === 'string') {
    	            serialized.message = _error.message;
    	            if (hasKey(_error, 'data')) {
    	                serialized.data = _error.data;
    	            }
    	        }
    	        else {
    	            serialized.message = getMessageFromCode(serialized.code);
    	            serialized.data = { originalError: assignOriginalError(error) };
    	        }
    	    }
    	    else {
    	        serialized.code = constants_1.standardErrorCodes.rpc.internal;
    	        serialized.message = hasStringProperty(error, 'message') ? error.message : FALLBACK_MESSAGE;
    	        serialized.data = { originalError: assignOriginalError(error) };
    	    }
    	    if (shouldIncludeStack) {
    	        serialized.stack = hasStringProperty(error, 'stack') ? error.stack : undefined;
    	    }
    	    return serialized;
    	}
    	exports.serialize = serialize;
    	// Internal
    	function isJsonRpcServerError(code) {
    	    return code >= -32099 && code <= -32000;
    	}
    	function assignOriginalError(error) {
    	    if (error && typeof error === 'object' && !Array.isArray(error)) {
    	        return Object.assign({}, error);
    	    }
    	    return error;
    	}
    	function hasKey(obj, key) {
    	    return Object.prototype.hasOwnProperty.call(obj, key);
    	}
    	function hasStringProperty(obj, prop) {
    	    return (typeof obj === 'object' && obj !== null && prop in obj && typeof obj[prop] === 'string');
    	} 
    } (utils$1));

    Object.defineProperty(errors$1, "__esModule", { value: true });
    errors$1.standardErrors = void 0;
    const constants_1$2 = constants$2;
    const utils_1$2 = utils$1;
    errors$1.standardErrors = {
        rpc: {
            parse: (arg) => getEthJsonRpcError$1(constants_1$2.standardErrorCodes.rpc.parse, arg),
            invalidRequest: (arg) => getEthJsonRpcError$1(constants_1$2.standardErrorCodes.rpc.invalidRequest, arg),
            invalidParams: (arg) => getEthJsonRpcError$1(constants_1$2.standardErrorCodes.rpc.invalidParams, arg),
            methodNotFound: (arg) => getEthJsonRpcError$1(constants_1$2.standardErrorCodes.rpc.methodNotFound, arg),
            internal: (arg) => getEthJsonRpcError$1(constants_1$2.standardErrorCodes.rpc.internal, arg),
            server: (opts) => {
                if (!opts || typeof opts !== 'object' || Array.isArray(opts)) {
                    throw new Error('Ethereum RPC Server errors must provide single object argument.');
                }
                const { code } = opts;
                if (!Number.isInteger(code) || code > -32005 || code < -32099) {
                    throw new Error('"code" must be an integer such that: -32099 <= code <= -32005');
                }
                return getEthJsonRpcError$1(code, opts);
            },
            invalidInput: (arg) => getEthJsonRpcError$1(constants_1$2.standardErrorCodes.rpc.invalidInput, arg),
            resourceNotFound: (arg) => getEthJsonRpcError$1(constants_1$2.standardErrorCodes.rpc.resourceNotFound, arg),
            resourceUnavailable: (arg) => getEthJsonRpcError$1(constants_1$2.standardErrorCodes.rpc.resourceUnavailable, arg),
            transactionRejected: (arg) => getEthJsonRpcError$1(constants_1$2.standardErrorCodes.rpc.transactionRejected, arg),
            methodNotSupported: (arg) => getEthJsonRpcError$1(constants_1$2.standardErrorCodes.rpc.methodNotSupported, arg),
            limitExceeded: (arg) => getEthJsonRpcError$1(constants_1$2.standardErrorCodes.rpc.limitExceeded, arg),
        },
        provider: {
            userRejectedRequest: (arg) => {
                return getEthProviderError$1(constants_1$2.standardErrorCodes.provider.userRejectedRequest, arg);
            },
            unauthorized: (arg) => {
                return getEthProviderError$1(constants_1$2.standardErrorCodes.provider.unauthorized, arg);
            },
            unsupportedMethod: (arg) => {
                return getEthProviderError$1(constants_1$2.standardErrorCodes.provider.unsupportedMethod, arg);
            },
            disconnected: (arg) => {
                return getEthProviderError$1(constants_1$2.standardErrorCodes.provider.disconnected, arg);
            },
            chainDisconnected: (arg) => {
                return getEthProviderError$1(constants_1$2.standardErrorCodes.provider.chainDisconnected, arg);
            },
            unsupportedChain: (arg) => {
                return getEthProviderError$1(constants_1$2.standardErrorCodes.provider.unsupportedChain, arg);
            },
            custom: (opts) => {
                if (!opts || typeof opts !== 'object' || Array.isArray(opts)) {
                    throw new Error('Ethereum Provider custom errors must provide single object argument.');
                }
                const { code, message, data } = opts;
                if (!message || typeof message !== 'string') {
                    throw new Error('"message" must be a nonempty string');
                }
                return new EthereumProviderError$1(code, message, data);
            },
        },
    };
    // Internal
    function getEthJsonRpcError$1(code, arg) {
        const [message, data] = parseOpts$1(arg);
        return new EthereumRpcError$1(code, message || (0, utils_1$2.getMessageFromCode)(code), data);
    }
    function getEthProviderError$1(code, arg) {
        const [message, data] = parseOpts$1(arg);
        return new EthereumProviderError$1(code, message || (0, utils_1$2.getMessageFromCode)(code), data);
    }
    function parseOpts$1(arg) {
        if (arg) {
            if (typeof arg === 'string') {
                return [arg];
            }
            else if (typeof arg === 'object' && !Array.isArray(arg)) {
                const { message, data } = arg;
                if (message && typeof message !== 'string') {
                    throw new Error('Must specify string message.');
                }
                return [message || undefined, data];
            }
        }
        return [];
    }
    let EthereumRpcError$1 = class EthereumRpcError extends Error {
        constructor(code, message, data) {
            if (!Number.isInteger(code)) {
                throw new Error('"code" must be an integer.');
            }
            if (!message || typeof message !== 'string') {
                throw new Error('"message" must be a nonempty string.');
            }
            super(message);
            this.code = code;
            if (data !== undefined) {
                this.data = data;
            }
        }
    };
    let EthereumProviderError$1 = class EthereumProviderError extends EthereumRpcError$1 {
        /**
         * Create an Ethereum Provider JSON-RPC error.
         * `code` must be an integer in the 1000 <= 4999 range.
         */
        constructor(code, message, data) {
            if (!isValidEthProviderCode$1(code)) {
                throw new Error('"code" must be an integer such that: 1000 <= code <= 4999');
            }
            super(code, message, data);
        }
    };
    function isValidEthProviderCode$1(code) {
        return Number.isInteger(code) && code >= 1000 && code <= 4999;
    }

    var serialize = {};

    var Web3Response = {};

    // Copyright (c) 2018-2023 Coinbase, Inc. <https://www.coinbase.com/>
    // Licensed under the Apache License, version 2.0
    Object.defineProperty(Web3Response, "__esModule", { value: true });
    Web3Response.isErrorResponse = void 0;
    // TODO: revisit if this is still needed
    function isErrorResponse(response) {
        return response.errorMessage !== undefined;
    }
    Web3Response.isErrorResponse = isErrorResponse;

    var version = {};

    Object.defineProperty(version, "__esModule", { value: true });
    version.LIB_VERSION = void 0;
    version.LIB_VERSION = '3.9.1';

    Object.defineProperty(serialize, "__esModule", { value: true });
    serialize.serializeError = void 0;
    // TODO: error should not depend on walletlink. revisit this.
    const Web3Response_1$2 = Web3Response;
    const version_1$2 = version;
    const constants_1$1 = constants$2;
    const utils_1$1 = utils$1;
    /**
     * Serializes an error to a format that is compatible with the Ethereum JSON RPC error format.
     * See https://docs.cloud.coinbase.com/wallet-sdk/docs/errors
     * for more information.
     */
    function serializeError(error, requestOrMethod) {
        const serialized = (0, utils_1$1.serialize)(getErrorObject(error), {
            shouldIncludeStack: true,
        });
        const docUrl = new URL('https://docs.cloud.coinbase.com/wallet-sdk/docs/errors');
        docUrl.searchParams.set('version', version_1$2.LIB_VERSION);
        docUrl.searchParams.set('code', serialized.code.toString());
        const method = getMethod(serialized.data, requestOrMethod);
        if (method) {
            docUrl.searchParams.set('method', method);
        }
        docUrl.searchParams.set('message', serialized.message);
        return Object.assign(Object.assign({}, serialized), { docUrl: docUrl.href });
    }
    serialize.serializeError = serializeError;
    /**
     * Converts an error to a serializable object.
     */
    function getErrorObject(error) {
        if (typeof error === 'string') {
            return {
                message: error,
                code: constants_1$1.standardErrorCodes.rpc.internal,
            };
        }
        else if ((0, Web3Response_1$2.isErrorResponse)(error)) {
            return Object.assign(Object.assign({}, error), { message: error.errorMessage, code: error.errorCode, data: { method: error.method } });
        }
        return error;
    }
    /**
     * Gets the method name from the serialized data or the request.
     */
    function getMethod(serializedData, request) {
        const methodInData = serializedData === null || serializedData === void 0 ? void 0 : serializedData.method;
        if (methodInData) {
            return methodInData;
        }
        if (request === undefined) {
            return undefined;
        }
        else if (typeof request === 'string') {
            return request;
        }
        else if (!Array.isArray(request)) {
            return request.method;
        }
        else if (request.length > 0) {
            return request[0].method;
        }
        return undefined;
    }

    (function (exports) {
    	Object.defineProperty(exports, "__esModule", { value: true });
    	exports.standardErrors = exports.standardErrorCodes = exports.serializeError = exports.getMessageFromCode = exports.getErrorCode = void 0;
    	const constants_1 = constants$2;
    	Object.defineProperty(exports, "standardErrorCodes", { enumerable: true, get: function () { return constants_1.standardErrorCodes; } });
    	const errors_1 = errors$1;
    	Object.defineProperty(exports, "standardErrors", { enumerable: true, get: function () { return errors_1.standardErrors; } });
    	const serialize_1 = serialize;
    	Object.defineProperty(exports, "serializeError", { enumerable: true, get: function () { return serialize_1.serializeError; } });
    	const utils_1 = utils$1;
    	Object.defineProperty(exports, "getErrorCode", { enumerable: true, get: function () { return utils_1.getErrorCode; } });
    	Object.defineProperty(exports, "getMessageFromCode", { enumerable: true, get: function () { return utils_1.getMessageFromCode; } }); 
    } (error));

    var type$1 = {};

    // Copyright (c) 2018-2023 Coinbase, Inc. <https://www.coinbase.com/>
    // Licensed under the Apache License, version 2.0
    Object.defineProperty(type$1, "__esModule", { value: true });
    type$1.ProviderType = type$1.RegExpString = type$1.IntNumber = type$1.BigIntString = type$1.AddressString = type$1.HexString = type$1.OpaqueType = void 0;
    function OpaqueType() {
        return (value) => value;
    }
    type$1.OpaqueType = OpaqueType;
    type$1.HexString = OpaqueType();
    type$1.AddressString = OpaqueType();
    type$1.BigIntString = OpaqueType();
    function IntNumber(num) {
        return Math.floor(num);
    }
    type$1.IntNumber = IntNumber;
    type$1.RegExpString = OpaqueType();
    var ProviderType;
    (function (ProviderType) {
        ProviderType["CoinbaseWallet"] = "CoinbaseWallet";
        ProviderType["MetaMask"] = "MetaMask";
        ProviderType["Unselected"] = "";
    })(ProviderType || (type$1.ProviderType = ProviderType = {}));

    // Copyright (c) 2018-2023 Coinbase, Inc. <https://www.coinbase.com/>
    // Licensed under the Apache License, version 2.0
    var __importDefault$d = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };
    Object.defineProperty(util$3, "__esModule", { value: true });
    util$3.isMobileWeb = util$3.getLocation = util$3.isInIFrame = util$3.createQrUrl = util$3.getFavicon = util$3.range = util$3.isBigNumber = util$3.ensureParsedJSONObject = util$3.ensureBN = util$3.ensureRegExpString = util$3.ensureIntNumber = util$3.ensureBuffer = util$3.ensureAddressString = util$3.ensureEvenLengthHexString = util$3.ensureHexString = util$3.isHexString = util$3.prepend0x = util$3.strip0x = util$3.has0xPrefix = util$3.hexStringFromIntNumber = util$3.intNumberFromHexString = util$3.bigIntStringFromBN = util$3.hexStringFromBuffer = util$3.hexStringToUint8Array = util$3.uint8ArrayToHex = util$3.randomBytesHex = void 0;
    const bn_js_1$1 = __importDefault$d(bnExports);
    const error_1$3 = error;
    const type_1$3 = type$1;
    const INT_STRING_REGEX = /^[0-9]*$/;
    const HEXADECIMAL_STRING_REGEX = /^[a-f0-9]*$/;
    /**
     * @param length number of bytes
     */
    function randomBytesHex(length) {
        return uint8ArrayToHex(crypto.getRandomValues(new Uint8Array(length)));
    }
    util$3.randomBytesHex = randomBytesHex;
    function uint8ArrayToHex(value) {
        return [...value].map((b) => b.toString(16).padStart(2, '0')).join('');
    }
    util$3.uint8ArrayToHex = uint8ArrayToHex;
    function hexStringToUint8Array(hexString) {
        return new Uint8Array(hexString.match(/.{1,2}/g).map((byte) => parseInt(byte, 16)));
    }
    util$3.hexStringToUint8Array = hexStringToUint8Array;
    function hexStringFromBuffer(buf, includePrefix = false) {
        const hex = buf.toString('hex');
        return (0, type_1$3.HexString)(includePrefix ? `0x${hex}` : hex);
    }
    util$3.hexStringFromBuffer = hexStringFromBuffer;
    function bigIntStringFromBN(bn) {
        return (0, type_1$3.BigIntString)(bn.toString(10));
    }
    util$3.bigIntStringFromBN = bigIntStringFromBN;
    function intNumberFromHexString(hex) {
        return (0, type_1$3.IntNumber)(new bn_js_1$1.default(ensureEvenLengthHexString(hex, false), 16).toNumber());
    }
    util$3.intNumberFromHexString = intNumberFromHexString;
    function hexStringFromIntNumber(num) {
        return (0, type_1$3.HexString)(`0x${new bn_js_1$1.default(num).toString(16)}`);
    }
    util$3.hexStringFromIntNumber = hexStringFromIntNumber;
    function has0xPrefix(str) {
        return str.startsWith('0x') || str.startsWith('0X');
    }
    util$3.has0xPrefix = has0xPrefix;
    function strip0x(hex) {
        if (has0xPrefix(hex)) {
            return hex.slice(2);
        }
        return hex;
    }
    util$3.strip0x = strip0x;
    function prepend0x(hex) {
        if (has0xPrefix(hex)) {
            return `0x${hex.slice(2)}`;
        }
        return `0x${hex}`;
    }
    util$3.prepend0x = prepend0x;
    function isHexString$1(hex) {
        if (typeof hex !== 'string') {
            return false;
        }
        const s = strip0x(hex).toLowerCase();
        return HEXADECIMAL_STRING_REGEX.test(s);
    }
    util$3.isHexString = isHexString$1;
    function ensureHexString(hex, includePrefix = false) {
        if (typeof hex === 'string') {
            const s = strip0x(hex).toLowerCase();
            if (HEXADECIMAL_STRING_REGEX.test(s)) {
                return (0, type_1$3.HexString)(includePrefix ? `0x${s}` : s);
            }
        }
        throw error_1$3.standardErrors.rpc.invalidParams(`"${String(hex)}" is not a hexadecimal string`);
    }
    util$3.ensureHexString = ensureHexString;
    function ensureEvenLengthHexString(hex, includePrefix = false) {
        let h = ensureHexString(hex, false);
        if (h.length % 2 === 1) {
            h = (0, type_1$3.HexString)(`0${h}`);
        }
        return includePrefix ? (0, type_1$3.HexString)(`0x${h}`) : h;
    }
    util$3.ensureEvenLengthHexString = ensureEvenLengthHexString;
    function ensureAddressString(str) {
        if (typeof str === 'string') {
            const s = strip0x(str).toLowerCase();
            if (isHexString$1(s) && s.length === 40) {
                return (0, type_1$3.AddressString)(prepend0x(s));
            }
        }
        throw error_1$3.standardErrors.rpc.invalidParams(`Invalid Ethereum address: ${String(str)}`);
    }
    util$3.ensureAddressString = ensureAddressString;
    function ensureBuffer(str) {
        if (Buffer$8.isBuffer(str)) {
            return str;
        }
        if (typeof str === 'string') {
            if (isHexString$1(str)) {
                const s = ensureEvenLengthHexString(str, false);
                return Buffer$8.from(s, 'hex');
            }
            return Buffer$8.from(str, 'utf8');
        }
        throw error_1$3.standardErrors.rpc.invalidParams(`Not binary data: ${String(str)}`);
    }
    util$3.ensureBuffer = ensureBuffer;
    function ensureIntNumber(num) {
        if (typeof num === 'number' && Number.isInteger(num)) {
            return (0, type_1$3.IntNumber)(num);
        }
        if (typeof num === 'string') {
            if (INT_STRING_REGEX.test(num)) {
                return (0, type_1$3.IntNumber)(Number(num));
            }
            if (isHexString$1(num)) {
                return (0, type_1$3.IntNumber)(new bn_js_1$1.default(ensureEvenLengthHexString(num, false), 16).toNumber());
            }
        }
        throw error_1$3.standardErrors.rpc.invalidParams(`Not an integer: ${String(num)}`);
    }
    util$3.ensureIntNumber = ensureIntNumber;
    function ensureRegExpString(regExp) {
        if (regExp instanceof RegExp) {
            return (0, type_1$3.RegExpString)(regExp.toString());
        }
        throw error_1$3.standardErrors.rpc.invalidParams(`Not a RegExp: ${String(regExp)}`);
    }
    util$3.ensureRegExpString = ensureRegExpString;
    function ensureBN(val) {
        if (val !== null && (bn_js_1$1.default.isBN(val) || isBigNumber(val))) {
            return new bn_js_1$1.default(val.toString(10), 10);
        }
        if (typeof val === 'number') {
            return new bn_js_1$1.default(ensureIntNumber(val));
        }
        if (typeof val === 'string') {
            if (INT_STRING_REGEX.test(val)) {
                return new bn_js_1$1.default(val, 10);
            }
            if (isHexString$1(val)) {
                return new bn_js_1$1.default(ensureEvenLengthHexString(val, false), 16);
            }
        }
        throw error_1$3.standardErrors.rpc.invalidParams(`Not an integer: ${String(val)}`);
    }
    util$3.ensureBN = ensureBN;
    function ensureParsedJSONObject(val) {
        if (typeof val === 'string') {
            return JSON.parse(val);
        }
        if (typeof val === 'object') {
            return val;
        }
        throw error_1$3.standardErrors.rpc.invalidParams(`Not a JSON string or an object: ${String(val)}`);
    }
    util$3.ensureParsedJSONObject = ensureParsedJSONObject;
    function isBigNumber(val) {
        if (val == null || typeof val.constructor !== 'function') {
            return false;
        }
        const { constructor } = val;
        return typeof constructor.config === 'function' && typeof constructor.EUCLID === 'number';
    }
    util$3.isBigNumber = isBigNumber;
    function range$1(start, stop) {
        return Array.from({ length: stop - start }, (_, i) => start + i);
    }
    util$3.range = range$1;
    function getFavicon() {
        const el = document.querySelector('link[sizes="192x192"]') ||
            document.querySelector('link[sizes="180x180"]') ||
            document.querySelector('link[rel="icon"]') ||
            document.querySelector('link[rel="shortcut icon"]');
        const { protocol, host } = document.location;
        const href = el ? el.getAttribute('href') : null;
        if (!href || href.startsWith('javascript:') || href.startsWith('vbscript:')) {
            return null;
        }
        if (href.startsWith('http://') || href.startsWith('https://') || href.startsWith('data:')) {
            return href;
        }
        if (href.startsWith('//')) {
            return protocol + href;
        }
        return `${protocol}//${host}${href}`;
    }
    util$3.getFavicon = getFavicon;
    function createQrUrl(sessionId, sessionSecret, serverUrl, isParentConnection, version, chainId) {
        const sessionIdKey = isParentConnection ? 'parent-id' : 'id';
        const query = new URLSearchParams({
            [sessionIdKey]: sessionId,
            secret: sessionSecret,
            server: serverUrl,
            v: version,
            chainId: chainId.toString(),
        }).toString();
        const qrUrl = `${serverUrl}/#/link?${query}`;
        return qrUrl;
    }
    util$3.createQrUrl = createQrUrl;
    function isInIFrame() {
        try {
            return window.frameElement !== null;
        }
        catch (e) {
            return false;
        }
    }
    util$3.isInIFrame = isInIFrame;
    function getLocation() {
        try {
            if (isInIFrame() && window.top) {
                return window.top.location;
            }
            return window.location;
        }
        catch (e) {
            return window.location;
        }
    }
    util$3.getLocation = getLocation;
    function isMobileWeb() {
        var _a;
        return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test((_a = window === null || window === void 0 ? void 0 : window.navigator) === null || _a === void 0 ? void 0 : _a.userAgent);
    }
    util$3.isMobileWeb = isMobileWeb;

    var ScopedLocalStorage$1 = {};

    // Copyright (c) 2018-2023 Coinbase, Inc. <https://www.coinbase.com/>
    // Licensed under the Apache License, version 2.0
    Object.defineProperty(ScopedLocalStorage$1, "__esModule", { value: true });
    ScopedLocalStorage$1.ScopedLocalStorage = void 0;
    class ScopedLocalStorage {
        // eslint-disable-next-line no-useless-constructor
        constructor(scope) {
            this.scope = scope;
        }
        setItem(key, value) {
            localStorage.setItem(this.scopedKey(key), value);
        }
        getItem(key) {
            return localStorage.getItem(this.scopedKey(key));
        }
        removeItem(key) {
            localStorage.removeItem(this.scopedKey(key));
        }
        clear() {
            const prefix = this.scopedKey('');
            const keysToRemove = [];
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (typeof key === 'string' && key.startsWith(prefix)) {
                    keysToRemove.push(key);
                }
            }
            keysToRemove.forEach((key) => localStorage.removeItem(key));
        }
        scopedKey(key) {
            return `${this.scope}:${key}`;
        }
    }
    ScopedLocalStorage$1.ScopedLocalStorage = ScopedLocalStorage;

    var CoinbaseWalletProvider$1 = {};

    var MobileRelay$1 = {};

    var WalletLinkRelay$1 = {};

    var DiagnosticLogger = {};

    // DiagnosticLogger for debugging purposes only
    Object.defineProperty(DiagnosticLogger, "__esModule", { value: true });
    DiagnosticLogger.EVENTS = void 0;
    DiagnosticLogger.EVENTS = {
        STARTED_CONNECTING: 'walletlink_sdk.started.connecting',
        CONNECTED_STATE_CHANGE: 'walletlink_sdk.connected',
        DISCONNECTED: 'walletlink_sdk.disconnected',
        METADATA_DESTROYED: 'walletlink_sdk_metadata_destroyed',
        LINKED: 'walletlink_sdk.linked',
        FAILURE: 'walletlink_sdk.generic_failure',
        SESSION_CONFIG_RECEIVED: 'walletlink_sdk.session_config_event_received',
        ETH_ACCOUNTS_STATE: 'walletlink_sdk.eth_accounts_state',
        SESSION_STATE_CHANGE: 'walletlink_sdk.session_state_change',
        UNLINKED_ERROR_STATE: 'walletlink_sdk.unlinked_error_state',
        SKIPPED_CLEARING_SESSION: 'walletlink_sdk.skipped_clearing_session',
        GENERAL_ERROR: 'walletlink_sdk.general_error',
        WEB3_REQUEST: 'walletlink_sdk.web3.request',
        WEB3_REQUEST_PUBLISHED: 'walletlink_sdk.web3.request_published',
        WEB3_RESPONSE: 'walletlink_sdk.web3.response',
        METHOD_NOT_IMPLEMENTED: 'walletlink_sdk.method_not_implemented',
        UNKNOWN_ADDRESS_ENCOUNTERED: 'walletlink_sdk.unknown_address_encountered',
    };

    var RelayAbstract$1 = {};

    Object.defineProperty(RelayAbstract$1, "__esModule", { value: true });
    RelayAbstract$1.RelayAbstract = RelayAbstract$1.APP_VERSION_KEY = RelayAbstract$1.LOCAL_STORAGE_ADDRESSES_KEY = RelayAbstract$1.WALLET_USER_NAME_KEY = void 0;
    const error_1$2 = error;
    RelayAbstract$1.WALLET_USER_NAME_KEY = 'walletUsername';
    RelayAbstract$1.LOCAL_STORAGE_ADDRESSES_KEY = 'Addresses';
    RelayAbstract$1.APP_VERSION_KEY = 'AppVersion';
    class RelayAbstract {
        async makeEthereumJSONRPCRequest(request, jsonRpcUrl) {
            if (!jsonRpcUrl)
                throw new Error('Error: No jsonRpcUrl provided');
            return window
                .fetch(jsonRpcUrl, {
                method: 'POST',
                body: JSON.stringify(request),
                mode: 'cors',
                headers: { 'Content-Type': 'application/json' },
            })
                .then((res) => res.json())
                .then((json) => {
                if (!json) {
                    throw error_1$2.standardErrors.rpc.parse({});
                }
                const response = json;
                const { error } = response;
                if (error) {
                    throw (0, error_1$2.serializeError)(error, request.method);
                }
                return response;
            });
        }
    }
    RelayAbstract$1.RelayAbstract = RelayAbstract;

    var Session$1 = {};

    var sha_js = {exports: {}};

    var inherits$8;
    if (typeof Object.create === 'function'){
      inherits$8 = function inherits(ctor, superCtor) {
        // implementation from standard node.js 'util' module
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      };
    } else {
      inherits$8 = function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function () {};
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      };
    }
    var inherits$9 = inherits$8;

    var _polyfillNode_inherits = /*#__PURE__*/Object.freeze({
        __proto__: null,
        default: inherits$9
    });

    var require$$1$2 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_inherits);

    var safeBuffer = {exports: {}};

    /* eslint-disable node/no-deprecated-api */

    (function (module, exports) {
    	var buffer = require$$2$1;
    	var Buffer = buffer.Buffer;

    	// alternative to using Object.keys for old browsers
    	function copyProps (src, dst) {
    	  for (var key in src) {
    	    dst[key] = src[key];
    	  }
    	}
    	if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
    	  module.exports = buffer;
    	} else {
    	  // Copy properties from require('buffer')
    	  copyProps(buffer, exports);
    	  exports.Buffer = SafeBuffer;
    	}

    	function SafeBuffer (arg, encodingOrOffset, length) {
    	  return Buffer(arg, encodingOrOffset, length)
    	}

    	// Copy static methods from Buffer
    	copyProps(Buffer, SafeBuffer);

    	SafeBuffer.from = function (arg, encodingOrOffset, length) {
    	  if (typeof arg === 'number') {
    	    throw new TypeError('Argument must not be a number')
    	  }
    	  return Buffer(arg, encodingOrOffset, length)
    	};

    	SafeBuffer.alloc = function (size, fill, encoding) {
    	  if (typeof size !== 'number') {
    	    throw new TypeError('Argument must be a number')
    	  }
    	  var buf = Buffer(size);
    	  if (fill !== undefined) {
    	    if (typeof encoding === 'string') {
    	      buf.fill(fill, encoding);
    	    } else {
    	      buf.fill(fill);
    	    }
    	  } else {
    	    buf.fill(0);
    	  }
    	  return buf
    	};

    	SafeBuffer.allocUnsafe = function (size) {
    	  if (typeof size !== 'number') {
    	    throw new TypeError('Argument must be a number')
    	  }
    	  return Buffer(size)
    	};

    	SafeBuffer.allocUnsafeSlow = function (size) {
    	  if (typeof size !== 'number') {
    	    throw new TypeError('Argument must be a number')
    	  }
    	  return buffer.SlowBuffer(size)
    	}; 
    } (safeBuffer, safeBuffer.exports));

    var safeBufferExports = safeBuffer.exports;

    var Buffer$7 = safeBufferExports.Buffer;

    // prototype class for hash functions
    function Hash$6 (blockSize, finalSize) {
      this._block = Buffer$7.alloc(blockSize);
      this._finalSize = finalSize;
      this._blockSize = blockSize;
      this._len = 0;
    }

    Hash$6.prototype.update = function (data, enc) {
      if (typeof data === 'string') {
        enc = enc || 'utf8';
        data = Buffer$7.from(data, enc);
      }

      var block = this._block;
      var blockSize = this._blockSize;
      var length = data.length;
      var accum = this._len;

      for (var offset = 0; offset < length;) {
        var assigned = accum % blockSize;
        var remainder = Math.min(length - offset, blockSize - assigned);

        for (var i = 0; i < remainder; i++) {
          block[assigned + i] = data[offset + i];
        }

        accum += remainder;
        offset += remainder;

        if ((accum % blockSize) === 0) {
          this._update(block);
        }
      }

      this._len += length;
      return this
    };

    Hash$6.prototype.digest = function (enc) {
      var rem = this._len % this._blockSize;

      this._block[rem] = 0x80;

      // zero (rem + 1) trailing bits, where (rem + 1) is the smallest
      // non-negative solution to the equation (length + 1 + (rem + 1)) === finalSize mod blockSize
      this._block.fill(0, rem + 1);

      if (rem >= this._finalSize) {
        this._update(this._block);
        this._block.fill(0);
      }

      var bits = this._len * 8;

      // uint32
      if (bits <= 0xffffffff) {
        this._block.writeUInt32BE(bits, this._blockSize - 4);

      // uint64
      } else {
        var lowBits = (bits & 0xffffffff) >>> 0;
        var highBits = (bits - lowBits) / 0x100000000;

        this._block.writeUInt32BE(highBits, this._blockSize - 8);
        this._block.writeUInt32BE(lowBits, this._blockSize - 4);
      }

      this._update(this._block);
      var hash = this._hash();

      return enc ? hash.toString(enc) : hash
    };

    Hash$6.prototype._update = function () {
      throw new Error('_update must be implemented by subclass')
    };

    var hash = Hash$6;

    /*
     * A JavaScript implementation of the Secure Hash Algorithm, SHA-0, as defined
     * in FIPS PUB 180-1
     * This source code is derived from sha1.js of the same repository.
     * The difference between SHA-0 and SHA-1 is just a bitwise rotate left
     * operation was added.
     */

    var inherits$7 = require$$1$2;
    var Hash$5 = hash;
    var Buffer$6 = safeBufferExports.Buffer;

    var K$5 = [
      0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
    ];

    var W$6 = new Array(80);

    function Sha () {
      this.init();
      this._w = W$6;

      Hash$5.call(this, 64, 56);
    }

    inherits$7(Sha, Hash$5);

    Sha.prototype.init = function () {
      this._a = 0x67452301;
      this._b = 0xefcdab89;
      this._c = 0x98badcfe;
      this._d = 0x10325476;
      this._e = 0xc3d2e1f0;

      return this
    };

    function rotl5$1 (num) {
      return (num << 5) | (num >>> 27)
    }

    function rotl30$1 (num) {
      return (num << 30) | (num >>> 2)
    }

    function ft$2 (s, b, c, d) {
      if (s === 0) return (b & c) | ((~b) & d)
      if (s === 2) return (b & c) | (b & d) | (c & d)
      return b ^ c ^ d
    }

    Sha.prototype._update = function (M) {
      var W = this._w;

      var a = this._a | 0;
      var b = this._b | 0;
      var c = this._c | 0;
      var d = this._d | 0;
      var e = this._e | 0;

      for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4);
      for (; i < 80; ++i) W[i] = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];

      for (var j = 0; j < 80; ++j) {
        var s = ~~(j / 20);
        var t = (rotl5$1(a) + ft$2(s, b, c, d) + e + W[j] + K$5[s]) | 0;

        e = d;
        d = c;
        c = rotl30$1(b);
        b = a;
        a = t;
      }

      this._a = (a + this._a) | 0;
      this._b = (b + this._b) | 0;
      this._c = (c + this._c) | 0;
      this._d = (d + this._d) | 0;
      this._e = (e + this._e) | 0;
    };

    Sha.prototype._hash = function () {
      var H = Buffer$6.allocUnsafe(20);

      H.writeInt32BE(this._a | 0, 0);
      H.writeInt32BE(this._b | 0, 4);
      H.writeInt32BE(this._c | 0, 8);
      H.writeInt32BE(this._d | 0, 12);
      H.writeInt32BE(this._e | 0, 16);

      return H
    };

    var sha = Sha;

    /*
     * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
     * in FIPS PUB 180-1
     * Version 2.1a Copyright Paul Johnston 2000 - 2002.
     * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
     * Distributed under the BSD License
     * See http://pajhome.org.uk/crypt/md5 for details.
     */

    var inherits$6 = require$$1$2;
    var Hash$4 = hash;
    var Buffer$5 = safeBufferExports.Buffer;

    var K$4 = [
      0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
    ];

    var W$5 = new Array(80);

    function Sha1 () {
      this.init();
      this._w = W$5;

      Hash$4.call(this, 64, 56);
    }

    inherits$6(Sha1, Hash$4);

    Sha1.prototype.init = function () {
      this._a = 0x67452301;
      this._b = 0xefcdab89;
      this._c = 0x98badcfe;
      this._d = 0x10325476;
      this._e = 0xc3d2e1f0;

      return this
    };

    function rotl1 (num) {
      return (num << 1) | (num >>> 31)
    }

    function rotl5 (num) {
      return (num << 5) | (num >>> 27)
    }

    function rotl30 (num) {
      return (num << 30) | (num >>> 2)
    }

    function ft$1 (s, b, c, d) {
      if (s === 0) return (b & c) | ((~b) & d)
      if (s === 2) return (b & c) | (b & d) | (c & d)
      return b ^ c ^ d
    }

    Sha1.prototype._update = function (M) {
      var W = this._w;

      var a = this._a | 0;
      var b = this._b | 0;
      var c = this._c | 0;
      var d = this._d | 0;
      var e = this._e | 0;

      for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4);
      for (; i < 80; ++i) W[i] = rotl1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16]);

      for (var j = 0; j < 80; ++j) {
        var s = ~~(j / 20);
        var t = (rotl5(a) + ft$1(s, b, c, d) + e + W[j] + K$4[s]) | 0;

        e = d;
        d = c;
        c = rotl30(b);
        b = a;
        a = t;
      }

      this._a = (a + this._a) | 0;
      this._b = (b + this._b) | 0;
      this._c = (c + this._c) | 0;
      this._d = (d + this._d) | 0;
      this._e = (e + this._e) | 0;
    };

    Sha1.prototype._hash = function () {
      var H = Buffer$5.allocUnsafe(20);

      H.writeInt32BE(this._a | 0, 0);
      H.writeInt32BE(this._b | 0, 4);
      H.writeInt32BE(this._c | 0, 8);
      H.writeInt32BE(this._d | 0, 12);
      H.writeInt32BE(this._e | 0, 16);

      return H
    };

    var sha1 = Sha1;

    /**
     * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
     * in FIPS 180-2
     * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
     * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
     *
     */

    var inherits$5 = require$$1$2;
    var Hash$3 = hash;
    var Buffer$4 = safeBufferExports.Buffer;

    var K$3 = [
      0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,
      0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
      0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,
      0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
      0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,
      0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
      0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,
      0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
      0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,
      0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
      0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,
      0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
      0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,
      0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
      0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,
      0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2
    ];

    var W$4 = new Array(64);

    function Sha256$1 () {
      this.init();

      this._w = W$4; // new Array(64)

      Hash$3.call(this, 64, 56);
    }

    inherits$5(Sha256$1, Hash$3);

    Sha256$1.prototype.init = function () {
      this._a = 0x6a09e667;
      this._b = 0xbb67ae85;
      this._c = 0x3c6ef372;
      this._d = 0xa54ff53a;
      this._e = 0x510e527f;
      this._f = 0x9b05688c;
      this._g = 0x1f83d9ab;
      this._h = 0x5be0cd19;

      return this
    };

    function ch (x, y, z) {
      return z ^ (x & (y ^ z))
    }

    function maj$1 (x, y, z) {
      return (x & y) | (z & (x | y))
    }

    function sigma0$1 (x) {
      return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10)
    }

    function sigma1$1 (x) {
      return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7)
    }

    function gamma0 (x) {
      return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ (x >>> 3)
    }

    function gamma1 (x) {
      return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ (x >>> 10)
    }

    Sha256$1.prototype._update = function (M) {
      var W = this._w;

      var a = this._a | 0;
      var b = this._b | 0;
      var c = this._c | 0;
      var d = this._d | 0;
      var e = this._e | 0;
      var f = this._f | 0;
      var g = this._g | 0;
      var h = this._h | 0;

      for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4);
      for (; i < 64; ++i) W[i] = (gamma1(W[i - 2]) + W[i - 7] + gamma0(W[i - 15]) + W[i - 16]) | 0;

      for (var j = 0; j < 64; ++j) {
        var T1 = (h + sigma1$1(e) + ch(e, f, g) + K$3[j] + W[j]) | 0;
        var T2 = (sigma0$1(a) + maj$1(a, b, c)) | 0;

        h = g;
        g = f;
        f = e;
        e = (d + T1) | 0;
        d = c;
        c = b;
        b = a;
        a = (T1 + T2) | 0;
      }

      this._a = (a + this._a) | 0;
      this._b = (b + this._b) | 0;
      this._c = (c + this._c) | 0;
      this._d = (d + this._d) | 0;
      this._e = (e + this._e) | 0;
      this._f = (f + this._f) | 0;
      this._g = (g + this._g) | 0;
      this._h = (h + this._h) | 0;
    };

    Sha256$1.prototype._hash = function () {
      var H = Buffer$4.allocUnsafe(32);

      H.writeInt32BE(this._a, 0);
      H.writeInt32BE(this._b, 4);
      H.writeInt32BE(this._c, 8);
      H.writeInt32BE(this._d, 12);
      H.writeInt32BE(this._e, 16);
      H.writeInt32BE(this._f, 20);
      H.writeInt32BE(this._g, 24);
      H.writeInt32BE(this._h, 28);

      return H
    };

    var sha256 = Sha256$1;

    /**
     * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
     * in FIPS 180-2
     * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
     * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
     *
     */

    var inherits$4 = require$$1$2;
    var Sha256 = sha256;
    var Hash$2 = hash;
    var Buffer$3 = safeBufferExports.Buffer;

    var W$3 = new Array(64);

    function Sha224 () {
      this.init();

      this._w = W$3; // new Array(64)

      Hash$2.call(this, 64, 56);
    }

    inherits$4(Sha224, Sha256);

    Sha224.prototype.init = function () {
      this._a = 0xc1059ed8;
      this._b = 0x367cd507;
      this._c = 0x3070dd17;
      this._d = 0xf70e5939;
      this._e = 0xffc00b31;
      this._f = 0x68581511;
      this._g = 0x64f98fa7;
      this._h = 0xbefa4fa4;

      return this
    };

    Sha224.prototype._hash = function () {
      var H = Buffer$3.allocUnsafe(28);

      H.writeInt32BE(this._a, 0);
      H.writeInt32BE(this._b, 4);
      H.writeInt32BE(this._c, 8);
      H.writeInt32BE(this._d, 12);
      H.writeInt32BE(this._e, 16);
      H.writeInt32BE(this._f, 20);
      H.writeInt32BE(this._g, 24);

      return H
    };

    var sha224 = Sha224;

    var inherits$3 = require$$1$2;
    var Hash$1 = hash;
    var Buffer$2 = safeBufferExports.Buffer;

    var K$2 = [
      0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
      0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
      0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
      0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
      0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
      0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
      0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
      0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
      0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
      0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
      0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
      0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
      0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
      0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
      0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
      0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
      0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
      0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
      0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
      0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
      0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
      0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
      0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
      0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
      0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
      0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
      0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
      0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
      0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
      0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
      0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
      0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
      0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
      0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
      0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
      0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
      0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
      0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
      0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
      0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
    ];

    var W$2 = new Array(160);

    function Sha512 () {
      this.init();
      this._w = W$2;

      Hash$1.call(this, 128, 112);
    }

    inherits$3(Sha512, Hash$1);

    Sha512.prototype.init = function () {
      this._ah = 0x6a09e667;
      this._bh = 0xbb67ae85;
      this._ch = 0x3c6ef372;
      this._dh = 0xa54ff53a;
      this._eh = 0x510e527f;
      this._fh = 0x9b05688c;
      this._gh = 0x1f83d9ab;
      this._hh = 0x5be0cd19;

      this._al = 0xf3bcc908;
      this._bl = 0x84caa73b;
      this._cl = 0xfe94f82b;
      this._dl = 0x5f1d36f1;
      this._el = 0xade682d1;
      this._fl = 0x2b3e6c1f;
      this._gl = 0xfb41bd6b;
      this._hl = 0x137e2179;

      return this
    };

    function Ch (x, y, z) {
      return z ^ (x & (y ^ z))
    }

    function maj (x, y, z) {
      return (x & y) | (z & (x | y))
    }

    function sigma0 (x, xl) {
      return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25)
    }

    function sigma1 (x, xl) {
      return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23)
    }

    function Gamma0 (x, xl) {
      return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7)
    }

    function Gamma0l (x, xl) {
      return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25)
    }

    function Gamma1 (x, xl) {
      return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6)
    }

    function Gamma1l (x, xl) {
      return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26)
    }

    function getCarry (a, b) {
      return (a >>> 0) < (b >>> 0) ? 1 : 0
    }

    Sha512.prototype._update = function (M) {
      var W = this._w;

      var ah = this._ah | 0;
      var bh = this._bh | 0;
      var ch = this._ch | 0;
      var dh = this._dh | 0;
      var eh = this._eh | 0;
      var fh = this._fh | 0;
      var gh = this._gh | 0;
      var hh = this._hh | 0;

      var al = this._al | 0;
      var bl = this._bl | 0;
      var cl = this._cl | 0;
      var dl = this._dl | 0;
      var el = this._el | 0;
      var fl = this._fl | 0;
      var gl = this._gl | 0;
      var hl = this._hl | 0;

      for (var i = 0; i < 32; i += 2) {
        W[i] = M.readInt32BE(i * 4);
        W[i + 1] = M.readInt32BE(i * 4 + 4);
      }
      for (; i < 160; i += 2) {
        var xh = W[i - 15 * 2];
        var xl = W[i - 15 * 2 + 1];
        var gamma0 = Gamma0(xh, xl);
        var gamma0l = Gamma0l(xl, xh);

        xh = W[i - 2 * 2];
        xl = W[i - 2 * 2 + 1];
        var gamma1 = Gamma1(xh, xl);
        var gamma1l = Gamma1l(xl, xh);

        // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
        var Wi7h = W[i - 7 * 2];
        var Wi7l = W[i - 7 * 2 + 1];

        var Wi16h = W[i - 16 * 2];
        var Wi16l = W[i - 16 * 2 + 1];

        var Wil = (gamma0l + Wi7l) | 0;
        var Wih = (gamma0 + Wi7h + getCarry(Wil, gamma0l)) | 0;
        Wil = (Wil + gamma1l) | 0;
        Wih = (Wih + gamma1 + getCarry(Wil, gamma1l)) | 0;
        Wil = (Wil + Wi16l) | 0;
        Wih = (Wih + Wi16h + getCarry(Wil, Wi16l)) | 0;

        W[i] = Wih;
        W[i + 1] = Wil;
      }

      for (var j = 0; j < 160; j += 2) {
        Wih = W[j];
        Wil = W[j + 1];

        var majh = maj(ah, bh, ch);
        var majl = maj(al, bl, cl);

        var sigma0h = sigma0(ah, al);
        var sigma0l = sigma0(al, ah);
        var sigma1h = sigma1(eh, el);
        var sigma1l = sigma1(el, eh);

        // t1 = h + sigma1 + ch + K[j] + W[j]
        var Kih = K$2[j];
        var Kil = K$2[j + 1];

        var chh = Ch(eh, fh, gh);
        var chl = Ch(el, fl, gl);

        var t1l = (hl + sigma1l) | 0;
        var t1h = (hh + sigma1h + getCarry(t1l, hl)) | 0;
        t1l = (t1l + chl) | 0;
        t1h = (t1h + chh + getCarry(t1l, chl)) | 0;
        t1l = (t1l + Kil) | 0;
        t1h = (t1h + Kih + getCarry(t1l, Kil)) | 0;
        t1l = (t1l + Wil) | 0;
        t1h = (t1h + Wih + getCarry(t1l, Wil)) | 0;

        // t2 = sigma0 + maj
        var t2l = (sigma0l + majl) | 0;
        var t2h = (sigma0h + majh + getCarry(t2l, sigma0l)) | 0;

        hh = gh;
        hl = gl;
        gh = fh;
        gl = fl;
        fh = eh;
        fl = el;
        el = (dl + t1l) | 0;
        eh = (dh + t1h + getCarry(el, dl)) | 0;
        dh = ch;
        dl = cl;
        ch = bh;
        cl = bl;
        bh = ah;
        bl = al;
        al = (t1l + t2l) | 0;
        ah = (t1h + t2h + getCarry(al, t1l)) | 0;
      }

      this._al = (this._al + al) | 0;
      this._bl = (this._bl + bl) | 0;
      this._cl = (this._cl + cl) | 0;
      this._dl = (this._dl + dl) | 0;
      this._el = (this._el + el) | 0;
      this._fl = (this._fl + fl) | 0;
      this._gl = (this._gl + gl) | 0;
      this._hl = (this._hl + hl) | 0;

      this._ah = (this._ah + ah + getCarry(this._al, al)) | 0;
      this._bh = (this._bh + bh + getCarry(this._bl, bl)) | 0;
      this._ch = (this._ch + ch + getCarry(this._cl, cl)) | 0;
      this._dh = (this._dh + dh + getCarry(this._dl, dl)) | 0;
      this._eh = (this._eh + eh + getCarry(this._el, el)) | 0;
      this._fh = (this._fh + fh + getCarry(this._fl, fl)) | 0;
      this._gh = (this._gh + gh + getCarry(this._gl, gl)) | 0;
      this._hh = (this._hh + hh + getCarry(this._hl, hl)) | 0;
    };

    Sha512.prototype._hash = function () {
      var H = Buffer$2.allocUnsafe(64);

      function writeInt64BE (h, l, offset) {
        H.writeInt32BE(h, offset);
        H.writeInt32BE(l, offset + 4);
      }

      writeInt64BE(this._ah, this._al, 0);
      writeInt64BE(this._bh, this._bl, 8);
      writeInt64BE(this._ch, this._cl, 16);
      writeInt64BE(this._dh, this._dl, 24);
      writeInt64BE(this._eh, this._el, 32);
      writeInt64BE(this._fh, this._fl, 40);
      writeInt64BE(this._gh, this._gl, 48);
      writeInt64BE(this._hh, this._hl, 56);

      return H
    };

    var sha512 = Sha512;

    var inherits$2 = require$$1$2;
    var SHA512 = sha512;
    var Hash = hash;
    var Buffer$1 = safeBufferExports.Buffer;

    var W$1 = new Array(160);

    function Sha384 () {
      this.init();
      this._w = W$1;

      Hash.call(this, 128, 112);
    }

    inherits$2(Sha384, SHA512);

    Sha384.prototype.init = function () {
      this._ah = 0xcbbb9d5d;
      this._bh = 0x629a292a;
      this._ch = 0x9159015a;
      this._dh = 0x152fecd8;
      this._eh = 0x67332667;
      this._fh = 0x8eb44a87;
      this._gh = 0xdb0c2e0d;
      this._hh = 0x47b5481d;

      this._al = 0xc1059ed8;
      this._bl = 0x367cd507;
      this._cl = 0x3070dd17;
      this._dl = 0xf70e5939;
      this._el = 0xffc00b31;
      this._fl = 0x68581511;
      this._gl = 0x64f98fa7;
      this._hl = 0xbefa4fa4;

      return this
    };

    Sha384.prototype._hash = function () {
      var H = Buffer$1.allocUnsafe(48);

      function writeInt64BE (h, l, offset) {
        H.writeInt32BE(h, offset);
        H.writeInt32BE(l, offset + 4);
      }

      writeInt64BE(this._ah, this._al, 0);
      writeInt64BE(this._bh, this._bl, 8);
      writeInt64BE(this._ch, this._cl, 16);
      writeInt64BE(this._dh, this._dl, 24);
      writeInt64BE(this._eh, this._el, 32);
      writeInt64BE(this._fh, this._fl, 40);

      return H
    };

    var sha384 = Sha384;

    var exports$1 = sha_js.exports = function SHA (algorithm) {
      algorithm = algorithm.toLowerCase();

      var Algorithm = exports$1[algorithm];
      if (!Algorithm) throw new Error(algorithm + ' is not supported (we accept pull requests)')

      return new Algorithm()
    };

    exports$1.sha = sha;
    exports$1.sha1 = sha1;
    exports$1.sha224 = sha224;
    exports$1.sha256 = sha256;
    exports$1.sha384 = sha384;
    exports$1.sha512 = sha512;

    var sha_jsExports = sha_js.exports;

    // Copyright (c) 2018-2023 Coinbase, Inc. <https://www.coinbase.com/>
    // Licensed under the Apache License, version 2.0
    Object.defineProperty(Session$1, "__esModule", { value: true });
    Session$1.Session = void 0;
    const sha_js_1 = sha_jsExports;
    const util_1$8 = util$3;
    const STORAGE_KEY_SESSION_ID = 'session:id';
    const STORAGE_KEY_SESSION_SECRET = 'session:secret';
    const STORAGE_KEY_SESSION_LINKED = 'session:linked';
    class Session {
        constructor(storage, id, secret, linked) {
            this._storage = storage;
            this._id = id || (0, util_1$8.randomBytesHex)(16);
            this._secret = secret || (0, util_1$8.randomBytesHex)(32);
            this._key = new sha_js_1.sha256()
                .update(`${this._id}, ${this._secret} WalletLink`) // ensure old sessions stay connected
                .digest('hex');
            this._linked = !!linked;
        }
        static load(storage) {
            const id = storage.getItem(STORAGE_KEY_SESSION_ID);
            const linked = storage.getItem(STORAGE_KEY_SESSION_LINKED);
            const secret = storage.getItem(STORAGE_KEY_SESSION_SECRET);
            if (id && secret) {
                return new Session(storage, id, secret, linked === '1');
            }
            return null;
        }
        /**
         * Takes in a session ID and returns the sha256 hash of it.
         * @param sessionId session ID
         */
        static hash(sessionId) {
            return new sha_js_1.sha256().update(sessionId).digest('hex');
        }
        get id() {
            return this._id;
        }
        get secret() {
            return this._secret;
        }
        get key() {
            return this._key;
        }
        get linked() {
            return this._linked;
        }
        set linked(val) {
            this._linked = val;
            this.persistLinked();
        }
        save() {
            this._storage.setItem(STORAGE_KEY_SESSION_ID, this._id);
            this._storage.setItem(STORAGE_KEY_SESSION_SECRET, this._secret);
            this.persistLinked();
            return this;
        }
        persistLinked() {
            this._storage.setItem(STORAGE_KEY_SESSION_LINKED, this._linked ? '1' : '0');
        }
    }
    Session$1.Session = Session;

    var WalletLinkConnection$1 = {};

    var Cipher$1 = {};

    // Copyright (c) 2018-2023 Coinbase, Inc. <https://www.coinbase.com/>
    // Licensed under the Apache License, version 2.0
    Object.defineProperty(Cipher$1, "__esModule", { value: true });
    Cipher$1.Cipher = void 0;
    const util_1$7 = util$3;
    class Cipher {
        // @param secret hex representation of 32-byte secret
        constructor(secret) {
            this.secret = secret;
        }
        /**
         *
         * @param plainText string to be encrypted
         * returns hex string representation of bytes in the order: initialization vector (iv),
         * auth tag, encrypted plaintext. IV is 12 bytes. Auth tag is 16 bytes. Remaining bytes are the
         * encrypted plainText.
         */
        async encrypt(plainText) {
            const secret = this.secret;
            if (secret.length !== 64)
                throw Error(`secret must be 256 bits`);
            const ivBytes = crypto.getRandomValues(new Uint8Array(12));
            const secretKey = await crypto.subtle.importKey('raw', (0, util_1$7.hexStringToUint8Array)(secret), { name: 'aes-gcm' }, false, ['encrypt', 'decrypt']);
            const enc = new TextEncoder();
            // Will return encrypted plainText with auth tag (ie MAC or checksum) appended at the end
            const encryptedResult = await window.crypto.subtle.encrypt({
                name: 'AES-GCM',
                iv: ivBytes,
            }, secretKey, enc.encode(plainText));
            const tagLength = 16;
            const authTag = encryptedResult.slice(encryptedResult.byteLength - tagLength);
            const encryptedPlaintext = encryptedResult.slice(0, encryptedResult.byteLength - tagLength);
            const authTagBytes = new Uint8Array(authTag);
            const encryptedPlaintextBytes = new Uint8Array(encryptedPlaintext);
            const concatted = new Uint8Array([...ivBytes, ...authTagBytes, ...encryptedPlaintextBytes]);
            return (0, util_1$7.uint8ArrayToHex)(concatted);
        }
        /**
         *
         * @param cipherText hex string representation of bytes in the order: initialization vector (iv),
         * auth tag, encrypted plaintext. IV is 12 bytes. Auth tag is 16 bytes.
         */
        async decrypt(cipherText) {
            const secret = this.secret;
            if (secret.length !== 64)
                throw Error(`secret must be 256 bits`);
            return new Promise((resolve, reject) => {
                void (async function () {
                    const secretKey = await crypto.subtle.importKey('raw', (0, util_1$7.hexStringToUint8Array)(secret), { name: 'aes-gcm' }, false, ['encrypt', 'decrypt']);
                    const encrypted = (0, util_1$7.hexStringToUint8Array)(cipherText);
                    const ivBytes = encrypted.slice(0, 12);
                    const authTagBytes = encrypted.slice(12, 28);
                    const encryptedPlaintextBytes = encrypted.slice(28);
                    const concattedBytes = new Uint8Array([...encryptedPlaintextBytes, ...authTagBytes]);
                    const algo = {
                        name: 'AES-GCM',
                        iv: new Uint8Array(ivBytes),
                    };
                    try {
                        const decrypted = await window.crypto.subtle.decrypt(algo, secretKey, concattedBytes);
                        const decoder = new TextDecoder();
                        resolve(decoder.decode(decrypted));
                    }
                    catch (err) {
                        reject(err);
                    }
                })();
            });
        }
    }
    Cipher$1.Cipher = Cipher;

    var WalletLinkHTTP$1 = {};

    Object.defineProperty(WalletLinkHTTP$1, "__esModule", { value: true });
    WalletLinkHTTP$1.WalletLinkHTTP = void 0;
    class WalletLinkHTTP {
        constructor(linkAPIUrl, sessionId, sessionKey) {
            this.linkAPIUrl = linkAPIUrl;
            this.sessionId = sessionId;
            const credentials = `${sessionId}:${sessionKey}`;
            this.auth = `Basic ${btoa(credentials)}`;
        }
        // mark unseen events as seen
        async markUnseenEventsAsSeen(events) {
            return Promise.all(events.map((e) => fetch(`${this.linkAPIUrl}/events/${e.eventId}/seen`, {
                method: 'POST',
                headers: {
                    Authorization: this.auth,
                },
            }))).catch((error) => console.error('Unabled to mark event as failed:', error));
        }
        async fetchUnseenEvents() {
            var _a;
            const response = await fetch(`${this.linkAPIUrl}/events?unseen=true`, {
                headers: {
                    Authorization: this.auth,
                },
            });
            if (response.ok) {
                const { events, error } = (await response.json());
                if (error) {
                    throw new Error(`Check unseen events failed: ${error}`);
                }
                const responseEvents = (_a = events === null || events === void 0 ? void 0 : events.filter((e) => e.event === 'Web3Response').map((e) => ({
                    type: 'Event',
                    sessionId: this.sessionId,
                    eventId: e.id,
                    event: e.event,
                    data: e.data,
                }))) !== null && _a !== void 0 ? _a : [];
                this.markUnseenEventsAsSeen(responseEvents);
                return responseEvents;
            }
            throw new Error(`Check unseen events failed: ${response.status}`);
        }
    }
    WalletLinkHTTP$1.WalletLinkHTTP = WalletLinkHTTP;

    var WalletLinkWebSocket$1 = {};

    // Copyright (c) 2018-2023 Coinbase, Inc. <https://www.coinbase.com/>
    // Licensed under the Apache License, version 2.0
    Object.defineProperty(WalletLinkWebSocket$1, "__esModule", { value: true });
    WalletLinkWebSocket$1.WalletLinkWebSocket = WalletLinkWebSocket$1.ConnectionState = void 0;
    var ConnectionState;
    (function (ConnectionState) {
        ConnectionState[ConnectionState["DISCONNECTED"] = 0] = "DISCONNECTED";
        ConnectionState[ConnectionState["CONNECTING"] = 1] = "CONNECTING";
        ConnectionState[ConnectionState["CONNECTED"] = 2] = "CONNECTED";
    })(ConnectionState || (WalletLinkWebSocket$1.ConnectionState = ConnectionState = {}));
    class WalletLinkWebSocket {
        setConnectionStateListener(listener) {
            this.connectionStateListener = listener;
        }
        setIncomingDataListener(listener) {
            this.incomingDataListener = listener;
        }
        /**
         * Constructor
         * @param url WebSocket server URL
         * @param [WebSocketClass] Custom WebSocket implementation
         */
        constructor(url, WebSocketClass = WebSocket) {
            this.WebSocketClass = WebSocketClass;
            this.webSocket = null;
            this.pendingData = [];
            this.url = url.replace(/^http/, 'ws');
        }
        /**
         * Make a websocket connection
         * @returns a Promise that resolves when connected
         */
        async connect() {
            if (this.webSocket) {
                throw new Error('webSocket object is not null');
            }
            return new Promise((resolve, reject) => {
                var _a;
                let webSocket;
                try {
                    this.webSocket = webSocket = new this.WebSocketClass(this.url);
                }
                catch (err) {
                    reject(err);
                    return;
                }
                (_a = this.connectionStateListener) === null || _a === void 0 ? void 0 : _a.call(this, ConnectionState.CONNECTING);
                webSocket.onclose = (evt) => {
                    var _a;
                    this.clearWebSocket();
                    reject(new Error(`websocket error ${evt.code}: ${evt.reason}`));
                    (_a = this.connectionStateListener) === null || _a === void 0 ? void 0 : _a.call(this, ConnectionState.DISCONNECTED);
                };
                webSocket.onopen = (_) => {
                    var _a;
                    resolve();
                    (_a = this.connectionStateListener) === null || _a === void 0 ? void 0 : _a.call(this, ConnectionState.CONNECTED);
                    if (this.pendingData.length > 0) {
                        const pending = [...this.pendingData];
                        pending.forEach((data) => this.sendData(data));
                        this.pendingData = [];
                    }
                };
                webSocket.onmessage = (evt) => {
                    var _a, _b;
                    if (evt.data === 'h') {
                        (_a = this.incomingDataListener) === null || _a === void 0 ? void 0 : _a.call(this, {
                            type: 'Heartbeat',
                        });
                    }
                    else {
                        try {
                            const message = JSON.parse(evt.data);
                            (_b = this.incomingDataListener) === null || _b === void 0 ? void 0 : _b.call(this, message);
                        }
                        catch (_c) {
                            /* empty */
                        }
                    }
                };
            });
        }
        /**
         * Disconnect from server
         */
        disconnect() {
            var _a;
            const { webSocket } = this;
            if (!webSocket) {
                return;
            }
            this.clearWebSocket();
            (_a = this.connectionStateListener) === null || _a === void 0 ? void 0 : _a.call(this, ConnectionState.DISCONNECTED);
            this.connectionStateListener = undefined;
            this.incomingDataListener = undefined;
            try {
                webSocket.close();
            }
            catch (_b) {
                // noop
            }
        }
        /**
         * Send data to server
         * @param data text to send
         */
        sendData(data) {
            const { webSocket } = this;
            if (!webSocket) {
                this.pendingData.push(data);
                this.connect();
                return;
            }
            webSocket.send(data);
        }
        clearWebSocket() {
            const { webSocket } = this;
            if (!webSocket) {
                return;
            }
            this.webSocket = null;
            webSocket.onclose = null;
            webSocket.onerror = null;
            webSocket.onmessage = null;
            webSocket.onopen = null;
        }
    }
    WalletLinkWebSocket$1.WalletLinkWebSocket = WalletLinkWebSocket;

    // Copyright (c) 2018-2023 Coinbase, Inc. <https://www.coinbase.com/>
    // Licensed under the Apache License, version 2.0
    Object.defineProperty(WalletLinkConnection$1, "__esModule", { value: true });
    WalletLinkConnection$1.WalletLinkConnection = void 0;
    const type_1$2 = type$1;
    const Cipher_1 = Cipher$1;
    const DiagnosticLogger_1$2 = DiagnosticLogger;
    const RelayAbstract_1$2 = RelayAbstract$1;
    const Session_1$2 = Session$1;
    const WalletLinkHTTP_1 = WalletLinkHTTP$1;
    const WalletLinkWebSocket_1 = WalletLinkWebSocket$1;
    const HEARTBEAT_INTERVAL = 10000;
    const REQUEST_TIMEOUT = 60000;
    /**
     * Coinbase Wallet Connection
     */
    class WalletLinkConnection {
        /**
         * Constructor
         * @param session Session
         * @param linkAPIUrl Coinbase Wallet link server URL
         * @param listener WalletLinkConnectionUpdateListener
         * @param [WebSocketClass] Custom WebSocket implementation
         */
        constructor({ session, linkAPIUrl, listener, diagnostic, WebSocketClass = WebSocket, }) {
            this.destroyed = false;
            this.lastHeartbeatResponse = 0;
            this.nextReqId = (0, type_1$2.IntNumber)(1);
            /**
             * true if connected and authenticated, else false
             * runs listener when connected status changes
             */
            this._connected = false;
            /**
             * true if linked (a guest has joined before)
             * runs listener when linked status changes
             */
            this._linked = false;
            this.shouldFetchUnseenEventsOnConnect = false;
            this.requestResolutions = new Map();
            this.handleSessionMetadataUpdated = (metadata) => {
                if (!metadata)
                    return;
                // Map of metadata key to handler function
                const handlers = new Map([
                    ['__destroyed', this.handleDestroyed],
                    ['EthereumAddress', this.handleAccountUpdated],
                    ['WalletUsername', this.handleWalletUsernameUpdated],
                    ['AppVersion', this.handleAppVersionUpdated],
                    [
                        'ChainId',
                        (v) => metadata.JsonRpcUrl && this.handleChainUpdated(v, metadata.JsonRpcUrl),
                    ],
                ]);
                // call handler for each metadata key if value is defined
                handlers.forEach((handler, key) => {
                    const value = metadata[key];
                    if (value === undefined)
                        return;
                    handler(value);
                });
            };
            this.handleDestroyed = (__destroyed) => {
                var _a, _b;
                if (__destroyed !== '1')
                    return;
                (_a = this.listener) === null || _a === void 0 ? void 0 : _a.resetAndReload();
                (_b = this.diagnostic) === null || _b === void 0 ? void 0 : _b.log(DiagnosticLogger_1$2.EVENTS.METADATA_DESTROYED, {
                    alreadyDestroyed: this.isDestroyed,
                    sessionIdHash: Session_1$2.Session.hash(this.session.id),
                });
            };
            this.handleAccountUpdated = async (encryptedEthereumAddress) => {
                var _a, _b;
                try {
                    const address = await this.cipher.decrypt(encryptedEthereumAddress);
                    (_a = this.listener) === null || _a === void 0 ? void 0 : _a.accountUpdated(address);
                }
                catch (_c) {
                    (_b = this.diagnostic) === null || _b === void 0 ? void 0 : _b.log(DiagnosticLogger_1$2.EVENTS.GENERAL_ERROR, {
                        message: 'Had error decrypting',
                        value: 'selectedAddress',
                    });
                }
            };
            this.handleMetadataUpdated = async (key, encryptedMetadataValue) => {
                var _a, _b;
                try {
                    const decryptedValue = await this.cipher.decrypt(encryptedMetadataValue);
                    (_a = this.listener) === null || _a === void 0 ? void 0 : _a.metadataUpdated(key, decryptedValue);
                }
                catch (_c) {
                    (_b = this.diagnostic) === null || _b === void 0 ? void 0 : _b.log(DiagnosticLogger_1$2.EVENTS.GENERAL_ERROR, {
                        message: 'Had error decrypting',
                        value: key,
                    });
                }
            };
            this.handleWalletUsernameUpdated = async (walletUsername) => {
                this.handleMetadataUpdated(RelayAbstract_1$2.WALLET_USER_NAME_KEY, walletUsername);
            };
            this.handleAppVersionUpdated = async (appVersion) => {
                this.handleMetadataUpdated(RelayAbstract_1$2.APP_VERSION_KEY, appVersion);
            };
            this.handleChainUpdated = async (encryptedChainId, encryptedJsonRpcUrl) => {
                var _a, _b;
                try {
                    const chainId = await this.cipher.decrypt(encryptedChainId);
                    const jsonRpcUrl = await this.cipher.decrypt(encryptedJsonRpcUrl);
                    (_a = this.listener) === null || _a === void 0 ? void 0 : _a.chainUpdated(chainId, jsonRpcUrl);
                }
                catch (_c) {
                    (_b = this.diagnostic) === null || _b === void 0 ? void 0 : _b.log(DiagnosticLogger_1$2.EVENTS.GENERAL_ERROR, {
                        message: 'Had error decrypting',
                        value: 'chainId|jsonRpcUrl',
                    });
                }
            };
            this.session = session;
            this.cipher = new Cipher_1.Cipher(session.secret);
            this.diagnostic = diagnostic;
            this.listener = listener;
            const ws = new WalletLinkWebSocket_1.WalletLinkWebSocket(`${linkAPIUrl}/rpc`, WebSocketClass);
            ws.setConnectionStateListener(async (state) => {
                var _a;
                // attempt to reconnect every 5 seconds when disconnected
                (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1$2.EVENTS.CONNECTED_STATE_CHANGE, {
                    state,
                    sessionIdHash: Session_1$2.Session.hash(session.id),
                });
                let connected = false;
                switch (state) {
                    case WalletLinkWebSocket_1.ConnectionState.DISCONNECTED:
                        // if DISCONNECTED and not destroyed
                        if (!this.destroyed) {
                            const connect = async () => {
                                // wait 5 seconds
                                await new Promise((resolve) => setTimeout(resolve, 5000));
                                // check whether it's destroyed again
                                if (!this.destroyed) {
                                    // reconnect
                                    ws.connect().catch(() => {
                                        connect();
                                    });
                                }
                            };
                            connect();
                        }
                        break;
                    case WalletLinkWebSocket_1.ConnectionState.CONNECTED:
                        // perform authentication upon connection
                        try {
                            // if CONNECTED, authenticate, and then check link status
                            await this.authenticate();
                            this.sendIsLinked();
                            this.sendGetSessionConfig();
                            connected = true;
                        }
                        catch (_b) {
                            /* empty */
                        }
                        // send heartbeat every n seconds while connected
                        // if CONNECTED, start the heartbeat timer
                        // first timer event updates lastHeartbeat timestamp
                        // subsequent calls send heartbeat message
                        this.updateLastHeartbeat();
                        setInterval(() => {
                            this.heartbeat();
                        }, HEARTBEAT_INTERVAL);
                        // check for unseen events
                        if (this.shouldFetchUnseenEventsOnConnect) {
                            this.fetchUnseenEventsAPI();
                        }
                        break;
                    case WalletLinkWebSocket_1.ConnectionState.CONNECTING:
                        break;
                }
                // distinctUntilChanged
                if (this.connected !== connected) {
                    this.connected = connected;
                }
            });
            ws.setIncomingDataListener((m) => {
                var _a, _b, _c;
                switch (m.type) {
                    // handle server's heartbeat responses
                    case 'Heartbeat':
                        this.updateLastHeartbeat();
                        return;
                    // handle link status updates
                    case 'IsLinkedOK':
                    case 'Linked': {
                        const linked = m.type === 'IsLinkedOK' ? m.linked : undefined;
                        (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1$2.EVENTS.LINKED, {
                            sessionIdHash: Session_1$2.Session.hash(session.id),
                            linked,
                            type: m.type,
                            onlineGuests: m.onlineGuests,
                        });
                        this.linked = linked || m.onlineGuests > 0;
                        break;
                    }
                    // handle session config updates
                    case 'GetSessionConfigOK':
                    case 'SessionConfigUpdated': {
                        (_b = this.diagnostic) === null || _b === void 0 ? void 0 : _b.log(DiagnosticLogger_1$2.EVENTS.SESSION_CONFIG_RECEIVED, {
                            sessionIdHash: Session_1$2.Session.hash(session.id),
                            metadata_keys: m && m.metadata ? Object.keys(m.metadata) : undefined,
                        });
                        this.handleSessionMetadataUpdated(m.metadata);
                        break;
                    }
                    case 'Event': {
                        this.handleIncomingEvent(m);
                        break;
                    }
                }
                // resolve request promises
                if (m.id !== undefined) {
                    (_c = this.requestResolutions.get(m.id)) === null || _c === void 0 ? void 0 : _c(m);
                }
            });
            this.ws = ws;
            this.http = new WalletLinkHTTP_1.WalletLinkHTTP(linkAPIUrl, session.id, session.key);
        }
        /**
         * Make a connection to the server
         */
        connect() {
            var _a;
            if (this.destroyed) {
                throw new Error('instance is destroyed');
            }
            (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1$2.EVENTS.STARTED_CONNECTING, {
                sessionIdHash: Session_1$2.Session.hash(this.session.id),
            });
            this.ws.connect();
        }
        /**
         * Terminate connection, and mark as destroyed. To reconnect, create a new
         * instance of WalletSDKConnection
         */
        destroy() {
            var _a;
            this.destroyed = true;
            this.ws.disconnect();
            (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1$2.EVENTS.DISCONNECTED, {
                sessionIdHash: Session_1$2.Session.hash(this.session.id),
            });
            this.listener = undefined;
        }
        get isDestroyed() {
            return this.destroyed;
        }
        get connected() {
            return this._connected;
        }
        set connected(connected) {
            var _a, _b;
            this._connected = connected;
            if (connected)
                (_a = this.onceConnected) === null || _a === void 0 ? void 0 : _a.call(this);
            (_b = this.listener) === null || _b === void 0 ? void 0 : _b.connectedUpdated(connected);
        }
        setOnceConnected(callback) {
            return new Promise((resolve) => {
                if (this.connected) {
                    callback().then(resolve);
                }
                else {
                    this.onceConnected = () => {
                        callback().then(resolve);
                        this.onceConnected = undefined;
                    };
                }
            });
        }
        get linked() {
            return this._linked;
        }
        set linked(linked) {
            var _a, _b;
            this._linked = linked;
            if (linked)
                (_a = this.onceLinked) === null || _a === void 0 ? void 0 : _a.call(this);
            (_b = this.listener) === null || _b === void 0 ? void 0 : _b.linkedUpdated(linked);
        }
        setOnceLinked(callback) {
            return new Promise((resolve) => {
                if (this.linked) {
                    callback().then(resolve);
                }
                else {
                    this.onceLinked = () => {
                        callback().then(resolve);
                        this.onceLinked = undefined;
                    };
                }
            });
        }
        async handleIncomingEvent(m) {
            var _a, _b;
            if (m.type !== 'Event' || m.event !== 'Web3Response') {
                return;
            }
            try {
                const decryptedData = await this.cipher.decrypt(m.data);
                const message = JSON.parse(decryptedData);
                if (message.type !== 'WEB3_RESPONSE')
                    return;
                (_a = this.listener) === null || _a === void 0 ? void 0 : _a.handleWeb3ResponseMessage(message);
            }
            catch (_c) {
                (_b = this.diagnostic) === null || _b === void 0 ? void 0 : _b.log(DiagnosticLogger_1$2.EVENTS.GENERAL_ERROR, {
                    message: 'Had error decrypting',
                    value: 'incomingEvent',
                });
            }
        }
        async checkUnseenEvents() {
            if (!this.connected) {
                this.shouldFetchUnseenEventsOnConnect = true;
                return;
            }
            await new Promise((resolve) => setTimeout(resolve, 250));
            try {
                await this.fetchUnseenEventsAPI();
            }
            catch (e) {
                console.error('Unable to check for unseen events', e);
            }
        }
        async fetchUnseenEventsAPI() {
            this.shouldFetchUnseenEventsOnConnect = false;
            const responseEvents = await this.http.fetchUnseenEvents();
            responseEvents.forEach((e) => this.handleIncomingEvent(e));
        }
        /**
         * Set session metadata in SessionConfig object
         * @param key
         * @param value
         * @returns a Promise that completes when successful
         */
        async setSessionMetadata(key, value) {
            const message = {
                type: 'SetSessionConfig',
                id: (0, type_1$2.IntNumber)(this.nextReqId++),
                sessionId: this.session.id,
                metadata: { [key]: value },
            };
            return this.setOnceConnected(async () => {
                const res = await this.makeRequest(message);
                if (res.type === 'Fail') {
                    throw new Error(res.error || 'failed to set session metadata');
                }
            });
        }
        /**
         * Publish an event and emit event ID when successful
         * @param event event name
         * @param unencryptedData unencrypted event data
         * @param callWebhook whether the webhook should be invoked
         * @returns a Promise that emits event ID when successful
         */
        async publishEvent(event, unencryptedData, callWebhook = false) {
            const data = await this.cipher.encrypt(JSON.stringify(Object.assign(Object.assign({}, unencryptedData), { origin: location.origin, relaySource: window.coinbaseWalletExtension ? 'injected_sdk' : 'sdk' })));
            const message = {
                type: 'PublishEvent',
                id: (0, type_1$2.IntNumber)(this.nextReqId++),
                sessionId: this.session.id,
                event,
                data,
                callWebhook,
            };
            return this.setOnceLinked(async () => {
                const res = await this.makeRequest(message);
                if (res.type === 'Fail') {
                    throw new Error(res.error || 'failed to publish event');
                }
                return res.eventId;
            });
        }
        sendData(message) {
            this.ws.sendData(JSON.stringify(message));
        }
        updateLastHeartbeat() {
            this.lastHeartbeatResponse = Date.now();
        }
        heartbeat() {
            if (Date.now() - this.lastHeartbeatResponse > HEARTBEAT_INTERVAL * 2) {
                this.ws.disconnect();
                return;
            }
            try {
                this.ws.sendData('h');
            }
            catch (_a) {
                // noop
            }
        }
        async makeRequest(message, timeout = REQUEST_TIMEOUT) {
            const reqId = message.id;
            this.sendData(message);
            // await server message with corresponding id
            let timeoutId;
            return Promise.race([
                new Promise((_, reject) => {
                    timeoutId = window.setTimeout(() => {
                        reject(new Error(`request ${reqId} timed out`));
                    }, timeout);
                }),
                new Promise((resolve) => {
                    this.requestResolutions.set(reqId, (m) => {
                        clearTimeout(timeoutId); // clear the timeout
                        resolve(m);
                        this.requestResolutions.delete(reqId);
                    });
                }),
            ]);
        }
        async authenticate() {
            const m = {
                type: 'HostSession',
                id: (0, type_1$2.IntNumber)(this.nextReqId++),
                sessionId: this.session.id,
                sessionKey: this.session.key,
            };
            const res = await this.makeRequest(m);
            if (res.type === 'Fail') {
                throw new Error(res.error || 'failed to authentcate');
            }
        }
        sendIsLinked() {
            const m = {
                type: 'IsLinked',
                id: (0, type_1$2.IntNumber)(this.nextReqId++),
                sessionId: this.session.id,
            };
            this.sendData(m);
        }
        sendGetSessionConfig() {
            const m = {
                type: 'GetSessionConfig',
                id: (0, type_1$2.IntNumber)(this.nextReqId++),
                sessionId: this.session.id,
            };
            this.sendData(m);
        }
    }
    WalletLinkConnection$1.WalletLinkConnection = WalletLinkConnection;

    var WalletLinkRelayUI$1 = {};

    var cssReset = {};

    var cssResetCss = {};

    Object.defineProperty(cssResetCss, "__esModule", { value: true });
    cssResetCss.default = (() => `@namespace svg "http://www.w3.org/2000/svg";.-cbwsdk-css-reset,.-cbwsdk-css-reset *{animation:none;animation-delay:0;animation-direction:normal;animation-duration:0;animation-fill-mode:none;animation-iteration-count:1;animation-name:none;animation-play-state:running;animation-timing-function:ease;backface-visibility:visible;background:0;background-attachment:scroll;background-clip:border-box;background-color:rgba(0,0,0,0);background-image:none;background-origin:padding-box;background-position:0 0;background-position-x:0;background-position-y:0;background-repeat:repeat;background-size:auto auto;border:0;border-style:none;border-width:medium;border-color:inherit;border-bottom:0;border-bottom-color:inherit;border-bottom-left-radius:0;border-bottom-right-radius:0;border-bottom-style:none;border-bottom-width:medium;border-collapse:separate;border-image:none;border-left:0;border-left-color:inherit;border-left-style:none;border-left-width:medium;border-radius:0;border-right:0;border-right-color:inherit;border-right-style:none;border-right-width:medium;border-spacing:0;border-top:0;border-top-color:inherit;border-top-left-radius:0;border-top-right-radius:0;border-top-style:none;border-top-width:medium;box-shadow:none;box-sizing:border-box;caption-side:top;clear:none;clip:auto;color:inherit;columns:auto;column-count:auto;column-fill:balance;column-gap:normal;column-rule:medium none currentColor;column-rule-color:currentColor;column-rule-style:none;column-rule-width:none;column-span:1;column-width:auto;counter-increment:none;counter-reset:none;direction:ltr;empty-cells:show;float:none;font:normal;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Helvetica Neue",Arial,sans-serif;font-size:medium;font-style:normal;font-variant:normal;font-weight:normal;height:auto;hyphens:none;letter-spacing:normal;line-height:normal;list-style:none;list-style-image:none;list-style-position:outside;list-style-type:disc;margin:0;margin-bottom:0;margin-left:0;margin-right:0;margin-top:0;opacity:1;orphans:0;outline:0;outline-color:invert;outline-style:none;outline-width:medium;overflow:visible;overflow-x:visible;overflow-y:visible;padding:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;page-break-after:auto;page-break-before:auto;page-break-inside:auto;perspective:none;perspective-origin:50% 50%;pointer-events:auto;position:static;quotes:"\\201C" "\\201D" "\\2018" "\\2019";tab-size:8;table-layout:auto;text-align:inherit;text-align-last:auto;text-decoration:none;text-decoration-color:inherit;text-decoration-line:none;text-decoration-style:solid;text-indent:0;text-shadow:none;text-transform:none;transform:none;transform-style:flat;transition:none;transition-delay:0s;transition-duration:0s;transition-property:none;transition-timing-function:ease;unicode-bidi:normal;vertical-align:baseline;visibility:visible;white-space:normal;widows:0;word-spacing:normal;z-index:auto}.-cbwsdk-css-reset strong{font-weight:bold}.-cbwsdk-css-reset *{box-sizing:border-box;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Helvetica Neue",Arial,sans-serif;line-height:1}.-cbwsdk-css-reset [class*=container]{margin:0;padding:0}.-cbwsdk-css-reset style{display:none}`)();

    // Copyright (c) 2018-2023 Coinbase, Inc. <https://www.coinbase.com/>
    // Licensed under the Apache License, version 2.0
    var __importDefault$c = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };
    Object.defineProperty(cssReset, "__esModule", { value: true });
    cssReset.injectCssReset = void 0;
    const cssReset_css_1 = __importDefault$c(cssResetCss);
    function injectCssReset() {
        const styleEl = document.createElement('style');
        styleEl.type = 'text/css';
        styleEl.appendChild(document.createTextNode(cssReset_css_1.default));
        document.documentElement.appendChild(styleEl);
    }
    cssReset.injectCssReset = injectCssReset;

    var LinkFlow$1 = {};

    var n$a,l$7,u$5,t$9,i$9,o$b,r$c,f$4,e$a,c$8={},s$8=[],a$6=/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i,h$6=Array.isArray;function v$4(n,l){for(var u in l)n[u]=l[u];return n}function p$5(n){var l=n.parentNode;l&&l.removeChild(n);}function y$5(l,u,t){var i,o,r,f={};for(r in u)"key"==r?i=u[r]:"ref"==r?o=u[r]:f[r]=u[r];if(arguments.length>2&&(f.children=arguments.length>3?n$a.call(arguments,2):t),"function"==typeof l&&null!=l.defaultProps)for(r in l.defaultProps)void 0===f[r]&&(f[r]=l.defaultProps[r]);return d$7(l,f,i,o,null)}function d$7(n,t,i,o,r){var f={type:n,props:t,key:i,ref:o,__k:null,__:null,__b:0,__e:null,__d:void 0,__c:null,constructor:void 0,__v:null==r?++u$5:r,__i:-1,__u:0};return null==r&&null!=l$7.vnode&&l$7.vnode(f),f}function _$5(){return {current:null}}function g$4(n){return n.children}function b$3(n,l){this.props=n,this.context=l;}function m$4(n,l){if(null==l)return n.__?m$4(n.__,n.__i+1):null;for(var u;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e)return u.__e;return "function"==typeof n.type?m$4(n):null}function w$4(n){var l,u;if(null!=(n=n.__)&&null!=n.__c){for(n.__e=n.__c.base=null,l=0;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e){n.__e=n.__c.base=u.__e;break}return w$4(n)}}function k$4(n){(!n.__d&&(n.__d=!0)&&i$9.push(n)&&!x$3.__r++||o$b!==l$7.debounceRendering)&&((o$b=l$7.debounceRendering)||r$c)(x$3);}function x$3(){var n,u,t,o,r,e,c,s,a;for(i$9.sort(f$4);n=i$9.shift();)n.__d&&(u=i$9.length,o=void 0,e=(r=(t=n).__v).__e,s=[],a=[],(c=t.__P)&&((o=v$4({},r)).__v=r.__v+1,l$7.vnode&&l$7.vnode(o),F$3(c,o,r,t.__n,void 0!==c.ownerSVGElement,32&r.__u?[e]:null,s,null==e?m$4(r):e,!!(32&r.__u),a),o.__v=r.__v,o.__.__k[o.__i]=o,L$4(s,o,a),o.__e!=e&&w$4(o)),i$9.length>u&&i$9.sort(f$4));x$3.__r=0;}function C$4(n,l,u,t,i,o,r,f,e,a,h){var v,p,y,d,_,g=t&&t.__k||s$8,b=l.length;for(u.__d=e,P$3(u,l,g),e=u.__d,v=0;v<b;v++)null!=(y=u.__k[v])&&"boolean"!=typeof y&&"function"!=typeof y&&(p=-1===y.__i?c$8:g[y.__i]||c$8,y.__i=v,F$3(n,y,p,i,o,r,f,e,a,h),d=y.__e,y.ref&&p.ref!=y.ref&&(p.ref&&O$1(p.ref,null,y),h.push(y.ref,y.__c||d,y)),null==_&&null!=d&&(_=d),65536&y.__u||p.__k===y.__k?(d||p.__e!=e||(e=m$4(p)),e=S$6(y,e,n)):"function"==typeof y.type&&void 0!==y.__d?e=y.__d:d&&(e=d.nextSibling),y.__d=void 0,y.__u&=-196609);u.__d=e,u.__e=_;}function P$3(n,l,u){var t,i,o,r,f,e=l.length,c=u.length,s=c,a=0;for(n.__k=[],t=0;t<e;t++)r=t+a,null!=(i=n.__k[t]=null==(i=l[t])||"boolean"==typeof i||"function"==typeof i?null:"string"==typeof i||"number"==typeof i||"bigint"==typeof i||i.constructor==String?d$7(null,i,null,null,null):h$6(i)?d$7(g$4,{children:i},null,null,null):void 0===i.constructor&&i.__b>0?d$7(i.type,i.props,i.key,i.ref?i.ref:null,i.__v):i)?(i.__=n,i.__b=n.__b+1,f=I$3(i,u,r,s),i.__i=f,o=null,-1!==f&&(s--,(o=u[f])&&(o.__u|=131072)),null==o||null===o.__v?(-1==f&&a--,"function"!=typeof i.type&&(i.__u|=65536)):f!==r&&(f===r+1?a++:f>r?s>e-r?a+=f-r:a--:f<r?f==r-1&&(a=f-r):a=0,f!==t+a&&(i.__u|=65536))):(o=u[r])&&null==o.key&&o.__e&&0==(131072&o.__u)&&(o.__e==n.__d&&(n.__d=m$4(o)),j$4(o,o,!1),u[r]=null,s--);if(s)for(t=0;t<c;t++)null!=(o=u[t])&&0==(131072&o.__u)&&(o.__e==n.__d&&(n.__d=m$4(o)),j$4(o,o));}function S$6(n,l,u){var t,i;if("function"==typeof n.type){for(t=n.__k,i=0;t&&i<t.length;i++)t[i]&&(t[i].__=n,l=S$6(t[i],l,u));return l}n.__e!=l&&(u.insertBefore(n.__e,l||null),l=n.__e);do{l=l&&l.nextSibling;}while(null!=l&&8===l.nodeType);return l}function $$3(n,l){return l=l||[],null==n||"boolean"==typeof n||(h$6(n)?n.some(function(n){$$3(n,l);}):l.push(n)),l}function I$3(n,l,u,t){var i=n.key,o=n.type,r=u-1,f=u+1,e=l[u];if(null===e||e&&i==e.key&&o===e.type&&0==(131072&e.__u))return u;if(t>(null!=e&&0==(131072&e.__u)?1:0))for(;r>=0||f<l.length;){if(r>=0){if((e=l[r])&&0==(131072&e.__u)&&i==e.key&&o===e.type)return r;r--;}if(f<l.length){if((e=l[f])&&0==(131072&e.__u)&&i==e.key&&o===e.type)return f;f++;}}return -1}function H$3(n,l,u){"-"===l[0]?n.setProperty(l,null==u?"":u):n[l]=null==u?"":"number"!=typeof u||a$6.test(l)?u:u+"px";}function T$5(n,l,u,t,i){var o;n:if("style"===l)if("string"==typeof u)n.style.cssText=u;else {if("string"==typeof t&&(n.style.cssText=t=""),t)for(l in t)u&&l in u||H$3(n.style,l,"");if(u)for(l in u)t&&u[l]===t[l]||H$3(n.style,l,u[l]);}else if("o"===l[0]&&"n"===l[1])o=l!==(l=l.replace(/(PointerCapture)$|Capture$/i,"$1")),l=l.toLowerCase()in n||"onFocusOut"===l||"onFocusIn"===l?l.toLowerCase().slice(2):l.slice(2),n.l||(n.l={}),n.l[l+o]=u,u?t?u.u=t.u:(u.u=Date.now(),n.addEventListener(l,o?D$4:A$4,o)):n.removeEventListener(l,o?D$4:A$4,o);else {if(i)l=l.replace(/xlink(H|:h)/,"h").replace(/sName$/,"s");else if("width"!==l&&"height"!==l&&"href"!==l&&"list"!==l&&"form"!==l&&"tabIndex"!==l&&"download"!==l&&"rowSpan"!==l&&"colSpan"!==l&&"role"!==l&&l in n)try{n[l]=null==u?"":u;break n}catch(n){}"function"==typeof u||(null==u||!1===u&&"-"!==l[4]?n.removeAttribute(l):n.setAttribute(l,u));}}function A$4(n){if(this.l){var u=this.l[n.type+!1];if(n.t){if(n.t<=u.u)return}else n.t=Date.now();return u(l$7.event?l$7.event(n):n)}}function D$4(n){if(this.l)return this.l[n.type+!0](l$7.event?l$7.event(n):n)}function F$3(n,u,t,i,o,r,f,e,c,s){var a,p,y,d,_,m,w,k,x,P,S,$,I,H,T,A=u.type;if(void 0!==u.constructor)return null;128&t.__u&&(c=!!(32&t.__u),r=[e=u.__e=t.__e]),(a=l$7.__b)&&a(u);n:if("function"==typeof A)try{if(k=u.props,x=(a=A.contextType)&&i[a.__c],P=a?x?x.props.value:a.__:i,t.__c?w=(p=u.__c=t.__c).__=p.__E:("prototype"in A&&A.prototype.render?u.__c=p=new A(k,P):(u.__c=p=new b$3(k,P),p.constructor=A,p.render=z$3),x&&x.sub(p),p.props=k,p.state||(p.state={}),p.context=P,p.__n=i,y=p.__d=!0,p.__h=[],p._sb=[]),null==p.__s&&(p.__s=p.state),null!=A.getDerivedStateFromProps&&(p.__s==p.state&&(p.__s=v$4({},p.__s)),v$4(p.__s,A.getDerivedStateFromProps(k,p.__s))),d=p.props,_=p.state,p.__v=u,y)null==A.getDerivedStateFromProps&&null!=p.componentWillMount&&p.componentWillMount(),null!=p.componentDidMount&&p.__h.push(p.componentDidMount);else {if(null==A.getDerivedStateFromProps&&k!==d&&null!=p.componentWillReceiveProps&&p.componentWillReceiveProps(k,P),!p.__e&&(null!=p.shouldComponentUpdate&&!1===p.shouldComponentUpdate(k,p.__s,P)||u.__v===t.__v)){for(u.__v!==t.__v&&(p.props=k,p.state=p.__s,p.__d=!1),u.__e=t.__e,u.__k=t.__k,u.__k.forEach(function(n){n&&(n.__=u);}),S=0;S<p._sb.length;S++)p.__h.push(p._sb[S]);p._sb=[],p.__h.length&&f.push(p);break n}null!=p.componentWillUpdate&&p.componentWillUpdate(k,p.__s,P),null!=p.componentDidUpdate&&p.__h.push(function(){p.componentDidUpdate(d,_,m);});}if(p.context=P,p.props=k,p.__P=n,p.__e=!1,$=l$7.__r,I=0,"prototype"in A&&A.prototype.render){for(p.state=p.__s,p.__d=!1,$&&$(u),a=p.render(p.props,p.state,p.context),H=0;H<p._sb.length;H++)p.__h.push(p._sb[H]);p._sb=[];}else do{p.__d=!1,$&&$(u),a=p.render(p.props,p.state,p.context),p.state=p.__s;}while(p.__d&&++I<25);p.state=p.__s,null!=p.getChildContext&&(i=v$4(v$4({},i),p.getChildContext())),y||null==p.getSnapshotBeforeUpdate||(m=p.getSnapshotBeforeUpdate(d,_)),C$4(n,h$6(T=null!=a&&a.type===g$4&&null==a.key?a.props.children:a)?T:[T],u,t,i,o,r,f,e,c,s),p.base=u.__e,u.__u&=-161,p.__h.length&&f.push(p),w&&(p.__E=p.__=null);}catch(n){u.__v=null,c||null!=r?(u.__e=e,u.__u|=c?160:32,r[r.indexOf(e)]=null):(u.__e=t.__e,u.__k=t.__k),l$7.__e(n,u,t);}else null==r&&u.__v===t.__v?(u.__k=t.__k,u.__e=t.__e):u.__e=M$3(t.__e,u,t,i,o,r,f,c,s);(a=l$7.diffed)&&a(u);}function L$4(n,u,t){u.__d=void 0;for(var i=0;i<t.length;i++)O$1(t[i],t[++i],t[++i]);l$7.__c&&l$7.__c(u,n),n.some(function(u){try{n=u.__h,u.__h=[],n.some(function(n){n.call(u);});}catch(n){l$7.__e(n,u.__v);}});}function M$3(l,u,t,i,o,r,f,e,s){var a,v,y,d,_,g,b,w=t.props,k=u.props,x=u.type;if("svg"===x&&(o=!0),null!=r)for(a=0;a<r.length;a++)if((_=r[a])&&"setAttribute"in _==!!x&&(x?_.localName===x:3===_.nodeType)){l=_,r[a]=null;break}if(null==l){if(null===x)return document.createTextNode(k);l=o?document.createElementNS("http://www.w3.org/2000/svg",x):document.createElement(x,k.is&&k),r=null,e=!1;}if(null===x)w===k||e&&l.data===k||(l.data=k);else {if(r=r&&n$a.call(l.childNodes),w=t.props||c$8,!e&&null!=r)for(w={},a=0;a<l.attributes.length;a++)w[(_=l.attributes[a]).name]=_.value;for(a in w)_=w[a],"children"==a||("dangerouslySetInnerHTML"==a?y=_:"key"===a||a in k||T$5(l,a,null,_,o));for(a in k)_=k[a],"children"==a?d=_:"dangerouslySetInnerHTML"==a?v=_:"value"==a?g=_:"checked"==a?b=_:"key"===a||e&&"function"!=typeof _||w[a]===_||T$5(l,a,_,w[a],o);if(v)e||y&&(v.__html===y.__html||v.__html===l.innerHTML)||(l.innerHTML=v.__html),u.__k=[];else if(y&&(l.innerHTML=""),C$4(l,h$6(d)?d:[d],u,t,i,o&&"foreignObject"!==x,r,f,r?r[0]:t.__k&&m$4(t,0),e,s),null!=r)for(a=r.length;a--;)null!=r[a]&&p$5(r[a]);e||(a="value",void 0!==g&&(g!==l[a]||"progress"===x&&!g||"option"===x&&g!==w[a])&&T$5(l,a,g,w[a],!1),a="checked",void 0!==b&&b!==l[a]&&T$5(l,a,b,w[a],!1));}return l}function O$1(n,u,t){try{"function"==typeof n?n(u):n.current=u;}catch(n){l$7.__e(n,t);}}function j$4(n,u,t){var i,o;if(l$7.unmount&&l$7.unmount(n),(i=n.ref)&&(i.current&&i.current!==n.__e||O$1(i,null,u)),null!=(i=n.__c)){if(i.componentWillUnmount)try{i.componentWillUnmount();}catch(n){l$7.__e(n,u);}i.base=i.__P=null,n.__c=void 0;}if(i=n.__k)for(o=0;o<i.length;o++)i[o]&&j$4(i[o],u,t||"function"!=typeof n.type);t||null==n.__e||p$5(n.__e),n.__=n.__e=n.__d=void 0;}function z$3(n,l,u){return this.constructor(n,u)}function N$3(u,t,i){var o,r,f,e;l$7.__&&l$7.__(u,t),r=(o="function"==typeof i)?null:i&&i.__k||t.__k,f=[],e=[],F$3(t,u=(!o&&i||t).__k=y$5(g$4,null,[u]),r||c$8,c$8,void 0!==t.ownerSVGElement,!o&&i?[i]:r?null:t.firstChild?n$a.call(t.childNodes):null,f,!o&&i?i:r?r.__e:t.firstChild,o,e),L$4(f,u,e);}function q$3(n,l){N$3(n,l,q$3);}function B$4(l,u,t){var i,o,r,f,e=v$4({},l.props);for(r in l.type&&l.type.defaultProps&&(f=l.type.defaultProps),u)"key"==r?i=u[r]:"ref"==r?o=u[r]:e[r]=void 0===u[r]&&void 0!==f?f[r]:u[r];return arguments.length>2&&(e.children=arguments.length>3?n$a.call(arguments,2):t),d$7(l.type,e,i||l.key,o||l.ref,null)}function E$3(n,l){var u={__c:l="__cC"+e$a++,__:n,Consumer:function(n,l){return n.children(l)},Provider:function(n){var u,t;return this.getChildContext||(u=[],(t={})[l]=this,this.getChildContext=function(){return t},this.shouldComponentUpdate=function(n){this.props.value!==n.value&&u.some(function(n){n.__e=!0,k$4(n);});},this.sub=function(n){u.push(n);var l=n.componentWillUnmount;n.componentWillUnmount=function(){u.splice(u.indexOf(n),1),l&&l.call(n);};}),n.children}};return u.Provider.__=u.Consumer.contextType=u}n$a=s$8.slice,l$7={__e:function(n,l,u,t){for(var i,o,r;l=l.__;)if((i=l.__c)&&!i.__)try{if((o=i.constructor)&&null!=o.getDerivedStateFromError&&(i.setState(o.getDerivedStateFromError(n)),r=i.__d),null!=i.componentDidCatch&&(i.componentDidCatch(n,t||{}),r=i.__d),r)return i.__E=i}catch(l){n=l;}throw n}},u$5=0,t$9=function(n){return null!=n&&null==n.constructor},b$3.prototype.setState=function(n,l){var u;u=null!=this.__s&&this.__s!==this.state?this.__s:this.__s=v$4({},this.state),"function"==typeof n&&(n=n(v$4({},u),this.props)),n&&v$4(u,n),null!=n&&this.__v&&(l&&this._sb.push(l),k$4(this));},b$3.prototype.forceUpdate=function(n){this.__v&&(this.__e=!0,n&&this.__h.push(n),k$4(this));},b$3.prototype.render=g$4,i$9=[],r$c="function"==typeof Promise?Promise.prototype.then.bind(Promise.resolve()):setTimeout,f$4=function(n,l){return n.__v.__b-l.__v.__b},x$3.__r=0,e$a=0;

    var preact_module = /*#__PURE__*/Object.freeze({
        __proto__: null,
        Component: b$3,
        Fragment: g$4,
        cloneElement: B$4,
        createContext: E$3,
        createElement: y$5,
        createRef: _$5,
        h: y$5,
        hydrate: q$3,
        get isValidElement () { return t$9; },
        get options () { return l$7; },
        render: N$3,
        toChildArray: $$3
    });

    var require$$1$1 = /*@__PURE__*/getAugmentedNamespace(preact_module);

    var ConnectDialog$1 = {};

    function r$b(e){var t,f,n="";if("string"==typeof e||"number"==typeof e)n+=e;else if("object"==typeof e)if(Array.isArray(e))for(t=0;t<e.length;t++)e[t]&&(f=r$b(e[t]))&&(n&&(n+=" "),n+=f);else for(t in e)e[t]&&(n&&(n+=" "),n+=t);return n}function clsx(){for(var e,t,f=0,n="";f<arguments.length;)(e=arguments[f++])&&(t=r$b(e))&&(n&&(n+=" "),n+=t);return n}

    var clsx_m = /*#__PURE__*/Object.freeze({
        __proto__: null,
        clsx: clsx,
        default: clsx
    });

    var require$$0 = /*@__PURE__*/getAugmentedNamespace(clsx_m);

    var t$8,r$a,u$4,i$8,o$a=0,f$3=[],c$7=[],e$9=l$7,a$5=e$9.__b,v$3=e$9.__r,l$6=e$9.diffed,m$3=e$9.__c,s$7=e$9.unmount,d$6=e$9.__;function h$5(n,t){e$9.__h&&e$9.__h(r$a,n,o$a||t),o$a=0;var u=r$a.__H||(r$a.__H={__:[],__h:[]});return n>=u.__.length&&u.__.push({__V:c$7}),u.__[n]}function p$4(n){return o$a=1,y$4(D$3,n)}function y$4(n,u,i){var o=h$5(t$8++,2);if(o.t=n,!o.__c&&(o.__=[i?i(u):D$3(void 0,u),function(n){var t=o.__N?o.__N[0]:o.__[0],r=o.t(t,n);t!==r&&(o.__N=[r,o.__[1]],o.__c.setState({}));}],o.__c=r$a,!r$a.u)){var f=function(n,t,r){if(!o.__c.__H)return !0;var u=o.__c.__H.__.filter(function(n){return !!n.__c});if(u.every(function(n){return !n.__N}))return !c||c.call(this,n,t,r);var i=!1;return u.forEach(function(n){if(n.__N){var t=n.__[0];n.__=n.__N,n.__N=void 0,t!==n.__[0]&&(i=!0);}}),!(!i&&o.__c.props===n)&&(!c||c.call(this,n,t,r))};r$a.u=!0;var c=r$a.shouldComponentUpdate,e=r$a.componentWillUpdate;r$a.componentWillUpdate=function(n,t,r){if(this.__e){var u=c;c=void 0,f(n,t,r),c=u;}e&&e.call(this,n,t,r);},r$a.shouldComponentUpdate=f;}return o.__N||o.__}function _$4(n,u){var i=h$5(t$8++,3);!e$9.__s&&C$3(i.__H,u)&&(i.__=n,i.i=u,r$a.__H.__h.push(i));}function A$3(n,u){var i=h$5(t$8++,4);!e$9.__s&&C$3(i.__H,u)&&(i.__=n,i.i=u,r$a.__h.push(i));}function F$2(n){return o$a=5,q$2(function(){return {current:n}},[])}function T$4(n,t,r){o$a=6,A$3(function(){return "function"==typeof n?(n(t()),function(){return n(null)}):n?(n.current=t(),function(){return n.current=null}):void 0},null==r?r:r.concat(n));}function q$2(n,r){var u=h$5(t$8++,7);return C$3(u.__H,r)?(u.__V=n(),u.i=r,u.__h=n,u.__V):u.__}function x$2(n,t){return o$a=8,q$2(function(){return n},t)}function P$2(n){var u=r$a.context[n.__c],i=h$5(t$8++,9);return i.c=n,u?(null==i.__&&(i.__=!0,u.sub(r$a)),u.props.value):n.__}function V$3(n,t){e$9.useDebugValue&&e$9.useDebugValue(t?t(n):n);}function b$2(n){var u=h$5(t$8++,10),i=p$4();return u.__=n,r$a.componentDidCatch||(r$a.componentDidCatch=function(n,t){u.__&&u.__(n,t),i[1](n);}),[i[0],function(){i[1](void 0);}]}function g$3(){var n=h$5(t$8++,11);if(!n.__){for(var u=r$a.__v;null!==u&&!u.__m&&null!==u.__;)u=u.__;var i=u.__m||(u.__m=[0,0]);n.__="P"+i[0]+"-"+i[1]++;}return n.__}function j$3(){for(var n;n=f$3.shift();)if(n.__P&&n.__H)try{n.__H.__h.forEach(z$2),n.__H.__h.forEach(B$3),n.__H.__h=[];}catch(t){n.__H.__h=[],e$9.__e(t,n.__v);}}e$9.__b=function(n){r$a=null,a$5&&a$5(n);},e$9.__=function(n,t){n&&t.__k&&t.__k.__m&&(n.__m=t.__k.__m),d$6&&d$6(n,t);},e$9.__r=function(n){v$3&&v$3(n),t$8=0;var i=(r$a=n.__c).__H;i&&(u$4===r$a?(i.__h=[],r$a.__h=[],i.__.forEach(function(n){n.__N&&(n.__=n.__N),n.__V=c$7,n.__N=n.i=void 0;})):(i.__h.forEach(z$2),i.__h.forEach(B$3),i.__h=[],t$8=0)),u$4=r$a;},e$9.diffed=function(n){l$6&&l$6(n);var t=n.__c;t&&t.__H&&(t.__H.__h.length&&(1!==f$3.push(t)&&i$8===e$9.requestAnimationFrame||((i$8=e$9.requestAnimationFrame)||w$3)(j$3)),t.__H.__.forEach(function(n){n.i&&(n.__H=n.i),n.__V!==c$7&&(n.__=n.__V),n.i=void 0,n.__V=c$7;})),u$4=r$a=null;},e$9.__c=function(n,t){t.some(function(n){try{n.__h.forEach(z$2),n.__h=n.__h.filter(function(n){return !n.__||B$3(n)});}catch(r){t.some(function(n){n.__h&&(n.__h=[]);}),t=[],e$9.__e(r,n.__v);}}),m$3&&m$3(n,t);},e$9.unmount=function(n){s$7&&s$7(n);var t,r=n.__c;r&&r.__H&&(r.__H.__.forEach(function(n){try{z$2(n);}catch(n){t=n;}}),r.__H=void 0,t&&e$9.__e(t,r.__v));};var k$3="function"==typeof requestAnimationFrame;function w$3(n){var t,r=function(){clearTimeout(u),k$3&&cancelAnimationFrame(t),setTimeout(n);},u=setTimeout(r,100);k$3&&(t=requestAnimationFrame(r));}function z$2(n){var t=r$a,u=n.__c;"function"==typeof u&&(n.__c=void 0,u()),r$a=t;}function B$3(n){var t=r$a;n.__c=n.__(),r$a=t;}function C$3(n,t){return !n||n.length!==t.length||t.some(function(t,r){return t!==n[r]})}function D$3(n,t){return "function"==typeof t?t(n):t}

    var hooks_module = /*#__PURE__*/Object.freeze({
        __proto__: null,
        useCallback: x$2,
        useContext: P$2,
        useDebugValue: V$3,
        useEffect: _$4,
        useErrorBoundary: b$2,
        useId: g$3,
        useImperativeHandle: T$4,
        useLayoutEffect: A$3,
        useMemo: q$2,
        useReducer: y$4,
        useRef: F$2,
        useState: p$4
    });

    var require$$2 = /*@__PURE__*/getAugmentedNamespace(hooks_module);

    var ConnectContent$1 = {};

    var CloseIcon$1 = {};

    Object.defineProperty(CloseIcon$1, "__esModule", { value: true });
    CloseIcon$1.CloseIcon = void 0;
    const preact_1$c = require$$1$1;
    function CloseIcon(props) {
        return ((0, preact_1$c.h)("svg", Object.assign({ width: "40", height: "40", viewBox: "0 0 40 40", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, props),
            (0, preact_1$c.h)("path", { d: "M13.7677 13L12.3535 14.4142L18.3535 20.4142L12.3535 26.4142L13.7677 27.8284L19.7677 21.8284L25.7677 27.8284L27.1819 26.4142L21.1819 20.4142L27.1819 14.4142L25.7677 13L19.7677 19L13.7677 13Z" })));
    }
    CloseIcon$1.CloseIcon = CloseIcon;

    var CoinbaseWalletRound$1 = {};

    Object.defineProperty(CoinbaseWalletRound$1, "__esModule", { value: true });
    CoinbaseWalletRound$1.CoinbaseWalletRound = void 0;
    const preact_1$b = require$$1$1;
    function CoinbaseWalletRound(props) {
        return ((0, preact_1$b.h)("svg", Object.assign({ width: "28", height: "28", viewBox: "0 0 28 28", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, props),
            (0, preact_1$b.h)("circle", { cx: "14", cy: "14", r: "14", fill: "#0052FF" }),
            (0, preact_1$b.h)("path", { d: "M23.8521 14.0003C23.8521 19.455 19.455 23.8521 14.0003 23.8521C8.54559 23.8521 4.14844 19.455 4.14844 14.0003C4.14844 8.54559 8.54559 4.14844 14.0003 4.14844C19.455 4.14844 23.8521 8.54559 23.8521 14.0003Z", fill: "white" }),
            (0, preact_1$b.h)("path", { d: "M11.1855 12.5042C11.1855 12.0477 11.1855 11.7942 11.2835 11.642C11.3814 11.4899 11.4793 11.3377 11.6261 11.287C11.8219 11.1855 12.0178 11.1855 12.5073 11.1855H15.4934C15.983 11.1855 16.1788 11.1855 16.3746 11.287C16.5215 11.3884 16.6683 11.4899 16.7173 11.642C16.8152 11.8449 16.8152 12.0477 16.8152 12.5042V15.4965C16.8152 15.953 16.8152 16.2066 16.7173 16.3587C16.6194 16.5109 16.5215 16.663 16.3746 16.7137C16.1788 16.8152 15.983 16.8152 15.4934 16.8152H12.5073C12.0178 16.8152 11.8219 16.8152 11.6261 16.7137C11.4793 16.6123 11.3324 16.5109 11.2835 16.3587C11.1855 16.1558 11.1855 15.953 11.1855 15.4965V12.5042Z", fill: "#0052FF" })));
    }
    CoinbaseWalletRound$1.CoinbaseWalletRound = CoinbaseWalletRound;

    var QRCodeIcon$1 = {};

    Object.defineProperty(QRCodeIcon$1, "__esModule", { value: true });
    QRCodeIcon$1.QRCodeIcon = void 0;
    const preact_1$a = require$$1$1;
    function QRCodeIcon(props) {
        return ((0, preact_1$a.h)("svg", Object.assign({ width: "18", height: "18", viewBox: "0 0 24 24", xmlns: "http://www.w3.org/2000/svg" }, props),
            (0, preact_1$a.h)("path", { d: "M3 3V8.99939L5 8.99996V5H9V3H3Z" }),
            (0, preact_1$a.h)("path", { d: "M15 21L21 21V15.0006L19 15V19L15 19V21Z" }),
            (0, preact_1$a.h)("path", { d: "M21 9H19V5H15.0006L15 3H21V9Z" }),
            (0, preact_1$a.h)("path", { d: "M3 15V21H8.99939L8.99996 19H5L5 15H3Z" })));
    }
    QRCodeIcon$1.QRCodeIcon = QRCodeIcon;

    var QRCode$2 = {};

    /**
     * @fileoverview
     * - modified davidshimjs/qrcodejs library for use in node.js
     * - Using the 'QRCode for Javascript library'
     * - Fixed dataset of 'QRCode for Javascript library' for support full-spec.
     * - this library has no dependencies.
     *
     * @version 0.9.1 (2016-02-12)
     * @author davidshimjs, papnkukn
     * @see <a href="http://www.d-project.com/" target="_blank">http://www.d-project.com/</a>
     * @see <a href="http://jeromeetienne.github.com/jquery-qrcode/" target="_blank">http://jeromeetienne.github.com/jquery-qrcode/</a>
     * @see <a href="https://github.com/davidshimjs/qrcodejs" target="_blank">https://github.com/davidshimjs/qrcodejs</a>
     */

    //---------------------------------------------------------------------
    // QRCode for JavaScript
    //
    // Copyright (c) 2009 Kazuhiko Arase
    //
    // URL: http://www.d-project.com/
    //
    // Licensed under the MIT license:
    //   http://www.opensource.org/licenses/mit-license.php
    //
    // The word "QR Code" is registered trademark of
    // DENSO WAVE INCORPORATED
    //   http://www.denso-wave.com/qrcode/faqpatent-e.html
    //
    //---------------------------------------------------------------------
    function QR8bitByte(data) {
      this.mode = QRMode.MODE_8BIT_BYTE;
      this.data = data;
      this.parsedData = [];

      // Added to support UTF-8 Characters
      for (var i = 0, l = this.data.length; i < l; i++) {
        var byteArray = [];
        var code = this.data.charCodeAt(i);

        if (code > 0x10000) {
          byteArray[0] = 0xF0 | ((code & 0x1C0000) >>> 18);
          byteArray[1] = 0x80 | ((code & 0x3F000) >>> 12);
          byteArray[2] = 0x80 | ((code & 0xFC0) >>> 6);
          byteArray[3] = 0x80 | (code & 0x3F);
        } else if (code > 0x800) {
          byteArray[0] = 0xE0 | ((code & 0xF000) >>> 12);
          byteArray[1] = 0x80 | ((code & 0xFC0) >>> 6);
          byteArray[2] = 0x80 | (code & 0x3F);
        } else if (code > 0x80) {
          byteArray[0] = 0xC0 | ((code & 0x7C0) >>> 6);
          byteArray[1] = 0x80 | (code & 0x3F);
        } else {
          byteArray[0] = code;
        }

        this.parsedData.push(byteArray);
      }

      this.parsedData = Array.prototype.concat.apply([], this.parsedData);

      if (this.parsedData.length != this.data.length) {
        this.parsedData.unshift(191);
        this.parsedData.unshift(187);
        this.parsedData.unshift(239);
      }
    }

    QR8bitByte.prototype = {
      getLength: function (buffer) {
        return this.parsedData.length;
      },
      write: function (buffer) {
        for (var i = 0, l = this.parsedData.length; i < l; i++) {
          buffer.put(this.parsedData[i], 8);
        }
      }
    };

    function QRCodeModel(typeNumber, errorCorrectLevel) {
      this.typeNumber = typeNumber;
      this.errorCorrectLevel = errorCorrectLevel;
      this.modules = null;
      this.moduleCount = 0;
      this.dataCache = null;
      this.dataList = [];
    }

    QRCodeModel.prototype={addData:function(data){var newData=new QR8bitByte(data);this.dataList.push(newData);this.dataCache=null;},isDark:function(row,col){if(row<0||this.moduleCount<=row||col<0||this.moduleCount<=col){throw new Error(row+","+col);}
    return this.modules[row][col];},getModuleCount:function(){return this.moduleCount;},make:function(){this.makeImpl(false,this.getBestMaskPattern());},makeImpl:function(test,maskPattern){this.moduleCount=this.typeNumber*4+17;this.modules=new Array(this.moduleCount);for(var row=0;row<this.moduleCount;row++){this.modules[row]=new Array(this.moduleCount);for(var col=0;col<this.moduleCount;col++){this.modules[row][col]=null;}}
    this.setupPositionProbePattern(0,0);this.setupPositionProbePattern(this.moduleCount-7,0);this.setupPositionProbePattern(0,this.moduleCount-7);this.setupPositionAdjustPattern();this.setupTimingPattern();this.setupTypeInfo(test,maskPattern);if(this.typeNumber>=7){this.setupTypeNumber(test);}
    if(this.dataCache==null){this.dataCache=QRCodeModel.createData(this.typeNumber,this.errorCorrectLevel,this.dataList);}
    this.mapData(this.dataCache,maskPattern);},setupPositionProbePattern:function(row,col){for(var r=-1;r<=7;r++){if(row+r<=-1||this.moduleCount<=row+r)continue;for(var c=-1;c<=7;c++){if(col+c<=-1||this.moduleCount<=col+c)continue;if((0<=r&&r<=6&&(c==0||c==6))||(0<=c&&c<=6&&(r==0||r==6))||(2<=r&&r<=4&&2<=c&&c<=4)){this.modules[row+r][col+c]=true;}else {this.modules[row+r][col+c]=false;}}}},getBestMaskPattern:function(){var minLostPoint=0;var pattern=0;for(var i=0;i<8;i++){this.makeImpl(true,i);var lostPoint=QRUtil.getLostPoint(this);if(i==0||minLostPoint>lostPoint){minLostPoint=lostPoint;pattern=i;}}
    return pattern;},createMovieClip:function(target_mc,instance_name,depth){var qr_mc=target_mc.createEmptyMovieClip(instance_name,depth);var cs=1;this.make();for(var row=0;row<this.modules.length;row++){var y=row*cs;for(var col=0;col<this.modules[row].length;col++){var x=col*cs;var dark=this.modules[row][col];if(dark){qr_mc.beginFill(0,100);qr_mc.moveTo(x,y);qr_mc.lineTo(x+cs,y);qr_mc.lineTo(x+cs,y+cs);qr_mc.lineTo(x,y+cs);qr_mc.endFill();}}}
    return qr_mc;},setupTimingPattern:function(){for(var r=8;r<this.moduleCount-8;r++){if(this.modules[r][6]!=null){continue;}
    this.modules[r][6]=(r%2==0);}
    for(var c=8;c<this.moduleCount-8;c++){if(this.modules[6][c]!=null){continue;}
    this.modules[6][c]=(c%2==0);}},setupPositionAdjustPattern:function(){var pos=QRUtil.getPatternPosition(this.typeNumber);for(var i=0;i<pos.length;i++){for(var j=0;j<pos.length;j++){var row=pos[i];var col=pos[j];if(this.modules[row][col]!=null){continue;}
    for(var r=-2;r<=2;r++){for(var c=-2;c<=2;c++){if(r==-2||r==2||c==-2||c==2||(r==0&&c==0)){this.modules[row+r][col+c]=true;}else {this.modules[row+r][col+c]=false;}}}}}},setupTypeNumber:function(test){var bits=QRUtil.getBCHTypeNumber(this.typeNumber);for(var i=0;i<18;i++){var mod=(!test&&((bits>>i)&1)==1);this.modules[Math.floor(i/3)][i%3+this.moduleCount-8-3]=mod;}
    for(var i=0;i<18;i++){var mod=(!test&&((bits>>i)&1)==1);this.modules[i%3+this.moduleCount-8-3][Math.floor(i/3)]=mod;}},setupTypeInfo:function(test,maskPattern){var data=(this.errorCorrectLevel<<3)|maskPattern;var bits=QRUtil.getBCHTypeInfo(data);for(var i=0;i<15;i++){var mod=(!test&&((bits>>i)&1)==1);if(i<6){this.modules[i][8]=mod;}else if(i<8){this.modules[i+1][8]=mod;}else {this.modules[this.moduleCount-15+i][8]=mod;}}
    for(var i=0;i<15;i++){var mod=(!test&&((bits>>i)&1)==1);if(i<8){this.modules[8][this.moduleCount-i-1]=mod;}else if(i<9){this.modules[8][15-i-1+1]=mod;}else {this.modules[8][15-i-1]=mod;}}
    this.modules[this.moduleCount-8][8]=(!test);},mapData:function(data,maskPattern){var inc=-1;var row=this.moduleCount-1;var bitIndex=7;var byteIndex=0;for(var col=this.moduleCount-1;col>0;col-=2){if(col==6)col--;while(true){for(var c=0;c<2;c++){if(this.modules[row][col-c]==null){var dark=false;if(byteIndex<data.length){dark=(((data[byteIndex]>>>bitIndex)&1)==1);}
    var mask=QRUtil.getMask(maskPattern,row,col-c);if(mask){dark=!dark;}
    this.modules[row][col-c]=dark;bitIndex--;if(bitIndex==-1){byteIndex++;bitIndex=7;}}}
    row+=inc;if(row<0||this.moduleCount<=row){row-=inc;inc=-inc;break;}}}}};QRCodeModel.PAD0=0xEC;QRCodeModel.PAD1=0x11;QRCodeModel.createData=function(typeNumber,errorCorrectLevel,dataList){var rsBlocks=QRRSBlock.getRSBlocks(typeNumber,errorCorrectLevel);var buffer=new QRBitBuffer();for(var i=0;i<dataList.length;i++){var data=dataList[i];buffer.put(data.mode,4);buffer.put(data.getLength(),QRUtil.getLengthInBits(data.mode,typeNumber));data.write(buffer);}
    var totalDataCount=0;for(var i=0;i<rsBlocks.length;i++){totalDataCount+=rsBlocks[i].dataCount;}
    if(buffer.getLengthInBits()>totalDataCount*8){throw new Error("code length overflow. ("
    +buffer.getLengthInBits()
    +">"
    +totalDataCount*8
    +")");}
    if(buffer.getLengthInBits()+4<=totalDataCount*8){buffer.put(0,4);}
    while(buffer.getLengthInBits()%8!=0){buffer.putBit(false);}
    while(true){if(buffer.getLengthInBits()>=totalDataCount*8){break;}
    buffer.put(QRCodeModel.PAD0,8);if(buffer.getLengthInBits()>=totalDataCount*8){break;}
    buffer.put(QRCodeModel.PAD1,8);}
    return QRCodeModel.createBytes(buffer,rsBlocks);};QRCodeModel.createBytes=function(buffer,rsBlocks){var offset=0;var maxDcCount=0;var maxEcCount=0;var dcdata=new Array(rsBlocks.length);var ecdata=new Array(rsBlocks.length);for(var r=0;r<rsBlocks.length;r++){var dcCount=rsBlocks[r].dataCount;var ecCount=rsBlocks[r].totalCount-dcCount;maxDcCount=Math.max(maxDcCount,dcCount);maxEcCount=Math.max(maxEcCount,ecCount);dcdata[r]=new Array(dcCount);for(var i=0;i<dcdata[r].length;i++){dcdata[r][i]=0xff&buffer.buffer[i+offset];}
    offset+=dcCount;var rsPoly=QRUtil.getErrorCorrectPolynomial(ecCount);var rawPoly=new QRPolynomial(dcdata[r],rsPoly.getLength()-1);var modPoly=rawPoly.mod(rsPoly);ecdata[r]=new Array(rsPoly.getLength()-1);for(var i=0;i<ecdata[r].length;i++){var modIndex=i+modPoly.getLength()-ecdata[r].length;ecdata[r][i]=(modIndex>=0)?modPoly.get(modIndex):0;}}
    var totalCodeCount=0;for(var i=0;i<rsBlocks.length;i++){totalCodeCount+=rsBlocks[i].totalCount;}
    var data=new Array(totalCodeCount);var index=0;for(var i=0;i<maxDcCount;i++){for(var r=0;r<rsBlocks.length;r++){if(i<dcdata[r].length){data[index++]=dcdata[r][i];}}}
    for(var i=0;i<maxEcCount;i++){for(var r=0;r<rsBlocks.length;r++){if(i<ecdata[r].length){data[index++]=ecdata[r][i];}}}
    return data;};var QRMode={MODE_NUMBER:1<<0,MODE_ALPHA_NUM:1<<1,MODE_8BIT_BYTE:1<<2,MODE_KANJI:1<<3};var QRErrorCorrectLevel={L:1,M:0,Q:3,H:2};var QRMaskPattern={PATTERN000:0,PATTERN001:1,PATTERN010:2,PATTERN011:3,PATTERN100:4,PATTERN101:5,PATTERN110:6,PATTERN111:7};var QRUtil={PATTERN_POSITION_TABLE:[[],[6,18],[6,22],[6,26],[6,30],[6,34],[6,22,38],[6,24,42],[6,26,46],[6,28,50],[6,30,54],[6,32,58],[6,34,62],[6,26,46,66],[6,26,48,70],[6,26,50,74],[6,30,54,78],[6,30,56,82],[6,30,58,86],[6,34,62,90],[6,28,50,72,94],[6,26,50,74,98],[6,30,54,78,102],[6,28,54,80,106],[6,32,58,84,110],[6,30,58,86,114],[6,34,62,90,118],[6,26,50,74,98,122],[6,30,54,78,102,126],[6,26,52,78,104,130],[6,30,56,82,108,134],[6,34,60,86,112,138],[6,30,58,86,114,142],[6,34,62,90,118,146],[6,30,54,78,102,126,150],[6,24,50,76,102,128,154],[6,28,54,80,106,132,158],[6,32,58,84,110,136,162],[6,26,54,82,110,138,166],[6,30,58,86,114,142,170]],G15:(1<<10)|(1<<8)|(1<<5)|(1<<4)|(1<<2)|(1<<1)|(1<<0),G18:(1<<12)|(1<<11)|(1<<10)|(1<<9)|(1<<8)|(1<<5)|(1<<2)|(1<<0),G15_MASK:(1<<14)|(1<<12)|(1<<10)|(1<<4)|(1<<1),getBCHTypeInfo:function(data){var d=data<<10;while(QRUtil.getBCHDigit(d)-QRUtil.getBCHDigit(QRUtil.G15)>=0){d^=(QRUtil.G15<<(QRUtil.getBCHDigit(d)-QRUtil.getBCHDigit(QRUtil.G15)));}
    return ((data<<10)|d)^QRUtil.G15_MASK;},getBCHTypeNumber:function(data){var d=data<<12;while(QRUtil.getBCHDigit(d)-QRUtil.getBCHDigit(QRUtil.G18)>=0){d^=(QRUtil.G18<<(QRUtil.getBCHDigit(d)-QRUtil.getBCHDigit(QRUtil.G18)));}
    return (data<<12)|d;},getBCHDigit:function(data){var digit=0;while(data!=0){digit++;data>>>=1;}
    return digit;},getPatternPosition:function(typeNumber){return QRUtil.PATTERN_POSITION_TABLE[typeNumber-1];},getMask:function(maskPattern,i,j){switch(maskPattern){case QRMaskPattern.PATTERN000:return (i+j)%2==0;case QRMaskPattern.PATTERN001:return i%2==0;case QRMaskPattern.PATTERN010:return j%3==0;case QRMaskPattern.PATTERN011:return (i+j)%3==0;case QRMaskPattern.PATTERN100:return (Math.floor(i/2)+Math.floor(j/3))%2==0;case QRMaskPattern.PATTERN101:return (i*j)%2+(i*j)%3==0;case QRMaskPattern.PATTERN110:return ((i*j)%2+(i*j)%3)%2==0;case QRMaskPattern.PATTERN111:return ((i*j)%3+(i+j)%2)%2==0;default:throw new Error("bad maskPattern:"+maskPattern);}},getErrorCorrectPolynomial:function(errorCorrectLength){var a=new QRPolynomial([1],0);for(var i=0;i<errorCorrectLength;i++){a=a.multiply(new QRPolynomial([1,QRMath.gexp(i)],0));}
    return a;},getLengthInBits:function(mode,type){if(1<=type&&type<10){switch(mode){case QRMode.MODE_NUMBER:return 10;case QRMode.MODE_ALPHA_NUM:return 9;case QRMode.MODE_8BIT_BYTE:return 8;case QRMode.MODE_KANJI:return 8;default:throw new Error("mode:"+mode);}}else if(type<27){switch(mode){case QRMode.MODE_NUMBER:return 12;case QRMode.MODE_ALPHA_NUM:return 11;case QRMode.MODE_8BIT_BYTE:return 16;case QRMode.MODE_KANJI:return 10;default:throw new Error("mode:"+mode);}}else if(type<41){switch(mode){case QRMode.MODE_NUMBER:return 14;case QRMode.MODE_ALPHA_NUM:return 13;case QRMode.MODE_8BIT_BYTE:return 16;case QRMode.MODE_KANJI:return 12;default:throw new Error("mode:"+mode);}}else {throw new Error("type:"+type);}},getLostPoint:function(qrCode){var moduleCount=qrCode.getModuleCount();var lostPoint=0;for(var row=0;row<moduleCount;row++){for(var col=0;col<moduleCount;col++){var sameCount=0;var dark=qrCode.isDark(row,col);for(var r=-1;r<=1;r++){if(row+r<0||moduleCount<=row+r){continue;}
    for(var c=-1;c<=1;c++){if(col+c<0||moduleCount<=col+c){continue;}
    if(r==0&&c==0){continue;}
    if(dark==qrCode.isDark(row+r,col+c)){sameCount++;}}}
    if(sameCount>5){lostPoint+=(3+sameCount-5);}}}
    for(var row=0;row<moduleCount-1;row++){for(var col=0;col<moduleCount-1;col++){var count=0;if(qrCode.isDark(row,col))count++;if(qrCode.isDark(row+1,col))count++;if(qrCode.isDark(row,col+1))count++;if(qrCode.isDark(row+1,col+1))count++;if(count==0||count==4){lostPoint+=3;}}}
    for(var row=0;row<moduleCount;row++){for(var col=0;col<moduleCount-6;col++){if(qrCode.isDark(row,col)&&!qrCode.isDark(row,col+1)&&qrCode.isDark(row,col+2)&&qrCode.isDark(row,col+3)&&qrCode.isDark(row,col+4)&&!qrCode.isDark(row,col+5)&&qrCode.isDark(row,col+6)){lostPoint+=40;}}}
    for(var col=0;col<moduleCount;col++){for(var row=0;row<moduleCount-6;row++){if(qrCode.isDark(row,col)&&!qrCode.isDark(row+1,col)&&qrCode.isDark(row+2,col)&&qrCode.isDark(row+3,col)&&qrCode.isDark(row+4,col)&&!qrCode.isDark(row+5,col)&&qrCode.isDark(row+6,col)){lostPoint+=40;}}}
    var darkCount=0;for(var col=0;col<moduleCount;col++){for(var row=0;row<moduleCount;row++){if(qrCode.isDark(row,col)){darkCount++;}}}
    var ratio=Math.abs(100*darkCount/moduleCount/moduleCount-50)/5;lostPoint+=ratio*10;return lostPoint;}};var QRMath={glog:function(n){if(n<1){throw new Error("glog("+n+")");}
    return QRMath.LOG_TABLE[n];},gexp:function(n){while(n<0){n+=255;}
    while(n>=256){n-=255;}
    return QRMath.EXP_TABLE[n];},EXP_TABLE:new Array(256),LOG_TABLE:new Array(256)};for(var i$7=0;i$7<8;i$7++){QRMath.EXP_TABLE[i$7]=1<<i$7;}
    for(var i$7=8;i$7<256;i$7++){QRMath.EXP_TABLE[i$7]=QRMath.EXP_TABLE[i$7-4]^QRMath.EXP_TABLE[i$7-5]^QRMath.EXP_TABLE[i$7-6]^QRMath.EXP_TABLE[i$7-8];}
    for(var i$7=0;i$7<255;i$7++){QRMath.LOG_TABLE[QRMath.EXP_TABLE[i$7]]=i$7;}
    function QRPolynomial(num,shift){if(num.length==undefined){throw new Error(num.length+"/"+shift);}
    var offset=0;while(offset<num.length&&num[offset]==0){offset++;}
    this.num=new Array(num.length-offset+shift);for(var i=0;i<num.length-offset;i++){this.num[i]=num[i+offset];}}
    QRPolynomial.prototype={get:function(index){return this.num[index];},getLength:function(){return this.num.length;},multiply:function(e){var num=new Array(this.getLength()+e.getLength()-1);for(var i=0;i<this.getLength();i++){for(var j=0;j<e.getLength();j++){num[i+j]^=QRMath.gexp(QRMath.glog(this.get(i))+QRMath.glog(e.get(j)));}}
    return new QRPolynomial(num,0);},mod:function(e){if(this.getLength()-e.getLength()<0){return this;}
    var ratio=QRMath.glog(this.get(0))-QRMath.glog(e.get(0));var num=new Array(this.getLength());for(var i=0;i<this.getLength();i++){num[i]=this.get(i);}
    for(var i=0;i<e.getLength();i++){num[i]^=QRMath.gexp(QRMath.glog(e.get(i))+ratio);}
    return new QRPolynomial(num,0).mod(e);}};function QRRSBlock(totalCount,dataCount){this.totalCount=totalCount;this.dataCount=dataCount;}
    QRRSBlock.RS_BLOCK_TABLE=[[1,26,19],[1,26,16],[1,26,13],[1,26,9],[1,44,34],[1,44,28],[1,44,22],[1,44,16],[1,70,55],[1,70,44],[2,35,17],[2,35,13],[1,100,80],[2,50,32],[2,50,24],[4,25,9],[1,134,108],[2,67,43],[2,33,15,2,34,16],[2,33,11,2,34,12],[2,86,68],[4,43,27],[4,43,19],[4,43,15],[2,98,78],[4,49,31],[2,32,14,4,33,15],[4,39,13,1,40,14],[2,121,97],[2,60,38,2,61,39],[4,40,18,2,41,19],[4,40,14,2,41,15],[2,146,116],[3,58,36,2,59,37],[4,36,16,4,37,17],[4,36,12,4,37,13],[2,86,68,2,87,69],[4,69,43,1,70,44],[6,43,19,2,44,20],[6,43,15,2,44,16],[4,101,81],[1,80,50,4,81,51],[4,50,22,4,51,23],[3,36,12,8,37,13],[2,116,92,2,117,93],[6,58,36,2,59,37],[4,46,20,6,47,21],[7,42,14,4,43,15],[4,133,107],[8,59,37,1,60,38],[8,44,20,4,45,21],[12,33,11,4,34,12],[3,145,115,1,146,116],[4,64,40,5,65,41],[11,36,16,5,37,17],[11,36,12,5,37,13],[5,109,87,1,110,88],[5,65,41,5,66,42],[5,54,24,7,55,25],[11,36,12],[5,122,98,1,123,99],[7,73,45,3,74,46],[15,43,19,2,44,20],[3,45,15,13,46,16],[1,135,107,5,136,108],[10,74,46,1,75,47],[1,50,22,15,51,23],[2,42,14,17,43,15],[5,150,120,1,151,121],[9,69,43,4,70,44],[17,50,22,1,51,23],[2,42,14,19,43,15],[3,141,113,4,142,114],[3,70,44,11,71,45],[17,47,21,4,48,22],[9,39,13,16,40,14],[3,135,107,5,136,108],[3,67,41,13,68,42],[15,54,24,5,55,25],[15,43,15,10,44,16],[4,144,116,4,145,117],[17,68,42],[17,50,22,6,51,23],[19,46,16,6,47,17],[2,139,111,7,140,112],[17,74,46],[7,54,24,16,55,25],[34,37,13],[4,151,121,5,152,122],[4,75,47,14,76,48],[11,54,24,14,55,25],[16,45,15,14,46,16],[6,147,117,4,148,118],[6,73,45,14,74,46],[11,54,24,16,55,25],[30,46,16,2,47,17],[8,132,106,4,133,107],[8,75,47,13,76,48],[7,54,24,22,55,25],[22,45,15,13,46,16],[10,142,114,2,143,115],[19,74,46,4,75,47],[28,50,22,6,51,23],[33,46,16,4,47,17],[8,152,122,4,153,123],[22,73,45,3,74,46],[8,53,23,26,54,24],[12,45,15,28,46,16],[3,147,117,10,148,118],[3,73,45,23,74,46],[4,54,24,31,55,25],[11,45,15,31,46,16],[7,146,116,7,147,117],[21,73,45,7,74,46],[1,53,23,37,54,24],[19,45,15,26,46,16],[5,145,115,10,146,116],[19,75,47,10,76,48],[15,54,24,25,55,25],[23,45,15,25,46,16],[13,145,115,3,146,116],[2,74,46,29,75,47],[42,54,24,1,55,25],[23,45,15,28,46,16],[17,145,115],[10,74,46,23,75,47],[10,54,24,35,55,25],[19,45,15,35,46,16],[17,145,115,1,146,116],[14,74,46,21,75,47],[29,54,24,19,55,25],[11,45,15,46,46,16],[13,145,115,6,146,116],[14,74,46,23,75,47],[44,54,24,7,55,25],[59,46,16,1,47,17],[12,151,121,7,152,122],[12,75,47,26,76,48],[39,54,24,14,55,25],[22,45,15,41,46,16],[6,151,121,14,152,122],[6,75,47,34,76,48],[46,54,24,10,55,25],[2,45,15,64,46,16],[17,152,122,4,153,123],[29,74,46,14,75,47],[49,54,24,10,55,25],[24,45,15,46,46,16],[4,152,122,18,153,123],[13,74,46,32,75,47],[48,54,24,14,55,25],[42,45,15,32,46,16],[20,147,117,4,148,118],[40,75,47,7,76,48],[43,54,24,22,55,25],[10,45,15,67,46,16],[19,148,118,6,149,119],[18,75,47,31,76,48],[34,54,24,34,55,25],[20,45,15,61,46,16]];QRRSBlock.getRSBlocks=function(typeNumber,errorCorrectLevel){var rsBlock=QRRSBlock.getRsBlockTable(typeNumber,errorCorrectLevel);if(rsBlock==undefined){throw new Error("bad rs block @ typeNumber:"+typeNumber+"/errorCorrectLevel:"+errorCorrectLevel);}
    var length=rsBlock.length/3;var list=[];for(var i=0;i<length;i++){var count=rsBlock[i*3+0];var totalCount=rsBlock[i*3+1];var dataCount=rsBlock[i*3+2];for(var j=0;j<count;j++){list.push(new QRRSBlock(totalCount,dataCount));}}
    return list;};QRRSBlock.getRsBlockTable=function(typeNumber,errorCorrectLevel){switch(errorCorrectLevel){case QRErrorCorrectLevel.L:return QRRSBlock.RS_BLOCK_TABLE[(typeNumber-1)*4+0];case QRErrorCorrectLevel.M:return QRRSBlock.RS_BLOCK_TABLE[(typeNumber-1)*4+1];case QRErrorCorrectLevel.Q:return QRRSBlock.RS_BLOCK_TABLE[(typeNumber-1)*4+2];case QRErrorCorrectLevel.H:return QRRSBlock.RS_BLOCK_TABLE[(typeNumber-1)*4+3];default:return undefined;}};function QRBitBuffer(){this.buffer=[];this.length=0;}
    QRBitBuffer.prototype={get:function(index){var bufIndex=Math.floor(index/8);return ((this.buffer[bufIndex]>>>(7-index%8))&1)==1;},put:function(num,length){for(var i=0;i<length;i++){this.putBit(((num>>>(length-i-1))&1)==1);}},getLengthInBits:function(){return this.length;},putBit:function(bit){var bufIndex=Math.floor(this.length/8);if(this.buffer.length<=bufIndex){this.buffer.push(0);}
    if(bit){this.buffer[bufIndex]|=(0x80>>>(this.length%8));}
    this.length++;}};var QRCodeLimitLength=[[17,14,11,7],[32,26,20,14],[53,42,32,24],[78,62,46,34],[106,84,60,44],[134,106,74,58],[154,122,86,64],[192,152,108,84],[230,180,130,98],[271,213,151,119],[321,251,177,137],[367,287,203,155],[425,331,241,177],[458,362,258,194],[520,412,292,220],[586,450,322,250],[644,504,364,280],[718,560,394,310],[792,624,442,338],[858,666,482,382],[929,711,509,403],[1003,779,565,439],[1091,857,611,461],[1171,911,661,511],[1273,997,715,535],[1367,1059,751,593],[1465,1125,805,625],[1528,1190,868,658],[1628,1264,908,698],[1732,1370,982,742],[1840,1452,1030,790],[1952,1538,1112,842],[2068,1628,1168,898],[2188,1722,1228,958],[2303,1809,1283,983],[2431,1911,1351,1051],[2563,1989,1423,1093],[2699,2099,1499,1139],[2809,2213,1579,1219],[2953,2331,1663,1273]];


    /** Constructor */
    function QRCode$1(options) {

      //Default options
      this.options = {
        padding: 4,
        width: 256,
        height: 256,
        typeNumber: 4,
        color: "#000000",
        background: "#ffffff",
        ecl: "M",
        image:{
          svg:"",
          width:0,
          height:0
        }
      };

      //In case the options is string
      if (typeof options === 'string') {
        options = {
          content: options
        };
      }

      //Merge options
      if (options) {
        for (var i in options) {
          this.options[i] = options[i];
        }
      }

      if (typeof this.options.content !== 'string') {
        throw new Error("Expected 'content' as string!");
      }

      if (this.options.content.length === 0 /* || this.options.content.length > 7089 */) {
        throw new Error("Expected 'content' to be non-empty!");
      }

      if (!(this.options.padding >= 0)) {
        throw new Error("Expected 'padding' value to be non-negative!");
      }

      if (!(this.options.width > 0) || !(this.options.height > 0)) {
        throw new Error("Expected 'width' or 'height' value to be higher than zero!");
      }

      //Gets the error correction level
      function _getErrorCorrectLevel(ecl) {
        switch (ecl) {
            case "L":
              return QRErrorCorrectLevel.L;

            case "M":
              return QRErrorCorrectLevel.M;

            case "Q":
              return QRErrorCorrectLevel.Q;

            case "H":
              return QRErrorCorrectLevel.H;

            default:
              throw new Error("Unknwon error correction level: " + ecl);
          }
      }

      //Get type number
      function _getTypeNumber(content, ecl) {
        var length = _getUTF8Length(content);

        var type = 1;
        var limit = 0;
        for (var i = 0, len = QRCodeLimitLength.length; i <= len; i++) {
          var table = QRCodeLimitLength[i];
          if (!table) {
            throw new Error("Content too long: expected " + limit + " but got " + length);
          }

          switch (ecl) {
            case "L":
              limit = table[0];
              break;

            case "M":
              limit = table[1];
              break;

            case "Q":
              limit = table[2];
              break;

            case "H":
              limit = table[3];
              break;

            default:
              throw new Error("Unknwon error correction level: " + ecl);
          }

          if (length <= limit) {
            break;
          }

          type++;
        }

        if (type > QRCodeLimitLength.length) {
          throw new Error("Content too long");
        }

        return type;
      }

      //Gets text length
      function _getUTF8Length(content) {
        var result = encodeURI(content).toString().replace(/\%[0-9a-fA-F]{2}/g, 'a');
        return result.length + (result.length != content ? 3 : 0);
      }

      //Generate QR Code matrix
      var content = this.options.content;
      var type = _getTypeNumber(content, this.options.ecl);
      var ecl = _getErrorCorrectLevel(this.options.ecl);
      this.qrcode = new QRCodeModel(type, ecl);
      this.qrcode.addData(content);
      this.qrcode.make();
    }

    /** Generates QR Code as SVG image */
    QRCode$1.prototype.svg = function(opt) {
      var options = this.options || { };
      var modules = this.qrcode.modules;

      if (typeof opt == "undefined") {
        opt = { container: options.container || "svg" };
      }

      //Apply new lines and indents in SVG?
      var pretty = typeof options.pretty != "undefined" ? !!options.pretty : true;

      var indent = pretty ? '  ' : '';
      var EOL = pretty ? '\r\n' : '';
      var width = options.width;
      var height = options.height;
      var length = modules.length;
      var xsize = width / (length + 2 * options.padding);
      var ysize = height / (length + 2 * options.padding);

      //Join (union, merge) rectangles into one shape?
      var join = typeof options.join != "undefined" ? !!options.join : false;

      //Swap the X and Y modules, pull request #2
      var swap = typeof options.swap != "undefined" ? !!options.swap : false;

      //Apply <?xml...?> declaration in SVG?
      var xmlDeclaration = typeof options.xmlDeclaration != "undefined" ? !!options.xmlDeclaration : true;

      //Populate with predefined shape instead of "rect" elements, thanks to @kkocdko
      var predefined = typeof options.predefined != "undefined" ? !!options.predefined : false;
      var defs = predefined ? indent + '<defs><path id="qrmodule" d="M0 0 h' + ysize + ' v' + xsize + ' H0 z" style="fill:' + options.color + ';shape-rendering:crispEdges;" /></defs>' + EOL : '';

      //Background rectangle
      var bgrect = indent + '<rect x="0" y="0" width="' + width + '" height="' + height + '" style="fill:' + options.background + ';shape-rendering:crispEdges;"/>' + EOL;

      //Rectangles representing modules
      var modrect = '';
      var pathdata = '';

      for (var y = 0; y < length; y++) {
        for (var x = 0; x < length; x++) {
          var module = modules[x][y];
          if (module) {

            var px = (x * xsize + options.padding * xsize);
            var py = (y * ysize + options.padding * ysize);

            //Some users have had issues with the QR Code, thanks to @danioso for the solution
            if (swap) {
              var t = px;
              px = py;
              py = t;
            }

            if (join) {
              //Module as a part of svg path data, thanks to @danioso
              var w = xsize + px;
              var h = ysize + py;

              px = (Number.isInteger(px))? Number(px): px.toFixed(2);
              py = (Number.isInteger(py))? Number(py): py.toFixed(2);
              w = (Number.isInteger(w))? Number(w): w.toFixed(2);
              h = (Number.isInteger(h))? Number(h): h.toFixed(2);

              pathdata += ('M' + px + ',' + py + ' V' + h + ' H' + w + ' V' + py + ' H' + px + ' Z ');
            }
            else if (predefined) {
              //Module as a predefined shape, thanks to @kkocdko
              modrect += indent + '<use x="' + px.toString() + '" y="' + py.toString() + '" href="#qrmodule" />' + EOL;
            }
            else {
              //Module as rectangle element
              modrect += indent + '<rect x="' + px.toString() + '" y="' + py.toString() + '" width="' + xsize + '" height="' + ysize + '" style="fill:' + options.color + ';shape-rendering:crispEdges;"/>' + EOL;
            }
          }
        }
      }

      if (join) {
        modrect = indent + '<path x="0" y="0" style="fill:' + options.color + ';shape-rendering:crispEdges;" d="' + pathdata + '" />';
      }
      let imgSvg = "";
      if(this.options.image !== undefined && this.options.image.svg){
        const imgWidth = width * this.options.image.width / 100;
        const imgHeight = height * this.options.image.height / 100;
        const imgX = (width/2) - imgWidth/2;
        const imgY = (height/2) - imgHeight/2;
        imgSvg += `<svg x="${imgX}" y="${imgY}" width="${imgWidth}" height="${imgHeight}" viewBox="0 0 100 100" preserveAspectRatio="xMinYMin meet">`;
        imgSvg += this.options.image.svg + EOL;
        imgSvg += '</svg>';
      }

      var svg = "";
      switch (opt.container) {
        //Wrapped in SVG document
        case "svg":
          if (xmlDeclaration) {
            svg += '<?xml version="1.0" standalone="yes"?>' + EOL;
          }
          svg += '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="' + width + '" height="' + height + '">' + EOL;
          svg += defs + bgrect + modrect;
          svg += imgSvg;
          svg += '</svg>';
          break;

        //Viewbox for responsive use in a browser, thanks to @danioso
        case "svg-viewbox":
          if (xmlDeclaration) {
            svg += '<?xml version="1.0" standalone="yes"?>' + EOL;
          }
          svg += '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 ' + width + ' ' + height + '">' + EOL;
          svg += defs + bgrect + modrect;
          svg += imgSvg;
          svg += '</svg>';
          break;


        //Wrapped in group element
        case "g":
          svg += '<g width="' + width + '" height="' + height + '">' + EOL;
          svg += defs + bgrect + modrect;
          svg += imgSvg;
          svg += '</g>';

          break;

        //Without a container
        default:
          svg += (defs + bgrect + modrect + imgSvg).replace(/^\s+/, ""); //Clear indents on each line
          break;
      }

      return svg;
    };

    var qrcodeSvg = QRCode$1;

    // Copyright (c) 2018-2023 Coinbase, Inc. <https://www.coinbase.com/>
    // Licensed under the Apache License, version 2.0
    var __importDefault$b = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };
    Object.defineProperty(QRCode$2, "__esModule", { value: true });
    QRCode$2.QRCode = void 0;
    const preact_1$9 = require$$1$1;
    const hooks_1$2 = require$$2;
    const qrcode_svg_1 = __importDefault$b(qrcodeSvg);
    const QRCode = (props) => {
        const [svg, setSvg] = (0, hooks_1$2.useState)('');
        (0, hooks_1$2.useEffect)(() => {
            var _a, _b;
            const qrcode = new qrcode_svg_1.default({
                content: props.content,
                background: props.bgColor || '#ffffff',
                color: props.fgColor || '#000000',
                container: 'svg',
                ecl: 'M',
                width: (_a = props.width) !== null && _a !== void 0 ? _a : 256,
                height: (_b = props.height) !== null && _b !== void 0 ? _b : 256,
                padding: 0,
                image: props.image,
            });
            const base64 = Buffer$8.from(qrcode.svg(), 'utf8').toString('base64');
            setSvg(`data:image/svg+xml;base64,${base64}`);
        }, [props.bgColor, props.content, props.fgColor, props.height, props.image, props.width]);
        return svg ? (0, preact_1$9.h)("img", { src: svg, alt: "QR Code" }) : null;
    };
    QRCode$2.QRCode = QRCode;

    var Spinner$1 = {};

    var SpinnerCss = {};

    Object.defineProperty(SpinnerCss, "__esModule", { value: true });
    SpinnerCss.default = (() => `.-cbwsdk-css-reset .-cbwsdk-spinner{display:inline-block}.-cbwsdk-css-reset .-cbwsdk-spinner svg{display:inline-block;animation:2s linear infinite -cbwsdk-spinner-svg}.-cbwsdk-css-reset .-cbwsdk-spinner svg circle{animation:1.9s ease-in-out infinite both -cbwsdk-spinner-circle;display:block;fill:rgba(0,0,0,0);stroke-dasharray:283;stroke-dashoffset:280;stroke-linecap:round;stroke-width:10px;transform-origin:50% 50%}@keyframes -cbwsdk-spinner-svg{0%{transform:rotateZ(0deg)}100%{transform:rotateZ(360deg)}}@keyframes -cbwsdk-spinner-circle{0%,25%{stroke-dashoffset:280;transform:rotate(0)}50%,75%{stroke-dashoffset:75;transform:rotate(45deg)}100%{stroke-dashoffset:280;transform:rotate(360deg)}}`)();

    // Copyright (c) 2018-2023 Coinbase, Inc. <https://www.coinbase.com/>
    // Licensed under the Apache License, version 2.0
    var __importDefault$a = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };
    Object.defineProperty(Spinner$1, "__esModule", { value: true });
    Spinner$1.Spinner = void 0;
    const preact_1$8 = require$$1$1;
    const Spinner_css_1 = __importDefault$a(SpinnerCss);
    const Spinner = (props) => {
        var _a;
        const size = (_a = props.size) !== null && _a !== void 0 ? _a : 64;
        const color = props.color || '#000';
        return ((0, preact_1$8.h)("div", { class: "-cbwsdk-spinner" },
            (0, preact_1$8.h)("style", null, Spinner_css_1.default),
            (0, preact_1$8.h)("svg", { viewBox: "0 0 100 100", xmlns: "http://www.w3.org/2000/svg", style: { width: size, height: size } },
                (0, preact_1$8.h)("circle", { style: { cx: 50, cy: 50, r: 45, stroke: color } }))));
    };
    Spinner$1.Spinner = Spinner;

    var ConnectContentCss = {};

    Object.defineProperty(ConnectContentCss, "__esModule", { value: true });
    ConnectContentCss.default = (() => `.-cbwsdk-css-reset .-cbwsdk-connect-content{height:430px;width:700px;border-radius:12px;padding:30px}.-cbwsdk-css-reset .-cbwsdk-connect-content.light{background:#fff}.-cbwsdk-css-reset .-cbwsdk-connect-content.dark{background:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-connect-content-header{display:flex;align-items:center;justify-content:space-between;margin:0 0 30px}.-cbwsdk-css-reset .-cbwsdk-connect-content-heading{font-style:normal;font-weight:500;font-size:28px;line-height:36px;margin:0}.-cbwsdk-css-reset .-cbwsdk-connect-content-heading.light{color:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-connect-content-heading.dark{color:#fff}.-cbwsdk-css-reset .-cbwsdk-connect-content-layout{display:flex;flex-direction:row}.-cbwsdk-css-reset .-cbwsdk-connect-content-column-left{margin-right:30px;display:flex;flex-direction:column;justify-content:space-between}.-cbwsdk-css-reset .-cbwsdk-connect-content-column-right{flex:25%;margin-right:34px}.-cbwsdk-css-reset .-cbwsdk-connect-content-qr-wrapper{width:220px;height:220px;border-radius:12px;display:flex;justify-content:center;align-items:center;background:#fff}.-cbwsdk-css-reset .-cbwsdk-connect-content-qr-connecting{position:absolute;top:0;bottom:0;left:0;right:0;display:flex;flex-direction:column;align-items:center;justify-content:center}.-cbwsdk-css-reset .-cbwsdk-connect-content-qr-connecting.light{background-color:rgba(255,255,255,.95)}.-cbwsdk-css-reset .-cbwsdk-connect-content-qr-connecting.light>p{color:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-connect-content-qr-connecting.dark{background-color:rgba(10,11,13,.9)}.-cbwsdk-css-reset .-cbwsdk-connect-content-qr-connecting.dark>p{color:#fff}.-cbwsdk-css-reset .-cbwsdk-connect-content-qr-connecting>p{font-size:12px;font-weight:bold;margin-top:16px}.-cbwsdk-css-reset .-cbwsdk-connect-content-update-app{border-radius:8px;font-size:14px;line-height:20px;padding:12px;width:339px}.-cbwsdk-css-reset .-cbwsdk-connect-content-update-app.light{background:#eef0f3;color:#5b636e}.-cbwsdk-css-reset .-cbwsdk-connect-content-update-app.dark{background:#1e2025;color:#8a919e}.-cbwsdk-css-reset .-cbwsdk-cancel-button{-webkit-appearance:none;border:none;background:none;cursor:pointer;padding:0;margin:0}.-cbwsdk-css-reset .-cbwsdk-cancel-button-x{position:relative;display:block;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-wallet-steps{padding:0 0 0 16px;margin:0;width:100%;list-style:decimal}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-item{list-style-type:decimal;display:list-item;font-style:normal;font-weight:400;font-size:16px;line-height:24px;margin-top:20px}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-item.light{color:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-item.dark{color:#fff}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-item-wrapper{display:flex;align-items:center}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-pad-left{margin-left:6px}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-icon{display:flex;border-radius:50%;height:24px;width:24px}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-icon svg{margin:auto;display:block}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-icon.light{background:#0052ff}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-icon.dark{background:#588af5}.-cbwsdk-css-reset .-cbwsdk-connect-item{align-items:center;display:flex;flex-direction:row;padding:16px 24px;gap:12px;cursor:pointer;border-radius:100px;font-weight:600}.-cbwsdk-css-reset .-cbwsdk-connect-item.light{background:#f5f8ff;color:#0052ff}.-cbwsdk-css-reset .-cbwsdk-connect-item.dark{background:#001033;color:#588af5}.-cbwsdk-css-reset .-cbwsdk-connect-item-copy-wrapper{margin:0 4px 0 8px}.-cbwsdk-css-reset .-cbwsdk-connect-item-title{margin:0 0 0;font-size:16px;line-height:24px;font-weight:500}.-cbwsdk-css-reset .-cbwsdk-connect-item-description{font-weight:400;font-size:14px;line-height:20px;margin:0}`)();

    // Copyright (c) 2018-2023 Coinbase, Inc. <https://www.coinbase.com/>
    // Licensed under the Apache License, version 2.0
    var __importDefault$9 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };
    Object.defineProperty(ConnectContent$1, "__esModule", { value: true });
    ConnectContent$1.CoinbaseWalletSteps = ConnectContent$1.ConnectContent = void 0;
    const clsx_1$3 = __importDefault$9(require$$0);
    const preact_1$7 = require$$1$1;
    const util_1$6 = util$3;
    const version_1$1 = version;
    const CloseIcon_1 = CloseIcon$1;
    const CoinbaseWalletRound_1 = CoinbaseWalletRound$1;
    const QRCodeIcon_1 = QRCodeIcon$1;
    const QRCode_1 = QRCode$2;
    const Spinner_1 = Spinner$1;
    const ConnectContent_css_1 = __importDefault$9(ConnectContentCss);
    const wallet = {
        title: 'Coinbase Wallet app',
        description: 'Connect with your self-custody wallet',
        steps: CoinbaseWalletSteps,
    };
    const makeIconColor = (theme) => {
        return theme === 'light' ? '#FFFFFF' : '#0A0B0D';
    };
    function ConnectContent(props) {
        const { theme } = props;
        const qrUrl = (0, util_1$6.createQrUrl)(props.sessionId, props.sessionSecret, props.linkAPIUrl, props.isParentConnection, props.version, props.chainId);
        const WalletSteps = wallet.steps;
        return ((0, preact_1$7.h)("div", { "data-testid": "connect-content", className: (0, clsx_1$3.default)('-cbwsdk-connect-content', theme) },
            (0, preact_1$7.h)("style", null, ConnectContent_css_1.default),
            (0, preact_1$7.h)("div", { className: "-cbwsdk-connect-content-header" },
                (0, preact_1$7.h)("h2", { className: (0, clsx_1$3.default)('-cbwsdk-connect-content-heading', theme) }, "Scan to connect with our mobile app"),
                props.onCancel && ((0, preact_1$7.h)("button", { type: "button", className: '-cbwsdk-cancel-button', onClick: props.onCancel },
                    (0, preact_1$7.h)(CloseIcon_1.CloseIcon, { fill: theme === 'light' ? '#0A0B0D' : '#FFFFFF' })))),
            (0, preact_1$7.h)("div", { className: "-cbwsdk-connect-content-layout" },
                (0, preact_1$7.h)("div", { className: "-cbwsdk-connect-content-column-left" },
                    (0, preact_1$7.h)(ConnectItem, { title: wallet.title, description: wallet.description, theme: theme })),
                (0, preact_1$7.h)("div", { className: "-cbwsdk-connect-content-column-right" },
                    (0, preact_1$7.h)("div", { className: "-cbwsdk-connect-content-qr-wrapper" },
                        (0, preact_1$7.h)(QRCode_1.QRCode, { content: qrUrl, width: 200, height: 200, fgColor: "#000", bgColor: "transparent" }),
                        (0, preact_1$7.h)("input", { type: "hidden", name: "cbw-cbwsdk-version", value: version_1$1.LIB_VERSION }),
                        (0, preact_1$7.h)("input", { type: "hidden", value: qrUrl })),
                    (0, preact_1$7.h)(WalletSteps, { theme: theme }),
                    !props.isConnected && ((0, preact_1$7.h)("div", { "data-testid": "connecting-spinner", className: (0, clsx_1$3.default)('-cbwsdk-connect-content-qr-connecting', theme) },
                        (0, preact_1$7.h)(Spinner_1.Spinner, { size: 36, color: theme === 'dark' ? '#FFF' : '#000' }),
                        (0, preact_1$7.h)("p", null, "Connecting...")))))));
    }
    ConnectContent$1.ConnectContent = ConnectContent;
    function ConnectItem({ title, description, theme }) {
        return ((0, preact_1$7.h)("div", { className: (0, clsx_1$3.default)('-cbwsdk-connect-item', theme) },
            (0, preact_1$7.h)("div", null,
                (0, preact_1$7.h)(CoinbaseWalletRound_1.CoinbaseWalletRound, null)),
            (0, preact_1$7.h)("div", { className: "-cbwsdk-connect-item-copy-wrapper" },
                (0, preact_1$7.h)("h3", { className: "-cbwsdk-connect-item-title" }, title),
                (0, preact_1$7.h)("p", { className: "-cbwsdk-connect-item-description" }, description))));
    }
    function CoinbaseWalletSteps({ theme }) {
        return ((0, preact_1$7.h)("ol", { className: "-cbwsdk-wallet-steps" },
            (0, preact_1$7.h)("li", { className: (0, clsx_1$3.default)('-cbwsdk-wallet-steps-item', theme) },
                (0, preact_1$7.h)("div", { className: "-cbwsdk-wallet-steps-item-wrapper" }, "Open Coinbase Wallet app")),
            (0, preact_1$7.h)("li", { className: (0, clsx_1$3.default)('-cbwsdk-wallet-steps-item', theme) },
                (0, preact_1$7.h)("div", { className: "-cbwsdk-wallet-steps-item-wrapper" },
                    (0, preact_1$7.h)("span", null,
                        "Tap ",
                        (0, preact_1$7.h)("strong", null, "Scan"),
                        ' '),
                    (0, preact_1$7.h)("span", { className: (0, clsx_1$3.default)('-cbwsdk-wallet-steps-pad-left', '-cbwsdk-wallet-steps-icon', theme) },
                        (0, preact_1$7.h)(QRCodeIcon_1.QRCodeIcon, { fill: makeIconColor(theme) }))))));
    }
    ConnectContent$1.CoinbaseWalletSteps = CoinbaseWalletSteps;

    var TryExtensionContent$1 = {};

    var ArrowLeftIcon$1 = {};

    Object.defineProperty(ArrowLeftIcon$1, "__esModule", { value: true });
    ArrowLeftIcon$1.ArrowLeftIcon = void 0;
    const preact_1$6 = require$$1$1;
    function ArrowLeftIcon(props) {
        return ((0, preact_1$6.h)("svg", Object.assign({ width: "16", height: "16", viewBox: "0 0 16 16", xmlns: "http://www.w3.org/2000/svg" }, props),
            (0, preact_1$6.h)("path", { d: "M8.60675 0.155884L7.37816 1.28209L12.7723 7.16662H0V8.83328H12.6548L6.82149 14.6666L8 15.8451L15.8201 8.02501L8.60675 0.155884Z" })));
    }
    ArrowLeftIcon$1.ArrowLeftIcon = ArrowLeftIcon;

    var LaptopIcon$1 = {};

    Object.defineProperty(LaptopIcon$1, "__esModule", { value: true });
    LaptopIcon$1.LaptopIcon = void 0;
    const preact_1$5 = require$$1$1;
    function LaptopIcon(props) {
        return ((0, preact_1$5.h)("svg", Object.assign({ width: "14", height: "14", viewBox: "0 0 14 14", xmlns: "http://www.w3.org/2000/svg" }, props),
            (0, preact_1$5.h)("path", { d: "M1.8001 2.2002H12.2001V9.40019H1.8001V2.2002ZM3.4001 3.8002V7.80019H10.6001V3.8002H3.4001Z" }),
            (0, preact_1$5.h)("path", { d: "M13.4001 10.2002H0.600098C0.600098 11.0838 1.31644 11.8002 2.2001 11.8002H11.8001C12.6838 11.8002 13.4001 11.0838 13.4001 10.2002Z" })));
    }
    LaptopIcon$1.LaptopIcon = LaptopIcon;

    var SafeIcon$1 = {};

    Object.defineProperty(SafeIcon$1, "__esModule", { value: true });
    SafeIcon$1.SafeIcon = void 0;
    const preact_1$4 = require$$1$1;
    function SafeIcon(props) {
        return ((0, preact_1$4.h)("svg", Object.assign({ width: "14", height: "14", viewBox: "0 0 14 14", xmlns: "http://www.w3.org/2000/svg" }, props),
            (0, preact_1$4.h)("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M0.600098 0.600098V11.8001H13.4001V0.600098H0.600098ZM7.0001 9.2001C5.3441 9.2001 4.0001 7.8561 4.0001 6.2001C4.0001 4.5441 5.3441 3.2001 7.0001 3.2001C8.6561 3.2001 10.0001 4.5441 10.0001 6.2001C10.0001 7.8561 8.6561 9.2001 7.0001 9.2001ZM0.600098 12.6001H3.8001V13.4001H0.600098V12.6001ZM10.2001 12.6001H13.4001V13.4001H10.2001V12.6001ZM8.8001 6.2001C8.8001 7.19421 7.99421 8.0001 7.0001 8.0001C6.00598 8.0001 5.2001 7.19421 5.2001 6.2001C5.2001 5.20598 6.00598 4.4001 7.0001 4.4001C7.99421 4.4001 8.8001 5.20598 8.8001 6.2001Z" })));
    }
    SafeIcon$1.SafeIcon = SafeIcon;

    var TryExtensionContentCss = {};

    Object.defineProperty(TryExtensionContentCss, "__esModule", { value: true });
    TryExtensionContentCss.default = (() => `.-cbwsdk-css-reset .-cbwsdk-try-extension{display:flex;margin-top:12px;height:202px;width:700px;border-radius:12px;padding:30px}.-cbwsdk-css-reset .-cbwsdk-try-extension.light{background:#fff}.-cbwsdk-css-reset .-cbwsdk-try-extension.dark{background:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-try-extension-column-half{flex:50%}.-cbwsdk-css-reset .-cbwsdk-try-extension-heading{font-style:normal;font-weight:500;font-size:25px;line-height:32px;margin:0;max-width:204px}.-cbwsdk-css-reset .-cbwsdk-try-extension-heading.light{color:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-try-extension-heading.dark{color:#fff}.-cbwsdk-css-reset .-cbwsdk-try-extension-cta{appearance:none;border:none;background:none;color:#0052ff;cursor:pointer;padding:0;text-decoration:none;display:block;font-weight:600;font-size:16px;line-height:24px}.-cbwsdk-css-reset .-cbwsdk-try-extension-cta.light{color:#0052ff}.-cbwsdk-css-reset .-cbwsdk-try-extension-cta.dark{color:#588af5}.-cbwsdk-css-reset .-cbwsdk-try-extension-cta-wrapper{display:flex;align-items:center;margin-top:12px}.-cbwsdk-css-reset .-cbwsdk-try-extension-cta-icon{display:block;margin-left:4px;height:14px}.-cbwsdk-css-reset .-cbwsdk-try-extension-list{display:flex;flex-direction:column;justify-content:center;align-items:center;margin:0;padding:0;list-style:none;height:100%}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item{display:flex;align-items:center;flex-flow:nowrap;margin-top:24px}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item:first-of-type{margin-top:0}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-icon-wrapper{display:block}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-icon{display:flex;height:32px;width:32px;border-radius:50%}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-icon svg{margin:auto;display:block}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-icon.light{background:#eef0f3}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-icon.dark{background:#1e2025}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-copy{display:block;font-weight:400;font-size:14px;line-height:20px;padding-left:12px}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-copy.light{color:#5b636e}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-copy.dark{color:#8a919e}`)();

    // Copyright (c) 2018-2023 Coinbase, Inc. <https://www.coinbase.com/>
    // Licensed under the Apache License, version 2.0
    var __importDefault$8 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };
    Object.defineProperty(TryExtensionContent$1, "__esModule", { value: true });
    TryExtensionContent$1.TryExtensionContent = void 0;
    const clsx_1$2 = __importDefault$8(require$$0);
    const preact_1$3 = require$$1$1;
    const hooks_1$1 = require$$2;
    const ArrowLeftIcon_1 = ArrowLeftIcon$1;
    const LaptopIcon_1 = LaptopIcon$1;
    const SafeIcon_1 = SafeIcon$1;
    const TryExtensionContent_css_1 = __importDefault$8(TryExtensionContentCss);
    function TryExtensionContent({ theme }) {
        const [clicked, setClicked] = (0, hooks_1$1.useState)(false);
        const handleInstallClick = (0, hooks_1$1.useCallback)(() => {
            window.open('https://api.wallet.coinbase.com/rpc/v2/desktop/chrome', '_blank');
        }, []);
        const handleClick = (0, hooks_1$1.useCallback)(() => {
            if (clicked) {
                window.location.reload();
            }
            else {
                handleInstallClick();
                setClicked(true);
            }
        }, [handleInstallClick, clicked]);
        return ((0, preact_1$3.h)("div", { class: (0, clsx_1$2.default)('-cbwsdk-try-extension', theme) },
            (0, preact_1$3.h)("style", null, TryExtensionContent_css_1.default),
            (0, preact_1$3.h)("div", { class: "-cbwsdk-try-extension-column-half" },
                (0, preact_1$3.h)("h3", { class: (0, clsx_1$2.default)('-cbwsdk-try-extension-heading', theme) }, "Or try the Coinbase Wallet browser extension"),
                (0, preact_1$3.h)("div", { class: "-cbwsdk-try-extension-cta-wrapper" },
                    (0, preact_1$3.h)("button", { class: (0, clsx_1$2.default)('-cbwsdk-try-extension-cta', theme), onClick: handleClick }, clicked ? 'Refresh' : 'Install'),
                    (0, preact_1$3.h)("div", null, !clicked && ((0, preact_1$3.h)(ArrowLeftIcon_1.ArrowLeftIcon, { class: "-cbwsdk-try-extension-cta-icon", fill: theme === 'light' ? '#0052FF' : '#588AF5' }))))),
            (0, preact_1$3.h)("div", { class: "-cbwsdk-try-extension-column-half" },
                (0, preact_1$3.h)("ul", { class: "-cbwsdk-try-extension-list" },
                    (0, preact_1$3.h)("li", { class: "-cbwsdk-try-extension-list-item" },
                        (0, preact_1$3.h)("div", { class: "-cbwsdk-try-extension-list-item-icon-wrapper" },
                            (0, preact_1$3.h)("span", { class: (0, clsx_1$2.default)('-cbwsdk-try-extension-list-item-icon', theme) },
                                (0, preact_1$3.h)(LaptopIcon_1.LaptopIcon, { fill: theme === 'light' ? '#0A0B0D' : '#FFFFFF' }))),
                        (0, preact_1$3.h)("div", { class: (0, clsx_1$2.default)('-cbwsdk-try-extension-list-item-copy', theme) }, "Connect with dapps with just one click on your desktop browser")),
                    (0, preact_1$3.h)("li", { class: "-cbwsdk-try-extension-list-item" },
                        (0, preact_1$3.h)("div", { class: "-cbwsdk-try-extension-list-item-icon-wrapper" },
                            (0, preact_1$3.h)("span", { class: (0, clsx_1$2.default)('-cbwsdk-try-extension-list-item-icon', theme) },
                                (0, preact_1$3.h)(SafeIcon_1.SafeIcon, { fill: theme === 'light' ? '#0A0B0D' : '#FFFFFF' }))),
                        (0, preact_1$3.h)("div", { class: (0, clsx_1$2.default)('-cbwsdk-try-extension-list-item-copy', theme) }, "Add an additional layer of security by using a supported Ledger hardware wallet"))))));
    }
    TryExtensionContent$1.TryExtensionContent = TryExtensionContent;

    var ConnectDialogCss = {};

    Object.defineProperty(ConnectDialogCss, "__esModule", { value: true });
    ConnectDialogCss.default = (() => `.-cbwsdk-css-reset .-cbwsdk-connect-dialog{z-index:2147483647;position:fixed;top:0;left:0;right:0;bottom:0;display:flex;align-items:center;justify-content:center}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-backdrop{z-index:2147483647;position:fixed;top:0;left:0;right:0;bottom:0;transition:opacity .25s}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-backdrop.light{background-color:rgba(0,0,0,.5)}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-backdrop.dark{background-color:rgba(50,53,61,.4)}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-backdrop-hidden{opacity:0}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-box{display:flex;position:relative;flex-direction:column;transform:scale(1);transition:opacity .25s,transform .25s}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-box-hidden{opacity:0;transform:scale(0.85)}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-container{display:block}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-container-hidden{display:none}`)();

    // Copyright (c) 2018-2023 Coinbase, Inc. <https://www.coinbase.com/>
    // Licensed under the Apache License, version 2.0
    var __importDefault$7 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };
    Object.defineProperty(ConnectDialog$1, "__esModule", { value: true });
    ConnectDialog$1.ConnectDialog = void 0;
    const clsx_1$1 = __importDefault$7(require$$0);
    const preact_1$2 = require$$1$1;
    const hooks_1 = require$$2;
    const ConnectContent_1 = ConnectContent$1;
    const TryExtensionContent_1 = TryExtensionContent$1;
    const ConnectDialog_css_1 = __importDefault$7(ConnectDialogCss);
    const ConnectDialog = (props) => {
        const { isOpen, darkMode } = props;
        const [containerHidden, setContainerHidden] = (0, hooks_1.useState)(!isOpen);
        const [dialogHidden, setDialogHidden] = (0, hooks_1.useState)(!isOpen);
        (0, hooks_1.useEffect)(() => {
            const timers = [
                window.setTimeout(() => {
                    setDialogHidden(!isOpen);
                }, 10),
            ];
            if (isOpen) {
                setContainerHidden(false);
            }
            else {
                timers.push(window.setTimeout(() => {
                    setContainerHidden(true);
                }, 360));
            }
            return () => {
                timers.forEach(window.clearTimeout);
            };
        }, [isOpen]);
        const theme = darkMode ? 'dark' : 'light';
        return ((0, preact_1$2.h)("div", { class: (0, clsx_1$1.default)('-cbwsdk-connect-dialog-container', containerHidden && '-cbwsdk-connect-dialog-container-hidden') },
            (0, preact_1$2.h)("style", null, ConnectDialog_css_1.default),
            (0, preact_1$2.h)("div", { class: (0, clsx_1$1.default)('-cbwsdk-connect-dialog-backdrop', theme, dialogHidden && '-cbwsdk-connect-dialog-backdrop-hidden') }),
            (0, preact_1$2.h)("div", { class: "-cbwsdk-connect-dialog" },
                (0, preact_1$2.h)("div", { class: (0, clsx_1$1.default)('-cbwsdk-connect-dialog-box', dialogHidden && '-cbwsdk-connect-dialog-box-hidden') },
                    !props.connectDisabled ? ((0, preact_1$2.h)(ConnectContent_1.ConnectContent, { theme: theme, version: props.version, sessionId: props.sessionId, sessionSecret: props.sessionSecret, linkAPIUrl: props.linkAPIUrl, isConnected: props.isConnected, isParentConnection: props.isParentConnection, chainId: props.chainId, onCancel: props.onCancel })) : null,
                    (0, preact_1$2.h)(TryExtensionContent_1.TryExtensionContent, { theme: theme })))));
    };
    ConnectDialog$1.ConnectDialog = ConnectDialog;

    // Copyright (c) 2018-2023 Coinbase, Inc. <https://www.coinbase.com/>
    // Licensed under the Apache License, version 2.0
    Object.defineProperty(LinkFlow$1, "__esModule", { value: true });
    LinkFlow$1.LinkFlow = void 0;
    const preact_1$1 = require$$1$1;
    const ConnectDialog_1 = ConnectDialog$1;
    class LinkFlow {
        constructor(options) {
            this.connected = false;
            this.chainId = 1;
            this.isOpen = false;
            this.onCancel = null;
            this.root = null;
            // if true, hide QR code in LinkFlow (which happens if no jsonRpcUrl is provided)
            this.connectDisabled = false;
            this.darkMode = options.darkMode;
            this.version = options.version;
            this.sessionId = options.sessionId;
            this.sessionSecret = options.sessionSecret;
            this.linkAPIUrl = options.linkAPIUrl;
            this.isParentConnection = options.isParentConnection;
        }
        attach(el) {
            this.root = document.createElement('div');
            this.root.className = '-cbwsdk-link-flow-root';
            el.appendChild(this.root);
            this.render();
        }
        setConnected(v) {
            if (this.connected !== v) {
                this.connected = v;
                this.render();
            }
        }
        setChainId(chainId) {
            if (this.chainId !== chainId) {
                this.chainId = chainId;
                this.render();
            }
        }
        detach() {
            var _a;
            if (!this.root) {
                return;
            }
            (0, preact_1$1.render)(null, this.root);
            (_a = this.root.parentElement) === null || _a === void 0 ? void 0 : _a.removeChild(this.root);
        }
        setConnectDisabled(connectDisabled) {
            this.connectDisabled = connectDisabled;
        }
        open(options) {
            this.isOpen = true;
            this.onCancel = options.onCancel;
            this.render();
        }
        close() {
            this.isOpen = false;
            this.onCancel = null;
            this.render();
        }
        render() {
            if (!this.root) {
                return;
            }
            (0, preact_1$1.render)((0, preact_1$1.h)(ConnectDialog_1.ConnectDialog, { darkMode: this.darkMode, version: this.version, sessionId: this.sessionId, sessionSecret: this.sessionSecret, linkAPIUrl: this.linkAPIUrl, isOpen: this.isOpen, isConnected: this.connected, isParentConnection: this.isParentConnection, chainId: this.chainId, onCancel: this.onCancel, connectDisabled: this.connectDisabled }), this.root);
        }
    }
    LinkFlow$1.LinkFlow = LinkFlow;

    var Snackbar$1 = {};

    var SnackbarCss = {};

    Object.defineProperty(SnackbarCss, "__esModule", { value: true });
    SnackbarCss.default = (() => `.-cbwsdk-css-reset .-gear-container{margin-left:16px !important;margin-right:9px !important;display:flex;align-items:center;justify-content:center;width:24px;height:24px;transition:opacity .25s}.-cbwsdk-css-reset .-gear-container *{user-select:none}.-cbwsdk-css-reset .-gear-container svg{opacity:0;position:absolute}.-cbwsdk-css-reset .-gear-icon{height:12px;width:12px;z-index:10000}.-cbwsdk-css-reset .-cbwsdk-snackbar{align-items:flex-end;display:flex;flex-direction:column;position:fixed;right:0;top:0;z-index:2147483647}.-cbwsdk-css-reset .-cbwsdk-snackbar *{user-select:none}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance{display:flex;flex-direction:column;margin:8px 16px 0 16px;overflow:visible;text-align:left;transform:translateX(0);transition:opacity .25s,transform .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header:hover .-gear-container svg{opacity:1}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header{display:flex;align-items:center;background:#fff;overflow:hidden;border:1px solid #e7ebee;box-sizing:border-box;border-radius:8px;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header-cblogo{margin:8px 8px 8px 8px}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header *{cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header-message{color:#000;font-size:13px;line-height:1.5;user-select:none}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu{background:#fff;transition:opacity .25s ease-in-out,transform .25s linear,visibility 0s;visibility:hidden;border:1px solid #e7ebee;box-sizing:border-box;border-radius:8px;opacity:0;flex-direction:column;padding-left:8px;padding-right:8px}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:last-child{margin-bottom:8px !important}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:hover{background:#f5f7f8;border-radius:6px;transition:background .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:hover span{color:#050f19;transition:color .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:hover svg path{fill:#000;transition:fill .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item{visibility:inherit;height:35px;margin-top:8px;margin-bottom:0;display:flex;flex-direction:row;align-items:center;padding:8px;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item *{visibility:inherit;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover{background:rgba(223,95,103,.2);transition:background .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover *{cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover svg path{fill:#df5f67;transition:fill .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover span{color:#df5f67;transition:color .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-info{color:#aaa;font-size:13px;margin:0 8px 0 32px;position:absolute}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-hidden{opacity:0;text-align:left;transform:translateX(25%);transition:opacity .5s linear}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-expanded .-cbwsdk-snackbar-instance-menu{opacity:1;display:flex;transform:translateY(8px);visibility:visible}`)();

    (function (exports) {
    	// Copyright (c) 2018-2023 Coinbase, Inc. <https://www.coinbase.com/>
    	// Licensed under the Apache License, version 2.0
    	var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    	    return (mod && mod.__esModule) ? mod : { "default": mod };
    	};
    	Object.defineProperty(exports, "__esModule", { value: true });
    	exports.SnackbarInstance = exports.SnackbarContainer = exports.Snackbar = void 0;
    	const clsx_1 = __importDefault(require$$0);
    	const preact_1 = require$$1$1;
    	const hooks_1 = require$$2;
    	const Snackbar_css_1 = __importDefault(SnackbarCss);
    	const cblogo = `data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEuNDkyIDEwLjQxOWE4LjkzIDguOTMgMCAwMTguOTMtOC45M2gxMS4xNjNhOC45MyA4LjkzIDAgMDE4LjkzIDguOTN2MTEuMTYzYTguOTMgOC45MyAwIDAxLTguOTMgOC45M0gxMC40MjJhOC45MyA4LjkzIDAgMDEtOC45My04LjkzVjEwLjQxOXoiIGZpbGw9IiMxNjUyRjAiLz48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEwLjQxOSAwSDIxLjU4QzI3LjMzNSAwIDMyIDQuNjY1IDMyIDEwLjQxOVYyMS41OEMzMiAyNy4zMzUgMjcuMzM1IDMyIDIxLjU4MSAzMkgxMC40MkM0LjY2NSAzMiAwIDI3LjMzNSAwIDIxLjU4MVYxMC40MkMwIDQuNjY1IDQuNjY1IDAgMTAuNDE5IDB6bTAgMS40ODhhOC45MyA4LjkzIDAgMDAtOC45MyA4LjkzdjExLjE2M2E4LjkzIDguOTMgMCAwMDguOTMgOC45M0gyMS41OGE4LjkzIDguOTMgMCAwMDguOTMtOC45M1YxMC40MmE4LjkzIDguOTMgMCAwMC04LjkzLTguOTNIMTAuNDJ6IiBmaWxsPSIjZmZmIi8+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xNS45OTggMjYuMDQ5Yy01LjU0OSAwLTEwLjA0Ny00LjQ5OC0xMC4wNDctMTAuMDQ3IDAtNS41NDggNC40OTgtMTAuMDQ2IDEwLjA0Ny0xMC4wNDYgNS41NDggMCAxMC4wNDYgNC40OTggMTAuMDQ2IDEwLjA0NiAwIDUuNTQ5LTQuNDk4IDEwLjA0Ny0xMC4wNDYgMTAuMDQ3eiIgZmlsbD0iI2ZmZiIvPjxwYXRoIGQ9Ik0xMi43NjIgMTQuMjU0YzAtLjgyMi42NjctMS40ODkgMS40ODktMS40ODloMy40OTdjLjgyMiAwIDEuNDg4LjY2NiAxLjQ4OCAxLjQ4OXYzLjQ5N2MwIC44MjItLjY2NiAxLjQ4OC0xLjQ4OCAxLjQ4OGgtMy40OTdhMS40ODggMS40ODggMCAwMS0xLjQ4OS0xLjQ4OHYtMy40OTh6IiBmaWxsPSIjMTY1MkYwIi8+PC9zdmc+`;
    	const gearIcon = `data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTIiIGhlaWdodD0iMTIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEyIDYuNzV2LTEuNWwtMS43Mi0uNTdjLS4wOC0uMjctLjE5LS41Mi0uMzItLjc3bC44MS0xLjYyLTEuMDYtMS4wNi0xLjYyLjgxYy0uMjQtLjEzLS41LS4yNC0uNzctLjMyTDYuNzUgMGgtMS41bC0uNTcgMS43MmMtLjI3LjA4LS41My4xOS0uNzcuMzJsLTEuNjItLjgxLTEuMDYgMS4wNi44MSAxLjYyYy0uMTMuMjQtLjI0LjUtLjMyLjc3TDAgNS4yNXYxLjVsMS43Mi41N2MuMDguMjcuMTkuNTMuMzIuNzdsLS44MSAxLjYyIDEuMDYgMS4wNiAxLjYyLS44MWMuMjQuMTMuNS4yMy43Ny4zMkw1LjI1IDEyaDEuNWwuNTctMS43MmMuMjctLjA4LjUyLS4xOS43Ny0uMzJsMS42Mi44MSAxLjA2LTEuMDYtLjgxLTEuNjJjLjEzLS4yNC4yMy0uNS4zMi0uNzdMMTIgNi43NXpNNiA4LjVhMi41IDIuNSAwIDAxMC01IDIuNSAyLjUgMCAwMTAgNXoiIGZpbGw9IiMwNTBGMTkiLz48L3N2Zz4=`;
    	class Snackbar {
    	    constructor(options) {
    	        this.items = new Map();
    	        this.nextItemKey = 0;
    	        this.root = null;
    	        this.darkMode = options.darkMode;
    	    }
    	    attach(el) {
    	        this.root = document.createElement('div');
    	        this.root.className = '-cbwsdk-snackbar-root';
    	        el.appendChild(this.root);
    	        this.render();
    	    }
    	    presentItem(itemProps) {
    	        const key = this.nextItemKey++;
    	        this.items.set(key, itemProps);
    	        this.render();
    	        return () => {
    	            this.items.delete(key);
    	            this.render();
    	        };
    	    }
    	    clear() {
    	        this.items.clear();
    	        this.render();
    	    }
    	    render() {
    	        if (!this.root) {
    	            return;
    	        }
    	        (0, preact_1.render)((0, preact_1.h)("div", null,
    	            (0, preact_1.h)(exports.SnackbarContainer, { darkMode: this.darkMode }, Array.from(this.items.entries()).map(([key, itemProps]) => ((0, preact_1.h)(exports.SnackbarInstance, Object.assign({}, itemProps, { key: key })))))), this.root);
    	    }
    	}
    	exports.Snackbar = Snackbar;
    	const SnackbarContainer = (props) => ((0, preact_1.h)("div", { class: (0, clsx_1.default)('-cbwsdk-snackbar-container') },
    	    (0, preact_1.h)("style", null, Snackbar_css_1.default),
    	    (0, preact_1.h)("div", { class: "-cbwsdk-snackbar" }, props.children)));
    	exports.SnackbarContainer = SnackbarContainer;
    	const SnackbarInstance = ({ autoExpand, message, menuItems, }) => {
    	    const [hidden, setHidden] = (0, hooks_1.useState)(true);
    	    const [expanded, setExpanded] = (0, hooks_1.useState)(autoExpand !== null && autoExpand !== void 0 ? autoExpand : false);
    	    (0, hooks_1.useEffect)(() => {
    	        const timers = [
    	            window.setTimeout(() => {
    	                setHidden(false);
    	            }, 1),
    	            window.setTimeout(() => {
    	                setExpanded(true);
    	            }, 10000),
    	        ];
    	        return () => {
    	            timers.forEach(window.clearTimeout);
    	        };
    	    });
    	    const toggleExpanded = () => {
    	        setExpanded(!expanded);
    	    };
    	    return ((0, preact_1.h)("div", { class: (0, clsx_1.default)('-cbwsdk-snackbar-instance', hidden && '-cbwsdk-snackbar-instance-hidden', expanded && '-cbwsdk-snackbar-instance-expanded') },
    	        (0, preact_1.h)("div", { class: "-cbwsdk-snackbar-instance-header", onClick: toggleExpanded },
    	            (0, preact_1.h)("img", { src: cblogo, class: "-cbwsdk-snackbar-instance-header-cblogo" }),
    	            ' ',
    	            (0, preact_1.h)("div", { class: "-cbwsdk-snackbar-instance-header-message" }, message),
    	            (0, preact_1.h)("div", { class: "-gear-container" },
    	                !expanded && ((0, preact_1.h)("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
    	                    (0, preact_1.h)("circle", { cx: "12", cy: "12", r: "12", fill: "#F5F7F8" }))),
    	                (0, preact_1.h)("img", { src: gearIcon, class: "-gear-icon", title: "Expand" }))),
    	        menuItems && menuItems.length > 0 && ((0, preact_1.h)("div", { class: "-cbwsdk-snackbar-instance-menu" }, menuItems.map((action, i) => ((0, preact_1.h)("div", { class: (0, clsx_1.default)('-cbwsdk-snackbar-instance-menu-item', action.isRed && '-cbwsdk-snackbar-instance-menu-item-is-red'), onClick: action.onClick, key: i },
    	            (0, preact_1.h)("svg", { width: action.svgWidth, height: action.svgHeight, viewBox: "0 0 10 11", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
    	                (0, preact_1.h)("path", { "fill-rule": action.defaultFillRule, "clip-rule": action.defaultClipRule, d: action.path, fill: "#AAAAAA" })),
    	            (0, preact_1.h)("span", { class: (0, clsx_1.default)('-cbwsdk-snackbar-instance-menu-item-info', action.isRed && '-cbwsdk-snackbar-instance-menu-item-info-is-red') }, action.info))))))));
    	};
    	exports.SnackbarInstance = SnackbarInstance; 
    } (Snackbar$1));

    Object.defineProperty(WalletLinkRelayUI$1, "__esModule", { value: true });
    WalletLinkRelayUI$1.WalletLinkRelayUI = void 0;
    const cssReset_1$1 = cssReset;
    const LinkFlow_1 = LinkFlow$1;
    const Snackbar_1$1 = Snackbar$1;
    class WalletLinkRelayUI {
        constructor(options) {
            this.standalone = null;
            this.attached = false;
            this.snackbar = new Snackbar_1$1.Snackbar({
                darkMode: options.darkMode,
            });
            this.linkFlow = new LinkFlow_1.LinkFlow({
                darkMode: options.darkMode,
                version: options.version,
                sessionId: options.session.id,
                sessionSecret: options.session.secret,
                linkAPIUrl: options.linkAPIUrl,
                isParentConnection: false,
            });
        }
        attach() {
            if (this.attached) {
                throw new Error('Coinbase Wallet SDK UI is already attached');
            }
            const el = document.documentElement;
            const container = document.createElement('div');
            container.className = '-cbwsdk-css-reset';
            el.appendChild(container);
            this.linkFlow.attach(container);
            this.snackbar.attach(container);
            this.attached = true;
            (0, cssReset_1$1.injectCssReset)();
        }
        setConnected(connected) {
            this.linkFlow.setConnected(connected);
        }
        setChainId(chainId) {
            this.linkFlow.setChainId(chainId);
        }
        setConnectDisabled(connectDisabled) {
            this.linkFlow.setConnectDisabled(connectDisabled);
        }
        /* istanbul ignore next */
        addEthereumChain() { } // no-op
        /* istanbul ignore next */
        watchAsset() { } // no-op
        /* istanbul ignore next */
        switchEthereumChain() { } // no-op
        requestEthereumAccounts(options) {
            this.linkFlow.open({ onCancel: options.onCancel });
        }
        hideRequestEthereumAccounts() {
            this.linkFlow.close();
        }
        /* istanbul ignore next */
        signEthereumMessage() { } // no-op
        /* istanbul ignore next */
        signEthereumTransaction() { } // no-op
        /* istanbul ignore next */
        submitEthereumTransaction() { } // no-op
        /* istanbul ignore next */
        ethereumAddressFromSignedMessage() { } // no-op
        showConnecting(options) {
            let snackbarProps;
            if (options.isUnlinkedErrorState) {
                snackbarProps = {
                    autoExpand: true,
                    message: 'Connection lost',
                    menuItems: [
                        {
                            isRed: false,
                            info: 'Reset connection',
                            svgWidth: '10',
                            svgHeight: '11',
                            path: 'M5.00008 0.96875C6.73133 0.96875 8.23758 1.94375 9.00008 3.375L10.0001 2.375V5.5H9.53133H7.96883H6.87508L7.80633 4.56875C7.41258 3.3875 6.31258 2.53125 5.00008 2.53125C3.76258 2.53125 2.70633 3.2875 2.25633 4.36875L0.812576 3.76875C1.50008 2.125 3.11258 0.96875 5.00008 0.96875ZM2.19375 6.43125C2.5875 7.6125 3.6875 8.46875 5 8.46875C6.2375 8.46875 7.29375 7.7125 7.74375 6.63125L9.1875 7.23125C8.5 8.875 6.8875 10.0312 5 10.0312C3.26875 10.0312 1.7625 9.05625 1 7.625L0 8.625V5.5H0.46875H2.03125H3.125L2.19375 6.43125Z',
                            defaultFillRule: 'evenodd',
                            defaultClipRule: 'evenodd',
                            onClick: options.onResetConnection,
                        },
                    ],
                };
            }
            else {
                snackbarProps = {
                    message: 'Confirm on phone',
                    menuItems: [
                        {
                            isRed: true,
                            info: 'Cancel transaction',
                            svgWidth: '11',
                            svgHeight: '11',
                            path: 'M10.3711 1.52346L9.21775 0.370117L5.37109 4.21022L1.52444 0.370117L0.371094 1.52346L4.2112 5.37012L0.371094 9.21677L1.52444 10.3701L5.37109 6.53001L9.21775 10.3701L10.3711 9.21677L6.53099 5.37012L10.3711 1.52346Z',
                            defaultFillRule: 'inherit',
                            defaultClipRule: 'inherit',
                            onClick: options.onCancel,
                        },
                        {
                            isRed: false,
                            info: 'Reset connection',
                            svgWidth: '10',
                            svgHeight: '11',
                            path: 'M5.00008 0.96875C6.73133 0.96875 8.23758 1.94375 9.00008 3.375L10.0001 2.375V5.5H9.53133H7.96883H6.87508L7.80633 4.56875C7.41258 3.3875 6.31258 2.53125 5.00008 2.53125C3.76258 2.53125 2.70633 3.2875 2.25633 4.36875L0.812576 3.76875C1.50008 2.125 3.11258 0.96875 5.00008 0.96875ZM2.19375 6.43125C2.5875 7.6125 3.6875 8.46875 5 8.46875C6.2375 8.46875 7.29375 7.7125 7.74375 6.63125L9.1875 7.23125C8.5 8.875 6.8875 10.0312 5 10.0312C3.26875 10.0312 1.7625 9.05625 1 7.625L0 8.625V5.5H0.46875H2.03125H3.125L2.19375 6.43125Z',
                            defaultFillRule: 'evenodd',
                            defaultClipRule: 'evenodd',
                            onClick: options.onResetConnection,
                        },
                    ],
                };
            }
            return this.snackbar.presentItem(snackbarProps);
        }
        /* istanbul ignore next */
        reloadUI() {
            document.location.reload();
        }
        /* istanbul ignore next */
        inlineAccountsResponse() {
            return false;
        }
        /* istanbul ignore next */
        inlineAddEthereumChain() {
            return false;
        }
        /* istanbul ignore next */
        inlineWatchAsset() {
            return false;
        }
        /* istanbul ignore next */
        inlineSwitchEthereumChain() {
            return false;
        }
        /* istanbul ignore next */
        setStandalone(status) {
            this.standalone = status;
        }
        /* istanbul ignore next */
        isStandalone() {
            var _a;
            return (_a = this.standalone) !== null && _a !== void 0 ? _a : false;
        }
    }
    WalletLinkRelayUI$1.WalletLinkRelayUI = WalletLinkRelayUI;

    // Copyright (c) 2018-2023 Coinbase, Inc. <https://www.coinbase.com/>
    // Licensed under the Apache License, version 2.0
    Object.defineProperty(WalletLinkRelay$1, "__esModule", { value: true });
    WalletLinkRelay$1.WalletLinkRelay = void 0;
    const error_1$1 = error;
    const type_1$1 = type$1;
    const util_1$5 = util$3;
    const DiagnosticLogger_1$1 = DiagnosticLogger;
    const RelayAbstract_1$1 = RelayAbstract$1;
    const Session_1$1 = Session$1;
    const WalletLinkConnection_1 = WalletLinkConnection$1;
    const Web3Response_1$1 = Web3Response;
    const WalletLinkRelayUI_1$1 = WalletLinkRelayUI$1;
    class WalletLinkRelay extends RelayAbstract_1$1.RelayAbstract {
        constructor(options) {
            var _a;
            super();
            this.accountsCallback = null;
            this.chainCallbackParams = { chainId: '', jsonRpcUrl: '' }; // to implement distinctUntilChanged
            this.chainCallback = null;
            this.dappDefaultChain = 1;
            this.appName = '';
            this.appLogoUrl = null;
            this.linkedUpdated = (linked) => {
                var _a;
                this.isLinked = linked;
                const cachedAddresses = this.storage.getItem(RelayAbstract_1$1.LOCAL_STORAGE_ADDRESSES_KEY);
                if (linked) {
                    // Only set linked session variable one way
                    this.session.linked = linked;
                }
                this.isUnlinkedErrorState = false;
                if (cachedAddresses) {
                    const addresses = cachedAddresses.split(' ');
                    const wasConnectedViaStandalone = this.storage.getItem('IsStandaloneSigning') === 'true';
                    if (addresses[0] !== '' && !linked && this.session.linked && !wasConnectedViaStandalone) {
                        this.isUnlinkedErrorState = true;
                        const sessionIdHash = this.getSessionIdHash();
                        (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1$1.EVENTS.UNLINKED_ERROR_STATE, {
                            sessionIdHash,
                        });
                    }
                }
            };
            this.metadataUpdated = (key, value) => {
                this.storage.setItem(key, value);
            };
            this.chainUpdated = (chainId, jsonRpcUrl) => {
                if (this.chainCallbackParams.chainId === chainId &&
                    this.chainCallbackParams.jsonRpcUrl === jsonRpcUrl) {
                    return;
                }
                this.chainCallbackParams = {
                    chainId,
                    jsonRpcUrl,
                };
                if (this.chainCallback) {
                    this.chainCallback(chainId, jsonRpcUrl);
                }
            };
            this.accountUpdated = (selectedAddress) => {
                if (this.accountsCallback) {
                    this.accountsCallback([selectedAddress]);
                }
                if (WalletLinkRelay.accountRequestCallbackIds.size > 0) {
                    // We get the ethereum address from the metadata.  If for whatever
                    // reason we don't get a response via an explicit web3 message
                    // we can still fulfill the eip1102 request.
                    Array.from(WalletLinkRelay.accountRequestCallbackIds.values()).forEach((id) => {
                        const message = {
                            type: 'WEB3_RESPONSE',
                            id,
                            response: {
                                method: 'requestEthereumAccounts',
                                result: [selectedAddress],
                            },
                        };
                        this.invokeCallback(Object.assign(Object.assign({}, message), { id }));
                    });
                    WalletLinkRelay.accountRequestCallbackIds.clear();
                }
            };
            this.connectedUpdated = (connected) => {
                this.ui.setConnected(connected);
            };
            this.resetAndReload = this.resetAndReload.bind(this);
            this.linkAPIUrl = options.linkAPIUrl;
            this.storage = options.storage;
            this.options = options;
            const { session, ui, connection } = this.subscribe();
            this._session = session;
            this.connection = connection;
            this.relayEventManager = options.relayEventManager;
            this.diagnostic = options.diagnosticLogger;
            this._reloadOnDisconnect = (_a = options.reloadOnDisconnect) !== null && _a !== void 0 ? _a : true;
            this.ui = ui;
        }
        subscribe() {
            const session = Session_1$1.Session.load(this.storage) || new Session_1$1.Session(this.storage).save();
            const { linkAPIUrl, diagnostic } = this;
            const connection = new WalletLinkConnection_1.WalletLinkConnection({
                session,
                linkAPIUrl,
                diagnostic,
                listener: this,
            });
            const { version, darkMode } = this.options;
            const ui = this.options.uiConstructor({
                linkAPIUrl,
                version,
                darkMode,
                session,
            });
            connection.connect();
            return { session, ui, connection };
        }
        attachUI() {
            this.ui.attach();
        }
        resetAndReload() {
            Promise.race([
                this.connection.setSessionMetadata('__destroyed', '1'),
                new Promise((resolve) => setTimeout(() => resolve(null), 1000)),
            ])
                .then(() => {
                var _a, _b;
                const isStandalone = this.ui.isStandalone();
                (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1$1.EVENTS.SESSION_STATE_CHANGE, {
                    method: 'relay::resetAndReload',
                    sessionMetadataChange: '__destroyed, 1',
                    sessionIdHash: this.getSessionIdHash(),
                });
                this.connection.destroy();
                /**
                 * Only clear storage if the session id we have in memory matches the one on disk
                 * Otherwise, in the case where we have 2 tabs, another tab might have cleared
                 * storage already.  In that case if we clear storage again, the user will be in
                 * a state where the first tab allows the user to connect but the session that
                 * was used isn't persisted.  This leaves the user in a state where they aren't
                 * connected to the mobile app.
                 */
                const storedSession = Session_1$1.Session.load(this.storage);
                if ((storedSession === null || storedSession === void 0 ? void 0 : storedSession.id) === this._session.id) {
                    this.storage.clear();
                }
                else if (storedSession) {
                    (_b = this.diagnostic) === null || _b === void 0 ? void 0 : _b.log(DiagnosticLogger_1$1.EVENTS.SKIPPED_CLEARING_SESSION, {
                        sessionIdHash: this.getSessionIdHash(),
                        storedSessionIdHash: Session_1$1.Session.hash(storedSession.id),
                    });
                }
                if (this._reloadOnDisconnect) {
                    this.ui.reloadUI();
                    return;
                }
                if (this.accountsCallback) {
                    this.accountsCallback([], true);
                }
                const { session, ui, connection } = this.subscribe();
                this._session = session;
                this.connection = connection;
                this.ui = ui;
                if (isStandalone && this.ui.setStandalone)
                    this.ui.setStandalone(true);
                this.attachUI();
            })
                .catch((err) => {
                var _a;
                (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1$1.EVENTS.FAILURE, {
                    method: 'relay::resetAndReload',
                    message: `failed to reset and reload with ${err}`,
                    sessionIdHash: this.getSessionIdHash(),
                });
            });
        }
        setAppInfo(appName, appLogoUrl) {
            this.appName = appName;
            this.appLogoUrl = appLogoUrl;
        }
        getStorageItem(key) {
            return this.storage.getItem(key);
        }
        get session() {
            return this._session;
        }
        setStorageItem(key, value) {
            this.storage.setItem(key, value);
        }
        signEthereumMessage(message, address, addPrefix, typedDataJson) {
            return this.sendRequest({
                method: 'signEthereumMessage',
                params: {
                    message: (0, util_1$5.hexStringFromBuffer)(message, true),
                    address,
                    addPrefix,
                    typedDataJson: typedDataJson || null,
                },
            });
        }
        ethereumAddressFromSignedMessage(message, signature, addPrefix) {
            return this.sendRequest({
                method: 'ethereumAddressFromSignedMessage',
                params: {
                    message: (0, util_1$5.hexStringFromBuffer)(message, true),
                    signature: (0, util_1$5.hexStringFromBuffer)(signature, true),
                    addPrefix,
                },
            });
        }
        signEthereumTransaction(params) {
            return this.sendRequest({
                method: 'signEthereumTransaction',
                params: {
                    fromAddress: params.fromAddress,
                    toAddress: params.toAddress,
                    weiValue: (0, util_1$5.bigIntStringFromBN)(params.weiValue),
                    data: (0, util_1$5.hexStringFromBuffer)(params.data, true),
                    nonce: params.nonce,
                    gasPriceInWei: params.gasPriceInWei ? (0, util_1$5.bigIntStringFromBN)(params.gasPriceInWei) : null,
                    maxFeePerGas: params.gasPriceInWei ? (0, util_1$5.bigIntStringFromBN)(params.gasPriceInWei) : null,
                    maxPriorityFeePerGas: params.gasPriceInWei
                        ? (0, util_1$5.bigIntStringFromBN)(params.gasPriceInWei)
                        : null,
                    gasLimit: params.gasLimit ? (0, util_1$5.bigIntStringFromBN)(params.gasLimit) : null,
                    chainId: params.chainId,
                    shouldSubmit: false,
                },
            });
        }
        signAndSubmitEthereumTransaction(params) {
            return this.sendRequest({
                method: 'signEthereumTransaction',
                params: {
                    fromAddress: params.fromAddress,
                    toAddress: params.toAddress,
                    weiValue: (0, util_1$5.bigIntStringFromBN)(params.weiValue),
                    data: (0, util_1$5.hexStringFromBuffer)(params.data, true),
                    nonce: params.nonce,
                    gasPriceInWei: params.gasPriceInWei ? (0, util_1$5.bigIntStringFromBN)(params.gasPriceInWei) : null,
                    maxFeePerGas: params.maxFeePerGas ? (0, util_1$5.bigIntStringFromBN)(params.maxFeePerGas) : null,
                    maxPriorityFeePerGas: params.maxPriorityFeePerGas
                        ? (0, util_1$5.bigIntStringFromBN)(params.maxPriorityFeePerGas)
                        : null,
                    gasLimit: params.gasLimit ? (0, util_1$5.bigIntStringFromBN)(params.gasLimit) : null,
                    chainId: params.chainId,
                    shouldSubmit: true,
                },
            });
        }
        submitEthereumTransaction(signedTransaction, chainId) {
            return this.sendRequest({
                method: 'submitEthereumTransaction',
                params: {
                    signedTransaction: (0, util_1$5.hexStringFromBuffer)(signedTransaction, true),
                    chainId,
                },
            });
        }
        scanQRCode(regExp) {
            return this.sendRequest({
                method: 'scanQRCode',
                params: {
                    regExp,
                },
            });
        }
        getQRCodeUrl() {
            return (0, util_1$5.createQrUrl)(this._session.id, this._session.secret, this.linkAPIUrl, false, this.options.version, this.dappDefaultChain);
        }
        genericRequest(data, action) {
            return this.sendRequest({
                method: 'generic',
                params: {
                    action,
                    data,
                },
            });
        }
        sendGenericMessage(request) {
            return this.sendRequest(request);
        }
        sendRequest(request) {
            let hideSnackbarItem = null;
            const id = (0, util_1$5.randomBytesHex)(8);
            const cancel = (error) => {
                this.publishWeb3RequestCanceledEvent(id);
                this.handleErrorResponse(id, request.method, error);
                hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
            };
            const promise = new Promise((resolve, reject) => {
                if (!this.ui.isStandalone()) {
                    hideSnackbarItem = this.ui.showConnecting({
                        isUnlinkedErrorState: this.isUnlinkedErrorState,
                        onCancel: cancel,
                        onResetConnection: this.resetAndReload, // eslint-disable-line @typescript-eslint/unbound-method
                    });
                }
                this.relayEventManager.callbacks.set(id, (response) => {
                    hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
                    if ((0, Web3Response_1$1.isErrorResponse)(response)) {
                        return reject(new Error(response.errorMessage));
                    }
                    resolve(response);
                });
                if (this.ui.isStandalone()) {
                    this.sendRequestStandalone(id, request);
                }
                else {
                    this.publishWeb3RequestEvent(id, request);
                }
            });
            return { promise, cancel };
        }
        setConnectDisabled(disabled) {
            this.ui.setConnectDisabled(disabled);
        }
        setAccountsCallback(accountsCallback) {
            this.accountsCallback = accountsCallback;
        }
        setChainCallback(chainCallback) {
            this.chainCallback = chainCallback;
        }
        setDappDefaultChainCallback(chainId) {
            this.dappDefaultChain = chainId;
            if (this.ui instanceof WalletLinkRelayUI_1$1.WalletLinkRelayUI) {
                this.ui.setChainId(chainId);
            }
        }
        publishWeb3RequestEvent(id, request) {
            var _a;
            const message = { type: 'WEB3_REQUEST', id, request };
            const storedSession = Session_1$1.Session.load(this.storage);
            (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1$1.EVENTS.WEB3_REQUEST, {
                eventId: message.id,
                method: `relay::${request.method}`,
                sessionIdHash: this.getSessionIdHash(),
                storedSessionIdHash: storedSession ? Session_1$1.Session.hash(storedSession.id) : '',
                isSessionMismatched: ((storedSession === null || storedSession === void 0 ? void 0 : storedSession.id) !== this._session.id).toString(),
            });
            this.publishEvent('Web3Request', message, true)
                .then((_) => {
                var _a;
                (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1$1.EVENTS.WEB3_REQUEST_PUBLISHED, {
                    eventId: message.id,
                    method: `relay::${request.method}`,
                    sessionIdHash: this.getSessionIdHash(),
                    storedSessionIdHash: storedSession ? Session_1$1.Session.hash(storedSession.id) : '',
                    isSessionMismatched: ((storedSession === null || storedSession === void 0 ? void 0 : storedSession.id) !== this._session.id).toString(),
                });
            })
                .catch((err) => {
                this.handleWeb3ResponseMessage({
                    type: 'WEB3_RESPONSE',
                    id: message.id,
                    response: {
                        method: request.method,
                        errorMessage: err.message,
                    },
                });
            });
        }
        publishWeb3RequestCanceledEvent(id) {
            const message = {
                type: 'WEB3_REQUEST_CANCELED',
                id,
            };
            this.publishEvent('Web3RequestCanceled', message, false).then();
        }
        publishEvent(event, message, callWebhook) {
            return this.connection.publishEvent(event, message, callWebhook);
        }
        handleWeb3ResponseMessage(message) {
            var _a;
            const { response } = message;
            (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1$1.EVENTS.WEB3_RESPONSE, {
                eventId: message.id,
                method: `relay::${response.method}`,
                sessionIdHash: this.getSessionIdHash(),
            });
            if (response.method === 'requestEthereumAccounts') {
                WalletLinkRelay.accountRequestCallbackIds.forEach((id) => this.invokeCallback(Object.assign(Object.assign({}, message), { id })));
                WalletLinkRelay.accountRequestCallbackIds.clear();
                return;
            }
            this.invokeCallback(message);
        }
        handleErrorResponse(id, method, error, errorCode) {
            var _a;
            const errorMessage = (_a = error === null || error === void 0 ? void 0 : error.message) !== null && _a !== void 0 ? _a : (0, error_1$1.getMessageFromCode)(errorCode);
            this.handleWeb3ResponseMessage({
                type: 'WEB3_RESPONSE',
                id,
                response: {
                    method,
                    errorMessage,
                    errorCode,
                },
            });
        }
        invokeCallback(message) {
            const callback = this.relayEventManager.callbacks.get(message.id);
            if (callback) {
                callback(message.response);
                this.relayEventManager.callbacks.delete(message.id);
            }
        }
        requestEthereumAccounts() {
            const request = {
                method: 'requestEthereumAccounts',
                params: {
                    appName: this.appName,
                    appLogoUrl: this.appLogoUrl || null,
                },
            };
            const id = (0, util_1$5.randomBytesHex)(8);
            const cancel = (error) => {
                this.publishWeb3RequestCanceledEvent(id);
                this.handleErrorResponse(id, request.method, error);
            };
            const promise = new Promise((resolve, reject) => {
                this.relayEventManager.callbacks.set(id, (response) => {
                    this.ui.hideRequestEthereumAccounts();
                    if ((0, Web3Response_1$1.isErrorResponse)(response)) {
                        return reject(new Error(response.errorMessage));
                    }
                    resolve(response);
                });
                if (this.ui.inlineAccountsResponse()) {
                    const onAccounts = (accounts) => {
                        this.handleWeb3ResponseMessage({
                            type: 'WEB3_RESPONSE',
                            id,
                            response: { method: 'requestEthereumAccounts', result: accounts },
                        });
                    };
                    this.ui.requestEthereumAccounts({
                        onCancel: cancel,
                        onAccounts,
                    });
                }
                else {
                    // Error if user closes TryExtensionLinkDialog without connecting
                    const err = error_1$1.standardErrors.provider.userRejectedRequest('User denied account authorization');
                    this.ui.requestEthereumAccounts({
                        onCancel: () => cancel(err),
                    });
                }
                WalletLinkRelay.accountRequestCallbackIds.add(id);
                if (!this.ui.inlineAccountsResponse() && !this.ui.isStandalone()) {
                    this.publishWeb3RequestEvent(id, request);
                }
            });
            return { promise, cancel };
        }
        selectProvider(providerOptions) {
            const request = {
                method: 'selectProvider',
                params: {
                    providerOptions,
                },
            };
            const id = (0, util_1$5.randomBytesHex)(8);
            const cancel = (error) => {
                this.publishWeb3RequestCanceledEvent(id);
                this.handleErrorResponse(id, request.method, error);
            };
            const promise = new Promise((resolve, reject) => {
                this.relayEventManager.callbacks.set(id, (response) => {
                    if ((0, Web3Response_1$1.isErrorResponse)(response)) {
                        return reject(new Error(response.errorMessage));
                    }
                    resolve(response);
                });
                const _cancel = (_error) => {
                    this.handleWeb3ResponseMessage({
                        type: 'WEB3_RESPONSE',
                        id,
                        response: { method: 'selectProvider', result: type_1$1.ProviderType.Unselected },
                    });
                };
                const approve = (selectedProviderKey) => {
                    this.handleWeb3ResponseMessage({
                        type: 'WEB3_RESPONSE',
                        id,
                        response: { method: 'selectProvider', result: selectedProviderKey },
                    });
                };
                if (this.ui.selectProvider)
                    this.ui.selectProvider({
                        onApprove: approve,
                        onCancel: _cancel,
                        providerOptions,
                    });
            });
            return { cancel, promise };
        }
        watchAsset(type, address, symbol, decimals, image, chainId) {
            const request = {
                method: 'watchAsset',
                params: {
                    type,
                    options: {
                        address,
                        symbol,
                        decimals,
                        image,
                    },
                    chainId,
                },
            };
            let hideSnackbarItem = null;
            const id = (0, util_1$5.randomBytesHex)(8);
            const cancel = (error) => {
                this.publishWeb3RequestCanceledEvent(id);
                this.handleErrorResponse(id, request.method, error);
                hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
            };
            if (!this.ui.inlineWatchAsset()) {
                hideSnackbarItem = this.ui.showConnecting({
                    isUnlinkedErrorState: this.isUnlinkedErrorState,
                    onCancel: cancel,
                    onResetConnection: this.resetAndReload, // eslint-disable-line @typescript-eslint/unbound-method
                });
            }
            const promise = new Promise((resolve, reject) => {
                this.relayEventManager.callbacks.set(id, (response) => {
                    hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
                    if ((0, Web3Response_1$1.isErrorResponse)(response)) {
                        return reject(new Error(response.errorMessage));
                    }
                    resolve(response);
                });
                const _cancel = (_error) => {
                    this.handleWeb3ResponseMessage({
                        type: 'WEB3_RESPONSE',
                        id,
                        response: {
                            method: 'watchAsset',
                            result: false,
                        },
                    });
                };
                const approve = () => {
                    this.handleWeb3ResponseMessage({
                        type: 'WEB3_RESPONSE',
                        id,
                        response: {
                            method: 'watchAsset',
                            result: true,
                        },
                    });
                };
                if (this.ui.inlineWatchAsset()) {
                    this.ui.watchAsset({
                        onApprove: approve,
                        onCancel: _cancel,
                        type,
                        address,
                        symbol,
                        decimals,
                        image,
                        chainId,
                    });
                }
                if (!this.ui.inlineWatchAsset() && !this.ui.isStandalone()) {
                    this.publishWeb3RequestEvent(id, request);
                }
            });
            return { cancel, promise };
        }
        addEthereumChain(chainId, rpcUrls, iconUrls, blockExplorerUrls, chainName, nativeCurrency) {
            const request = {
                method: 'addEthereumChain',
                params: {
                    chainId,
                    rpcUrls,
                    blockExplorerUrls,
                    chainName,
                    iconUrls,
                    nativeCurrency,
                },
            };
            let hideSnackbarItem = null;
            const id = (0, util_1$5.randomBytesHex)(8);
            const cancel = (error) => {
                this.publishWeb3RequestCanceledEvent(id);
                this.handleErrorResponse(id, request.method, error);
                hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
            };
            if (!this.ui.inlineAddEthereumChain(chainId)) {
                hideSnackbarItem = this.ui.showConnecting({
                    isUnlinkedErrorState: this.isUnlinkedErrorState,
                    onCancel: cancel,
                    onResetConnection: this.resetAndReload, // eslint-disable-line @typescript-eslint/unbound-method
                });
            }
            const promise = new Promise((resolve, reject) => {
                this.relayEventManager.callbacks.set(id, (response) => {
                    hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
                    if ((0, Web3Response_1$1.isErrorResponse)(response)) {
                        return reject(new Error(response.errorMessage));
                    }
                    resolve(response);
                });
                const _cancel = (_error) => {
                    this.handleWeb3ResponseMessage({
                        type: 'WEB3_RESPONSE',
                        id,
                        response: {
                            method: 'addEthereumChain',
                            result: {
                                isApproved: false,
                                rpcUrl: '',
                            },
                        },
                    });
                };
                const approve = (rpcUrl) => {
                    this.handleWeb3ResponseMessage({
                        type: 'WEB3_RESPONSE',
                        id,
                        response: {
                            method: 'addEthereumChain',
                            result: {
                                isApproved: true,
                                rpcUrl,
                            },
                        },
                    });
                };
                if (this.ui.inlineAddEthereumChain(chainId)) {
                    this.ui.addEthereumChain({
                        onCancel: _cancel,
                        onApprove: approve,
                        chainId: request.params.chainId,
                        rpcUrls: request.params.rpcUrls,
                        blockExplorerUrls: request.params.blockExplorerUrls,
                        chainName: request.params.chainName,
                        iconUrls: request.params.iconUrls,
                        nativeCurrency: request.params.nativeCurrency,
                    });
                }
                if (!this.ui.inlineAddEthereumChain(chainId) && !this.ui.isStandalone()) {
                    this.publishWeb3RequestEvent(id, request);
                }
            });
            return { promise, cancel };
        }
        switchEthereumChain(chainId, address) {
            const request = {
                method: 'switchEthereumChain',
                params: Object.assign({ chainId }, { address }),
            };
            const id = (0, util_1$5.randomBytesHex)(8);
            const cancel = (error) => {
                this.publishWeb3RequestCanceledEvent(id);
                this.handleErrorResponse(id, request.method, error);
            };
            const promise = new Promise((resolve, reject) => {
                this.relayEventManager.callbacks.set(id, (response) => {
                    if ((0, Web3Response_1$1.isErrorResponse)(response) && response.errorCode) {
                        return reject(error_1$1.standardErrors.provider.custom({
                            code: response.errorCode,
                            message: `Unrecognized chain ID. Try adding the chain using addEthereumChain first.`,
                        }));
                    }
                    else if ((0, Web3Response_1$1.isErrorResponse)(response)) {
                        return reject(new Error(response.errorMessage));
                    }
                    resolve(response);
                });
                const _cancel = (error) => {
                    var _a;
                    if (error) {
                        // backward compatibility
                        const errorCode = (_a = (0, error_1$1.getErrorCode)(error)) !== null && _a !== void 0 ? _a : error_1$1.standardErrorCodes.provider.unsupportedChain;
                        this.handleErrorResponse(id, 'switchEthereumChain', error instanceof Error ? error : error_1$1.standardErrors.provider.unsupportedChain(chainId), errorCode);
                    }
                    else {
                        this.handleWeb3ResponseMessage({
                            type: 'WEB3_RESPONSE',
                            id,
                            response: {
                                method: 'switchEthereumChain',
                                result: {
                                    isApproved: false,
                                    rpcUrl: '',
                                },
                            },
                        });
                    }
                };
                const approve = (rpcUrl) => {
                    this.handleWeb3ResponseMessage({
                        type: 'WEB3_RESPONSE',
                        id,
                        response: {
                            method: 'switchEthereumChain',
                            result: {
                                isApproved: true,
                                rpcUrl,
                            },
                        },
                    });
                };
                this.ui.switchEthereumChain({
                    onCancel: _cancel,
                    onApprove: approve,
                    chainId: request.params.chainId,
                    address: request.params.address,
                });
                if (!this.ui.inlineSwitchEthereumChain() && !this.ui.isStandalone()) {
                    this.publishWeb3RequestEvent(id, request);
                }
            });
            return { promise, cancel };
        }
        inlineAddEthereumChain(chainId) {
            return this.ui.inlineAddEthereumChain(chainId);
        }
        getSessionIdHash() {
            return Session_1$1.Session.hash(this._session.id);
        }
        sendRequestStandalone(id, request) {
            const _cancel = (error) => {
                this.handleErrorResponse(id, request.method, error);
            };
            const onSuccess = (response) => {
                this.handleWeb3ResponseMessage({
                    type: 'WEB3_RESPONSE',
                    id,
                    response,
                });
            };
            switch (request.method) {
                case 'signEthereumMessage':
                    this.ui.signEthereumMessage({
                        request,
                        onSuccess,
                        onCancel: _cancel,
                    });
                    break;
                case 'signEthereumTransaction':
                    this.ui.signEthereumTransaction({
                        request,
                        onSuccess,
                        onCancel: _cancel,
                    });
                    break;
                case 'submitEthereumTransaction':
                    this.ui.submitEthereumTransaction({
                        request,
                        onSuccess,
                        onCancel: _cancel,
                    });
                    break;
                case 'ethereumAddressFromSignedMessage':
                    this.ui.ethereumAddressFromSignedMessage({
                        request,
                        onSuccess,
                    });
                    break;
                default:
                    _cancel();
                    break;
            }
        }
    }
    WalletLinkRelay$1.WalletLinkRelay = WalletLinkRelay;
    WalletLinkRelay.accountRequestCallbackIds = new Set();

    var MobileRelayUI$1 = {};

    var RedirectDialog$1 = {};

    var Snackbar = {};

    (function (exports) {
    	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    	    if (k2 === undefined) k2 = k;
    	    var desc = Object.getOwnPropertyDescriptor(m, k);
    	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    	      desc = { enumerable: true, get: function() { return m[k]; } };
    	    }
    	    Object.defineProperty(o, k2, desc);
    	}) : (function(o, m, k, k2) {
    	    if (k2 === undefined) k2 = k;
    	    o[k2] = m[k];
    	}));
    	var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
    	    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
    	};
    	Object.defineProperty(exports, "__esModule", { value: true });
    	__exportStar(Snackbar$1, exports); 
    } (Snackbar));

    var RedirectDialogCss = {};

    Object.defineProperty(RedirectDialogCss, "__esModule", { value: true });
    RedirectDialogCss.default = (() => `.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-backdrop{position:fixed;top:0;left:0;right:0;bottom:0;transition:opacity .25s;background-color:rgba(10,11,13,.5)}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-backdrop-hidden{opacity:0}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box{display:block;position:fixed;top:50%;left:50%;transform:translate(-50%, -50%);padding:20px;border-radius:8px;background-color:#fff;color:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box p{display:block;font-weight:400;font-size:14px;line-height:20px;padding-bottom:12px;color:#5b636e}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box button{appearance:none;border:none;background:none;color:#0052ff;padding:0;text-decoration:none;display:block;font-weight:600;font-size:16px;line-height:24px}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box.dark{background-color:#0a0b0d;color:#fff}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box.dark button{color:#0052ff}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box.light{background-color:#fff;color:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box.light button{color:#0052ff}`)();

    var __importDefault$6 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };
    Object.defineProperty(RedirectDialog$1, "__esModule", { value: true });
    RedirectDialog$1.RedirectDialog = void 0;
    const clsx_1 = __importDefault$6(require$$0);
    const preact_1 = require$$1$1;
    const cssReset_1 = cssReset;
    const Snackbar_1 = Snackbar;
    const RedirectDialog_css_1 = __importDefault$6(RedirectDialogCss);
    class RedirectDialog {
        constructor() {
            this.root = null;
        }
        attach() {
            const el = document.documentElement;
            this.root = document.createElement('div');
            this.root.className = '-cbwsdk-css-reset';
            el.appendChild(this.root);
            (0, cssReset_1.injectCssReset)();
        }
        present(props) {
            this.render(props);
        }
        clear() {
            this.render(null);
        }
        render(props) {
            if (!this.root)
                return;
            (0, preact_1.render)(null, this.root);
            if (!props)
                return;
            (0, preact_1.render)((0, preact_1.h)(RedirectDialogContent, Object.assign({}, props, { onDismiss: () => {
                    this.clear();
                } })), this.root);
        }
    }
    RedirectDialog$1.RedirectDialog = RedirectDialog;
    const RedirectDialogContent = ({ title, buttonText, darkMode, onButtonClick, onDismiss }) => {
        const theme = darkMode ? 'dark' : 'light';
        return ((0, preact_1.h)(Snackbar_1.SnackbarContainer, { darkMode: darkMode },
            (0, preact_1.h)("div", { class: "-cbwsdk-redirect-dialog" },
                (0, preact_1.h)("style", null, RedirectDialog_css_1.default),
                (0, preact_1.h)("div", { class: "-cbwsdk-redirect-dialog-backdrop", onClick: onDismiss }),
                (0, preact_1.h)("div", { class: (0, clsx_1.default)('-cbwsdk-redirect-dialog-box', theme) },
                    (0, preact_1.h)("p", null, title),
                    (0, preact_1.h)("button", { onClick: onButtonClick }, buttonText)))));
    };

    Object.defineProperty(MobileRelayUI$1, "__esModule", { value: true });
    MobileRelayUI$1.MobileRelayUI = void 0;
    const RedirectDialog_1 = RedirectDialog$1;
    // TODO: Implement & present in-page wallet picker instead of navigating to www.coinbase.com/connect-dapp
    class MobileRelayUI {
        constructor(options) {
            this.attached = false;
            this.darkMode = false;
            this.openedWindow = null;
            this.redirectDialog = new RedirectDialog_1.RedirectDialog();
            this.darkMode = options.darkMode;
        }
        attach() {
            if (this.attached) {
                throw new Error('Coinbase Wallet SDK UI is already attached');
            }
            this.redirectDialog.attach();
            this.attached = true;
        }
        setConnected(_connected) { } // no-op
        closeOpenedWindow() {
            var _a;
            (_a = this.openedWindow) === null || _a === void 0 ? void 0 : _a.close();
            this.openedWindow = null;
        }
        redirectToCoinbaseWallet(walletLinkUrl) {
            const url = new URL('https://go.cb-w.com/walletlink');
            url.searchParams.append('redirect_url', window.location.href);
            if (walletLinkUrl) {
                url.searchParams.append('wl_url', walletLinkUrl);
            }
            this.openedWindow = window.open(url.href, 'cbw-opener');
            if (this.openedWindow) {
                setTimeout(() => this.closeOpenedWindow(), 5000);
            }
        }
        openCoinbaseWalletDeeplink(walletLinkUrl) {
            this.redirectDialog.present({
                title: 'Redirecting to Coinbase Wallet...',
                buttonText: 'Open',
                darkMode: this.darkMode,
                onButtonClick: () => {
                    this.redirectToCoinbaseWallet(walletLinkUrl);
                },
            });
            setTimeout(() => {
                this.redirectToCoinbaseWallet(walletLinkUrl);
            }, 99);
        }
        showConnecting(_options) {
            // it uses the return callback to clear the dialog
            return () => {
                this.closeOpenedWindow();
                this.redirectDialog.clear();
            };
        }
        hideRequestEthereumAccounts() {
            this.closeOpenedWindow();
            this.redirectDialog.clear();
        }
        // -- Methods below are not needed for mobile
        requestEthereumAccounts() { } // no-op
        addEthereumChain() { } // no-op
        watchAsset() { } // no-op
        selectProvider() { } // no-op
        switchEthereumChain() { } // no-op
        signEthereumMessage() { } // no-op
        signEthereumTransaction() { } // no-op
        submitEthereumTransaction() { } // no-op
        ethereumAddressFromSignedMessage() { } // no-op
        reloadUI() { } // no-op
        setStandalone() { } // no-op
        setConnectDisabled() { } // no-op
        inlineAccountsResponse() {
            return false;
        }
        inlineAddEthereumChain() {
            return false;
        }
        inlineWatchAsset() {
            return false;
        }
        inlineSwitchEthereumChain() {
            return false;
        }
        isStandalone() {
            return false;
        }
    }
    MobileRelayUI$1.MobileRelayUI = MobileRelayUI;

    Object.defineProperty(MobileRelay$1, "__esModule", { value: true });
    MobileRelay$1.MobileRelay = void 0;
    const util_1$4 = util$3;
    const WalletLinkRelay_1$1 = WalletLinkRelay$1;
    const MobileRelayUI_1$1 = MobileRelayUI$1;
    class MobileRelay extends WalletLinkRelay_1$1.WalletLinkRelay {
        constructor(options) {
            var _a;
            super(options);
            this._enableMobileWalletLink = (_a = options.enableMobileWalletLink) !== null && _a !== void 0 ? _a : false;
        }
        // override
        requestEthereumAccounts() {
            if (this._enableMobileWalletLink) {
                return super.requestEthereumAccounts();
            }
            // TODO: Implement & present in-page wallet picker instead of navigating to www.coinbase.com/connect-dapp
            return {
                promise: new Promise(() => {
                    const location = (0, util_1$4.getLocation)();
                    location.href = `https://go.cb-w.com/dapp?cb_url=${encodeURIComponent(location.href)}`;
                }),
                cancel: () => { },
            };
        }
        // override
        publishWeb3RequestEvent(id, request) {
            super.publishWeb3RequestEvent(id, request);
            if (!(this._enableMobileWalletLink && this.ui instanceof MobileRelayUI_1$1.MobileRelayUI))
                return;
            let navigatedToCBW = false;
            // For mobile relay requests, open the Coinbase Wallet app
            switch (request.method) {
                case 'requestEthereumAccounts':
                case 'connectAndSignIn':
                    navigatedToCBW = true;
                    this.ui.openCoinbaseWalletDeeplink(this.getQRCodeUrl());
                    break;
                case 'switchEthereumChain':
                    // switchEthereumChain doesn't need to open the app
                    return;
                default:
                    navigatedToCBW = true;
                    this.ui.openCoinbaseWalletDeeplink();
                    break;
            }
            // If the user navigated to the Coinbase Wallet app, then we need to check
            // for unseen events once the user returns to the browser
            if (navigatedToCBW) {
                window.addEventListener('blur', () => {
                    window.addEventListener('focus', () => {
                        this.connection.checkUnseenEvents();
                    }, { once: true });
                }, { once: true });
            }
        }
        // override
        handleWeb3ResponseMessage(message) {
            super.handleWeb3ResponseMessage(message);
            if (this._enableMobileWalletLink && this.ui instanceof MobileRelayUI_1$1.MobileRelayUI) {
                this.ui.closeOpenedWindow();
            }
        }
        connectAndSignIn(params) {
            if (!this._enableMobileWalletLink) {
                throw new Error('connectAndSignIn is supported only when enableMobileWalletLink is on');
            }
            return this.sendRequest({
                method: 'connectAndSignIn',
                params: {
                    appName: this.appName,
                    appLogoUrl: this.appLogoUrl,
                    domain: window.location.hostname,
                    aud: window.location.href,
                    version: '1',
                    type: 'eip4361',
                    nonce: params.nonce,
                    iat: new Date().toISOString(),
                    chainId: `eip155:${this.dappDefaultChain}`,
                    statement: params.statement,
                    resources: params.resources,
                },
            });
        }
    }
    MobileRelay$1.MobileRelay = MobileRelay;

    var readableBrowser = {exports: {}};

    var streamBrowser;
    var hasRequiredStreamBrowser;

    function requireStreamBrowser () {
    	if (hasRequiredStreamBrowser) return streamBrowser;
    	hasRequiredStreamBrowser = 1;
    	streamBrowser = require$$0$3.EventEmitter;
    	return streamBrowser;
    }

    var inherits;
    if (typeof Object.create === 'function'){
      inherits = function inherits(ctor, superCtor) {
        // implementation from standard node.js 'util' module
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      };
    } else {
      inherits = function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function () {};
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      };
    }
    var inherits$1 = inherits;

    var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||
      function getOwnPropertyDescriptors(obj) {
        var keys = Object.keys(obj);
        var descriptors = {};
        for (var i = 0; i < keys.length; i++) {
          descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
        }
        return descriptors;
      };

    var formatRegExp = /%[sdj%]/g;
    function format(f) {
      if (!isString$1(f)) {
        var objects = [];
        for (var i = 0; i < arguments.length; i++) {
          objects.push(inspect(arguments[i]));
        }
        return objects.join(' ');
      }

      var i = 1;
      var args = arguments;
      var len = args.length;
      var str = String(f).replace(formatRegExp, function(x) {
        if (x === '%%') return '%';
        if (i >= len) return x;
        switch (x) {
          case '%s': return String(args[i++]);
          case '%d': return Number(args[i++]);
          case '%j':
            try {
              return JSON.stringify(args[i++]);
            } catch (_) {
              return '[Circular]';
            }
          default:
            return x;
        }
      });
      for (var x = args[i]; i < len; x = args[++i]) {
        if (isNull(x) || !isObject$1(x)) {
          str += ' ' + x;
        } else {
          str += ' ' + inspect(x);
        }
      }
      return str;
    }

    // Mark that a method should not be used.
    // Returns a modified function which warns once by default.
    // If --no-deprecation is set, then it is a no-op.
    function deprecate(fn, msg) {
      // Allow for deprecating things in the process of starting up.
      if (isUndefined(global$1.process)) {
        return function() {
          return deprecate(fn, msg).apply(this, arguments);
        };
      }

      if (browser$1$1.noDeprecation === true) {
        return fn;
      }

      var warned = false;
      function deprecated() {
        if (!warned) {
          if (browser$1$1.throwDeprecation) {
            throw new Error(msg);
          } else if (browser$1$1.traceDeprecation) {
            console.trace(msg);
          } else {
            console.error(msg);
          }
          warned = true;
        }
        return fn.apply(this, arguments);
      }

      return deprecated;
    }

    var debugs = {};
    var debugEnviron;
    function debuglog(set) {
      if (isUndefined(debugEnviron))
        debugEnviron = browser$1$1.env.NODE_DEBUG || '';
      set = set.toUpperCase();
      if (!debugs[set]) {
        if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
          var pid = 0;
          debugs[set] = function() {
            var msg = format.apply(null, arguments);
            console.error('%s %d: %s', set, pid, msg);
          };
        } else {
          debugs[set] = function() {};
        }
      }
      return debugs[set];
    }

    /**
     * Echos the value of a value. Trys to print the value out
     * in the best way possible given the different types.
     *
     * @param {Object} obj The object to print out.
     * @param {Object} opts Optional options object that alters the output.
     */
    /* legacy: obj, showHidden, depth, colors*/
    function inspect(obj, opts) {
      // default options
      var ctx = {
        seen: [],
        stylize: stylizeNoColor
      };
      // legacy...
      if (arguments.length >= 3) ctx.depth = arguments[2];
      if (arguments.length >= 4) ctx.colors = arguments[3];
      if (isBoolean(opts)) {
        // legacy...
        ctx.showHidden = opts;
      } else if (opts) {
        // got an "options" object
        _extend(ctx, opts);
      }
      // set default options
      if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
      if (isUndefined(ctx.depth)) ctx.depth = 2;
      if (isUndefined(ctx.colors)) ctx.colors = false;
      if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
      if (ctx.colors) ctx.stylize = stylizeWithColor;
      return formatValue(ctx, obj, ctx.depth);
    }

    // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
    inspect.colors = {
      'bold' : [1, 22],
      'italic' : [3, 23],
      'underline' : [4, 24],
      'inverse' : [7, 27],
      'white' : [37, 39],
      'grey' : [90, 39],
      'black' : [30, 39],
      'blue' : [34, 39],
      'cyan' : [36, 39],
      'green' : [32, 39],
      'magenta' : [35, 39],
      'red' : [31, 39],
      'yellow' : [33, 39]
    };

    // Don't use 'blue' not visible on cmd.exe
    inspect.styles = {
      'special': 'cyan',
      'number': 'yellow',
      'boolean': 'yellow',
      'undefined': 'grey',
      'null': 'bold',
      'string': 'green',
      'date': 'magenta',
      // "name": intentionally not styling
      'regexp': 'red'
    };


    function stylizeWithColor(str, styleType) {
      var style = inspect.styles[styleType];

      if (style) {
        return '\u001b[' + inspect.colors[style][0] + 'm' + str +
               '\u001b[' + inspect.colors[style][1] + 'm';
      } else {
        return str;
      }
    }


    function stylizeNoColor(str, styleType) {
      return str;
    }


    function arrayToHash(array) {
      var hash = {};

      array.forEach(function(val, idx) {
        hash[val] = true;
      });

      return hash;
    }


    function formatValue(ctx, value, recurseTimes) {
      // Provide a hook for user-specified inspect functions.
      // Check that value is an object with an inspect function on it
      if (ctx.customInspect &&
          value &&
          isFunction$1(value.inspect) &&
          // Filter out the util module, it's inspect function is special
          value.inspect !== inspect &&
          // Also filter out any prototype objects using the circular check.
          !(value.constructor && value.constructor.prototype === value)) {
        var ret = value.inspect(recurseTimes, ctx);
        if (!isString$1(ret)) {
          ret = formatValue(ctx, ret, recurseTimes);
        }
        return ret;
      }

      // Primitive types cannot have properties
      var primitive = formatPrimitive(ctx, value);
      if (primitive) {
        return primitive;
      }

      // Look up the keys of the object.
      var keys = Object.keys(value);
      var visibleKeys = arrayToHash(keys);

      if (ctx.showHidden) {
        keys = Object.getOwnPropertyNames(value);
      }

      // IE doesn't make error fields non-enumerable
      // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
      if (isError(value)
          && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
        return formatError(value);
      }

      // Some type of object without properties can be shortcutted.
      if (keys.length === 0) {
        if (isFunction$1(value)) {
          var name = value.name ? ': ' + value.name : '';
          return ctx.stylize('[Function' + name + ']', 'special');
        }
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
        }
        if (isDate(value)) {
          return ctx.stylize(Date.prototype.toString.call(value), 'date');
        }
        if (isError(value)) {
          return formatError(value);
        }
      }

      var base = '', array = false, braces = ['{', '}'];

      // Make Array say that they are Array
      if (isArray$1(value)) {
        array = true;
        braces = ['[', ']'];
      }

      // Make functions say that they are functions
      if (isFunction$1(value)) {
        var n = value.name ? ': ' + value.name : '';
        base = ' [Function' + n + ']';
      }

      // Make RegExps say that they are RegExps
      if (isRegExp(value)) {
        base = ' ' + RegExp.prototype.toString.call(value);
      }

      // Make dates with properties first say the date
      if (isDate(value)) {
        base = ' ' + Date.prototype.toUTCString.call(value);
      }

      // Make error with message first say the error
      if (isError(value)) {
        base = ' ' + formatError(value);
      }

      if (keys.length === 0 && (!array || value.length == 0)) {
        return braces[0] + base + braces[1];
      }

      if (recurseTimes < 0) {
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
        } else {
          return ctx.stylize('[Object]', 'special');
        }
      }

      ctx.seen.push(value);

      var output;
      if (array) {
        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
      } else {
        output = keys.map(function(key) {
          return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
        });
      }

      ctx.seen.pop();

      return reduceToSingleString(output, base, braces);
    }


    function formatPrimitive(ctx, value) {
      if (isUndefined(value))
        return ctx.stylize('undefined', 'undefined');
      if (isString$1(value)) {
        var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                                 .replace(/'/g, "\\'")
                                                 .replace(/\\"/g, '"') + '\'';
        return ctx.stylize(simple, 'string');
      }
      if (isNumber$1(value))
        return ctx.stylize('' + value, 'number');
      if (isBoolean(value))
        return ctx.stylize('' + value, 'boolean');
      // For some reason typeof null is "object", so special case here.
      if (isNull(value))
        return ctx.stylize('null', 'null');
    }


    function formatError(value) {
      return '[' + Error.prototype.toString.call(value) + ']';
    }


    function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
      var output = [];
      for (var i = 0, l = value.length; i < l; ++i) {
        if (hasOwnProperty$1(value, String(i))) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
              String(i), true));
        } else {
          output.push('');
        }
      }
      keys.forEach(function(key) {
        if (!key.match(/^\d+$/)) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
              key, true));
        }
      });
      return output;
    }


    function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
      var name, str, desc;
      desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
      if (desc.get) {
        if (desc.set) {
          str = ctx.stylize('[Getter/Setter]', 'special');
        } else {
          str = ctx.stylize('[Getter]', 'special');
        }
      } else {
        if (desc.set) {
          str = ctx.stylize('[Setter]', 'special');
        }
      }
      if (!hasOwnProperty$1(visibleKeys, key)) {
        name = '[' + key + ']';
      }
      if (!str) {
        if (ctx.seen.indexOf(desc.value) < 0) {
          if (isNull(recurseTimes)) {
            str = formatValue(ctx, desc.value, null);
          } else {
            str = formatValue(ctx, desc.value, recurseTimes - 1);
          }
          if (str.indexOf('\n') > -1) {
            if (array) {
              str = str.split('\n').map(function(line) {
                return '  ' + line;
              }).join('\n').substr(2);
            } else {
              str = '\n' + str.split('\n').map(function(line) {
                return '   ' + line;
              }).join('\n');
            }
          }
        } else {
          str = ctx.stylize('[Circular]', 'special');
        }
      }
      if (isUndefined(name)) {
        if (array && key.match(/^\d+$/)) {
          return str;
        }
        name = JSON.stringify('' + key);
        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name = name.substr(1, name.length - 2);
          name = ctx.stylize(name, 'name');
        } else {
          name = name.replace(/'/g, "\\'")
                     .replace(/\\"/g, '"')
                     .replace(/(^"|"$)/g, "'");
          name = ctx.stylize(name, 'string');
        }
      }

      return name + ': ' + str;
    }


    function reduceToSingleString(output, base, braces) {
      var length = output.reduce(function(prev, cur) {
        if (cur.indexOf('\n') >= 0) ;
        return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
      }, 0);

      if (length > 60) {
        return braces[0] +
               (base === '' ? '' : base + '\n ') +
               ' ' +
               output.join(',\n  ') +
               ' ' +
               braces[1];
      }

      return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
    }


    // NOTE: These type checking functions intentionally don't use `instanceof`
    // because it is fragile and can be easily faked with `Object.create()`.
    function isArray$1(ar) {
      return Array.isArray(ar);
    }

    function isBoolean(arg) {
      return typeof arg === 'boolean';
    }

    function isNull(arg) {
      return arg === null;
    }

    function isNullOrUndefined(arg) {
      return arg == null;
    }

    function isNumber$1(arg) {
      return typeof arg === 'number';
    }

    function isString$1(arg) {
      return typeof arg === 'string';
    }

    function isSymbol(arg) {
      return typeof arg === 'symbol';
    }

    function isUndefined(arg) {
      return arg === void 0;
    }

    function isRegExp(re) {
      return isObject$1(re) && objectToString(re) === '[object RegExp]';
    }

    function isObject$1(arg) {
      return typeof arg === 'object' && arg !== null;
    }

    function isDate(d) {
      return isObject$1(d) && objectToString(d) === '[object Date]';
    }

    function isError(e) {
      return isObject$1(e) &&
          (objectToString(e) === '[object Error]' || e instanceof Error);
    }

    function isFunction$1(arg) {
      return typeof arg === 'function';
    }

    function isPrimitive(arg) {
      return arg === null ||
             typeof arg === 'boolean' ||
             typeof arg === 'number' ||
             typeof arg === 'string' ||
             typeof arg === 'symbol' ||  // ES6 symbol
             typeof arg === 'undefined';
    }

    function isBuffer(maybeBuf) {
      return Buffer$8.isBuffer(maybeBuf);
    }

    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }


    function pad(n) {
      return n < 10 ? '0' + n.toString(10) : n.toString(10);
    }


    var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
                  'Oct', 'Nov', 'Dec'];

    // 26 Feb 16:19:34
    function timestamp() {
      var d = new Date();
      var time = [pad(d.getHours()),
                  pad(d.getMinutes()),
                  pad(d.getSeconds())].join(':');
      return [d.getDate(), months[d.getMonth()], time].join(' ');
    }


    // log is just a thin wrapper to console.log that prepends a timestamp
    function log$1() {
      console.log('%s - %s', timestamp(), format.apply(null, arguments));
    }

    function _extend(origin, add) {
      // Don't do anything if add isn't an object
      if (!add || !isObject$1(add)) return origin;

      var keys = Object.keys(add);
      var i = keys.length;
      while (i--) {
        origin[keys[i]] = add[keys[i]];
      }
      return origin;
    }
    function hasOwnProperty$1(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }

    var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;

    function promisify(original) {
      if (typeof original !== 'function')
        throw new TypeError('The "original" argument must be of type Function');

      if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
        var fn = original[kCustomPromisifiedSymbol];
        if (typeof fn !== 'function') {
          throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        }
        Object.defineProperty(fn, kCustomPromisifiedSymbol, {
          value: fn, enumerable: false, writable: false, configurable: true
        });
        return fn;
      }

      function fn() {
        var promiseResolve, promiseReject;
        var promise = new Promise(function (resolve, reject) {
          promiseResolve = resolve;
          promiseReject = reject;
        });

        var args = [];
        for (var i = 0; i < arguments.length; i++) {
          args.push(arguments[i]);
        }
        args.push(function (err, value) {
          if (err) {
            promiseReject(err);
          } else {
            promiseResolve(value);
          }
        });

        try {
          original.apply(this, args);
        } catch (err) {
          promiseReject(err);
        }

        return promise;
      }

      Object.setPrototypeOf(fn, Object.getPrototypeOf(original));

      if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
        value: fn, enumerable: false, writable: false, configurable: true
      });
      return Object.defineProperties(
        fn,
        getOwnPropertyDescriptors(original)
      );
    }

    promisify.custom = kCustomPromisifiedSymbol;

    function callbackifyOnRejected(reason, cb) {
      // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
      // Because `null` is a special error value in callbacks which means "no error
      // occurred", we error-wrap so the callback consumer can distinguish between
      // "the promise rejected with null" or "the promise fulfilled with undefined".
      if (!reason) {
        var newReason = new Error('Promise was rejected with a falsy value');
        newReason.reason = reason;
        reason = newReason;
      }
      return cb(reason);
    }

    function callbackify(original) {
      if (typeof original !== 'function') {
        throw new TypeError('The "original" argument must be of type Function');
      }

      // We DO NOT return the promise as it gives the user a false sense that
      // the promise is actually somehow related to the callback's execution
      // and that the callback throwing will reject the promise.
      function callbackified() {
        var args = [];
        for (var i = 0; i < arguments.length; i++) {
          args.push(arguments[i]);
        }

        var maybeCb = args.pop();
        if (typeof maybeCb !== 'function') {
          throw new TypeError('The last argument must be of type Function');
        }
        var self = this;
        var cb = function() {
          return maybeCb.apply(self, arguments);
        };
        // In true node style we process the callback on `nextTick` with all the
        // implications (stack, `uncaughtException`, `async_hooks`)
        original.apply(this, args)
          .then(function(ret) { browser$1$1.nextTick(cb.bind(null, null, ret)); },
            function(rej) { browser$1$1.nextTick(callbackifyOnRejected.bind(null, rej, cb)); });
      }

      Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
      Object.defineProperties(callbackified, getOwnPropertyDescriptors(original));
      return callbackified;
    }

    var _polyfillNode_util = {
      inherits: inherits$1,
      _extend: _extend,
      log: log$1,
      isBuffer: isBuffer,
      isPrimitive: isPrimitive,
      isFunction: isFunction$1,
      isError: isError,
      isDate: isDate,
      isObject: isObject$1,
      isRegExp: isRegExp,
      isUndefined: isUndefined,
      isSymbol: isSymbol,
      isString: isString$1,
      isNumber: isNumber$1,
      isNullOrUndefined: isNullOrUndefined,
      isNull: isNull,
      isBoolean: isBoolean,
      isArray: isArray$1,
      inspect: inspect,
      deprecate: deprecate,
      format: format,
      debuglog: debuglog,
      promisify: promisify,
      callbackify: callbackify,
    };

    var _polyfillNode_util$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        _extend: _extend,
        callbackify: callbackify,
        debuglog: debuglog,
        default: _polyfillNode_util,
        deprecate: deprecate,
        format: format,
        inherits: inherits$1,
        inspect: inspect,
        isArray: isArray$1,
        isBoolean: isBoolean,
        isBuffer: isBuffer,
        isDate: isDate,
        isError: isError,
        isFunction: isFunction$1,
        isNull: isNull,
        isNullOrUndefined: isNullOrUndefined,
        isNumber: isNumber$1,
        isObject: isObject$1,
        isPrimitive: isPrimitive,
        isRegExp: isRegExp,
        isString: isString$1,
        isSymbol: isSymbol,
        isUndefined: isUndefined,
        log: log$1,
        promisify: promisify
    });

    var require$$3 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_util$1);

    var buffer_list;
    var hasRequiredBuffer_list;

    function requireBuffer_list () {
    	if (hasRequiredBuffer_list) return buffer_list;
    	hasRequiredBuffer_list = 1;

    	function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
    	function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
    	function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
    	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
    	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
    	function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
    	function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
    	var _require = require$$2$1,
    	  Buffer = _require.Buffer;
    	var _require2 = require$$3,
    	  inspect = _require2.inspect;
    	var custom = inspect && inspect.custom || 'inspect';
    	function copyBuffer(src, target, offset) {
    	  Buffer.prototype.copy.call(src, target, offset);
    	}
    	buffer_list = /*#__PURE__*/function () {
    	  function BufferList() {
    	    _classCallCheck(this, BufferList);
    	    this.head = null;
    	    this.tail = null;
    	    this.length = 0;
    	  }
    	  _createClass(BufferList, [{
    	    key: "push",
    	    value: function push(v) {
    	      var entry = {
    	        data: v,
    	        next: null
    	      };
    	      if (this.length > 0) this.tail.next = entry;else this.head = entry;
    	      this.tail = entry;
    	      ++this.length;
    	    }
    	  }, {
    	    key: "unshift",
    	    value: function unshift(v) {
    	      var entry = {
    	        data: v,
    	        next: this.head
    	      };
    	      if (this.length === 0) this.tail = entry;
    	      this.head = entry;
    	      ++this.length;
    	    }
    	  }, {
    	    key: "shift",
    	    value: function shift() {
    	      if (this.length === 0) return;
    	      var ret = this.head.data;
    	      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    	      --this.length;
    	      return ret;
    	    }
    	  }, {
    	    key: "clear",
    	    value: function clear() {
    	      this.head = this.tail = null;
    	      this.length = 0;
    	    }
    	  }, {
    	    key: "join",
    	    value: function join(s) {
    	      if (this.length === 0) return '';
    	      var p = this.head;
    	      var ret = '' + p.data;
    	      while (p = p.next) ret += s + p.data;
    	      return ret;
    	    }
    	  }, {
    	    key: "concat",
    	    value: function concat(n) {
    	      if (this.length === 0) return Buffer.alloc(0);
    	      var ret = Buffer.allocUnsafe(n >>> 0);
    	      var p = this.head;
    	      var i = 0;
    	      while (p) {
    	        copyBuffer(p.data, ret, i);
    	        i += p.data.length;
    	        p = p.next;
    	      }
    	      return ret;
    	    }

    	    // Consumes a specified amount of bytes or characters from the buffered data.
    	  }, {
    	    key: "consume",
    	    value: function consume(n, hasStrings) {
    	      var ret;
    	      if (n < this.head.data.length) {
    	        // `slice` is the same for buffers and strings.
    	        ret = this.head.data.slice(0, n);
    	        this.head.data = this.head.data.slice(n);
    	      } else if (n === this.head.data.length) {
    	        // First chunk is a perfect match.
    	        ret = this.shift();
    	      } else {
    	        // Result spans more than one buffer.
    	        ret = hasStrings ? this._getString(n) : this._getBuffer(n);
    	      }
    	      return ret;
    	    }
    	  }, {
    	    key: "first",
    	    value: function first() {
    	      return this.head.data;
    	    }

    	    // Consumes a specified amount of characters from the buffered data.
    	  }, {
    	    key: "_getString",
    	    value: function _getString(n) {
    	      var p = this.head;
    	      var c = 1;
    	      var ret = p.data;
    	      n -= ret.length;
    	      while (p = p.next) {
    	        var str = p.data;
    	        var nb = n > str.length ? str.length : n;
    	        if (nb === str.length) ret += str;else ret += str.slice(0, n);
    	        n -= nb;
    	        if (n === 0) {
    	          if (nb === str.length) {
    	            ++c;
    	            if (p.next) this.head = p.next;else this.head = this.tail = null;
    	          } else {
    	            this.head = p;
    	            p.data = str.slice(nb);
    	          }
    	          break;
    	        }
    	        ++c;
    	      }
    	      this.length -= c;
    	      return ret;
    	    }

    	    // Consumes a specified amount of bytes from the buffered data.
    	  }, {
    	    key: "_getBuffer",
    	    value: function _getBuffer(n) {
    	      var ret = Buffer.allocUnsafe(n);
    	      var p = this.head;
    	      var c = 1;
    	      p.data.copy(ret);
    	      n -= p.data.length;
    	      while (p = p.next) {
    	        var buf = p.data;
    	        var nb = n > buf.length ? buf.length : n;
    	        buf.copy(ret, ret.length - n, 0, nb);
    	        n -= nb;
    	        if (n === 0) {
    	          if (nb === buf.length) {
    	            ++c;
    	            if (p.next) this.head = p.next;else this.head = this.tail = null;
    	          } else {
    	            this.head = p;
    	            p.data = buf.slice(nb);
    	          }
    	          break;
    	        }
    	        ++c;
    	      }
    	      this.length -= c;
    	      return ret;
    	    }

    	    // Make sure the linked list only shows the minimal necessary information.
    	  }, {
    	    key: custom,
    	    value: function value(_, options) {
    	      return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
    	        // Only inspect one level.
    	        depth: 0,
    	        // It should not recurse.
    	        customInspect: false
    	      }));
    	    }
    	  }]);
    	  return BufferList;
    	}();
    	return buffer_list;
    }

    var destroy_1;
    var hasRequiredDestroy;

    function requireDestroy () {
    	if (hasRequiredDestroy) return destroy_1;
    	hasRequiredDestroy = 1;

    	// undocumented cb() API, needed for core, not for public API
    	function destroy(err, cb) {
    	  var _this = this;
    	  var readableDestroyed = this._readableState && this._readableState.destroyed;
    	  var writableDestroyed = this._writableState && this._writableState.destroyed;
    	  if (readableDestroyed || writableDestroyed) {
    	    if (cb) {
    	      cb(err);
    	    } else if (err) {
    	      if (!this._writableState) {
    	        browser$1$1.nextTick(emitErrorNT, this, err);
    	      } else if (!this._writableState.errorEmitted) {
    	        this._writableState.errorEmitted = true;
    	        browser$1$1.nextTick(emitErrorNT, this, err);
    	      }
    	    }
    	    return this;
    	  }

    	  // we set destroyed to true before firing error callbacks in order
    	  // to make it re-entrance safe in case destroy() is called within callbacks

    	  if (this._readableState) {
    	    this._readableState.destroyed = true;
    	  }

    	  // if this is a duplex stream mark the writable part as destroyed as well
    	  if (this._writableState) {
    	    this._writableState.destroyed = true;
    	  }
    	  this._destroy(err || null, function (err) {
    	    if (!cb && err) {
    	      if (!_this._writableState) {
    	        browser$1$1.nextTick(emitErrorAndCloseNT, _this, err);
    	      } else if (!_this._writableState.errorEmitted) {
    	        _this._writableState.errorEmitted = true;
    	        browser$1$1.nextTick(emitErrorAndCloseNT, _this, err);
    	      } else {
    	        browser$1$1.nextTick(emitCloseNT, _this);
    	      }
    	    } else if (cb) {
    	      browser$1$1.nextTick(emitCloseNT, _this);
    	      cb(err);
    	    } else {
    	      browser$1$1.nextTick(emitCloseNT, _this);
    	    }
    	  });
    	  return this;
    	}
    	function emitErrorAndCloseNT(self, err) {
    	  emitErrorNT(self, err);
    	  emitCloseNT(self);
    	}
    	function emitCloseNT(self) {
    	  if (self._writableState && !self._writableState.emitClose) return;
    	  if (self._readableState && !self._readableState.emitClose) return;
    	  self.emit('close');
    	}
    	function undestroy() {
    	  if (this._readableState) {
    	    this._readableState.destroyed = false;
    	    this._readableState.reading = false;
    	    this._readableState.ended = false;
    	    this._readableState.endEmitted = false;
    	  }
    	  if (this._writableState) {
    	    this._writableState.destroyed = false;
    	    this._writableState.ended = false;
    	    this._writableState.ending = false;
    	    this._writableState.finalCalled = false;
    	    this._writableState.prefinished = false;
    	    this._writableState.finished = false;
    	    this._writableState.errorEmitted = false;
    	  }
    	}
    	function emitErrorNT(self, err) {
    	  self.emit('error', err);
    	}
    	function errorOrDestroy(stream, err) {
    	  // We have tests that rely on errors being emitted
    	  // in the same tick, so changing this is semver major.
    	  // For now when you opt-in to autoDestroy we allow
    	  // the error to be emitted nextTick. In a future
    	  // semver major update we should change the default to this.

    	  var rState = stream._readableState;
    	  var wState = stream._writableState;
    	  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);
    	}
    	destroy_1 = {
    	  destroy: destroy,
    	  undestroy: undestroy,
    	  errorOrDestroy: errorOrDestroy
    	};
    	return destroy_1;
    }

    var errorsBrowser = {};

    function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

    var codes = {};

    function createErrorType(code, message, Base) {
      if (!Base) {
        Base = Error;
      }

      function getMessage(arg1, arg2, arg3) {
        if (typeof message === 'string') {
          return message;
        } else {
          return message(arg1, arg2, arg3);
        }
      }

      var NodeError =
      /*#__PURE__*/
      function (_Base) {
        _inheritsLoose(NodeError, _Base);

        function NodeError(arg1, arg2, arg3) {
          return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
        }

        return NodeError;
      }(Base);

      NodeError.prototype.name = Base.name;
      NodeError.prototype.code = code;
      codes[code] = NodeError;
    } // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js


    function oneOf(expected, thing) {
      if (Array.isArray(expected)) {
        var len = expected.length;
        expected = expected.map(function (i) {
          return String(i);
        });

        if (len > 2) {
          return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
        } else if (len === 2) {
          return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
        } else {
          return "of ".concat(thing, " ").concat(expected[0]);
        }
      } else {
        return "of ".concat(thing, " ").concat(String(expected));
      }
    } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith


    function startsWith(str, search, pos) {
      return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
    } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith


    function endsWith(str, search, this_len) {
      if (this_len === undefined || this_len > str.length) {
        this_len = str.length;
      }

      return str.substring(this_len - search.length, this_len) === search;
    } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes


    function includes(str, search, start) {
      if (typeof start !== 'number') {
        start = 0;
      }

      if (start + search.length > str.length) {
        return false;
      } else {
        return str.indexOf(search, start) !== -1;
      }
    }

    createErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {
      return 'The value "' + value + '" is invalid for option "' + name + '"';
    }, TypeError);
    createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
      // determiner: 'must be' or 'must not be'
      var determiner;

      if (typeof expected === 'string' && startsWith(expected, 'not ')) {
        determiner = 'must not be';
        expected = expected.replace(/^not /, '');
      } else {
        determiner = 'must be';
      }

      var msg;

      if (endsWith(name, ' argument')) {
        // For cases like 'first argument'
        msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
      } else {
        var type = includes(name, '.') ? 'property' : 'argument';
        msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
      }

      msg += ". Received type ".concat(typeof actual);
      return msg;
    }, TypeError);
    createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');
    createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {
      return 'The ' + name + ' method is not implemented';
    });
    createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');
    createErrorType('ERR_STREAM_DESTROYED', function (name) {
      return 'Cannot call ' + name + ' after a stream was destroyed';
    });
    createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
    createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');
    createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');
    createErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
    createErrorType('ERR_UNKNOWN_ENCODING', function (arg) {
      return 'Unknown encoding: ' + arg;
    }, TypeError);
    createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');
    errorsBrowser.codes = codes;

    var state$1;
    var hasRequiredState;

    function requireState () {
    	if (hasRequiredState) return state$1;
    	hasRequiredState = 1;

    	var ERR_INVALID_OPT_VALUE = errorsBrowser.codes.ERR_INVALID_OPT_VALUE;
    	function highWaterMarkFrom(options, isDuplex, duplexKey) {
    	  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
    	}
    	function getHighWaterMark(state, options, duplexKey, isDuplex) {
    	  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
    	  if (hwm != null) {
    	    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
    	      var name = isDuplex ? duplexKey : 'highWaterMark';
    	      throw new ERR_INVALID_OPT_VALUE(name, hwm);
    	    }
    	    return Math.floor(hwm);
    	  }

    	  // Default value
    	  return state.objectMode ? 16 : 16 * 1024;
    	}
    	state$1 = {
    	  getHighWaterMark: getHighWaterMark
    	};
    	return state$1;
    }

    var browser$1;
    var hasRequiredBrowser;

    function requireBrowser () {
    	if (hasRequiredBrowser) return browser$1;
    	hasRequiredBrowser = 1;
    	/**
    	 * Module exports.
    	 */

    	browser$1 = deprecate;

    	/**
    	 * Mark that a method should not be used.
    	 * Returns a modified function which warns once by default.
    	 *
    	 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
    	 *
    	 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
    	 * will throw an Error when invoked.
    	 *
    	 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
    	 * will invoke `console.trace()` instead of `console.error()`.
    	 *
    	 * @param {Function} fn - the function to deprecate
    	 * @param {String} msg - the string to print to the console when `fn` is invoked
    	 * @returns {Function} a new "deprecated" version of `fn`
    	 * @api public
    	 */

    	function deprecate (fn, msg) {
    	  if (config('noDeprecation')) {
    	    return fn;
    	  }

    	  var warned = false;
    	  function deprecated() {
    	    if (!warned) {
    	      if (config('throwDeprecation')) {
    	        throw new Error(msg);
    	      } else if (config('traceDeprecation')) {
    	        console.trace(msg);
    	      } else {
    	        console.warn(msg);
    	      }
    	      warned = true;
    	    }
    	    return fn.apply(this, arguments);
    	  }

    	  return deprecated;
    	}

    	/**
    	 * Checks `localStorage` for boolean values for the given `name`.
    	 *
    	 * @param {String} name
    	 * @returns {Boolean}
    	 * @api private
    	 */

    	function config (name) {
    	  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
    	  try {
    	    if (!commonjsGlobal.localStorage) return false;
    	  } catch (_) {
    	    return false;
    	  }
    	  var val = commonjsGlobal.localStorage[name];
    	  if (null == val) return false;
    	  return String(val).toLowerCase() === 'true';
    	}
    	return browser$1;
    }

    var _stream_writable;
    var hasRequired_stream_writable;

    function require_stream_writable () {
    	if (hasRequired_stream_writable) return _stream_writable;
    	hasRequired_stream_writable = 1;

    	_stream_writable = Writable;

    	// It seems a linked list but it is not
    	// there will be only 2 of these for each stream
    	function CorkedRequest(state) {
    	  var _this = this;
    	  this.next = null;
    	  this.entry = null;
    	  this.finish = function () {
    	    onCorkedFinish(_this, state);
    	  };
    	}
    	/* </replacement> */

    	/*<replacement>*/
    	var Duplex;
    	/*</replacement>*/

    	Writable.WritableState = WritableState;

    	/*<replacement>*/
    	var internalUtil = {
    	  deprecate: requireBrowser()
    	};
    	/*</replacement>*/

    	/*<replacement>*/
    	var Stream = requireStreamBrowser();
    	/*</replacement>*/

    	var Buffer = require$$2$1.Buffer;
    	var OurUint8Array = (typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};
    	function _uint8ArrayToBuffer(chunk) {
    	  return Buffer.from(chunk);
    	}
    	function _isUint8Array(obj) {
    	  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
    	}
    	var destroyImpl = requireDestroy();
    	var _require = requireState(),
    	  getHighWaterMark = _require.getHighWaterMark;
    	var _require$codes = errorsBrowser.codes,
    	  ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    	  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    	  ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    	  ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,
    	  ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,
    	  ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,
    	  ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,
    	  ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
    	var errorOrDestroy = destroyImpl.errorOrDestroy;
    	require$$1$2(Writable, Stream);
    	function nop() {}
    	function WritableState(options, stream, isDuplex) {
    	  Duplex = Duplex || require_stream_duplex();
    	  options = options || {};

    	  // Duplex streams are both readable and writable, but share
    	  // the same options object.
    	  // However, some cases require setting options to different
    	  // values for the readable and the writable sides of the duplex stream,
    	  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.
    	  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex;

    	  // object stream flag to indicate whether or not this stream
    	  // contains buffers or objects.
    	  this.objectMode = !!options.objectMode;
    	  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

    	  // the point at which write() starts returning false
    	  // Note: 0 is a valid value, means that we always return false if
    	  // the entire buffer is not flushed immediately on write()
    	  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex);

    	  // if _final has been called
    	  this.finalCalled = false;

    	  // drain event flag.
    	  this.needDrain = false;
    	  // at the start of calling end()
    	  this.ending = false;
    	  // when end() has been called, and returned
    	  this.ended = false;
    	  // when 'finish' is emitted
    	  this.finished = false;

    	  // has it been destroyed
    	  this.destroyed = false;

    	  // should we decode strings into buffers before passing to _write?
    	  // this is here so that some node-core streams can optimize string
    	  // handling at a lower level.
    	  var noDecode = options.decodeStrings === false;
    	  this.decodeStrings = !noDecode;

    	  // Crypto is kind of old and crusty.  Historically, its default string
    	  // encoding is 'binary' so we have to make this configurable.
    	  // Everything else in the universe uses 'utf8', though.
    	  this.defaultEncoding = options.defaultEncoding || 'utf8';

    	  // not an actual buffer we keep track of, but a measurement
    	  // of how much we're waiting to get pushed to some underlying
    	  // socket or file.
    	  this.length = 0;

    	  // a flag to see when we're in the middle of a write.
    	  this.writing = false;

    	  // when true all writes will be buffered until .uncork() call
    	  this.corked = 0;

    	  // a flag to be able to tell if the onwrite cb is called immediately,
    	  // or on a later tick.  We set this to true at first, because any
    	  // actions that shouldn't happen until "later" should generally also
    	  // not happen before the first write call.
    	  this.sync = true;

    	  // a flag to know if we're processing previously buffered items, which
    	  // may call the _write() callback in the same tick, so that we don't
    	  // end up in an overlapped onwrite situation.
    	  this.bufferProcessing = false;

    	  // the callback that's passed to _write(chunk,cb)
    	  this.onwrite = function (er) {
    	    onwrite(stream, er);
    	  };

    	  // the callback that the user supplies to write(chunk,encoding,cb)
    	  this.writecb = null;

    	  // the amount that is being written when _write is called.
    	  this.writelen = 0;
    	  this.bufferedRequest = null;
    	  this.lastBufferedRequest = null;

    	  // number of pending user-supplied write callbacks
    	  // this must be 0 before 'finish' can be emitted
    	  this.pendingcb = 0;

    	  // emit prefinish if the only thing we're waiting for is _write cbs
    	  // This is relevant for synchronous Transform streams
    	  this.prefinished = false;

    	  // True if the error was already emitted and should not be thrown again
    	  this.errorEmitted = false;

    	  // Should close be emitted on destroy. Defaults to true.
    	  this.emitClose = options.emitClose !== false;

    	  // Should .destroy() be called after 'finish' (and potentially 'end')
    	  this.autoDestroy = !!options.autoDestroy;

    	  // count buffered requests
    	  this.bufferedRequestCount = 0;

    	  // allocate the first CorkedRequest, there is always
    	  // one allocated and free to use, and we maintain at most two
    	  this.corkedRequestsFree = new CorkedRequest(this);
    	}
    	WritableState.prototype.getBuffer = function getBuffer() {
    	  var current = this.bufferedRequest;
    	  var out = [];
    	  while (current) {
    	    out.push(current);
    	    current = current.next;
    	  }
    	  return out;
    	};
    	(function () {
    	  try {
    	    Object.defineProperty(WritableState.prototype, 'buffer', {
    	      get: internalUtil.deprecate(function writableStateBufferGetter() {
    	        return this.getBuffer();
    	      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    	    });
    	  } catch (_) {}
    	})();

    	// Test _writableState for inheritance to account for Duplex streams,
    	// whose prototype chain only points to Readable.
    	var realHasInstance;
    	if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
    	  realHasInstance = Function.prototype[Symbol.hasInstance];
    	  Object.defineProperty(Writable, Symbol.hasInstance, {
    	    value: function value(object) {
    	      if (realHasInstance.call(this, object)) return true;
    	      if (this !== Writable) return false;
    	      return object && object._writableState instanceof WritableState;
    	    }
    	  });
    	} else {
    	  realHasInstance = function realHasInstance(object) {
    	    return object instanceof this;
    	  };
    	}
    	function Writable(options) {
    	  Duplex = Duplex || require_stream_duplex();

    	  // Writable ctor is applied to Duplexes, too.
    	  // `realHasInstance` is necessary because using plain `instanceof`
    	  // would return false, as no `_writableState` property is attached.

    	  // Trying to use the custom `instanceof` for Writable here will also break the
    	  // Node.js LazyTransform implementation, which has a non-trivial getter for
    	  // `_writableState` that would lead to infinite recursion.

    	  // Checking for a Stream.Duplex instance is faster here instead of inside
    	  // the WritableState constructor, at least with V8 6.5
    	  var isDuplex = this instanceof Duplex;
    	  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
    	  this._writableState = new WritableState(options, this, isDuplex);

    	  // legacy.
    	  this.writable = true;
    	  if (options) {
    	    if (typeof options.write === 'function') this._write = options.write;
    	    if (typeof options.writev === 'function') this._writev = options.writev;
    	    if (typeof options.destroy === 'function') this._destroy = options.destroy;
    	    if (typeof options.final === 'function') this._final = options.final;
    	  }
    	  Stream.call(this);
    	}

    	// Otherwise people can pipe Writable streams, which is just wrong.
    	Writable.prototype.pipe = function () {
    	  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
    	};
    	function writeAfterEnd(stream, cb) {
    	  var er = new ERR_STREAM_WRITE_AFTER_END();
    	  // TODO: defer error events consistently everywhere, not just the cb
    	  errorOrDestroy(stream, er);
    	  browser$1$1.nextTick(cb, er);
    	}

    	// Checks that a user-supplied chunk is valid, especially for the particular
    	// mode the stream is in. Currently this means that `null` is never accepted
    	// and undefined/non-string values are only allowed in object mode.
    	function validChunk(stream, state, chunk, cb) {
    	  var er;
    	  if (chunk === null) {
    	    er = new ERR_STREAM_NULL_VALUES();
    	  } else if (typeof chunk !== 'string' && !state.objectMode) {
    	    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);
    	  }
    	  if (er) {
    	    errorOrDestroy(stream, er);
    	    browser$1$1.nextTick(cb, er);
    	    return false;
    	  }
    	  return true;
    	}
    	Writable.prototype.write = function (chunk, encoding, cb) {
    	  var state = this._writableState;
    	  var ret = false;
    	  var isBuf = !state.objectMode && _isUint8Array(chunk);
    	  if (isBuf && !Buffer.isBuffer(chunk)) {
    	    chunk = _uint8ArrayToBuffer(chunk);
    	  }
    	  if (typeof encoding === 'function') {
    	    cb = encoding;
    	    encoding = null;
    	  }
    	  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
    	  if (typeof cb !== 'function') cb = nop;
    	  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    	    state.pendingcb++;
    	    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
    	  }
    	  return ret;
    	};
    	Writable.prototype.cork = function () {
    	  this._writableState.corked++;
    	};
    	Writable.prototype.uncork = function () {
    	  var state = this._writableState;
    	  if (state.corked) {
    	    state.corked--;
    	    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
    	  }
    	};
    	Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    	  // node::ParseEncoding() requires lower case.
    	  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
    	  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
    	  this._writableState.defaultEncoding = encoding;
    	  return this;
    	};
    	Object.defineProperty(Writable.prototype, 'writableBuffer', {
    	  // making it explicit this property is not enumerable
    	  // because otherwise some prototype manipulation in
    	  // userland will fail
    	  enumerable: false,
    	  get: function get() {
    	    return this._writableState && this._writableState.getBuffer();
    	  }
    	});
    	function decodeChunk(state, chunk, encoding) {
    	  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    	    chunk = Buffer.from(chunk, encoding);
    	  }
    	  return chunk;
    	}
    	Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
    	  // making it explicit this property is not enumerable
    	  // because otherwise some prototype manipulation in
    	  // userland will fail
    	  enumerable: false,
    	  get: function get() {
    	    return this._writableState.highWaterMark;
    	  }
    	});

    	// if we're already writing something, then just put this
    	// in the queue, and wait our turn.  Otherwise, call _write
    	// If we return false, then we need a drain event, so set that flag.
    	function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
    	  if (!isBuf) {
    	    var newChunk = decodeChunk(state, chunk, encoding);
    	    if (chunk !== newChunk) {
    	      isBuf = true;
    	      encoding = 'buffer';
    	      chunk = newChunk;
    	    }
    	  }
    	  var len = state.objectMode ? 1 : chunk.length;
    	  state.length += len;
    	  var ret = state.length < state.highWaterMark;
    	  // we must ensure that previous needDrain will not be reset to false.
    	  if (!ret) state.needDrain = true;
    	  if (state.writing || state.corked) {
    	    var last = state.lastBufferedRequest;
    	    state.lastBufferedRequest = {
    	      chunk: chunk,
    	      encoding: encoding,
    	      isBuf: isBuf,
    	      callback: cb,
    	      next: null
    	    };
    	    if (last) {
    	      last.next = state.lastBufferedRequest;
    	    } else {
    	      state.bufferedRequest = state.lastBufferedRequest;
    	    }
    	    state.bufferedRequestCount += 1;
    	  } else {
    	    doWrite(stream, state, false, len, chunk, encoding, cb);
    	  }
    	  return ret;
    	}
    	function doWrite(stream, state, writev, len, chunk, encoding, cb) {
    	  state.writelen = len;
    	  state.writecb = cb;
    	  state.writing = true;
    	  state.sync = true;
    	  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
    	  state.sync = false;
    	}
    	function onwriteError(stream, state, sync, er, cb) {
    	  --state.pendingcb;
    	  if (sync) {
    	    // defer the callback if we are being called synchronously
    	    // to avoid piling up things on the stack
    	    browser$1$1.nextTick(cb, er);
    	    // this can emit finish, and it will always happen
    	    // after error
    	    browser$1$1.nextTick(finishMaybe, stream, state);
    	    stream._writableState.errorEmitted = true;
    	    errorOrDestroy(stream, er);
    	  } else {
    	    // the caller expect this to happen before if
    	    // it is async
    	    cb(er);
    	    stream._writableState.errorEmitted = true;
    	    errorOrDestroy(stream, er);
    	    // this can emit finish, but finish must
    	    // always follow error
    	    finishMaybe(stream, state);
    	  }
    	}
    	function onwriteStateUpdate(state) {
    	  state.writing = false;
    	  state.writecb = null;
    	  state.length -= state.writelen;
    	  state.writelen = 0;
    	}
    	function onwrite(stream, er) {
    	  var state = stream._writableState;
    	  var sync = state.sync;
    	  var cb = state.writecb;
    	  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();
    	  onwriteStateUpdate(state);
    	  if (er) onwriteError(stream, state, sync, er, cb);else {
    	    // Check if we're actually ready to finish, but don't emit yet
    	    var finished = needFinish(state) || stream.destroyed;
    	    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
    	      clearBuffer(stream, state);
    	    }
    	    if (sync) {
    	      browser$1$1.nextTick(afterWrite, stream, state, finished, cb);
    	    } else {
    	      afterWrite(stream, state, finished, cb);
    	    }
    	  }
    	}
    	function afterWrite(stream, state, finished, cb) {
    	  if (!finished) onwriteDrain(stream, state);
    	  state.pendingcb--;
    	  cb();
    	  finishMaybe(stream, state);
    	}

    	// Must force callback to be called on nextTick, so that we don't
    	// emit 'drain' before the write() consumer gets the 'false' return
    	// value, and has a chance to attach a 'drain' listener.
    	function onwriteDrain(stream, state) {
    	  if (state.length === 0 && state.needDrain) {
    	    state.needDrain = false;
    	    stream.emit('drain');
    	  }
    	}

    	// if there's something in the buffer waiting, then process it
    	function clearBuffer(stream, state) {
    	  state.bufferProcessing = true;
    	  var entry = state.bufferedRequest;
    	  if (stream._writev && entry && entry.next) {
    	    // Fast case, write everything using _writev()
    	    var l = state.bufferedRequestCount;
    	    var buffer = new Array(l);
    	    var holder = state.corkedRequestsFree;
    	    holder.entry = entry;
    	    var count = 0;
    	    var allBuffers = true;
    	    while (entry) {
    	      buffer[count] = entry;
    	      if (!entry.isBuf) allBuffers = false;
    	      entry = entry.next;
    	      count += 1;
    	    }
    	    buffer.allBuffers = allBuffers;
    	    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    	    // doWrite is almost always async, defer these to save a bit of time
    	    // as the hot path ends with doWrite
    	    state.pendingcb++;
    	    state.lastBufferedRequest = null;
    	    if (holder.next) {
    	      state.corkedRequestsFree = holder.next;
    	      holder.next = null;
    	    } else {
    	      state.corkedRequestsFree = new CorkedRequest(state);
    	    }
    	    state.bufferedRequestCount = 0;
    	  } else {
    	    // Slow case, write chunks one-by-one
    	    while (entry) {
    	      var chunk = entry.chunk;
    	      var encoding = entry.encoding;
    	      var cb = entry.callback;
    	      var len = state.objectMode ? 1 : chunk.length;
    	      doWrite(stream, state, false, len, chunk, encoding, cb);
    	      entry = entry.next;
    	      state.bufferedRequestCount--;
    	      // if we didn't call the onwrite immediately, then
    	      // it means that we need to wait until it does.
    	      // also, that means that the chunk and cb are currently
    	      // being processed, so move the buffer counter past them.
    	      if (state.writing) {
    	        break;
    	      }
    	    }
    	    if (entry === null) state.lastBufferedRequest = null;
    	  }
    	  state.bufferedRequest = entry;
    	  state.bufferProcessing = false;
    	}
    	Writable.prototype._write = function (chunk, encoding, cb) {
    	  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));
    	};
    	Writable.prototype._writev = null;
    	Writable.prototype.end = function (chunk, encoding, cb) {
    	  var state = this._writableState;
    	  if (typeof chunk === 'function') {
    	    cb = chunk;
    	    chunk = null;
    	    encoding = null;
    	  } else if (typeof encoding === 'function') {
    	    cb = encoding;
    	    encoding = null;
    	  }
    	  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

    	  // .end() fully uncorks
    	  if (state.corked) {
    	    state.corked = 1;
    	    this.uncork();
    	  }

    	  // ignore unnecessary end() calls.
    	  if (!state.ending) endWritable(this, state, cb);
    	  return this;
    	};
    	Object.defineProperty(Writable.prototype, 'writableLength', {
    	  // making it explicit this property is not enumerable
    	  // because otherwise some prototype manipulation in
    	  // userland will fail
    	  enumerable: false,
    	  get: function get() {
    	    return this._writableState.length;
    	  }
    	});
    	function needFinish(state) {
    	  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    	}
    	function callFinal(stream, state) {
    	  stream._final(function (err) {
    	    state.pendingcb--;
    	    if (err) {
    	      errorOrDestroy(stream, err);
    	    }
    	    state.prefinished = true;
    	    stream.emit('prefinish');
    	    finishMaybe(stream, state);
    	  });
    	}
    	function prefinish(stream, state) {
    	  if (!state.prefinished && !state.finalCalled) {
    	    if (typeof stream._final === 'function' && !state.destroyed) {
    	      state.pendingcb++;
    	      state.finalCalled = true;
    	      browser$1$1.nextTick(callFinal, stream, state);
    	    } else {
    	      state.prefinished = true;
    	      stream.emit('prefinish');
    	    }
    	  }
    	}
    	function finishMaybe(stream, state) {
    	  var need = needFinish(state);
    	  if (need) {
    	    prefinish(stream, state);
    	    if (state.pendingcb === 0) {
    	      state.finished = true;
    	      stream.emit('finish');
    	      if (state.autoDestroy) {
    	        // In case of duplex streams we need a way to detect
    	        // if the readable side is ready for autoDestroy as well
    	        var rState = stream._readableState;
    	        if (!rState || rState.autoDestroy && rState.endEmitted) {
    	          stream.destroy();
    	        }
    	      }
    	    }
    	  }
    	  return need;
    	}
    	function endWritable(stream, state, cb) {
    	  state.ending = true;
    	  finishMaybe(stream, state);
    	  if (cb) {
    	    if (state.finished) browser$1$1.nextTick(cb);else stream.once('finish', cb);
    	  }
    	  state.ended = true;
    	  stream.writable = false;
    	}
    	function onCorkedFinish(corkReq, state, err) {
    	  var entry = corkReq.entry;
    	  corkReq.entry = null;
    	  while (entry) {
    	    var cb = entry.callback;
    	    state.pendingcb--;
    	    cb(err);
    	    entry = entry.next;
    	  }

    	  // reuse the free corkReq.
    	  state.corkedRequestsFree.next = corkReq;
    	}
    	Object.defineProperty(Writable.prototype, 'destroyed', {
    	  // making it explicit this property is not enumerable
    	  // because otherwise some prototype manipulation in
    	  // userland will fail
    	  enumerable: false,
    	  get: function get() {
    	    if (this._writableState === undefined) {
    	      return false;
    	    }
    	    return this._writableState.destroyed;
    	  },
    	  set: function set(value) {
    	    // we ignore the value if the stream
    	    // has not been initialized yet
    	    if (!this._writableState) {
    	      return;
    	    }

    	    // backward compatibility, the user is explicitly
    	    // managing destroyed
    	    this._writableState.destroyed = value;
    	  }
    	});
    	Writable.prototype.destroy = destroyImpl.destroy;
    	Writable.prototype._undestroy = destroyImpl.undestroy;
    	Writable.prototype._destroy = function (err, cb) {
    	  cb(err);
    	};
    	return _stream_writable;
    }

    var _stream_duplex;
    var hasRequired_stream_duplex;

    function require_stream_duplex () {
    	if (hasRequired_stream_duplex) return _stream_duplex;
    	hasRequired_stream_duplex = 1;

    	/*<replacement>*/
    	var objectKeys = Object.keys || function (obj) {
    	  var keys = [];
    	  for (var key in obj) keys.push(key);
    	  return keys;
    	};
    	/*</replacement>*/

    	_stream_duplex = Duplex;
    	var Readable = require_stream_readable();
    	var Writable = require_stream_writable();
    	require$$1$2(Duplex, Readable);
    	{
    	  // Allow the keys array to be GC'ed.
    	  var keys = objectKeys(Writable.prototype);
    	  for (var v = 0; v < keys.length; v++) {
    	    var method = keys[v];
    	    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
    	  }
    	}
    	function Duplex(options) {
    	  if (!(this instanceof Duplex)) return new Duplex(options);
    	  Readable.call(this, options);
    	  Writable.call(this, options);
    	  this.allowHalfOpen = true;
    	  if (options) {
    	    if (options.readable === false) this.readable = false;
    	    if (options.writable === false) this.writable = false;
    	    if (options.allowHalfOpen === false) {
    	      this.allowHalfOpen = false;
    	      this.once('end', onend);
    	    }
    	  }
    	}
    	Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
    	  // making it explicit this property is not enumerable
    	  // because otherwise some prototype manipulation in
    	  // userland will fail
    	  enumerable: false,
    	  get: function get() {
    	    return this._writableState.highWaterMark;
    	  }
    	});
    	Object.defineProperty(Duplex.prototype, 'writableBuffer', {
    	  // making it explicit this property is not enumerable
    	  // because otherwise some prototype manipulation in
    	  // userland will fail
    	  enumerable: false,
    	  get: function get() {
    	    return this._writableState && this._writableState.getBuffer();
    	  }
    	});
    	Object.defineProperty(Duplex.prototype, 'writableLength', {
    	  // making it explicit this property is not enumerable
    	  // because otherwise some prototype manipulation in
    	  // userland will fail
    	  enumerable: false,
    	  get: function get() {
    	    return this._writableState.length;
    	  }
    	});

    	// the no-half-open enforcer
    	function onend() {
    	  // If the writable side ended, then we're ok.
    	  if (this._writableState.ended) return;

    	  // no more data can be written.
    	  // But allow more writes to happen in this tick.
    	  browser$1$1.nextTick(onEndNT, this);
    	}
    	function onEndNT(self) {
    	  self.end();
    	}
    	Object.defineProperty(Duplex.prototype, 'destroyed', {
    	  // making it explicit this property is not enumerable
    	  // because otherwise some prototype manipulation in
    	  // userland will fail
    	  enumerable: false,
    	  get: function get() {
    	    if (this._readableState === undefined || this._writableState === undefined) {
    	      return false;
    	    }
    	    return this._readableState.destroyed && this._writableState.destroyed;
    	  },
    	  set: function set(value) {
    	    // we ignore the value if the stream
    	    // has not been initialized yet
    	    if (this._readableState === undefined || this._writableState === undefined) {
    	      return;
    	    }

    	    // backward compatibility, the user is explicitly
    	    // managing destroyed
    	    this._readableState.destroyed = value;
    	    this._writableState.destroyed = value;
    	  }
    	});
    	return _stream_duplex;
    }

    // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.

    var isBufferEncoding = Buffer$8.isEncoding
      || function(encoding) {
           switch (encoding && encoding.toLowerCase()) {
             case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
             default: return false;
           }
         };


    function assertEncoding(encoding) {
      if (encoding && !isBufferEncoding(encoding)) {
        throw new Error('Unknown encoding: ' + encoding);
      }
    }

    // StringDecoder provides an interface for efficiently splitting a series of
    // buffers into a series of JS strings without breaking apart multi-byte
    // characters. CESU-8 is handled as part of the UTF-8 encoding.
    //
    // @TODO Handling all encodings inside a single object makes it very difficult
    // to reason about this code, so it should be split up in the future.
    // @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
    // points as used by CESU-8.
    function StringDecoder(encoding) {
      this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
      assertEncoding(encoding);
      switch (this.encoding) {
        case 'utf8':
          // CESU-8 represents each of Surrogate Pair by 3-bytes
          this.surrogateSize = 3;
          break;
        case 'ucs2':
        case 'utf16le':
          // UTF-16 represents each of Surrogate Pair by 2-bytes
          this.surrogateSize = 2;
          this.detectIncompleteChar = utf16DetectIncompleteChar;
          break;
        case 'base64':
          // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
          this.surrogateSize = 3;
          this.detectIncompleteChar = base64DetectIncompleteChar;
          break;
        default:
          this.write = passThroughWrite;
          return;
      }

      // Enough space to store all bytes of a single character. UTF-8 needs 4
      // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
      this.charBuffer = new Buffer$8(6);
      // Number of bytes received for the current incomplete multi-byte character.
      this.charReceived = 0;
      // Number of bytes expected for the current incomplete multi-byte character.
      this.charLength = 0;
    }

    // write decodes the given buffer and returns it as JS string that is
    // guaranteed to not contain any partial multi-byte characters. Any partial
    // character found at the end of the buffer is buffered up, and will be
    // returned when calling write again with the remaining bytes.
    //
    // Note: Converting a Buffer containing an orphan surrogate to a String
    // currently works, but converting a String to a Buffer (via `new Buffer`, or
    // Buffer#write) will replace incomplete surrogates with the unicode
    // replacement character. See https://codereview.chromium.org/121173009/ .
    StringDecoder.prototype.write = function(buffer) {
      var charStr = '';
      // if our last write ended with an incomplete multibyte character
      while (this.charLength) {
        // determine how many remaining bytes this buffer has to offer for this char
        var available = (buffer.length >= this.charLength - this.charReceived) ?
            this.charLength - this.charReceived :
            buffer.length;

        // add the new bytes to the char buffer
        buffer.copy(this.charBuffer, this.charReceived, 0, available);
        this.charReceived += available;

        if (this.charReceived < this.charLength) {
          // still not enough chars in this buffer? wait for more ...
          return '';
        }

        // remove bytes belonging to the current character from the buffer
        buffer = buffer.slice(available, buffer.length);

        // get the character that was split
        charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

        // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
        var charCode = charStr.charCodeAt(charStr.length - 1);
        if (charCode >= 0xD800 && charCode <= 0xDBFF) {
          this.charLength += this.surrogateSize;
          charStr = '';
          continue;
        }
        this.charReceived = this.charLength = 0;

        // if there are no more bytes in this buffer, just emit our char
        if (buffer.length === 0) {
          return charStr;
        }
        break;
      }

      // determine and set charLength / charReceived
      this.detectIncompleteChar(buffer);

      var end = buffer.length;
      if (this.charLength) {
        // buffer the incomplete character bytes we got
        buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
        end -= this.charReceived;
      }

      charStr += buffer.toString(this.encoding, 0, end);

      var end = charStr.length - 1;
      var charCode = charStr.charCodeAt(end);
      // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
      if (charCode >= 0xD800 && charCode <= 0xDBFF) {
        var size = this.surrogateSize;
        this.charLength += size;
        this.charReceived += size;
        this.charBuffer.copy(this.charBuffer, size, 0, size);
        buffer.copy(this.charBuffer, 0, 0, size);
        return charStr.substring(0, end);
      }

      // or just emit the charStr
      return charStr;
    };

    // detectIncompleteChar determines if there is an incomplete UTF-8 character at
    // the end of the given buffer. If so, it sets this.charLength to the byte
    // length that character, and sets this.charReceived to the number of bytes
    // that are available for this character.
    StringDecoder.prototype.detectIncompleteChar = function(buffer) {
      // determine how many bytes we have to check at the end of this buffer
      var i = (buffer.length >= 3) ? 3 : buffer.length;

      // Figure out if one of the last i bytes of our buffer announces an
      // incomplete char.
      for (; i > 0; i--) {
        var c = buffer[buffer.length - i];

        // See http://en.wikipedia.org/wiki/UTF-8#Description

        // 110XXXXX
        if (i == 1 && c >> 5 == 0x06) {
          this.charLength = 2;
          break;
        }

        // 1110XXXX
        if (i <= 2 && c >> 4 == 0x0E) {
          this.charLength = 3;
          break;
        }

        // 11110XXX
        if (i <= 3 && c >> 3 == 0x1E) {
          this.charLength = 4;
          break;
        }
      }
      this.charReceived = i;
    };

    StringDecoder.prototype.end = function(buffer) {
      var res = '';
      if (buffer && buffer.length)
        res = this.write(buffer);

      if (this.charReceived) {
        var cr = this.charReceived;
        var buf = this.charBuffer;
        var enc = this.encoding;
        res += buf.slice(0, cr).toString(enc);
      }

      return res;
    };

    function passThroughWrite(buffer) {
      return buffer.toString(this.encoding);
    }

    function utf16DetectIncompleteChar(buffer) {
      this.charReceived = buffer.length % 2;
      this.charLength = this.charReceived ? 2 : 0;
    }

    function base64DetectIncompleteChar(buffer) {
      this.charReceived = buffer.length % 3;
      this.charLength = this.charReceived ? 3 : 0;
    }

    var _polyfillNode_string_decoder = /*#__PURE__*/Object.freeze({
        __proto__: null,
        StringDecoder: StringDecoder
    });

    var require$$10 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_string_decoder);

    var ERR_STREAM_PREMATURE_CLOSE = errorsBrowser.codes.ERR_STREAM_PREMATURE_CLOSE;
    function once$1(callback) {
      var called = false;
      return function () {
        if (called) return;
        called = true;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        callback.apply(this, args);
      };
    }
    function noop$3() {}
    function isRequest$1(stream) {
      return stream.setHeader && typeof stream.abort === 'function';
    }
    function eos$1(stream, opts, callback) {
      if (typeof opts === 'function') return eos$1(stream, null, opts);
      if (!opts) opts = {};
      callback = once$1(callback || noop$3);
      var readable = opts.readable || opts.readable !== false && stream.readable;
      var writable = opts.writable || opts.writable !== false && stream.writable;
      var onlegacyfinish = function onlegacyfinish() {
        if (!stream.writable) onfinish();
      };
      var writableEnded = stream._writableState && stream._writableState.finished;
      var onfinish = function onfinish() {
        writable = false;
        writableEnded = true;
        if (!readable) callback.call(stream);
      };
      var readableEnded = stream._readableState && stream._readableState.endEmitted;
      var onend = function onend() {
        readable = false;
        readableEnded = true;
        if (!writable) callback.call(stream);
      };
      var onerror = function onerror(err) {
        callback.call(stream, err);
      };
      var onclose = function onclose() {
        var err;
        if (readable && !readableEnded) {
          if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
        if (writable && !writableEnded) {
          if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
      };
      var onrequest = function onrequest() {
        stream.req.on('finish', onfinish);
      };
      if (isRequest$1(stream)) {
        stream.on('complete', onfinish);
        stream.on('abort', onclose);
        if (stream.req) onrequest();else stream.on('request', onrequest);
      } else if (writable && !stream._writableState) {
        // legacy streams
        stream.on('end', onlegacyfinish);
        stream.on('close', onlegacyfinish);
      }
      stream.on('end', onend);
      stream.on('finish', onfinish);
      if (opts.error !== false) stream.on('error', onerror);
      stream.on('close', onclose);
      return function () {
        stream.removeListener('complete', onfinish);
        stream.removeListener('abort', onclose);
        stream.removeListener('request', onrequest);
        if (stream.req) stream.req.removeListener('finish', onfinish);
        stream.removeListener('end', onlegacyfinish);
        stream.removeListener('close', onlegacyfinish);
        stream.removeListener('finish', onfinish);
        stream.removeListener('end', onend);
        stream.removeListener('error', onerror);
        stream.removeListener('close', onclose);
      };
    }
    var endOfStream = eos$1;

    var async_iterator;
    var hasRequiredAsync_iterator;

    function requireAsync_iterator () {
    	if (hasRequiredAsync_iterator) return async_iterator;
    	hasRequiredAsync_iterator = 1;

    	var _Object$setPrototypeO;
    	function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
    	function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
    	function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
    	var finished = endOfStream;
    	var kLastResolve = Symbol('lastResolve');
    	var kLastReject = Symbol('lastReject');
    	var kError = Symbol('error');
    	var kEnded = Symbol('ended');
    	var kLastPromise = Symbol('lastPromise');
    	var kHandlePromise = Symbol('handlePromise');
    	var kStream = Symbol('stream');
    	function createIterResult(value, done) {
    	  return {
    	    value: value,
    	    done: done
    	  };
    	}
    	function readAndResolve(iter) {
    	  var resolve = iter[kLastResolve];
    	  if (resolve !== null) {
    	    var data = iter[kStream].read();
    	    // we defer if data is null
    	    // we can be expecting either 'end' or
    	    // 'error'
    	    if (data !== null) {
    	      iter[kLastPromise] = null;
    	      iter[kLastResolve] = null;
    	      iter[kLastReject] = null;
    	      resolve(createIterResult(data, false));
    	    }
    	  }
    	}
    	function onReadable(iter) {
    	  // we wait for the next tick, because it might
    	  // emit an error with process.nextTick
    	  browser$1$1.nextTick(readAndResolve, iter);
    	}
    	function wrapForNext(lastPromise, iter) {
    	  return function (resolve, reject) {
    	    lastPromise.then(function () {
    	      if (iter[kEnded]) {
    	        resolve(createIterResult(undefined, true));
    	        return;
    	      }
    	      iter[kHandlePromise](resolve, reject);
    	    }, reject);
    	  };
    	}
    	var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
    	var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
    	  get stream() {
    	    return this[kStream];
    	  },
    	  next: function next() {
    	    var _this = this;
    	    // if we have detected an error in the meanwhile
    	    // reject straight away
    	    var error = this[kError];
    	    if (error !== null) {
    	      return Promise.reject(error);
    	    }
    	    if (this[kEnded]) {
    	      return Promise.resolve(createIterResult(undefined, true));
    	    }
    	    if (this[kStream].destroyed) {
    	      // We need to defer via nextTick because if .destroy(err) is
    	      // called, the error will be emitted via nextTick, and
    	      // we cannot guarantee that there is no error lingering around
    	      // waiting to be emitted.
    	      return new Promise(function (resolve, reject) {
    	        browser$1$1.nextTick(function () {
    	          if (_this[kError]) {
    	            reject(_this[kError]);
    	          } else {
    	            resolve(createIterResult(undefined, true));
    	          }
    	        });
    	      });
    	    }

    	    // if we have multiple next() calls
    	    // we will wait for the previous Promise to finish
    	    // this logic is optimized to support for await loops,
    	    // where next() is only called once at a time
    	    var lastPromise = this[kLastPromise];
    	    var promise;
    	    if (lastPromise) {
    	      promise = new Promise(wrapForNext(lastPromise, this));
    	    } else {
    	      // fast path needed to support multiple this.push()
    	      // without triggering the next() queue
    	      var data = this[kStream].read();
    	      if (data !== null) {
    	        return Promise.resolve(createIterResult(data, false));
    	      }
    	      promise = new Promise(this[kHandlePromise]);
    	    }
    	    this[kLastPromise] = promise;
    	    return promise;
    	  }
    	}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {
    	  return this;
    	}), _defineProperty(_Object$setPrototypeO, "return", function _return() {
    	  var _this2 = this;
    	  // destroy(err, cb) is a private API
    	  // we can guarantee we have that here, because we control the
    	  // Readable class this is attached to
    	  return new Promise(function (resolve, reject) {
    	    _this2[kStream].destroy(null, function (err) {
    	      if (err) {
    	        reject(err);
    	        return;
    	      }
    	      resolve(createIterResult(undefined, true));
    	    });
    	  });
    	}), _Object$setPrototypeO), AsyncIteratorPrototype);
    	var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
    	  var _Object$create;
    	  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
    	    value: stream,
    	    writable: true
    	  }), _defineProperty(_Object$create, kLastResolve, {
    	    value: null,
    	    writable: true
    	  }), _defineProperty(_Object$create, kLastReject, {
    	    value: null,
    	    writable: true
    	  }), _defineProperty(_Object$create, kError, {
    	    value: null,
    	    writable: true
    	  }), _defineProperty(_Object$create, kEnded, {
    	    value: stream._readableState.endEmitted,
    	    writable: true
    	  }), _defineProperty(_Object$create, kHandlePromise, {
    	    value: function value(resolve, reject) {
    	      var data = iterator[kStream].read();
    	      if (data) {
    	        iterator[kLastPromise] = null;
    	        iterator[kLastResolve] = null;
    	        iterator[kLastReject] = null;
    	        resolve(createIterResult(data, false));
    	      } else {
    	        iterator[kLastResolve] = resolve;
    	        iterator[kLastReject] = reject;
    	      }
    	    },
    	    writable: true
    	  }), _Object$create));
    	  iterator[kLastPromise] = null;
    	  finished(stream, function (err) {
    	    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
    	      var reject = iterator[kLastReject];
    	      // reject if we are waiting for data in the Promise
    	      // returned by next() and store the error
    	      if (reject !== null) {
    	        iterator[kLastPromise] = null;
    	        iterator[kLastResolve] = null;
    	        iterator[kLastReject] = null;
    	        reject(err);
    	      }
    	      iterator[kError] = err;
    	      return;
    	    }
    	    var resolve = iterator[kLastResolve];
    	    if (resolve !== null) {
    	      iterator[kLastPromise] = null;
    	      iterator[kLastResolve] = null;
    	      iterator[kLastReject] = null;
    	      resolve(createIterResult(undefined, true));
    	    }
    	    iterator[kEnded] = true;
    	  });
    	  stream.on('readable', onReadable.bind(null, iterator));
    	  return iterator;
    	};
    	async_iterator = createReadableStreamAsyncIterator;
    	return async_iterator;
    }

    var fromBrowser;
    var hasRequiredFromBrowser;

    function requireFromBrowser () {
    	if (hasRequiredFromBrowser) return fromBrowser;
    	hasRequiredFromBrowser = 1;
    	fromBrowser = function () {
    	  throw new Error('Readable.from is not available in the browser')
    	};
    	return fromBrowser;
    }

    var _stream_readable;
    var hasRequired_stream_readable;

    function require_stream_readable () {
    	if (hasRequired_stream_readable) return _stream_readable;
    	hasRequired_stream_readable = 1;

    	_stream_readable = Readable;

    	/*<replacement>*/
    	var Duplex;
    	/*</replacement>*/

    	Readable.ReadableState = ReadableState;

    	/*<replacement>*/
    	require$$0$3.EventEmitter;
    	var EElistenerCount = function EElistenerCount(emitter, type) {
    	  return emitter.listeners(type).length;
    	};
    	/*</replacement>*/

    	/*<replacement>*/
    	var Stream = requireStreamBrowser();
    	/*</replacement>*/

    	var Buffer = require$$2$1.Buffer;
    	var OurUint8Array = (typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};
    	function _uint8ArrayToBuffer(chunk) {
    	  return Buffer.from(chunk);
    	}
    	function _isUint8Array(obj) {
    	  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
    	}

    	/*<replacement>*/
    	var debugUtil = require$$3;
    	var debug;
    	if (debugUtil && debugUtil.debuglog) {
    	  debug = debugUtil.debuglog('stream');
    	} else {
    	  debug = function debug() {};
    	}
    	/*</replacement>*/

    	var BufferList = requireBuffer_list();
    	var destroyImpl = requireDestroy();
    	var _require = requireState(),
    	  getHighWaterMark = _require.getHighWaterMark;
    	var _require$codes = errorsBrowser.codes,
    	  ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    	  ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,
    	  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    	  ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;

    	// Lazy loaded to improve the startup performance.
    	var StringDecoder;
    	var createReadableStreamAsyncIterator;
    	var from;
    	require$$1$2(Readable, Stream);
    	var errorOrDestroy = destroyImpl.errorOrDestroy;
    	var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];
    	function prependListener(emitter, event, fn) {
    	  // Sadly this is not cacheable as some libraries bundle their own
    	  // event emitter implementation with them.
    	  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

    	  // This is a hack to make sure that our error handler is attached before any
    	  // userland ones.  NEVER DO THIS. This is here only because this code needs
    	  // to continue to work with older versions of Node.js that do not include
    	  // the prependListener() method. The goal is to eventually remove this hack.
    	  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
    	}
    	function ReadableState(options, stream, isDuplex) {
    	  Duplex = Duplex || require_stream_duplex();
    	  options = options || {};

    	  // Duplex streams are both readable and writable, but share
    	  // the same options object.
    	  // However, some cases require setting options to different
    	  // values for the readable and the writable sides of the duplex stream.
    	  // These options can be provided separately as readableXXX and writableXXX.
    	  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex;

    	  // object stream flag. Used to make read(n) ignore n and to
    	  // make all the buffer merging and length checks go away
    	  this.objectMode = !!options.objectMode;
    	  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

    	  // the point at which it stops calling _read() to fill the buffer
    	  // Note: 0 is a valid value, means "don't call _read preemptively ever"
    	  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex);

    	  // A linked list is used to store data chunks instead of an array because the
    	  // linked list can remove elements from the beginning faster than
    	  // array.shift()
    	  this.buffer = new BufferList();
    	  this.length = 0;
    	  this.pipes = null;
    	  this.pipesCount = 0;
    	  this.flowing = null;
    	  this.ended = false;
    	  this.endEmitted = false;
    	  this.reading = false;

    	  // a flag to be able to tell if the event 'readable'/'data' is emitted
    	  // immediately, or on a later tick.  We set this to true at first, because
    	  // any actions that shouldn't happen until "later" should generally also
    	  // not happen before the first read call.
    	  this.sync = true;

    	  // whenever we return null, then we set a flag to say
    	  // that we're awaiting a 'readable' event emission.
    	  this.needReadable = false;
    	  this.emittedReadable = false;
    	  this.readableListening = false;
    	  this.resumeScheduled = false;
    	  this.paused = true;

    	  // Should close be emitted on destroy. Defaults to true.
    	  this.emitClose = options.emitClose !== false;

    	  // Should .destroy() be called after 'end' (and potentially 'finish')
    	  this.autoDestroy = !!options.autoDestroy;

    	  // has it been destroyed
    	  this.destroyed = false;

    	  // Crypto is kind of old and crusty.  Historically, its default string
    	  // encoding is 'binary' so we have to make this configurable.
    	  // Everything else in the universe uses 'utf8', though.
    	  this.defaultEncoding = options.defaultEncoding || 'utf8';

    	  // the number of writers that are awaiting a drain event in .pipe()s
    	  this.awaitDrain = 0;

    	  // if true, a maybeReadMore has been scheduled
    	  this.readingMore = false;
    	  this.decoder = null;
    	  this.encoding = null;
    	  if (options.encoding) {
    	    if (!StringDecoder) StringDecoder = require$$10.StringDecoder;
    	    this.decoder = new StringDecoder(options.encoding);
    	    this.encoding = options.encoding;
    	  }
    	}
    	function Readable(options) {
    	  Duplex = Duplex || require_stream_duplex();
    	  if (!(this instanceof Readable)) return new Readable(options);

    	  // Checking for a Stream.Duplex instance is faster here instead of inside
    	  // the ReadableState constructor, at least with V8 6.5
    	  var isDuplex = this instanceof Duplex;
    	  this._readableState = new ReadableState(options, this, isDuplex);

    	  // legacy
    	  this.readable = true;
    	  if (options) {
    	    if (typeof options.read === 'function') this._read = options.read;
    	    if (typeof options.destroy === 'function') this._destroy = options.destroy;
    	  }
    	  Stream.call(this);
    	}
    	Object.defineProperty(Readable.prototype, 'destroyed', {
    	  // making it explicit this property is not enumerable
    	  // because otherwise some prototype manipulation in
    	  // userland will fail
    	  enumerable: false,
    	  get: function get() {
    	    if (this._readableState === undefined) {
    	      return false;
    	    }
    	    return this._readableState.destroyed;
    	  },
    	  set: function set(value) {
    	    // we ignore the value if the stream
    	    // has not been initialized yet
    	    if (!this._readableState) {
    	      return;
    	    }

    	    // backward compatibility, the user is explicitly
    	    // managing destroyed
    	    this._readableState.destroyed = value;
    	  }
    	});
    	Readable.prototype.destroy = destroyImpl.destroy;
    	Readable.prototype._undestroy = destroyImpl.undestroy;
    	Readable.prototype._destroy = function (err, cb) {
    	  cb(err);
    	};

    	// Manually shove something into the read() buffer.
    	// This returns true if the highWaterMark has not been hit yet,
    	// similar to how Writable.write() returns true if you should
    	// write() some more.
    	Readable.prototype.push = function (chunk, encoding) {
    	  var state = this._readableState;
    	  var skipChunkCheck;
    	  if (!state.objectMode) {
    	    if (typeof chunk === 'string') {
    	      encoding = encoding || state.defaultEncoding;
    	      if (encoding !== state.encoding) {
    	        chunk = Buffer.from(chunk, encoding);
    	        encoding = '';
    	      }
    	      skipChunkCheck = true;
    	    }
    	  } else {
    	    skipChunkCheck = true;
    	  }
    	  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    	};

    	// Unshift should *always* be something directly out of read()
    	Readable.prototype.unshift = function (chunk) {
    	  return readableAddChunk(this, chunk, null, true, false);
    	};
    	function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
    	  debug('readableAddChunk', chunk);
    	  var state = stream._readableState;
    	  if (chunk === null) {
    	    state.reading = false;
    	    onEofChunk(stream, state);
    	  } else {
    	    var er;
    	    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    	    if (er) {
    	      errorOrDestroy(stream, er);
    	    } else if (state.objectMode || chunk && chunk.length > 0) {
    	      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
    	        chunk = _uint8ArrayToBuffer(chunk);
    	      }
    	      if (addToFront) {
    	        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);
    	      } else if (state.ended) {
    	        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
    	      } else if (state.destroyed) {
    	        return false;
    	      } else {
    	        state.reading = false;
    	        if (state.decoder && !encoding) {
    	          chunk = state.decoder.write(chunk);
    	          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
    	        } else {
    	          addChunk(stream, state, chunk, false);
    	        }
    	      }
    	    } else if (!addToFront) {
    	      state.reading = false;
    	      maybeReadMore(stream, state);
    	    }
    	  }

    	  // We can push more data if we are below the highWaterMark.
    	  // Also, if we have no data yet, we can stand some more bytes.
    	  // This is to work around cases where hwm=0, such as the repl.
    	  return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    	}
    	function addChunk(stream, state, chunk, addToFront) {
    	  if (state.flowing && state.length === 0 && !state.sync) {
    	    state.awaitDrain = 0;
    	    stream.emit('data', chunk);
    	  } else {
    	    // update the buffer info.
    	    state.length += state.objectMode ? 1 : chunk.length;
    	    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
    	    if (state.needReadable) emitReadable(stream);
    	  }
    	  maybeReadMore(stream, state);
    	}
    	function chunkInvalid(state, chunk) {
    	  var er;
    	  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    	    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
    	  }
    	  return er;
    	}
    	Readable.prototype.isPaused = function () {
    	  return this._readableState.flowing === false;
    	};

    	// backwards compatibility.
    	Readable.prototype.setEncoding = function (enc) {
    	  if (!StringDecoder) StringDecoder = require$$10.StringDecoder;
    	  var decoder = new StringDecoder(enc);
    	  this._readableState.decoder = decoder;
    	  // If setEncoding(null), decoder.encoding equals utf8
    	  this._readableState.encoding = this._readableState.decoder.encoding;

    	  // Iterate over current buffer to convert already stored Buffers:
    	  var p = this._readableState.buffer.head;
    	  var content = '';
    	  while (p !== null) {
    	    content += decoder.write(p.data);
    	    p = p.next;
    	  }
    	  this._readableState.buffer.clear();
    	  if (content !== '') this._readableState.buffer.push(content);
    	  this._readableState.length = content.length;
    	  return this;
    	};

    	// Don't raise the hwm > 1GB
    	var MAX_HWM = 0x40000000;
    	function computeNewHighWaterMark(n) {
    	  if (n >= MAX_HWM) {
    	    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
    	    n = MAX_HWM;
    	  } else {
    	    // Get the next highest power of 2 to prevent increasing hwm excessively in
    	    // tiny amounts
    	    n--;
    	    n |= n >>> 1;
    	    n |= n >>> 2;
    	    n |= n >>> 4;
    	    n |= n >>> 8;
    	    n |= n >>> 16;
    	    n++;
    	  }
    	  return n;
    	}

    	// This function is designed to be inlinable, so please take care when making
    	// changes to the function body.
    	function howMuchToRead(n, state) {
    	  if (n <= 0 || state.length === 0 && state.ended) return 0;
    	  if (state.objectMode) return 1;
    	  if (n !== n) {
    	    // Only flow one buffer at a time
    	    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
    	  }
    	  // If we're asking for more than the current hwm, then raise the hwm.
    	  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
    	  if (n <= state.length) return n;
    	  // Don't have enough
    	  if (!state.ended) {
    	    state.needReadable = true;
    	    return 0;
    	  }
    	  return state.length;
    	}

    	// you can override either this method, or the async _read(n) below.
    	Readable.prototype.read = function (n) {
    	  debug('read', n);
    	  n = parseInt(n, 10);
    	  var state = this._readableState;
    	  var nOrig = n;
    	  if (n !== 0) state.emittedReadable = false;

    	  // if we're doing read(0) to trigger a readable event, but we
    	  // already have a bunch of data in the buffer, then just trigger
    	  // the 'readable' event and move on.
    	  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
    	    debug('read: emitReadable', state.length, state.ended);
    	    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    	    return null;
    	  }
    	  n = howMuchToRead(n, state);

    	  // if we've ended, and we're now clear, then finish it up.
    	  if (n === 0 && state.ended) {
    	    if (state.length === 0) endReadable(this);
    	    return null;
    	  }

    	  // All the actual chunk generation logic needs to be
    	  // *below* the call to _read.  The reason is that in certain
    	  // synthetic stream cases, such as passthrough streams, _read
    	  // may be a completely synchronous operation which may change
    	  // the state of the read buffer, providing enough data when
    	  // before there was *not* enough.
    	  //
    	  // So, the steps are:
    	  // 1. Figure out what the state of things will be after we do
    	  // a read from the buffer.
    	  //
    	  // 2. If that resulting state will trigger a _read, then call _read.
    	  // Note that this may be asynchronous, or synchronous.  Yes, it is
    	  // deeply ugly to write APIs this way, but that still doesn't mean
    	  // that the Readable class should behave improperly, as streams are
    	  // designed to be sync/async agnostic.
    	  // Take note if the _read call is sync or async (ie, if the read call
    	  // has returned yet), so that we know whether or not it's safe to emit
    	  // 'readable' etc.
    	  //
    	  // 3. Actually pull the requested chunks out of the buffer and return.

    	  // if we need a readable event, then we need to do some reading.
    	  var doRead = state.needReadable;
    	  debug('need readable', doRead);

    	  // if we currently have less than the highWaterMark, then also read some
    	  if (state.length === 0 || state.length - n < state.highWaterMark) {
    	    doRead = true;
    	    debug('length less than watermark', doRead);
    	  }

    	  // however, if we've ended, then there's no point, and if we're already
    	  // reading, then it's unnecessary.
    	  if (state.ended || state.reading) {
    	    doRead = false;
    	    debug('reading or ended', doRead);
    	  } else if (doRead) {
    	    debug('do read');
    	    state.reading = true;
    	    state.sync = true;
    	    // if the length is currently zero, then we *need* a readable event.
    	    if (state.length === 0) state.needReadable = true;
    	    // call internal read method
    	    this._read(state.highWaterMark);
    	    state.sync = false;
    	    // If _read pushed data synchronously, then `reading` will be false,
    	    // and we need to re-evaluate how much data we can return to the user.
    	    if (!state.reading) n = howMuchToRead(nOrig, state);
    	  }
    	  var ret;
    	  if (n > 0) ret = fromList(n, state);else ret = null;
    	  if (ret === null) {
    	    state.needReadable = state.length <= state.highWaterMark;
    	    n = 0;
    	  } else {
    	    state.length -= n;
    	    state.awaitDrain = 0;
    	  }
    	  if (state.length === 0) {
    	    // If we have nothing in the buffer, then we want to know
    	    // as soon as we *do* get something into the buffer.
    	    if (!state.ended) state.needReadable = true;

    	    // If we tried to read() past the EOF, then emit end on the next tick.
    	    if (nOrig !== n && state.ended) endReadable(this);
    	  }
    	  if (ret !== null) this.emit('data', ret);
    	  return ret;
    	};
    	function onEofChunk(stream, state) {
    	  debug('onEofChunk');
    	  if (state.ended) return;
    	  if (state.decoder) {
    	    var chunk = state.decoder.end();
    	    if (chunk && chunk.length) {
    	      state.buffer.push(chunk);
    	      state.length += state.objectMode ? 1 : chunk.length;
    	    }
    	  }
    	  state.ended = true;
    	  if (state.sync) {
    	    // if we are sync, wait until next tick to emit the data.
    	    // Otherwise we risk emitting data in the flow()
    	    // the readable code triggers during a read() call
    	    emitReadable(stream);
    	  } else {
    	    // emit 'readable' now to make sure it gets picked up.
    	    state.needReadable = false;
    	    if (!state.emittedReadable) {
    	      state.emittedReadable = true;
    	      emitReadable_(stream);
    	    }
    	  }
    	}

    	// Don't emit readable right away in sync mode, because this can trigger
    	// another read() call => stack overflow.  This way, it might trigger
    	// a nextTick recursion warning, but that's not so bad.
    	function emitReadable(stream) {
    	  var state = stream._readableState;
    	  debug('emitReadable', state.needReadable, state.emittedReadable);
    	  state.needReadable = false;
    	  if (!state.emittedReadable) {
    	    debug('emitReadable', state.flowing);
    	    state.emittedReadable = true;
    	    browser$1$1.nextTick(emitReadable_, stream);
    	  }
    	}
    	function emitReadable_(stream) {
    	  var state = stream._readableState;
    	  debug('emitReadable_', state.destroyed, state.length, state.ended);
    	  if (!state.destroyed && (state.length || state.ended)) {
    	    stream.emit('readable');
    	    state.emittedReadable = false;
    	  }

    	  // The stream needs another readable event if
    	  // 1. It is not flowing, as the flow mechanism will take
    	  //    care of it.
    	  // 2. It is not ended.
    	  // 3. It is below the highWaterMark, so we can schedule
    	  //    another readable later.
    	  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
    	  flow(stream);
    	}

    	// at this point, the user has presumably seen the 'readable' event,
    	// and called read() to consume some data.  that may have triggered
    	// in turn another _read(n) call, in which case reading = true if
    	// it's in progress.
    	// However, if we're not ended, or reading, and the length < hwm,
    	// then go ahead and try to read some more preemptively.
    	function maybeReadMore(stream, state) {
    	  if (!state.readingMore) {
    	    state.readingMore = true;
    	    browser$1$1.nextTick(maybeReadMore_, stream, state);
    	  }
    	}
    	function maybeReadMore_(stream, state) {
    	  // Attempt to read more data if we should.
    	  //
    	  // The conditions for reading more data are (one of):
    	  // - Not enough data buffered (state.length < state.highWaterMark). The loop
    	  //   is responsible for filling the buffer with enough data if such data
    	  //   is available. If highWaterMark is 0 and we are not in the flowing mode
    	  //   we should _not_ attempt to buffer any extra data. We'll get more data
    	  //   when the stream consumer calls read() instead.
    	  // - No data in the buffer, and the stream is in flowing mode. In this mode
    	  //   the loop below is responsible for ensuring read() is called. Failing to
    	  //   call read here would abort the flow and there's no other mechanism for
    	  //   continuing the flow if the stream consumer has just subscribed to the
    	  //   'data' event.
    	  //
    	  // In addition to the above conditions to keep reading data, the following
    	  // conditions prevent the data from being read:
    	  // - The stream has ended (state.ended).
    	  // - There is already a pending 'read' operation (state.reading). This is a
    	  //   case where the the stream has called the implementation defined _read()
    	  //   method, but they are processing the call asynchronously and have _not_
    	  //   called push() with new data. In this case we skip performing more
    	  //   read()s. The execution ends in this method again after the _read() ends
    	  //   up calling push() with more data.
    	  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
    	    var len = state.length;
    	    debug('maybeReadMore read 0');
    	    stream.read(0);
    	    if (len === state.length)
    	      // didn't get any data, stop spinning.
    	      break;
    	  }
    	  state.readingMore = false;
    	}

    	// abstract method.  to be overridden in specific implementation classes.
    	// call cb(er, data) where data is <= n in length.
    	// for virtual (non-string, non-buffer) streams, "length" is somewhat
    	// arbitrary, and perhaps not very meaningful.
    	Readable.prototype._read = function (n) {
    	  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));
    	};
    	Readable.prototype.pipe = function (dest, pipeOpts) {
    	  var src = this;
    	  var state = this._readableState;
    	  switch (state.pipesCount) {
    	    case 0:
    	      state.pipes = dest;
    	      break;
    	    case 1:
    	      state.pipes = [state.pipes, dest];
    	      break;
    	    default:
    	      state.pipes.push(dest);
    	      break;
    	  }
    	  state.pipesCount += 1;
    	  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
    	  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== browser$1$1.stdout && dest !== browser$1$1.stderr;
    	  var endFn = doEnd ? onend : unpipe;
    	  if (state.endEmitted) browser$1$1.nextTick(endFn);else src.once('end', endFn);
    	  dest.on('unpipe', onunpipe);
    	  function onunpipe(readable, unpipeInfo) {
    	    debug('onunpipe');
    	    if (readable === src) {
    	      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
    	        unpipeInfo.hasUnpiped = true;
    	        cleanup();
    	      }
    	    }
    	  }
    	  function onend() {
    	    debug('onend');
    	    dest.end();
    	  }

    	  // when the dest drains, it reduces the awaitDrain counter
    	  // on the source.  This would be more elegant with a .once()
    	  // handler in flow(), but adding and removing repeatedly is
    	  // too slow.
    	  var ondrain = pipeOnDrain(src);
    	  dest.on('drain', ondrain);
    	  var cleanedUp = false;
    	  function cleanup() {
    	    debug('cleanup');
    	    // cleanup event handlers once the pipe is broken
    	    dest.removeListener('close', onclose);
    	    dest.removeListener('finish', onfinish);
    	    dest.removeListener('drain', ondrain);
    	    dest.removeListener('error', onerror);
    	    dest.removeListener('unpipe', onunpipe);
    	    src.removeListener('end', onend);
    	    src.removeListener('end', unpipe);
    	    src.removeListener('data', ondata);
    	    cleanedUp = true;

    	    // if the reader is waiting for a drain event from this
    	    // specific writer, then it would cause it to never start
    	    // flowing again.
    	    // So, if this is awaiting a drain, then we just call it now.
    	    // If we don't know, then assume that we are waiting for one.
    	    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
    	  }
    	  src.on('data', ondata);
    	  function ondata(chunk) {
    	    debug('ondata');
    	    var ret = dest.write(chunk);
    	    debug('dest.write', ret);
    	    if (ret === false) {
    	      // If the user unpiped during `dest.write()`, it is possible
    	      // to get stuck in a permanently paused state if that write
    	      // also returned false.
    	      // => Check whether `dest` is still a piping destination.
    	      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
    	        debug('false write response, pause', state.awaitDrain);
    	        state.awaitDrain++;
    	      }
    	      src.pause();
    	    }
    	  }

    	  // if the dest has an error, then stop piping into it.
    	  // however, don't suppress the throwing behavior for this.
    	  function onerror(er) {
    	    debug('onerror', er);
    	    unpipe();
    	    dest.removeListener('error', onerror);
    	    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);
    	  }

    	  // Make sure our error handler is attached before userland ones.
    	  prependListener(dest, 'error', onerror);

    	  // Both close and finish should trigger unpipe, but only once.
    	  function onclose() {
    	    dest.removeListener('finish', onfinish);
    	    unpipe();
    	  }
    	  dest.once('close', onclose);
    	  function onfinish() {
    	    debug('onfinish');
    	    dest.removeListener('close', onclose);
    	    unpipe();
    	  }
    	  dest.once('finish', onfinish);
    	  function unpipe() {
    	    debug('unpipe');
    	    src.unpipe(dest);
    	  }

    	  // tell the dest that it's being piped to
    	  dest.emit('pipe', src);

    	  // start the flow if it hasn't been started already.
    	  if (!state.flowing) {
    	    debug('pipe resume');
    	    src.resume();
    	  }
    	  return dest;
    	};
    	function pipeOnDrain(src) {
    	  return function pipeOnDrainFunctionResult() {
    	    var state = src._readableState;
    	    debug('pipeOnDrain', state.awaitDrain);
    	    if (state.awaitDrain) state.awaitDrain--;
    	    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
    	      state.flowing = true;
    	      flow(src);
    	    }
    	  };
    	}
    	Readable.prototype.unpipe = function (dest) {
    	  var state = this._readableState;
    	  var unpipeInfo = {
    	    hasUnpiped: false
    	  };

    	  // if we're not piping anywhere, then do nothing.
    	  if (state.pipesCount === 0) return this;

    	  // just one destination.  most common case.
    	  if (state.pipesCount === 1) {
    	    // passed in one, but it's not the right one.
    	    if (dest && dest !== state.pipes) return this;
    	    if (!dest) dest = state.pipes;

    	    // got a match.
    	    state.pipes = null;
    	    state.pipesCount = 0;
    	    state.flowing = false;
    	    if (dest) dest.emit('unpipe', this, unpipeInfo);
    	    return this;
    	  }

    	  // slow case. multiple pipe destinations.

    	  if (!dest) {
    	    // remove all.
    	    var dests = state.pipes;
    	    var len = state.pipesCount;
    	    state.pipes = null;
    	    state.pipesCount = 0;
    	    state.flowing = false;
    	    for (var i = 0; i < len; i++) dests[i].emit('unpipe', this, {
    	      hasUnpiped: false
    	    });
    	    return this;
    	  }

    	  // try to find the right one.
    	  var index = indexOf(state.pipes, dest);
    	  if (index === -1) return this;
    	  state.pipes.splice(index, 1);
    	  state.pipesCount -= 1;
    	  if (state.pipesCount === 1) state.pipes = state.pipes[0];
    	  dest.emit('unpipe', this, unpipeInfo);
    	  return this;
    	};

    	// set up data events if they are asked for
    	// Ensure readable listeners eventually get something
    	Readable.prototype.on = function (ev, fn) {
    	  var res = Stream.prototype.on.call(this, ev, fn);
    	  var state = this._readableState;
    	  if (ev === 'data') {
    	    // update readableListening so that resume() may be a no-op
    	    // a few lines down. This is needed to support once('readable').
    	    state.readableListening = this.listenerCount('readable') > 0;

    	    // Try start flowing on next tick if stream isn't explicitly paused
    	    if (state.flowing !== false) this.resume();
    	  } else if (ev === 'readable') {
    	    if (!state.endEmitted && !state.readableListening) {
    	      state.readableListening = state.needReadable = true;
    	      state.flowing = false;
    	      state.emittedReadable = false;
    	      debug('on readable', state.length, state.reading);
    	      if (state.length) {
    	        emitReadable(this);
    	      } else if (!state.reading) {
    	        browser$1$1.nextTick(nReadingNextTick, this);
    	      }
    	    }
    	  }
    	  return res;
    	};
    	Readable.prototype.addListener = Readable.prototype.on;
    	Readable.prototype.removeListener = function (ev, fn) {
    	  var res = Stream.prototype.removeListener.call(this, ev, fn);
    	  if (ev === 'readable') {
    	    // We need to check if there is someone still listening to
    	    // readable and reset the state. However this needs to happen
    	    // after readable has been emitted but before I/O (nextTick) to
    	    // support once('readable', fn) cycles. This means that calling
    	    // resume within the same tick will have no
    	    // effect.
    	    browser$1$1.nextTick(updateReadableListening, this);
    	  }
    	  return res;
    	};
    	Readable.prototype.removeAllListeners = function (ev) {
    	  var res = Stream.prototype.removeAllListeners.apply(this, arguments);
    	  if (ev === 'readable' || ev === undefined) {
    	    // We need to check if there is someone still listening to
    	    // readable and reset the state. However this needs to happen
    	    // after readable has been emitted but before I/O (nextTick) to
    	    // support once('readable', fn) cycles. This means that calling
    	    // resume within the same tick will have no
    	    // effect.
    	    browser$1$1.nextTick(updateReadableListening, this);
    	  }
    	  return res;
    	};
    	function updateReadableListening(self) {
    	  var state = self._readableState;
    	  state.readableListening = self.listenerCount('readable') > 0;
    	  if (state.resumeScheduled && !state.paused) {
    	    // flowing needs to be set to true now, otherwise
    	    // the upcoming resume will not flow.
    	    state.flowing = true;

    	    // crude way to check if we should resume
    	  } else if (self.listenerCount('data') > 0) {
    	    self.resume();
    	  }
    	}
    	function nReadingNextTick(self) {
    	  debug('readable nexttick read 0');
    	  self.read(0);
    	}

    	// pause() and resume() are remnants of the legacy readable stream API
    	// If the user uses them, then switch into old mode.
    	Readable.prototype.resume = function () {
    	  var state = this._readableState;
    	  if (!state.flowing) {
    	    debug('resume');
    	    // we flow only if there is no one listening
    	    // for readable, but we still have to call
    	    // resume()
    	    state.flowing = !state.readableListening;
    	    resume(this, state);
    	  }
    	  state.paused = false;
    	  return this;
    	};
    	function resume(stream, state) {
    	  if (!state.resumeScheduled) {
    	    state.resumeScheduled = true;
    	    browser$1$1.nextTick(resume_, stream, state);
    	  }
    	}
    	function resume_(stream, state) {
    	  debug('resume', state.reading);
    	  if (!state.reading) {
    	    stream.read(0);
    	  }
    	  state.resumeScheduled = false;
    	  stream.emit('resume');
    	  flow(stream);
    	  if (state.flowing && !state.reading) stream.read(0);
    	}
    	Readable.prototype.pause = function () {
    	  debug('call pause flowing=%j', this._readableState.flowing);
    	  if (this._readableState.flowing !== false) {
    	    debug('pause');
    	    this._readableState.flowing = false;
    	    this.emit('pause');
    	  }
    	  this._readableState.paused = true;
    	  return this;
    	};
    	function flow(stream) {
    	  var state = stream._readableState;
    	  debug('flow', state.flowing);
    	  while (state.flowing && stream.read() !== null);
    	}

    	// wrap an old-style stream as the async data source.
    	// This is *not* part of the readable stream interface.
    	// It is an ugly unfortunate mess of history.
    	Readable.prototype.wrap = function (stream) {
    	  var _this = this;
    	  var state = this._readableState;
    	  var paused = false;
    	  stream.on('end', function () {
    	    debug('wrapped end');
    	    if (state.decoder && !state.ended) {
    	      var chunk = state.decoder.end();
    	      if (chunk && chunk.length) _this.push(chunk);
    	    }
    	    _this.push(null);
    	  });
    	  stream.on('data', function (chunk) {
    	    debug('wrapped data');
    	    if (state.decoder) chunk = state.decoder.write(chunk);

    	    // don't skip over falsy values in objectMode
    	    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;
    	    var ret = _this.push(chunk);
    	    if (!ret) {
    	      paused = true;
    	      stream.pause();
    	    }
    	  });

    	  // proxy all the other methods.
    	  // important when wrapping filters and duplexes.
    	  for (var i in stream) {
    	    if (this[i] === undefined && typeof stream[i] === 'function') {
    	      this[i] = function methodWrap(method) {
    	        return function methodWrapReturnFunction() {
    	          return stream[method].apply(stream, arguments);
    	        };
    	      }(i);
    	    }
    	  }

    	  // proxy certain important events.
    	  for (var n = 0; n < kProxyEvents.length; n++) {
    	    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
    	  }

    	  // when we try to consume some more bytes, simply unpause the
    	  // underlying stream.
    	  this._read = function (n) {
    	    debug('wrapped _read', n);
    	    if (paused) {
    	      paused = false;
    	      stream.resume();
    	    }
    	  };
    	  return this;
    	};
    	if (typeof Symbol === 'function') {
    	  Readable.prototype[Symbol.asyncIterator] = function () {
    	    if (createReadableStreamAsyncIterator === undefined) {
    	      createReadableStreamAsyncIterator = requireAsync_iterator();
    	    }
    	    return createReadableStreamAsyncIterator(this);
    	  };
    	}
    	Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
    	  // making it explicit this property is not enumerable
    	  // because otherwise some prototype manipulation in
    	  // userland will fail
    	  enumerable: false,
    	  get: function get() {
    	    return this._readableState.highWaterMark;
    	  }
    	});
    	Object.defineProperty(Readable.prototype, 'readableBuffer', {
    	  // making it explicit this property is not enumerable
    	  // because otherwise some prototype manipulation in
    	  // userland will fail
    	  enumerable: false,
    	  get: function get() {
    	    return this._readableState && this._readableState.buffer;
    	  }
    	});
    	Object.defineProperty(Readable.prototype, 'readableFlowing', {
    	  // making it explicit this property is not enumerable
    	  // because otherwise some prototype manipulation in
    	  // userland will fail
    	  enumerable: false,
    	  get: function get() {
    	    return this._readableState.flowing;
    	  },
    	  set: function set(state) {
    	    if (this._readableState) {
    	      this._readableState.flowing = state;
    	    }
    	  }
    	});

    	// exposed for testing purposes only.
    	Readable._fromList = fromList;
    	Object.defineProperty(Readable.prototype, 'readableLength', {
    	  // making it explicit this property is not enumerable
    	  // because otherwise some prototype manipulation in
    	  // userland will fail
    	  enumerable: false,
    	  get: function get() {
    	    return this._readableState.length;
    	  }
    	});

    	// Pluck off n bytes from an array of buffers.
    	// Length is the combined lengths of all the buffers in the list.
    	// This function is designed to be inlinable, so please take care when making
    	// changes to the function body.
    	function fromList(n, state) {
    	  // nothing buffered
    	  if (state.length === 0) return null;
    	  var ret;
    	  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    	    // read it all, truncate the list
    	    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);
    	    state.buffer.clear();
    	  } else {
    	    // read part of list
    	    ret = state.buffer.consume(n, state.decoder);
    	  }
    	  return ret;
    	}
    	function endReadable(stream) {
    	  var state = stream._readableState;
    	  debug('endReadable', state.endEmitted);
    	  if (!state.endEmitted) {
    	    state.ended = true;
    	    browser$1$1.nextTick(endReadableNT, state, stream);
    	  }
    	}
    	function endReadableNT(state, stream) {
    	  debug('endReadableNT', state.endEmitted, state.length);

    	  // Check that we didn't get one last unshift.
    	  if (!state.endEmitted && state.length === 0) {
    	    state.endEmitted = true;
    	    stream.readable = false;
    	    stream.emit('end');
    	    if (state.autoDestroy) {
    	      // In case of duplex streams we need a way to detect
    	      // if the writable side is ready for autoDestroy as well
    	      var wState = stream._writableState;
    	      if (!wState || wState.autoDestroy && wState.finished) {
    	        stream.destroy();
    	      }
    	    }
    	  }
    	}
    	if (typeof Symbol === 'function') {
    	  Readable.from = function (iterable, opts) {
    	    if (from === undefined) {
    	      from = requireFromBrowser();
    	    }
    	    return from(Readable, iterable, opts);
    	  };
    	}
    	function indexOf(xs, x) {
    	  for (var i = 0, l = xs.length; i < l; i++) {
    	    if (xs[i] === x) return i;
    	  }
    	  return -1;
    	}
    	return _stream_readable;
    }

    var _stream_transform = Transform$3;
    var _require$codes$1 = errorsBrowser.codes,
      ERR_METHOD_NOT_IMPLEMENTED = _require$codes$1.ERR_METHOD_NOT_IMPLEMENTED,
      ERR_MULTIPLE_CALLBACK = _require$codes$1.ERR_MULTIPLE_CALLBACK,
      ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes$1.ERR_TRANSFORM_ALREADY_TRANSFORMING,
      ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes$1.ERR_TRANSFORM_WITH_LENGTH_0;
    var Duplex = require_stream_duplex();
    require$$1$2(Transform$3, Duplex);
    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (cb === null) {
        return this.emit('error', new ERR_MULTIPLE_CALLBACK());
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        // single equals check for both `null` and `undefined`
        this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    function Transform$3(options) {
      if (!(this instanceof Transform$3)) return new Transform$3(options);
      Duplex.call(this, options);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };

      // start out asking for a readable event once data is transformed.
      this._readableState.needReadable = true;

      // we have implemented the _read method, and done the other things
      // that Readable wants before the first _read call, so unset the
      // sync guard flag.
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === 'function') this._transform = options.transform;
        if (typeof options.flush === 'function') this._flush = options.flush;
      }

      // When the writable side finishes, then flush out anything remaining.
      this.on('prefinish', prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === 'function' && !this._readableState.destroyed) {
        this._flush(function (er, data) {
          done(_this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform$3.prototype.push = function (chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };

    // This is the part where you do stuff!
    // override this function in implementation classes.
    // 'chunk' is an input chunk.
    //
    // Call `push(newChunk)` to pass along transformed output
    // to the readable side.  You may call 'push' zero or more times.
    //
    // Call `cb(err)` when you are done with this chunk.  If you pass
    // an error, then that'll put the hurt on the whole operation.  If you
    // never call cb(), then you'll never get another chunk.
    Transform$3.prototype._transform = function (chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));
    };
    Transform$3.prototype._write = function (chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
      }
    };

    // Doesn't matter what the args are here.
    // _transform does all the work.
    // That we got here means that the readable side wants more data.
    Transform$3.prototype._read = function (n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        // mark that we need a transform, so that any data that comes in
        // will get processed, now that we've asked for it.
        ts.needTransform = true;
      }
    };
    Transform$3.prototype._destroy = function (err, cb) {
      Duplex.prototype._destroy.call(this, err, function (err2) {
        cb(err2);
      });
    };
    function done(stream, er, data) {
      if (er) return stream.emit('error', er);
      if (data != null)
        // single equals check for both `null` and `undefined`
        stream.push(data);

      // TODO(BridgeAR): Write a test for these two error cases
      // if there's nothing in the write buffer, then that means
      // that nothing more will ever be provided
      if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
      if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
      return stream.push(null);
    }

    var _stream_passthrough = PassThrough;
    var Transform$2 = _stream_transform;
    require$$1$2(PassThrough, Transform$2);
    function PassThrough(options) {
      if (!(this instanceof PassThrough)) return new PassThrough(options);
      Transform$2.call(this, options);
    }
    PassThrough.prototype._transform = function (chunk, encoding, cb) {
      cb(null, chunk);
    };

    var eos;
    function once(callback) {
      var called = false;
      return function () {
        if (called) return;
        called = true;
        callback.apply(void 0, arguments);
      };
    }
    var _require$codes = errorsBrowser.codes,
      ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,
      ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    function noop$2(err) {
      // Rethrow the error if it exists to avoid swallowing it
      if (err) throw err;
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === 'function';
    }
    function destroyer(stream, reading, writing, callback) {
      callback = once(callback);
      var closed = false;
      stream.on('close', function () {
        closed = true;
      });
      if (eos === undefined) eos = endOfStream;
      eos(stream, {
        readable: reading,
        writable: writing
      }, function (err) {
        if (err) return callback(err);
        closed = true;
        callback();
      });
      var destroyed = false;
      return function (err) {
        if (closed) return;
        if (destroyed) return;
        destroyed = true;

        // request.destroy just do .end - .abort is what we want
        if (isRequest(stream)) return stream.abort();
        if (typeof stream.destroy === 'function') return stream.destroy();
        callback(err || new ERR_STREAM_DESTROYED('pipe'));
      };
    }
    function call(fn) {
      fn();
    }
    function pipe(from, to) {
      return from.pipe(to);
    }
    function popCallback(streams) {
      if (!streams.length) return noop$2;
      if (typeof streams[streams.length - 1] !== 'function') return noop$2;
      return streams.pop();
    }
    function pipeline() {
      for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
        streams[_key] = arguments[_key];
      }
      var callback = popCallback(streams);
      if (Array.isArray(streams[0])) streams = streams[0];
      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS('streams');
      }
      var error;
      var destroys = streams.map(function (stream, i) {
        var reading = i < streams.length - 1;
        var writing = i > 0;
        return destroyer(stream, reading, writing, function (err) {
          if (!error) error = err;
          if (err) destroys.forEach(call);
          if (reading) return;
          destroys.forEach(call);
          callback(error);
        });
      });
      return streams.reduce(pipe);
    }
    var pipeline_1 = pipeline;

    (function (module, exports) {
    	exports = module.exports = require_stream_readable();
    	exports.Stream = exports;
    	exports.Readable = exports;
    	exports.Writable = require_stream_writable();
    	exports.Duplex = require_stream_duplex();
    	exports.Transform = _stream_transform;
    	exports.PassThrough = _stream_passthrough;
    	exports.finished = endOfStream;
    	exports.pipeline = pipeline_1; 
    } (readableBrowser, readableBrowser.exports));

    var readableBrowserExports = readableBrowser.exports;

    const { Transform: Transform$1 } = readableBrowserExports;

    var keccak$2 = (KeccakState) => class Keccak extends Transform$1 {
      constructor (rate, capacity, delimitedSuffix, hashBitLength, options) {
        super(options);

        this._rate = rate;
        this._capacity = capacity;
        this._delimitedSuffix = delimitedSuffix;
        this._hashBitLength = hashBitLength;
        this._options = options;

        this._state = new KeccakState();
        this._state.initialize(rate, capacity);
        this._finalized = false;
      }

      _transform (chunk, encoding, callback) {
        let error = null;
        try {
          this.update(chunk, encoding);
        } catch (err) {
          error = err;
        }

        callback(error);
      }

      _flush (callback) {
        let error = null;
        try {
          this.push(this.digest());
        } catch (err) {
          error = err;
        }

        callback(error);
      }

      update (data, encoding) {
        if (!Buffer$8.isBuffer(data) && typeof data !== 'string') throw new TypeError('Data must be a string or a buffer')
        if (this._finalized) throw new Error('Digest already called')
        if (!Buffer$8.isBuffer(data)) data = Buffer$8.from(data, encoding);

        this._state.absorb(data);

        return this
      }

      digest (encoding) {
        if (this._finalized) throw new Error('Digest already called')
        this._finalized = true;

        if (this._delimitedSuffix) this._state.absorbLastFewBits(this._delimitedSuffix);
        let digest = this._state.squeeze(this._hashBitLength / 8);
        if (encoding !== undefined) digest = digest.toString(encoding);

        this._resetState();

        return digest
      }

      // remove result from memory
      _resetState () {
        this._state.initialize(this._rate, this._capacity);
        return this
      }

      // because sometimes we need hash right now and little later
      _clone () {
        const clone = new Keccak(this._rate, this._capacity, this._delimitedSuffix, this._hashBitLength, this._options);
        this._state.copy(clone._state);
        clone._finalized = this._finalized;

        return clone
      }
    };

    const { Transform } = readableBrowserExports;

    var shake = (KeccakState) => class Shake extends Transform {
      constructor (rate, capacity, delimitedSuffix, options) {
        super(options);

        this._rate = rate;
        this._capacity = capacity;
        this._delimitedSuffix = delimitedSuffix;
        this._options = options;

        this._state = new KeccakState();
        this._state.initialize(rate, capacity);
        this._finalized = false;
      }

      _transform (chunk, encoding, callback) {
        let error = null;
        try {
          this.update(chunk, encoding);
        } catch (err) {
          error = err;
        }

        callback(error);
      }

      _flush () {}

      _read (size) {
        this.push(this.squeeze(size));
      }

      update (data, encoding) {
        if (!Buffer$8.isBuffer(data) && typeof data !== 'string') throw new TypeError('Data must be a string or a buffer')
        if (this._finalized) throw new Error('Squeeze already called')
        if (!Buffer$8.isBuffer(data)) data = Buffer$8.from(data, encoding);

        this._state.absorb(data);

        return this
      }

      squeeze (dataByteLength, encoding) {
        if (!this._finalized) {
          this._finalized = true;
          this._state.absorbLastFewBits(this._delimitedSuffix);
        }

        let data = this._state.squeeze(dataByteLength);
        if (encoding !== undefined) data = data.toString(encoding);

        return data
      }

      _resetState () {
        this._state.initialize(this._rate, this._capacity);
        return this
      }

      _clone () {
        const clone = new Shake(this._rate, this._capacity, this._delimitedSuffix, this._options);
        this._state.copy(clone._state);
        clone._finalized = this._finalized;

        return clone
      }
    };

    const createKeccak = keccak$2;
    const createShake = shake;

    var api = function (KeccakState) {
      const Keccak = createKeccak(KeccakState);
      const Shake = createShake(KeccakState);

      return function (algorithm, options) {
        const hash = typeof algorithm === 'string' ? algorithm.toLowerCase() : algorithm;
        switch (hash) {
          case 'keccak224': return new Keccak(1152, 448, null, 224, options)
          case 'keccak256': return new Keccak(1088, 512, null, 256, options)
          case 'keccak384': return new Keccak(832, 768, null, 384, options)
          case 'keccak512': return new Keccak(576, 1024, null, 512, options)

          case 'sha3-224': return new Keccak(1152, 448, 0x06, 224, options)
          case 'sha3-256': return new Keccak(1088, 512, 0x06, 256, options)
          case 'sha3-384': return new Keccak(832, 768, 0x06, 384, options)
          case 'sha3-512': return new Keccak(576, 1024, 0x06, 512, options)

          case 'shake128': return new Shake(1344, 256, 0x1f, options)
          case 'shake256': return new Shake(1088, 512, 0x1f, options)

          default: throw new Error('Invald algorithm: ' + algorithm)
        }
      }
    };

    var keccakStateUnroll = {};

    const P1600_ROUND_CONSTANTS = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648];

    keccakStateUnroll.p1600 = function (s) {
      for (let round = 0; round < 24; ++round) {
        // theta
        const lo0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];
        const hi0 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];
        const lo1 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];
        const hi1 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];
        const lo2 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];
        const hi2 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];
        const lo3 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];
        const hi3 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];
        const lo4 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];
        const hi4 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];

        let lo = lo4 ^ (lo1 << 1 | hi1 >>> 31);
        let hi = hi4 ^ (hi1 << 1 | lo1 >>> 31);
        const t1slo0 = s[0] ^ lo;
        const t1shi0 = s[1] ^ hi;
        const t1slo5 = s[10] ^ lo;
        const t1shi5 = s[11] ^ hi;
        const t1slo10 = s[20] ^ lo;
        const t1shi10 = s[21] ^ hi;
        const t1slo15 = s[30] ^ lo;
        const t1shi15 = s[31] ^ hi;
        const t1slo20 = s[40] ^ lo;
        const t1shi20 = s[41] ^ hi;
        lo = lo0 ^ (lo2 << 1 | hi2 >>> 31);
        hi = hi0 ^ (hi2 << 1 | lo2 >>> 31);
        const t1slo1 = s[2] ^ lo;
        const t1shi1 = s[3] ^ hi;
        const t1slo6 = s[12] ^ lo;
        const t1shi6 = s[13] ^ hi;
        const t1slo11 = s[22] ^ lo;
        const t1shi11 = s[23] ^ hi;
        const t1slo16 = s[32] ^ lo;
        const t1shi16 = s[33] ^ hi;
        const t1slo21 = s[42] ^ lo;
        const t1shi21 = s[43] ^ hi;
        lo = lo1 ^ (lo3 << 1 | hi3 >>> 31);
        hi = hi1 ^ (hi3 << 1 | lo3 >>> 31);
        const t1slo2 = s[4] ^ lo;
        const t1shi2 = s[5] ^ hi;
        const t1slo7 = s[14] ^ lo;
        const t1shi7 = s[15] ^ hi;
        const t1slo12 = s[24] ^ lo;
        const t1shi12 = s[25] ^ hi;
        const t1slo17 = s[34] ^ lo;
        const t1shi17 = s[35] ^ hi;
        const t1slo22 = s[44] ^ lo;
        const t1shi22 = s[45] ^ hi;
        lo = lo2 ^ (lo4 << 1 | hi4 >>> 31);
        hi = hi2 ^ (hi4 << 1 | lo4 >>> 31);
        const t1slo3 = s[6] ^ lo;
        const t1shi3 = s[7] ^ hi;
        const t1slo8 = s[16] ^ lo;
        const t1shi8 = s[17] ^ hi;
        const t1slo13 = s[26] ^ lo;
        const t1shi13 = s[27] ^ hi;
        const t1slo18 = s[36] ^ lo;
        const t1shi18 = s[37] ^ hi;
        const t1slo23 = s[46] ^ lo;
        const t1shi23 = s[47] ^ hi;
        lo = lo3 ^ (lo0 << 1 | hi0 >>> 31);
        hi = hi3 ^ (hi0 << 1 | lo0 >>> 31);
        const t1slo4 = s[8] ^ lo;
        const t1shi4 = s[9] ^ hi;
        const t1slo9 = s[18] ^ lo;
        const t1shi9 = s[19] ^ hi;
        const t1slo14 = s[28] ^ lo;
        const t1shi14 = s[29] ^ hi;
        const t1slo19 = s[38] ^ lo;
        const t1shi19 = s[39] ^ hi;
        const t1slo24 = s[48] ^ lo;
        const t1shi24 = s[49] ^ hi;

        // rho & pi
        const t2slo0 = t1slo0;
        const t2shi0 = t1shi0;
        const t2slo16 = (t1shi5 << 4 | t1slo5 >>> 28);
        const t2shi16 = (t1slo5 << 4 | t1shi5 >>> 28);
        const t2slo7 = (t1slo10 << 3 | t1shi10 >>> 29);
        const t2shi7 = (t1shi10 << 3 | t1slo10 >>> 29);
        const t2slo23 = (t1shi15 << 9 | t1slo15 >>> 23);
        const t2shi23 = (t1slo15 << 9 | t1shi15 >>> 23);
        const t2slo14 = (t1slo20 << 18 | t1shi20 >>> 14);
        const t2shi14 = (t1shi20 << 18 | t1slo20 >>> 14);
        const t2slo10 = (t1slo1 << 1 | t1shi1 >>> 31);
        const t2shi10 = (t1shi1 << 1 | t1slo1 >>> 31);
        const t2slo1 = (t1shi6 << 12 | t1slo6 >>> 20);
        const t2shi1 = (t1slo6 << 12 | t1shi6 >>> 20);
        const t2slo17 = (t1slo11 << 10 | t1shi11 >>> 22);
        const t2shi17 = (t1shi11 << 10 | t1slo11 >>> 22);
        const t2slo8 = (t1shi16 << 13 | t1slo16 >>> 19);
        const t2shi8 = (t1slo16 << 13 | t1shi16 >>> 19);
        const t2slo24 = (t1slo21 << 2 | t1shi21 >>> 30);
        const t2shi24 = (t1shi21 << 2 | t1slo21 >>> 30);
        const t2slo20 = (t1shi2 << 30 | t1slo2 >>> 2);
        const t2shi20 = (t1slo2 << 30 | t1shi2 >>> 2);
        const t2slo11 = (t1slo7 << 6 | t1shi7 >>> 26);
        const t2shi11 = (t1shi7 << 6 | t1slo7 >>> 26);
        const t2slo2 = (t1shi12 << 11 | t1slo12 >>> 21);
        const t2shi2 = (t1slo12 << 11 | t1shi12 >>> 21);
        const t2slo18 = (t1slo17 << 15 | t1shi17 >>> 17);
        const t2shi18 = (t1shi17 << 15 | t1slo17 >>> 17);
        const t2slo9 = (t1shi22 << 29 | t1slo22 >>> 3);
        const t2shi9 = (t1slo22 << 29 | t1shi22 >>> 3);
        const t2slo5 = (t1slo3 << 28 | t1shi3 >>> 4);
        const t2shi5 = (t1shi3 << 28 | t1slo3 >>> 4);
        const t2slo21 = (t1shi8 << 23 | t1slo8 >>> 9);
        const t2shi21 = (t1slo8 << 23 | t1shi8 >>> 9);
        const t2slo12 = (t1slo13 << 25 | t1shi13 >>> 7);
        const t2shi12 = (t1shi13 << 25 | t1slo13 >>> 7);
        const t2slo3 = (t1slo18 << 21 | t1shi18 >>> 11);
        const t2shi3 = (t1shi18 << 21 | t1slo18 >>> 11);
        const t2slo19 = (t1shi23 << 24 | t1slo23 >>> 8);
        const t2shi19 = (t1slo23 << 24 | t1shi23 >>> 8);
        const t2slo15 = (t1slo4 << 27 | t1shi4 >>> 5);
        const t2shi15 = (t1shi4 << 27 | t1slo4 >>> 5);
        const t2slo6 = (t1slo9 << 20 | t1shi9 >>> 12);
        const t2shi6 = (t1shi9 << 20 | t1slo9 >>> 12);
        const t2slo22 = (t1shi14 << 7 | t1slo14 >>> 25);
        const t2shi22 = (t1slo14 << 7 | t1shi14 >>> 25);
        const t2slo13 = (t1slo19 << 8 | t1shi19 >>> 24);
        const t2shi13 = (t1shi19 << 8 | t1slo19 >>> 24);
        const t2slo4 = (t1slo24 << 14 | t1shi24 >>> 18);
        const t2shi4 = (t1shi24 << 14 | t1slo24 >>> 18);

        // chi
        s[0] = t2slo0 ^ (~t2slo1 & t2slo2);
        s[1] = t2shi0 ^ (~t2shi1 & t2shi2);
        s[10] = t2slo5 ^ (~t2slo6 & t2slo7);
        s[11] = t2shi5 ^ (~t2shi6 & t2shi7);
        s[20] = t2slo10 ^ (~t2slo11 & t2slo12);
        s[21] = t2shi10 ^ (~t2shi11 & t2shi12);
        s[30] = t2slo15 ^ (~t2slo16 & t2slo17);
        s[31] = t2shi15 ^ (~t2shi16 & t2shi17);
        s[40] = t2slo20 ^ (~t2slo21 & t2slo22);
        s[41] = t2shi20 ^ (~t2shi21 & t2shi22);
        s[2] = t2slo1 ^ (~t2slo2 & t2slo3);
        s[3] = t2shi1 ^ (~t2shi2 & t2shi3);
        s[12] = t2slo6 ^ (~t2slo7 & t2slo8);
        s[13] = t2shi6 ^ (~t2shi7 & t2shi8);
        s[22] = t2slo11 ^ (~t2slo12 & t2slo13);
        s[23] = t2shi11 ^ (~t2shi12 & t2shi13);
        s[32] = t2slo16 ^ (~t2slo17 & t2slo18);
        s[33] = t2shi16 ^ (~t2shi17 & t2shi18);
        s[42] = t2slo21 ^ (~t2slo22 & t2slo23);
        s[43] = t2shi21 ^ (~t2shi22 & t2shi23);
        s[4] = t2slo2 ^ (~t2slo3 & t2slo4);
        s[5] = t2shi2 ^ (~t2shi3 & t2shi4);
        s[14] = t2slo7 ^ (~t2slo8 & t2slo9);
        s[15] = t2shi7 ^ (~t2shi8 & t2shi9);
        s[24] = t2slo12 ^ (~t2slo13 & t2slo14);
        s[25] = t2shi12 ^ (~t2shi13 & t2shi14);
        s[34] = t2slo17 ^ (~t2slo18 & t2slo19);
        s[35] = t2shi17 ^ (~t2shi18 & t2shi19);
        s[44] = t2slo22 ^ (~t2slo23 & t2slo24);
        s[45] = t2shi22 ^ (~t2shi23 & t2shi24);
        s[6] = t2slo3 ^ (~t2slo4 & t2slo0);
        s[7] = t2shi3 ^ (~t2shi4 & t2shi0);
        s[16] = t2slo8 ^ (~t2slo9 & t2slo5);
        s[17] = t2shi8 ^ (~t2shi9 & t2shi5);
        s[26] = t2slo13 ^ (~t2slo14 & t2slo10);
        s[27] = t2shi13 ^ (~t2shi14 & t2shi10);
        s[36] = t2slo18 ^ (~t2slo19 & t2slo15);
        s[37] = t2shi18 ^ (~t2shi19 & t2shi15);
        s[46] = t2slo23 ^ (~t2slo24 & t2slo20);
        s[47] = t2shi23 ^ (~t2shi24 & t2shi20);
        s[8] = t2slo4 ^ (~t2slo0 & t2slo1);
        s[9] = t2shi4 ^ (~t2shi0 & t2shi1);
        s[18] = t2slo9 ^ (~t2slo5 & t2slo6);
        s[19] = t2shi9 ^ (~t2shi5 & t2shi6);
        s[28] = t2slo14 ^ (~t2slo10 & t2slo11);
        s[29] = t2shi14 ^ (~t2shi10 & t2shi11);
        s[38] = t2slo19 ^ (~t2slo15 & t2slo16);
        s[39] = t2shi19 ^ (~t2shi15 & t2shi16);
        s[48] = t2slo24 ^ (~t2slo20 & t2slo21);
        s[49] = t2shi24 ^ (~t2shi20 & t2shi21);

        // iota
        s[0] ^= P1600_ROUND_CONSTANTS[round * 2];
        s[1] ^= P1600_ROUND_CONSTANTS[round * 2 + 1];
      }
    };

    const keccakState = keccakStateUnroll;

    function Keccak () {
      // much faster than `new Array(50)`
      this.state = [
        0, 0, 0, 0, 0,
        0, 0, 0, 0, 0,
        0, 0, 0, 0, 0,
        0, 0, 0, 0, 0,
        0, 0, 0, 0, 0
      ];

      this.blockSize = null;
      this.count = 0;
      this.squeezing = false;
    }

    Keccak.prototype.initialize = function (rate, capacity) {
      for (let i = 0; i < 50; ++i) this.state[i] = 0;
      this.blockSize = rate / 8;
      this.count = 0;
      this.squeezing = false;
    };

    Keccak.prototype.absorb = function (data) {
      for (let i = 0; i < data.length; ++i) {
        this.state[~~(this.count / 4)] ^= data[i] << (8 * (this.count % 4));
        this.count += 1;
        if (this.count === this.blockSize) {
          keccakState.p1600(this.state);
          this.count = 0;
        }
      }
    };

    Keccak.prototype.absorbLastFewBits = function (bits) {
      this.state[~~(this.count / 4)] ^= bits << (8 * (this.count % 4));
      if ((bits & 0x80) !== 0 && this.count === (this.blockSize - 1)) keccakState.p1600(this.state);
      this.state[~~((this.blockSize - 1) / 4)] ^= 0x80 << (8 * ((this.blockSize - 1) % 4));
      keccakState.p1600(this.state);
      this.count = 0;
      this.squeezing = true;
    };

    Keccak.prototype.squeeze = function (length) {
      if (!this.squeezing) this.absorbLastFewBits(0x01);

      const output = Buffer$8.alloc(length);
      for (let i = 0; i < length; ++i) {
        output[i] = (this.state[~~(this.count / 4)] >>> (8 * (this.count % 4))) & 0xff;
        this.count += 1;
        if (this.count === this.blockSize) {
          keccakState.p1600(this.state);
          this.count = 0;
        }
      }

      return output
    };

    Keccak.prototype.copy = function (dest) {
      for (let i = 0; i < 50; ++i) dest.state[i] = this.state[i];
      dest.blockSize = this.blockSize;
      dest.count = this.count;
      dest.squeezing = this.squeezing;
    };

    var keccak$1 = Keccak;

    var js = api(keccak$1);

    // Extracted from https://github.com/ethereumjs/ethereumjs-util and stripped out irrelevant code
    // Original code licensed under the Mozilla Public License Version 2.0

    const createKeccakHash = js;
    const BN$1 = bnExports;

    /**
     * Returns a buffer filled with 0s
     * @method zeros
     * @param {Number} bytes  the number of bytes the buffer should be
     * @return {Buffer}
     */
    function zeros (bytes) {
      return Buffer$8.allocUnsafe(bytes).fill(0)
    }

    /**
     * Left Pads an `Array` or `Buffer` with leading zeros till it has `length` bytes.
     * Or it truncates the beginning if it exceeds.
     * @method setLength
     * @param {Buffer|Array} msg the value to pad
     * @param {Number} length the number of bytes the output should be
     * @param {Boolean} [right=false] whether to start padding form the left or right
     * @return {Buffer|Array}
     */
    function setLength (msg, length, right) {
      const buf = zeros(length);
      msg = toBuffer(msg);
      if (right) {
        if (msg.length < length) {
          msg.copy(buf);
          return buf
        }
        return msg.slice(0, length)
      } else {
        if (msg.length < length) {
          msg.copy(buf, length - msg.length);
          return buf
        }
        return msg.slice(-length)
      }
    }

    /**
     * Right Pads an `Array` or `Buffer` with leading zeros till it has `length` bytes.
     * Or it truncates the beginning if it exceeds.
     * @param {Buffer|Array} msg the value to pad
     * @param {Number} length the number of bytes the output should be
     * @return {Buffer|Array}
     */
    function setLengthRight (msg, length) {
      return setLength(msg, length, true)
    }

    /**
     * Attempts to turn a value into a `Buffer`. As input it supports `Buffer`, `String`, `Number`, null/undefined, `BN` and other objects with a `toArray()` method.
     * @param {*} v the value
     */
    function toBuffer (v) {
      if (!Buffer$8.isBuffer(v)) {
        if (Array.isArray(v)) {
          v = Buffer$8.from(v);
        } else if (typeof v === 'string') {
          if (isHexString(v)) {
            v = Buffer$8.from(padToEven(stripHexPrefix(v)), 'hex');
          } else {
            v = Buffer$8.from(v);
          }
        } else if (typeof v === 'number') {
          v = intToBuffer(v);
        } else if (v === null || v === undefined) {
          v = Buffer$8.allocUnsafe(0);
        } else if (BN$1.isBN(v)) {
          v = v.toArrayLike(Buffer$8);
        } else if (v.toArray) {
          // converts a BN to a Buffer
          v = Buffer$8.from(v.toArray());
        } else {
          throw new Error('invalid type')
        }
      }
      return v
    }

    /**
     * Converts a `Buffer` into a hex `String`
     * @param {Buffer} buf
     * @return {String}
     */
    function bufferToHex (buf) {
      buf = toBuffer(buf);
      return '0x' + buf.toString('hex')
    }

    /**
     * Creates Keccak hash of the input
     * @param {Buffer|Array|String|Number} a the input data
     * @param {Number} [bits=256] the Keccak width
     * @return {Buffer}
     */
    function keccak (a, bits) {
      a = toBuffer(a);
      if (!bits) bits = 256;

      return createKeccakHash('keccak' + bits).update(a).digest()
    }

    function padToEven (str) {
      return str.length % 2 ? '0' + str : str
    }

    function isHexString (str) {
      return typeof str === 'string' && str.match(/^0x[0-9A-Fa-f]*$/)
    }

    function stripHexPrefix (str) {
      if (typeof str === 'string' && str.startsWith('0x')) {
        return str.slice(2)
      }
      return str
    }

    var util$2 = {
      zeros,
      setLength,
      setLengthRight,
      isHexString,
      stripHexPrefix,
      toBuffer,
      bufferToHex,
      keccak
    };

    // Extracted from https://github.com/ethereumjs/ethereumjs-abi and stripped out irrelevant code
    // Original code licensed under the MIT License - Copyright (c) 2015 Alex Beregszaszi

    const util$1 = util$2;
    const BN = bnExports;

    // Convert from short to canonical names
    // FIXME: optimise or make this nicer?
    function elementaryName (name) {
      if (name.startsWith('int[')) {
        return 'int256' + name.slice(3)
      } else if (name === 'int') {
        return 'int256'
      } else if (name.startsWith('uint[')) {
        return 'uint256' + name.slice(4)
      } else if (name === 'uint') {
        return 'uint256'
      } else if (name.startsWith('fixed[')) {
        return 'fixed128x128' + name.slice(5)
      } else if (name === 'fixed') {
        return 'fixed128x128'
      } else if (name.startsWith('ufixed[')) {
        return 'ufixed128x128' + name.slice(6)
      } else if (name === 'ufixed') {
        return 'ufixed128x128'
      }
      return name
    }

    // Parse N from type<N>
    function parseTypeN (type) {
      return parseInt(/^\D+(\d+)$/.exec(type)[1], 10)
    }

    // Parse N,M from type<N>x<M>
    function parseTypeNxM (type) {
      var tmp = /^\D+(\d+)x(\d+)$/.exec(type);
      return [ parseInt(tmp[1], 10), parseInt(tmp[2], 10) ]
    }

    // Parse N in type[<N>] where "type" can itself be an array type.
    function parseTypeArray (type) {
      var tmp = type.match(/(.*)\[(.*?)\]$/);
      if (tmp) {
        return tmp[2] === '' ? 'dynamic' : parseInt(tmp[2], 10)
      }
      return null
    }

    function parseNumber (arg) {
      var type = typeof arg;
      if (type === 'string') {
        if (util$1.isHexString(arg)) {
          return new BN(util$1.stripHexPrefix(arg), 16)
        } else {
          return new BN(arg, 10)
        }
      } else if (type === 'number') {
        return new BN(arg)
      } else if (arg.toArray) {
        // assume this is a BN for the moment, replace with BN.isBN soon
        return arg
      } else {
        throw new Error('Argument is not a number')
      }
    }

    // Encodes a single item (can be dynamic array)
    // @returns: Buffer
    function encodeSingle (type, arg) {
      var size, num, ret, i;

      if (type === 'address') {
        return encodeSingle('uint160', parseNumber(arg))
      } else if (type === 'bool') {
        return encodeSingle('uint8', arg ? 1 : 0)
      } else if (type === 'string') {
        return encodeSingle('bytes', new Buffer$8(arg, 'utf8'))
      } else if (isArray(type)) {
        // this part handles fixed-length ([2]) and variable length ([]) arrays
        // NOTE: we catch here all calls to arrays, that simplifies the rest
        if (typeof arg.length === 'undefined') {
          throw new Error('Not an array?')
        }
        size = parseTypeArray(type);
        if (size !== 'dynamic' && size !== 0 && arg.length > size) {
          throw new Error('Elements exceed array size: ' + size)
        }
        ret = [];
        type = type.slice(0, type.lastIndexOf('['));
        if (typeof arg === 'string') {
          arg = JSON.parse(arg);
        }
        for (i in arg) {
          ret.push(encodeSingle(type, arg[i]));
        }
        if (size === 'dynamic') {
          var length = encodeSingle('uint256', arg.length);
          ret.unshift(length);
        }
        return Buffer$8.concat(ret)
      } else if (type === 'bytes') {
        arg = new Buffer$8(arg);

        ret = Buffer$8.concat([ encodeSingle('uint256', arg.length), arg ]);

        if ((arg.length % 32) !== 0) {
          ret = Buffer$8.concat([ ret, util$1.zeros(32 - (arg.length % 32)) ]);
        }

        return ret
      } else if (type.startsWith('bytes')) {
        size = parseTypeN(type);
        if (size < 1 || size > 32) {
          throw new Error('Invalid bytes<N> width: ' + size)
        }

        return util$1.setLengthRight(arg, 32)
      } else if (type.startsWith('uint')) {
        size = parseTypeN(type);
        if ((size % 8) || (size < 8) || (size > 256)) {
          throw new Error('Invalid uint<N> width: ' + size)
        }

        num = parseNumber(arg);
        if (num.bitLength() > size) {
          throw new Error('Supplied uint exceeds width: ' + size + ' vs ' + num.bitLength())
        }

        if (num < 0) {
          throw new Error('Supplied uint is negative')
        }

        return num.toArrayLike(Buffer$8, 'be', 32)
      } else if (type.startsWith('int')) {
        size = parseTypeN(type);
        if ((size % 8) || (size < 8) || (size > 256)) {
          throw new Error('Invalid int<N> width: ' + size)
        }

        num = parseNumber(arg);
        if (num.bitLength() > size) {
          throw new Error('Supplied int exceeds width: ' + size + ' vs ' + num.bitLength())
        }

        return num.toTwos(256).toArrayLike(Buffer$8, 'be', 32)
      } else if (type.startsWith('ufixed')) {
        size = parseTypeNxM(type);

        num = parseNumber(arg);

        if (num < 0) {
          throw new Error('Supplied ufixed is negative')
        }

        return encodeSingle('uint256', num.mul(new BN(2).pow(new BN(size[1]))))
      } else if (type.startsWith('fixed')) {
        size = parseTypeNxM(type);

        return encodeSingle('int256', parseNumber(arg).mul(new BN(2).pow(new BN(size[1]))))
      }

      throw new Error('Unsupported or invalid type: ' + type)
    }

    // Is a type dynamic?
    function isDynamic (type) {
      // FIXME: handle all types? I don't think anything is missing now
      return (type === 'string') || (type === 'bytes') || (parseTypeArray(type) === 'dynamic')
    }

    // Is a type an array?
    function isArray (type) {
      return type.lastIndexOf(']') === type.length - 1
    }

    // Encode a method/event with arguments
    // @types an array of string type names
    // @args  an array of the appropriate values
    function rawEncode (types, values) {
      var output = [];
      var data = [];

      var headLength = 32 * types.length;

      for (var i in types) {
        var type = elementaryName(types[i]);
        var value = values[i];
        var cur = encodeSingle(type, value);

        // Use the head/tail method for storing dynamic data
        if (isDynamic(type)) {
          output.push(encodeSingle('uint256', headLength));
          data.push(cur);
          headLength += cur.length;
        } else {
          output.push(cur);
        }
      }

      return Buffer$8.concat(output.concat(data))
    }

    function solidityPack (types, values) {
      if (types.length !== values.length) {
        throw new Error('Number of types are not matching the values')
      }

      var size, num;
      var ret = [];

      for (var i = 0; i < types.length; i++) {
        var type = elementaryName(types[i]);
        var value = values[i];

        if (type === 'bytes') {
          ret.push(value);
        } else if (type === 'string') {
          ret.push(new Buffer$8(value, 'utf8'));
        } else if (type === 'bool') {
          ret.push(new Buffer$8(value ? '01' : '00', 'hex'));
        } else if (type === 'address') {
          ret.push(util$1.setLength(value, 20));
        } else if (type.startsWith('bytes')) {
          size = parseTypeN(type);
          if (size < 1 || size > 32) {
            throw new Error('Invalid bytes<N> width: ' + size)
          }

          ret.push(util$1.setLengthRight(value, size));
        } else if (type.startsWith('uint')) {
          size = parseTypeN(type);
          if ((size % 8) || (size < 8) || (size > 256)) {
            throw new Error('Invalid uint<N> width: ' + size)
          }

          num = parseNumber(value);
          if (num.bitLength() > size) {
            throw new Error('Supplied uint exceeds width: ' + size + ' vs ' + num.bitLength())
          }

          ret.push(num.toArrayLike(Buffer$8, 'be', size / 8));
        } else if (type.startsWith('int')) {
          size = parseTypeN(type);
          if ((size % 8) || (size < 8) || (size > 256)) {
            throw new Error('Invalid int<N> width: ' + size)
          }

          num = parseNumber(value);
          if (num.bitLength() > size) {
            throw new Error('Supplied int exceeds width: ' + size + ' vs ' + num.bitLength())
          }

          ret.push(num.toTwos(size).toArrayLike(Buffer$8, 'be', size / 8));
        } else {
          // FIXME: support all other types
          throw new Error('Unsupported or invalid type: ' + type)
        }
      }

      return Buffer$8.concat(ret)
    }

    function soliditySHA3 (types, values) {
      return util$1.keccak(solidityPack(types, values))
    }

    var abi$1 = {
      rawEncode,
      solidityPack,
      soliditySHA3
    };

    const util = util$2;
    const abi = abi$1;

    const TYPED_MESSAGE_SCHEMA = {
      type: 'object',
      properties: {
        types: {
          type: 'object',
          additionalProperties: {
            type: 'array',
            items: {
              type: 'object',
              properties: {
                name: {type: 'string'},
                type: {type: 'string'},
              },
              required: ['name', 'type'],
            },
          },
        },
        primaryType: {type: 'string'},
        domain: {type: 'object'},
        message: {type: 'object'},
      },
      required: ['types', 'primaryType', 'domain', 'message'],
    };

    /**
     * A collection of utility functions used for signing typed data
     */
    const TypedDataUtils = {
      /**
       * Encodes an object by encoding and concatenating each of its members
       *
       * @param {string} primaryType - Root type
       * @param {Object} data - Object to encode
       * @param {Object} types - Type definitions
       * @returns {string} - Encoded representation of an object
       */
      encodeData (primaryType, data, types, useV4 = true) {
        const encodedTypes = ['bytes32'];
        const encodedValues = [this.hashType(primaryType, types)];

        if(useV4) {
          const encodeField = (name, type, value) => {
            if (types[type] !== undefined) {
              return ['bytes32', value == null ?
                '0x0000000000000000000000000000000000000000000000000000000000000000' :
                util.keccak(this.encodeData(type, value, types, useV4))]
            }

            if(value === undefined)
              throw new Error(`missing value for field ${name} of type ${type}`)

            if (type === 'bytes') {
              return ['bytes32', util.keccak(value)]
            }

            if (type === 'string') {
              // convert string to buffer - prevents ethUtil from interpreting strings like '0xabcd' as hex
              if (typeof value === 'string') {
                value = Buffer$8.from(value, 'utf8');
              }
              return ['bytes32', util.keccak(value)]
            }

            if (type.lastIndexOf(']') === type.length - 1) {
              const parsedType = type.slice(0, type.lastIndexOf('['));
              const typeValuePairs = value.map(item =>
                encodeField(name, parsedType, item));
              return ['bytes32', util.keccak(abi.rawEncode(
                typeValuePairs.map(([type]) => type),
                typeValuePairs.map(([, value]) => value),
              ))]
            }

            return [type, value]
          };

          for (const field of types[primaryType]) {
            const [type, value] = encodeField(field.name, field.type, data[field.name]);
            encodedTypes.push(type);
            encodedValues.push(value);
          }
        } else {
          for (const field of types[primaryType]) {
            let value = data[field.name];
            if (value !== undefined) {
              if (field.type === 'bytes') {
                encodedTypes.push('bytes32');
                value = util.keccak(value);
                encodedValues.push(value);
              } else if (field.type === 'string') {
                encodedTypes.push('bytes32');
                // convert string to buffer - prevents ethUtil from interpreting strings like '0xabcd' as hex
                if (typeof value === 'string') {
                  value = Buffer$8.from(value, 'utf8');
                }
                value = util.keccak(value);
                encodedValues.push(value);
              } else if (types[field.type] !== undefined) {
                encodedTypes.push('bytes32');
                value = util.keccak(this.encodeData(field.type, value, types, useV4));
                encodedValues.push(value);
              } else if (field.type.lastIndexOf(']') === field.type.length - 1) {
                throw new Error('Arrays currently unimplemented in encodeData')
              } else {
                encodedTypes.push(field.type);
                encodedValues.push(value);
              }
            }
          }
        }

        return abi.rawEncode(encodedTypes, encodedValues)
      },

      /**
       * Encodes the type of an object by encoding a comma delimited list of its members
       *
       * @param {string} primaryType - Root type to encode
       * @param {Object} types - Type definitions
       * @returns {string} - Encoded representation of the type of an object
       */
      encodeType (primaryType, types) {
        let result = '';
        let deps = this.findTypeDependencies(primaryType, types).filter(dep => dep !== primaryType);
        deps = [primaryType].concat(deps.sort());
        for (const type of deps) {
          const children = types[type];
          if (!children) {
            throw new Error('No type definition specified: ' + type)
          }
          result += type + '(' + types[type].map(({ name, type }) => type + ' ' + name).join(',') + ')';
        }
        return result
      },

      /**
       * Finds all types within a type defintion object
       *
       * @param {string} primaryType - Root type
       * @param {Object} types - Type definitions
       * @param {Array} results - current set of accumulated types
       * @returns {Array} - Set of all types found in the type definition
       */
      findTypeDependencies (primaryType, types, results = []) {
        primaryType = primaryType.match(/^\w*/)[0];
        if (results.includes(primaryType) || types[primaryType] === undefined) { return results }
        results.push(primaryType);
        for (const field of types[primaryType]) {
          for (const dep of this.findTypeDependencies(field.type, types, results)) {
            !results.includes(dep) && results.push(dep);
          }
        }
        return results
      },

      /**
       * Hashes an object
       *
       * @param {string} primaryType - Root type
       * @param {Object} data - Object to hash
       * @param {Object} types - Type definitions
       * @returns {Buffer} - Hash of an object
       */
      hashStruct (primaryType, data, types, useV4 = true) {
        return util.keccak(this.encodeData(primaryType, data, types, useV4))
      },

      /**
       * Hashes the type of an object
       *
       * @param {string} primaryType - Root type to hash
       * @param {Object} types - Type definitions
       * @returns {string} - Hash of an object
       */
      hashType (primaryType, types) {
        return util.keccak(this.encodeType(primaryType, types))
      },

      /**
       * Removes properties from a message object that are not defined per EIP-712
       *
       * @param {Object} data - typed message object
       * @returns {Object} - typed message object with only allowed fields
       */
      sanitizeData (data) {
        const sanitizedData = {};
        for (const key in TYPED_MESSAGE_SCHEMA.properties) {
          data[key] && (sanitizedData[key] = data[key]);
        }
        if (sanitizedData.types) {
          sanitizedData.types = Object.assign({ EIP712Domain: [] }, sanitizedData.types);
        }
        return sanitizedData
      },

      /**
       * Returns the hash of a typed message as per EIP-712 for signing
       *
       * @param {Object} typedData - Types message data to sign
       * @returns {string} - sha3 hash for signing
       */
      hash (typedData, useV4 = true) {
        const sanitizedData = this.sanitizeData(typedData);
        const parts = [Buffer$8.from('1901', 'hex')];
        parts.push(this.hashStruct('EIP712Domain', sanitizedData.domain, sanitizedData.types, useV4));
        if (sanitizedData.primaryType !== 'EIP712Domain') {
          parts.push(this.hashStruct(sanitizedData.primaryType, sanitizedData.message, sanitizedData.types, useV4));
        }
        return util.keccak(Buffer$8.concat(parts))
      },
    };

    var ethEip712Util = {
      TYPED_MESSAGE_SCHEMA,
      TypedDataUtils,

      hashForSignTypedDataLegacy: function (msgParams) {
        return typedSignatureHashLegacy(msgParams.data)
      },

      hashForSignTypedData_v3: function (msgParams) {
        return TypedDataUtils.hash(msgParams.data, false)
      },

      hashForSignTypedData_v4: function (msgParams) {
        return TypedDataUtils.hash(msgParams.data)
      },
    };

    /**
     * @param typedData - Array of data along with types, as per EIP712.
     * @returns Buffer
     */
    function typedSignatureHashLegacy(typedData) {
      const error = new Error('Expect argument to be non-empty array');
      if (typeof typedData !== 'object' || !typedData.length) throw error

      const data = typedData.map(function (e) {
        return e.type === 'bytes' ? util.toBuffer(e.value) : e.value
      });
      const types = typedData.map(function (e) { return e.type });
      const schema = typedData.map(function (e) {
        if (!e.name) throw error
        return e.type + ' ' + e.name
      });

      return abi.soliditySHA3(
        ['bytes32', 'bytes32'],
        [
          abi.soliditySHA3(new Array(typedData.length).fill('string'), schema),
          abi.soliditySHA3(types, data)
        ]
      )
    }

    var FilterPolyfill$1 = {};

    // Copyright (c) 2018-2023 Coinbase, Inc. <https://www.coinbase.com/>
    // Licensed under the Apache License, version 2.0
    Object.defineProperty(FilterPolyfill$1, "__esModule", { value: true });
    FilterPolyfill$1.filterFromParam = FilterPolyfill$1.FilterPolyfill = void 0;
    const type_1 = type$1;
    const util_1$3 = util$3;
    const TIMEOUT = 5 * 60 * 1000; // 5 minutes
    const JSONRPC_TEMPLATE = {
        jsonrpc: '2.0',
        id: 0,
    };
    class FilterPolyfill {
        constructor(provider) {
            this.logFilters = new Map(); // <id, filter>
            this.blockFilters = new Set(); // <id>
            this.pendingTransactionFilters = new Set(); // <id, true>
            this.cursors = new Map(); // <id, cursor>
            this.timeouts = new Map(); // <id, setTimeout id>
            this.nextFilterId = (0, type_1.IntNumber)(1);
            this.REQUEST_THROTTLE_INTERVAL = 1000; // in milliseconds
            this.lastFetchTimestamp = new Date(0);
            this.resolvers = [];
            this.provider = provider;
        }
        async newFilter(param) {
            const filter = filterFromParam(param);
            const id = this.makeFilterId();
            const cursor = await this.setInitialCursorPosition(id, filter.fromBlock);
            console.info(`Installing new log filter(${id}):`, filter, 'initial cursor position:', cursor);
            this.logFilters.set(id, filter);
            this.setFilterTimeout(id);
            return (0, util_1$3.hexStringFromIntNumber)(id);
        }
        async newBlockFilter() {
            const id = this.makeFilterId();
            const cursor = await this.setInitialCursorPosition(id, 'latest');
            console.info(`Installing new block filter (${id}) with initial cursor position:`, cursor);
            this.blockFilters.add(id);
            this.setFilterTimeout(id);
            return (0, util_1$3.hexStringFromIntNumber)(id);
        }
        async newPendingTransactionFilter() {
            const id = this.makeFilterId();
            const cursor = await this.setInitialCursorPosition(id, 'latest');
            console.info(`Installing new block filter (${id}) with initial cursor position:`, cursor);
            this.pendingTransactionFilters.add(id);
            this.setFilterTimeout(id);
            return (0, util_1$3.hexStringFromIntNumber)(id);
        }
        uninstallFilter(filterId) {
            const id = (0, util_1$3.intNumberFromHexString)(filterId);
            console.info(`Uninstalling filter (${id})`);
            this.deleteFilter(id);
            return true;
        }
        getFilterChanges(filterId) {
            const id = (0, util_1$3.intNumberFromHexString)(filterId);
            if (this.timeouts.has(id)) {
                // extend timeout
                this.setFilterTimeout(id);
            }
            if (this.logFilters.has(id)) {
                return this.getLogFilterChanges(id);
            }
            else if (this.blockFilters.has(id)) {
                return this.getBlockFilterChanges(id);
            }
            else if (this.pendingTransactionFilters.has(id)) {
                return this.getPendingTransactionFilterChanges(id);
            }
            return Promise.resolve(filterNotFoundError());
        }
        async getFilterLogs(filterId) {
            const id = (0, util_1$3.intNumberFromHexString)(filterId);
            const filter = this.logFilters.get(id);
            if (!filter) {
                return filterNotFoundError();
            }
            return this.sendAsyncPromise(Object.assign(Object.assign({}, JSONRPC_TEMPLATE), { method: 'eth_getLogs', params: [paramFromFilter(filter)] }));
        }
        makeFilterId() {
            return (0, type_1.IntNumber)(++this.nextFilterId);
        }
        sendAsyncPromise(request) {
            return new Promise((resolve, reject) => {
                this.provider.sendAsync(request, (err, response) => {
                    if (err) {
                        return reject(err);
                    }
                    if (Array.isArray(response) || response == null) {
                        return reject(new Error(`unexpected response received: ${JSON.stringify(response)}`));
                    }
                    resolve(response);
                });
            });
        }
        deleteFilter(id) {
            console.info(`Deleting filter (${id})`);
            this.logFilters.delete(id);
            this.blockFilters.delete(id);
            this.pendingTransactionFilters.delete(id);
            this.cursors.delete(id);
            this.timeouts.delete(id);
        }
        async getLogFilterChanges(id) {
            const filter = this.logFilters.get(id);
            const cursorPosition = this.cursors.get(id);
            if (!cursorPosition || !filter) {
                return filterNotFoundError();
            }
            const currentBlockHeight = await this.getCurrentBlockHeight();
            const toBlock = filter.toBlock === 'latest' ? currentBlockHeight : filter.toBlock;
            if (cursorPosition > currentBlockHeight) {
                return emptyResult();
            }
            if (cursorPosition > Number(filter.toBlock)) {
                return emptyResult();
            }
            console.info(`Fetching logs from ${cursorPosition} to ${toBlock} for filter ${id}`);
            const response = await this.sendAsyncPromise(Object.assign(Object.assign({}, JSONRPC_TEMPLATE), { method: 'eth_getLogs', params: [
                    paramFromFilter(Object.assign(Object.assign({}, filter), { fromBlock: cursorPosition, toBlock })),
                ] }));
            if (Array.isArray(response.result)) {
                const blocks = response.result.map((log) => (0, util_1$3.intNumberFromHexString)(log.blockNumber || '0x0'));
                const highestBlock = Math.max(...blocks);
                if (highestBlock && highestBlock > cursorPosition) {
                    const newCursorPosition = (0, type_1.IntNumber)(highestBlock + 1);
                    console.info(`Moving cursor position for filter (${id}) from ${cursorPosition} to ${newCursorPosition}`);
                    this.cursors.set(id, newCursorPosition);
                }
            }
            return response;
        }
        async getBlockFilterChanges(id) {
            const cursorPosition = this.cursors.get(id);
            if (!cursorPosition) {
                return filterNotFoundError();
            }
            const currentBlockHeight = await this.getCurrentBlockHeight();
            if (cursorPosition > currentBlockHeight) {
                return emptyResult();
            }
            console.info(`Fetching blocks from ${cursorPosition} to ${currentBlockHeight} for filter (${id})`);
            const blocks = (await Promise.all(
            // eslint-disable-next-line @typescript-eslint/restrict-plus-operands
            (0, util_1$3.range)(cursorPosition, currentBlockHeight + 1).map((i) => this.getBlockHashByNumber((0, type_1.IntNumber)(i))))).filter((hash) => !!hash);
            // eslint-disable-next-line @typescript-eslint/restrict-plus-operands
            const newCursorPosition = (0, type_1.IntNumber)(cursorPosition + blocks.length);
            console.info(`Moving cursor position for filter (${id}) from ${cursorPosition} to ${newCursorPosition}`);
            this.cursors.set(id, newCursorPosition);
            return Object.assign(Object.assign({}, JSONRPC_TEMPLATE), { result: blocks });
        }
        async getPendingTransactionFilterChanges(_id) {
            // pending transaction filters are not supported
            return Promise.resolve(emptyResult());
        }
        async setInitialCursorPosition(id, startBlock) {
            const currentBlockHeight = await this.getCurrentBlockHeight();
            const initialCursorPosition = typeof startBlock === 'number' && startBlock > currentBlockHeight
                ? startBlock
                : currentBlockHeight;
            this.cursors.set(id, initialCursorPosition);
            return initialCursorPosition;
        }
        setFilterTimeout(id) {
            const existing = this.timeouts.get(id);
            if (existing) {
                window.clearTimeout(existing);
            }
            const timeout = window.setTimeout(() => {
                console.info(`Filter (${id}) timed out`);
                this.deleteFilter(id);
            }, TIMEOUT);
            this.timeouts.set(id, timeout);
        }
        // throttle eth_blockNumber requests
        async getCurrentBlockHeight() {
            const now = new Date();
            if (now.getTime() - this.lastFetchTimestamp.getTime() > this.REQUEST_THROTTLE_INTERVAL) {
                this.lastFetchTimestamp = now;
                const height = await this._getCurrentBlockHeight();
                this.currentBlockHeight = height;
                this.resolvers.forEach((resolve) => resolve(height));
                this.resolvers = [];
            }
            if (!this.currentBlockHeight) {
                return new Promise((resolve) => this.resolvers.push(resolve));
            }
            return this.currentBlockHeight;
        }
        async _getCurrentBlockHeight() {
            const { result } = await this.sendAsyncPromise(Object.assign(Object.assign({}, JSONRPC_TEMPLATE), { method: 'eth_blockNumber', params: [] }));
            return (0, util_1$3.intNumberFromHexString)((0, util_1$3.ensureHexString)(result));
        }
        async getBlockHashByNumber(blockNumber) {
            const response = await this.sendAsyncPromise(Object.assign(Object.assign({}, JSONRPC_TEMPLATE), { method: 'eth_getBlockByNumber', params: [(0, util_1$3.hexStringFromIntNumber)(blockNumber), false] }));
            if (response.result && typeof response.result.hash === 'string') {
                return (0, util_1$3.ensureHexString)(response.result.hash);
            }
            return null;
        }
    }
    FilterPolyfill$1.FilterPolyfill = FilterPolyfill;
    function filterFromParam(param) {
        return {
            fromBlock: intBlockHeightFromHexBlockHeight(param.fromBlock),
            toBlock: intBlockHeightFromHexBlockHeight(param.toBlock),
            addresses: param.address === undefined
                ? null
                : Array.isArray(param.address)
                    ? param.address
                    : [param.address],
            topics: param.topics || [],
        };
    }
    FilterPolyfill$1.filterFromParam = filterFromParam;
    function paramFromFilter(filter) {
        const param = {
            fromBlock: hexBlockHeightFromIntBlockHeight(filter.fromBlock),
            toBlock: hexBlockHeightFromIntBlockHeight(filter.toBlock),
            topics: filter.topics,
        };
        if (filter.addresses !== null) {
            param.address = filter.addresses;
        }
        return param;
    }
    function intBlockHeightFromHexBlockHeight(value) {
        if (value === undefined || value === 'latest' || value === 'pending') {
            return 'latest';
        }
        else if (value === 'earliest') {
            return (0, type_1.IntNumber)(0);
        }
        else if ((0, util_1$3.isHexString)(value)) {
            return (0, util_1$3.intNumberFromHexString)(value);
        }
        throw new Error(`Invalid block option: ${String(value)}`);
    }
    function hexBlockHeightFromIntBlockHeight(value) {
        if (value === 'latest') {
            return value;
        }
        return (0, util_1$3.hexStringFromIntNumber)(value);
    }
    function filterNotFoundError() {
        return Object.assign(Object.assign({}, JSONRPC_TEMPLATE), { error: { code: -32000, message: 'filter not found' } });
    }
    function emptyResult() {
        return Object.assign(Object.assign({}, JSONRPC_TEMPLATE), { result: [] });
    }

    var SubscriptionManager$1 = {};

    var dist$4 = {};

    var PollingBlockTracker$1 = {};

    var jsonRpcRandomId = IdIterator;

    function IdIterator(opts){
      opts = opts || {};
      var max = opts.max || Number.MAX_SAFE_INTEGER;
      var idCounter = typeof opts.start !== 'undefined' ? opts.start : Math.floor(Math.random() * max);

      return function createRandomId () {
        idCounter = idCounter % max;
        return idCounter++
      }

    }

    const processFn$1 = (fn, opts) => function () {
    	const P = opts.promiseModule;
    	const args = new Array(arguments.length);

    	for (let i = 0; i < arguments.length; i++) {
    		args[i] = arguments[i];
    	}

    	return new P((resolve, reject) => {
    		if (opts.errorFirst) {
    			args.push(function (err, result) {
    				if (opts.multiArgs) {
    					const results = new Array(arguments.length - 1);

    					for (let i = 1; i < arguments.length; i++) {
    						results[i - 1] = arguments[i];
    					}

    					if (err) {
    						results.unshift(err);
    						reject(results);
    					} else {
    						resolve(results);
    					}
    				} else if (err) {
    					reject(err);
    				} else {
    					resolve(result);
    				}
    			});
    		} else {
    			args.push(function (result) {
    				if (opts.multiArgs) {
    					const results = new Array(arguments.length - 1);

    					for (let i = 0; i < arguments.length; i++) {
    						results[i] = arguments[i];
    					}

    					resolve(results);
    				} else {
    					resolve(result);
    				}
    			});
    		}

    		fn.apply(this, args);
    	});
    };

    var pify$2 = (obj, opts) => {
    	opts = Object.assign({
    		exclude: [/.+(Sync|Stream)$/],
    		errorFirst: true,
    		promiseModule: Promise
    	}, opts);

    	const filter = key => {
    		const match = pattern => typeof pattern === 'string' ? key === pattern : pattern.test(key);
    		return opts.include ? opts.include.some(match) : !opts.exclude.some(match);
    	};

    	let ret;
    	if (typeof obj === 'function') {
    		ret = function () {
    			if (opts.excludeMain) {
    				return obj.apply(this, arguments);
    			}

    			return processFn$1(obj, opts).apply(this, arguments);
    		};
    	} else {
    		ret = Object.create(Object.getPrototypeOf(obj));
    	}

    	for (const key in obj) { // eslint-disable-line guard-for-in
    		const x = obj[key];
    		ret[key] = typeof x === 'function' && filter(key) ? processFn$1(x, opts) : x;
    	}

    	return ret;
    };

    var BaseBlockTracker$1 = {};

    var cjs$1 = {};

    Object.defineProperty(cjs$1, "__esModule", { value: true });
    const events_1$2 = require$$0$3;
    function safeApply$2(handler, context, args) {
        try {
            Reflect.apply(handler, context, args);
        }
        catch (err) {
            // Throw error after timeout so as not to interrupt the stack
            setTimeout(() => {
                throw err;
            });
        }
    }
    function arrayClone$2(arr) {
        const n = arr.length;
        const copy = new Array(n);
        for (let i = 0; i < n; i += 1) {
            copy[i] = arr[i];
        }
        return copy;
    }
    let SafeEventEmitter$4 = class SafeEventEmitter extends events_1$2.EventEmitter {
        emit(type, ...args) {
            let doError = type === 'error';
            const events = this._events;
            if (events !== undefined) {
                doError = doError && events.error === undefined;
            }
            else if (!doError) {
                return false;
            }
            // If there is no 'error' event listener then throw.
            if (doError) {
                let er;
                if (args.length > 0) {
                    [er] = args;
                }
                if (er instanceof Error) {
                    // Note: The comments on the `throw` lines are intentional, they show
                    // up in Node's output if this results in an unhandled exception.
                    throw er; // Unhandled 'error' event
                }
                // At least give some kind of context to the user
                const err = new Error(`Unhandled error.${er ? ` (${er.message})` : ''}`);
                err.context = er;
                throw err; // Unhandled 'error' event
            }
            const handler = events[type];
            if (handler === undefined) {
                return false;
            }
            if (typeof handler === 'function') {
                safeApply$2(handler, this, args);
            }
            else {
                const len = handler.length;
                const listeners = arrayClone$2(handler);
                for (let i = 0; i < len; i += 1) {
                    safeApply$2(listeners[i], this, args);
                }
            }
            return true;
        }
    };
    cjs$1.default = SafeEventEmitter$4;

    var __importDefault$5 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };
    Object.defineProperty(BaseBlockTracker$1, "__esModule", { value: true });
    BaseBlockTracker$1.BaseBlockTracker = void 0;
    const safe_event_emitter_1$1 = __importDefault$5(cjs$1);
    const sec$1 = 1000;
    const calculateSum = (accumulator, currentValue) => accumulator + currentValue;
    const blockTrackerEvents = ['sync', 'latest'];
    class BaseBlockTracker extends safe_event_emitter_1$1.default {
        constructor(opts) {
            super();
            // config
            this._blockResetDuration = opts.blockResetDuration || 20 * sec$1;
            this._usePastBlocks = opts.usePastBlocks || false;
            // state
            this._currentBlock = null;
            this._isRunning = false;
            // bind functions for internal use
            this._onNewListener = this._onNewListener.bind(this);
            this._onRemoveListener = this._onRemoveListener.bind(this);
            this._resetCurrentBlock = this._resetCurrentBlock.bind(this);
            // listen for handler changes
            this._setupInternalEvents();
        }
        async destroy() {
            this._cancelBlockResetTimeout();
            await this._maybeEnd();
            super.removeAllListeners();
        }
        isRunning() {
            return this._isRunning;
        }
        getCurrentBlock() {
            return this._currentBlock;
        }
        async getLatestBlock() {
            // return if available
            if (this._currentBlock) {
                return this._currentBlock;
            }
            // wait for a new latest block
            const latestBlock = await new Promise((resolve) => this.once('latest', resolve));
            // return newly set current block
            return latestBlock;
        }
        // dont allow module consumer to remove our internal event listeners
        removeAllListeners(eventName) {
            // perform default behavior, preserve fn arity
            if (eventName) {
                super.removeAllListeners(eventName);
            }
            else {
                super.removeAllListeners();
            }
            // re-add internal events
            this._setupInternalEvents();
            // trigger stop check just in case
            this._onRemoveListener();
            return this;
        }
        _setupInternalEvents() {
            // first remove listeners for idempotence
            this.removeListener('newListener', this._onNewListener);
            this.removeListener('removeListener', this._onRemoveListener);
            // then add them
            this.on('newListener', this._onNewListener);
            this.on('removeListener', this._onRemoveListener);
        }
        _onNewListener(eventName) {
            // `newListener` is called *before* the listener is added
            if (blockTrackerEvents.includes(eventName)) {
                this._maybeStart();
            }
        }
        _onRemoveListener() {
            // `removeListener` is called *after* the listener is removed
            if (this._getBlockTrackerEventCount() > 0) {
                return;
            }
            this._maybeEnd();
        }
        async _maybeStart() {
            if (this._isRunning) {
                return;
            }
            this._isRunning = true;
            // cancel setting latest block to stale
            this._cancelBlockResetTimeout();
            await this._start();
            this.emit('_started');
        }
        async _maybeEnd() {
            if (!this._isRunning) {
                return;
            }
            this._isRunning = false;
            this._setupBlockResetTimeout();
            await this._end();
            this.emit('_ended');
        }
        _getBlockTrackerEventCount() {
            return blockTrackerEvents
                .map((eventName) => this.listenerCount(eventName))
                .reduce(calculateSum);
        }
        _shouldUseNewBlock(newBlock) {
            const currentBlock = this._currentBlock;
            if (!currentBlock) {
                return true;
            }
            const newBlockInt = hexToInt$4(newBlock);
            const currentBlockInt = hexToInt$4(currentBlock);
            return ((this._usePastBlocks && newBlockInt < currentBlockInt) ||
                newBlockInt > currentBlockInt);
        }
        _newPotentialLatest(newBlock) {
            if (!this._shouldUseNewBlock(newBlock)) {
                return;
            }
            this._setCurrentBlock(newBlock);
        }
        _setCurrentBlock(newBlock) {
            const oldBlock = this._currentBlock;
            this._currentBlock = newBlock;
            this.emit('latest', newBlock);
            this.emit('sync', { oldBlock, newBlock });
        }
        _setupBlockResetTimeout() {
            // clear any existing timeout
            this._cancelBlockResetTimeout();
            // clear latest block when stale
            this._blockResetTimeout = setTimeout(this._resetCurrentBlock, this._blockResetDuration);
            // nodejs - dont hold process open
            if (this._blockResetTimeout.unref) {
                this._blockResetTimeout.unref();
            }
        }
        _cancelBlockResetTimeout() {
            if (this._blockResetTimeout) {
                clearTimeout(this._blockResetTimeout);
            }
        }
        _resetCurrentBlock() {
            this._currentBlock = null;
        }
    }
    BaseBlockTracker$1.BaseBlockTracker = BaseBlockTracker;
    /**
     * Converts a number represented as a string in hexadecimal format into a native
     * number.
     *
     * @param hexInt - The hex string.
     * @returns The number.
     */
    function hexToInt$4(hexInt) {
        return Number.parseInt(hexInt, 16);
    }

    var loggingUtils = {};

    var dist$3 = {};

    var assert$2 = {};

    /**
     * A `StructFailure` represents a single specific failure in validation.
     */
    /**
     * `StructError` objects are thrown (or returned) when validation fails.
     *
     * Validation logic is design to exit early for maximum performance. The error
     * represents the first error encountered during validation. For more detail,
     * the `error.failures` property is a generator function that can be run to
     * continue validation and receive all the failures in the data.
     */
    class StructError extends TypeError {
        constructor(failure, failures) {
            let cached;
            const { message, explanation, ...rest } = failure;
            const { path } = failure;
            const msg = path.length === 0 ? message : `At path: ${path.join('.')} -- ${message}`;
            super(explanation ?? msg);
            if (explanation != null)
                this.cause = msg;
            Object.assign(this, rest);
            this.name = this.constructor.name;
            this.failures = () => {
                return (cached ?? (cached = [failure, ...failures()]));
            };
        }
    }

    /**
     * Check if a value is an iterator.
     */
    function isIterable(x) {
        return isObject(x) && typeof x[Symbol.iterator] === 'function';
    }
    /**
     * Check if a value is a plain object.
     */
    function isObject(x) {
        return typeof x === 'object' && x != null;
    }
    /**
     * Check if a value is a plain object.
     */
    function isPlainObject(x) {
        if (Object.prototype.toString.call(x) !== '[object Object]') {
            return false;
        }
        const prototype = Object.getPrototypeOf(x);
        return prototype === null || prototype === Object.prototype;
    }
    /**
     * Return a value as a printable string.
     */
    function print(value) {
        if (typeof value === 'symbol') {
            return value.toString();
        }
        return typeof value === 'string' ? JSON.stringify(value) : `${value}`;
    }
    /**
     * Shifts (removes and returns) the first value from the `input` iterator.
     * Like `Array.prototype.shift()` but for an `Iterator`.
     */
    function shiftIterator(input) {
        const { done, value } = input.next();
        return done ? undefined : value;
    }
    /**
     * Convert a single validation result to a failure.
     */
    function toFailure(result, context, struct, value) {
        if (result === true) {
            return;
        }
        else if (result === false) {
            result = {};
        }
        else if (typeof result === 'string') {
            result = { message: result };
        }
        const { path, branch } = context;
        const { type } = struct;
        const { refinement, message = `Expected a value of type \`${type}\`${refinement ? ` with refinement \`${refinement}\`` : ''}, but received: \`${print(value)}\``, } = result;
        return {
            value,
            type,
            refinement,
            key: path[path.length - 1],
            path,
            branch,
            ...result,
            message,
        };
    }
    /**
     * Convert a validation result to an iterable of failures.
     */
    function* toFailures(result, context, struct, value) {
        if (!isIterable(result)) {
            result = [result];
        }
        for (const r of result) {
            const failure = toFailure(r, context, struct, value);
            if (failure) {
                yield failure;
            }
        }
    }
    /**
     * Check a value against a struct, traversing deeply into nested values, and
     * returning an iterator of failures or success.
     */
    function* run(value, struct, options = {}) {
        const { path = [], branch = [value], coerce = false, mask = false } = options;
        const ctx = { path, branch };
        if (coerce) {
            value = struct.coercer(value, ctx);
            if (mask &&
                struct.type !== 'type' &&
                isObject(struct.schema) &&
                isObject(value) &&
                !Array.isArray(value)) {
                for (const key in value) {
                    if (struct.schema[key] === undefined) {
                        delete value[key];
                    }
                }
            }
        }
        let status = 'valid';
        for (const failure of struct.validator(value, ctx)) {
            failure.explanation = options.message;
            status = 'not_valid';
            yield [failure, undefined];
        }
        for (let [k, v, s] of struct.entries(value, ctx)) {
            const ts = run(v, s, {
                path: k === undefined ? path : [...path, k],
                branch: k === undefined ? branch : [...branch, v],
                coerce,
                mask,
                message: options.message,
            });
            for (const t of ts) {
                if (t[0]) {
                    status = t[0].refinement != null ? 'not_refined' : 'not_valid';
                    yield [t[0], undefined];
                }
                else if (coerce) {
                    v = t[1];
                    if (k === undefined) {
                        value = v;
                    }
                    else if (value instanceof Map) {
                        value.set(k, v);
                    }
                    else if (value instanceof Set) {
                        value.add(v);
                    }
                    else if (isObject(value)) {
                        if (v !== undefined || k in value)
                            value[k] = v;
                    }
                }
            }
        }
        if (status !== 'not_valid') {
            for (const failure of struct.refiner(value, ctx)) {
                failure.explanation = options.message;
                status = 'not_refined';
                yield [failure, undefined];
            }
        }
        if (status === 'valid') {
            yield [undefined, value];
        }
    }

    /**
     * `Struct` objects encapsulate the validation logic for a specific type of
     * values. Once constructed, you use the `assert`, `is` or `validate` helpers to
     * validate unknown input data against the struct.
     */
    class Struct {
        constructor(props) {
            const { type, schema, validator, refiner, coercer = (value) => value, entries = function* () { }, } = props;
            this.type = type;
            this.schema = schema;
            this.entries = entries;
            this.coercer = coercer;
            if (validator) {
                this.validator = (value, context) => {
                    const result = validator(value, context);
                    return toFailures(result, context, this, value);
                };
            }
            else {
                this.validator = () => [];
            }
            if (refiner) {
                this.refiner = (value, context) => {
                    const result = refiner(value, context);
                    return toFailures(result, context, this, value);
                };
            }
            else {
                this.refiner = () => [];
            }
        }
        /**
         * Assert that a value passes the struct's validation, throwing if it doesn't.
         */
        assert(value, message) {
            return assert$1(value, this, message);
        }
        /**
         * Create a value with the struct's coercion logic, then validate it.
         */
        create(value, message) {
            return create(value, this, message);
        }
        /**
         * Check if a value passes the struct's validation.
         */
        is(value) {
            return is(value, this);
        }
        /**
         * Mask a value, coercing and validating it, but returning only the subset of
         * properties defined by the struct's schema.
         */
        mask(value, message) {
            return mask(value, this, message);
        }
        /**
         * Validate a value with the struct's validation logic, returning a tuple
         * representing the result.
         *
         * You may optionally pass `true` for the `withCoercion` argument to coerce
         * the value before attempting to validate it. If you do, the result will
         * contain the coerced result when successful.
         */
        validate(value, options = {}) {
            return validate(value, this, options);
        }
    }
    /**
     * Assert that a value passes a struct, throwing if it doesn't.
     */
    function assert$1(value, struct, message) {
        const result = validate(value, struct, { message });
        if (result[0]) {
            throw result[0];
        }
    }
    /**
     * Create a value with the coercion logic of struct and validate it.
     */
    function create(value, struct, message) {
        const result = validate(value, struct, { coerce: true, message });
        if (result[0]) {
            throw result[0];
        }
        else {
            return result[1];
        }
    }
    /**
     * Mask a value, returning only the subset of properties defined by a struct.
     */
    function mask(value, struct, message) {
        const result = validate(value, struct, { coerce: true, mask: true, message });
        if (result[0]) {
            throw result[0];
        }
        else {
            return result[1];
        }
    }
    /**
     * Check if a value passes a struct.
     */
    function is(value, struct) {
        const result = validate(value, struct);
        return !result[0];
    }
    /**
     * Validate a value against a struct, returning an error if invalid, or the
     * value (with potential coercion) if valid.
     */
    function validate(value, struct, options = {}) {
        const tuples = run(value, struct, options);
        const tuple = shiftIterator(tuples);
        if (tuple[0]) {
            const error = new StructError(tuple[0], function* () {
                for (const t of tuples) {
                    if (t[0]) {
                        yield t[0];
                    }
                }
            });
            return [error, undefined];
        }
        else {
            const v = tuple[1];
            return [undefined, v];
        }
    }

    function assign(...Structs) {
        const isType = Structs[0].type === 'type';
        const schemas = Structs.map((s) => s.schema);
        const schema = Object.assign({}, ...schemas);
        return isType ? type(schema) : object(schema);
    }
    /**
     * Define a new struct type with a custom validation function.
     */
    function define(name, validator) {
        return new Struct({ type: name, schema: null, validator });
    }
    /**
     * Create a new struct based on an existing struct, but the value is allowed to
     * be `undefined`. `log` will be called if the value is not `undefined`.
     */
    function deprecated(struct, log) {
        return new Struct({
            ...struct,
            refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx),
            validator(value, ctx) {
                if (value === undefined) {
                    return true;
                }
                else {
                    log(value, ctx);
                    return struct.validator(value, ctx);
                }
            },
        });
    }
    /**
     * Create a struct with dynamic validation logic.
     *
     * The callback will receive the value currently being validated, and must
     * return a struct object to validate it with. This can be useful to model
     * validation logic that changes based on its input.
     */
    function dynamic(fn) {
        return new Struct({
            type: 'dynamic',
            schema: null,
            *entries(value, ctx) {
                const struct = fn(value, ctx);
                yield* struct.entries(value, ctx);
            },
            validator(value, ctx) {
                const struct = fn(value, ctx);
                return struct.validator(value, ctx);
            },
            coercer(value, ctx) {
                const struct = fn(value, ctx);
                return struct.coercer(value, ctx);
            },
            refiner(value, ctx) {
                const struct = fn(value, ctx);
                return struct.refiner(value, ctx);
            },
        });
    }
    /**
     * Create a struct with lazily evaluated validation logic.
     *
     * The first time validation is run with the struct, the callback will be called
     * and must return a struct object to use. This is useful for cases where you
     * want to have self-referential structs for nested data structures to avoid a
     * circular definition problem.
     */
    function lazy(fn) {
        let struct;
        return new Struct({
            type: 'lazy',
            schema: null,
            *entries(value, ctx) {
                struct ?? (struct = fn());
                yield* struct.entries(value, ctx);
            },
            validator(value, ctx) {
                struct ?? (struct = fn());
                return struct.validator(value, ctx);
            },
            coercer(value, ctx) {
                struct ?? (struct = fn());
                return struct.coercer(value, ctx);
            },
            refiner(value, ctx) {
                struct ?? (struct = fn());
                return struct.refiner(value, ctx);
            },
        });
    }
    /**
     * Create a new struct based on an existing object struct, but excluding
     * specific properties.
     *
     * Like TypeScript's `Omit` utility.
     */
    function omit(struct, keys) {
        const { schema } = struct;
        const subschema = { ...schema };
        for (const key of keys) {
            delete subschema[key];
        }
        switch (struct.type) {
            case 'type':
                return type(subschema);
            default:
                return object(subschema);
        }
    }
    /**
     * Create a new struct based on an existing object struct, but with all of its
     * properties allowed to be `undefined`.
     *
     * Like TypeScript's `Partial` utility.
     */
    function partial(struct) {
        const isStruct = struct instanceof Struct;
        const schema = isStruct ? { ...struct.schema } : { ...struct };
        for (const key in schema) {
            schema[key] = optional(schema[key]);
        }
        if (isStruct && struct.type === 'type') {
            return type(schema);
        }
        return object(schema);
    }
    /**
     * Create a new struct based on an existing object struct, but only including
     * specific properties.
     *
     * Like TypeScript's `Pick` utility.
     */
    function pick(struct, keys) {
        const { schema } = struct;
        const subschema = {};
        for (const key of keys) {
            subschema[key] = schema[key];
        }
        switch (struct.type) {
            case 'type':
                return type(subschema);
            default:
                return object(subschema);
        }
    }
    /**
     * Define a new struct type with a custom validation function.
     *
     * @deprecated This function has been renamed to `define`.
     */
    function struct(name, validator) {
        console.warn('superstruct@0.11 - The `struct` helper has been renamed to `define`.');
        return define(name, validator);
    }

    /**
     * Ensure that any value passes validation.
     */
    function any() {
        return define('any', () => true);
    }
    function array(Element) {
        return new Struct({
            type: 'array',
            schema: Element,
            *entries(value) {
                if (Element && Array.isArray(value)) {
                    for (const [i, v] of value.entries()) {
                        yield [i, v, Element];
                    }
                }
            },
            coercer(value) {
                return Array.isArray(value) ? value.slice() : value;
            },
            validator(value) {
                return (Array.isArray(value) ||
                    `Expected an array value, but received: ${print(value)}`);
            },
        });
    }
    /**
     * Ensure that a value is a bigint.
     */
    function bigint() {
        return define('bigint', (value) => {
            return typeof value === 'bigint';
        });
    }
    /**
     * Ensure that a value is a boolean.
     */
    function boolean() {
        return define('boolean', (value) => {
            return typeof value === 'boolean';
        });
    }
    /**
     * Ensure that a value is a valid `Date`.
     *
     * Note: this also ensures that the value is *not* an invalid `Date` object,
     * which can occur when parsing a date fails but still returns a `Date`.
     */
    function date() {
        return define('date', (value) => {
            return ((value instanceof Date && !isNaN(value.getTime())) ||
                `Expected a valid \`Date\` object, but received: ${print(value)}`);
        });
    }
    function enums(values) {
        const schema = {};
        const description = values.map((v) => print(v)).join();
        for (const key of values) {
            schema[key] = key;
        }
        return new Struct({
            type: 'enums',
            schema,
            validator(value) {
                return (values.includes(value) ||
                    `Expected one of \`${description}\`, but received: ${print(value)}`);
            },
        });
    }
    /**
     * Ensure that a value is a function.
     */
    function func() {
        return define('func', (value) => {
            return (typeof value === 'function' ||
                `Expected a function, but received: ${print(value)}`);
        });
    }
    /**
     * Ensure that a value is an instance of a specific class.
     */
    function instance(Class) {
        return define('instance', (value) => {
            return (value instanceof Class ||
                `Expected a \`${Class.name}\` instance, but received: ${print(value)}`);
        });
    }
    /**
     * Ensure that a value is an integer.
     */
    function integer() {
        return define('integer', (value) => {
            return ((typeof value === 'number' && !isNaN(value) && Number.isInteger(value)) ||
                `Expected an integer, but received: ${print(value)}`);
        });
    }
    /**
     * Ensure that a value matches all of a set of types.
     */
    function intersection(Structs) {
        return new Struct({
            type: 'intersection',
            schema: null,
            *entries(value, ctx) {
                for (const S of Structs) {
                    yield* S.entries(value, ctx);
                }
            },
            *validator(value, ctx) {
                for (const S of Structs) {
                    yield* S.validator(value, ctx);
                }
            },
            *refiner(value, ctx) {
                for (const S of Structs) {
                    yield* S.refiner(value, ctx);
                }
            },
        });
    }
    function literal(constant) {
        const description = print(constant);
        const t = typeof constant;
        return new Struct({
            type: 'literal',
            schema: t === 'string' || t === 'number' || t === 'boolean' ? constant : null,
            validator(value) {
                return (value === constant ||
                    `Expected the literal \`${description}\`, but received: ${print(value)}`);
            },
        });
    }
    function map(Key, Value) {
        return new Struct({
            type: 'map',
            schema: null,
            *entries(value) {
                if (Key && Value && value instanceof Map) {
                    for (const [k, v] of value.entries()) {
                        yield [k, k, Key];
                        yield [k, v, Value];
                    }
                }
            },
            coercer(value) {
                return value instanceof Map ? new Map(value) : value;
            },
            validator(value) {
                return (value instanceof Map ||
                    `Expected a \`Map\` object, but received: ${print(value)}`);
            },
        });
    }
    /**
     * Ensure that no value ever passes validation.
     */
    function never() {
        return define('never', () => false);
    }
    /**
     * Augment an existing struct to allow `null` values.
     */
    function nullable(struct) {
        return new Struct({
            ...struct,
            validator: (value, ctx) => value === null || struct.validator(value, ctx),
            refiner: (value, ctx) => value === null || struct.refiner(value, ctx),
        });
    }
    /**
     * Ensure that a value is a number.
     */
    function number$1() {
        return define('number', (value) => {
            return ((typeof value === 'number' && !isNaN(value)) ||
                `Expected a number, but received: ${print(value)}`);
        });
    }
    function object(schema) {
        const knowns = schema ? Object.keys(schema) : [];
        const Never = never();
        return new Struct({
            type: 'object',
            schema: schema ? schema : null,
            *entries(value) {
                if (schema && isObject(value)) {
                    const unknowns = new Set(Object.keys(value));
                    for (const key of knowns) {
                        unknowns.delete(key);
                        yield [key, value[key], schema[key]];
                    }
                    for (const key of unknowns) {
                        yield [key, value[key], Never];
                    }
                }
            },
            validator(value) {
                return (isObject(value) || `Expected an object, but received: ${print(value)}`);
            },
            coercer(value) {
                return isObject(value) ? { ...value } : value;
            },
        });
    }
    /**
     * Augment a struct to allow `undefined` values.
     */
    function optional(struct) {
        return new Struct({
            ...struct,
            validator: (value, ctx) => value === undefined || struct.validator(value, ctx),
            refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx),
        });
    }
    /**
     * Ensure that a value is an object with keys and values of specific types, but
     * without ensuring any specific shape of properties.
     *
     * Like TypeScript's `Record` utility.
     */
    function record(Key, Value) {
        return new Struct({
            type: 'record',
            schema: null,
            *entries(value) {
                if (isObject(value)) {
                    for (const k in value) {
                        const v = value[k];
                        yield [k, k, Key];
                        yield [k, v, Value];
                    }
                }
            },
            validator(value) {
                return (isObject(value) || `Expected an object, but received: ${print(value)}`);
            },
        });
    }
    /**
     * Ensure that a value is a `RegExp`.
     *
     * Note: this does not test the value against the regular expression! For that
     * you need to use the `pattern()` refinement.
     */
    function regexp() {
        return define('regexp', (value) => {
            return value instanceof RegExp;
        });
    }
    function set(Element) {
        return new Struct({
            type: 'set',
            schema: null,
            *entries(value) {
                if (Element && value instanceof Set) {
                    for (const v of value) {
                        yield [v, v, Element];
                    }
                }
            },
            coercer(value) {
                return value instanceof Set ? new Set(value) : value;
            },
            validator(value) {
                return (value instanceof Set ||
                    `Expected a \`Set\` object, but received: ${print(value)}`);
            },
        });
    }
    /**
     * Ensure that a value is a string.
     */
    function string() {
        return define('string', (value) => {
            return (typeof value === 'string' ||
                `Expected a string, but received: ${print(value)}`);
        });
    }
    /**
     * Ensure that a value is a tuple of a specific length, and that each of its
     * elements is of a specific type.
     */
    function tuple(Structs) {
        const Never = never();
        return new Struct({
            type: 'tuple',
            schema: null,
            *entries(value) {
                if (Array.isArray(value)) {
                    const length = Math.max(Structs.length, value.length);
                    for (let i = 0; i < length; i++) {
                        yield [i, value[i], Structs[i] || Never];
                    }
                }
            },
            validator(value) {
                return (Array.isArray(value) ||
                    `Expected an array, but received: ${print(value)}`);
            },
        });
    }
    /**
     * Ensure that a value has a set of known properties of specific types.
     *
     * Note: Unrecognized properties are allowed and untouched. This is similar to
     * how TypeScript's structural typing works.
     */
    function type(schema) {
        const keys = Object.keys(schema);
        return new Struct({
            type: 'type',
            schema,
            *entries(value) {
                if (isObject(value)) {
                    for (const k of keys) {
                        yield [k, value[k], schema[k]];
                    }
                }
            },
            validator(value) {
                return (isObject(value) || `Expected an object, but received: ${print(value)}`);
            },
            coercer(value) {
                return isObject(value) ? { ...value } : value;
            },
        });
    }
    /**
     * Ensure that a value matches one of a set of types.
     */
    function union(Structs) {
        const description = Structs.map((s) => s.type).join(' | ');
        return new Struct({
            type: 'union',
            schema: null,
            coercer(value) {
                for (const S of Structs) {
                    const [error, coerced] = S.validate(value, { coerce: true });
                    if (!error) {
                        return coerced;
                    }
                }
                return value;
            },
            validator(value, ctx) {
                const failures = [];
                for (const S of Structs) {
                    const [...tuples] = run(value, S, ctx);
                    const [first] = tuples;
                    if (!first[0]) {
                        return [];
                    }
                    else {
                        for (const [failure] of tuples) {
                            if (failure) {
                                failures.push(failure);
                            }
                        }
                    }
                }
                return [
                    `Expected the value to satisfy a union of \`${description}\`, but received: ${print(value)}`,
                    ...failures,
                ];
            },
        });
    }
    /**
     * Ensure that any value passes validation, without widening its type to `any`.
     */
    function unknown() {
        return define('unknown', () => true);
    }

    /**
     * Augment a `Struct` to add an additional coercion step to its input.
     *
     * This allows you to transform input data before validating it, to increase the
     * likelihood that it passes validation—for example for default values, parsing
     * different formats, etc.
     *
     * Note: You must use `create(value, Struct)` on the value to have the coercion
     * take effect! Using simply `assert()` or `is()` will not use coercion.
     */
    function coerce$2(struct, condition, coercer) {
        return new Struct({
            ...struct,
            coercer: (value, ctx) => {
                return is(value, condition)
                    ? struct.coercer(coercer(value, ctx), ctx)
                    : struct.coercer(value, ctx);
            },
        });
    }
    /**
     * Augment a struct to replace `undefined` values with a default.
     *
     * Note: You must use `create(value, Struct)` on the value to have the coercion
     * take effect! Using simply `assert()` or `is()` will not use coercion.
     */
    function defaulted(struct, fallback, options = {}) {
        return coerce$2(struct, unknown(), (x) => {
            const f = typeof fallback === 'function' ? fallback() : fallback;
            if (x === undefined) {
                return f;
            }
            if (!options.strict && isPlainObject(x) && isPlainObject(f)) {
                const ret = { ...x };
                let changed = false;
                for (const key in f) {
                    if (ret[key] === undefined) {
                        ret[key] = f[key];
                        changed = true;
                    }
                }
                if (changed) {
                    return ret;
                }
            }
            return x;
        });
    }
    /**
     * Augment a struct to trim string inputs.
     *
     * Note: You must use `create(value, Struct)` on the value to have the coercion
     * take effect! Using simply `assert()` or `is()` will not use coercion.
     */
    function trimmed(struct) {
        return coerce$2(struct, string(), (x) => x.trim());
    }

    /**
     * Ensure that a string, array, map, or set is empty.
     */
    function empty(struct) {
        return refine(struct, 'empty', (value) => {
            const size = getSize(value);
            return (size === 0 ||
                `Expected an empty ${struct.type} but received one with a size of \`${size}\``);
        });
    }
    function getSize(value) {
        if (value instanceof Map || value instanceof Set) {
            return value.size;
        }
        else {
            return value.length;
        }
    }
    /**
     * Ensure that a number or date is below a threshold.
     */
    function max(struct, threshold, options = {}) {
        const { exclusive } = options;
        return refine(struct, 'max', (value) => {
            return exclusive
                ? value < threshold
                : value <= threshold ||
                    `Expected a ${struct.type} less than ${exclusive ? '' : 'or equal to '}${threshold} but received \`${value}\``;
        });
    }
    /**
     * Ensure that a number or date is above a threshold.
     */
    function min(struct, threshold, options = {}) {
        const { exclusive } = options;
        return refine(struct, 'min', (value) => {
            return exclusive
                ? value > threshold
                : value >= threshold ||
                    `Expected a ${struct.type} greater than ${exclusive ? '' : 'or equal to '}${threshold} but received \`${value}\``;
        });
    }
    /**
     * Ensure that a string, array, map or set is not empty.
     */
    function nonempty(struct) {
        return refine(struct, 'nonempty', (value) => {
            const size = getSize(value);
            return (size > 0 || `Expected a nonempty ${struct.type} but received an empty one`);
        });
    }
    /**
     * Ensure that a string matches a regular expression.
     */
    function pattern(struct, regexp) {
        return refine(struct, 'pattern', (value) => {
            return (regexp.test(value) ||
                `Expected a ${struct.type} matching \`/${regexp.source}/\` but received "${value}"`);
        });
    }
    /**
     * Ensure that a string, array, number, date, map, or set has a size (or length, or time) between `min` and `max`.
     */
    function size(struct, min, max = min) {
        const expected = `Expected a ${struct.type}`;
        const of = min === max ? `of \`${min}\`` : `between \`${min}\` and \`${max}\``;
        return refine(struct, 'size', (value) => {
            if (typeof value === 'number' || value instanceof Date) {
                return ((min <= value && value <= max) ||
                    `${expected} ${of} but received \`${value}\``);
            }
            else if (value instanceof Map || value instanceof Set) {
                const { size } = value;
                return ((min <= size && size <= max) ||
                    `${expected} with a size ${of} but received one with a size of \`${size}\``);
            }
            else {
                const { length } = value;
                return ((min <= length && length <= max) ||
                    `${expected} with a length ${of} but received one with a length of \`${length}\``);
            }
        });
    }
    /**
     * Augment a `Struct` to add an additional refinement to the validation.
     *
     * The refiner function is guaranteed to receive a value of the struct's type,
     * because the struct's existing validation will already have passed. This
     * allows you to layer additional validation on top of existing structs.
     */
    function refine(struct, name, refiner) {
        return new Struct({
            ...struct,
            *refiner(value, ctx) {
                yield* struct.refiner(value, ctx);
                const result = refiner(value, ctx);
                const failures = toFailures(result, ctx, struct, value);
                for (const failure of failures) {
                    yield { ...failure, refinement: name };
                }
            },
        });
    }

    var dist$2 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        Struct: Struct,
        StructError: StructError,
        any: any,
        array: array,
        assert: assert$1,
        assign: assign,
        bigint: bigint,
        boolean: boolean,
        coerce: coerce$2,
        create: create,
        date: date,
        defaulted: defaulted,
        define: define,
        deprecated: deprecated,
        dynamic: dynamic,
        empty: empty,
        enums: enums,
        func: func,
        instance: instance,
        integer: integer,
        intersection: intersection,
        is: is,
        lazy: lazy,
        literal: literal,
        map: map,
        mask: mask,
        max: max,
        min: min,
        never: never,
        nonempty: nonempty,
        nullable: nullable,
        number: number$1,
        object: object,
        omit: omit,
        optional: optional,
        partial: partial,
        pattern: pattern,
        pick: pick,
        record: record,
        refine: refine,
        regexp: regexp,
        set: set,
        size: size,
        string: string,
        struct: struct,
        trimmed: trimmed,
        tuple: tuple,
        type: type,
        union: union,
        unknown: unknown,
        validate: validate
    });

    var require$$1 = /*@__PURE__*/getAugmentedNamespace(dist$2);

    Object.defineProperty(assert$2, "__esModule", { value: true });
    assert$2.assertExhaustive = assert$2.assertStruct = assert$2.assert = assert$2.AssertionError = void 0;
    const superstruct_1$3 = require$$1;
    /**
     * Type guard for determining whether the given value is an error object with a
     * `message` property, such as an instance of Error.
     *
     * @param error - The object to check.
     * @returns True or false, depending on the result.
     */
    function isErrorWithMessage(error) {
        return typeof error === 'object' && error !== null && 'message' in error;
    }
    /**
     * Check if a value is a constructor, i.e., a function that can be called with
     * the `new` keyword.
     *
     * @param fn - The value to check.
     * @returns `true` if the value is a constructor, or `false` otherwise.
     */
    function isConstructable(fn) {
        var _a, _b;
        /* istanbul ignore next */
        return Boolean(typeof ((_b = (_a = fn === null || fn === void 0 ? void 0 : fn.prototype) === null || _a === void 0 ? void 0 : _a.constructor) === null || _b === void 0 ? void 0 : _b.name) === 'string');
    }
    /**
     * Get the error message from an unknown error object. If the error object has
     * a `message` property, that property is returned. Otherwise, the stringified
     * error object is returned.
     *
     * @param error - The error object to get the message from.
     * @returns The error message.
     */
    function getErrorMessage(error) {
        const message = isErrorWithMessage(error) ? error.message : String(error);
        // If the error ends with a period, remove it, as we'll add our own period.
        if (message.endsWith('.')) {
            return message.slice(0, -1);
        }
        return message;
    }
    /**
     * Initialise an {@link AssertionErrorConstructor} error.
     *
     * @param ErrorWrapper - The error class to use.
     * @param message - The error message.
     * @returns The error object.
     */
    // eslint-disable-next-line @typescript-eslint/naming-convention
    function getError(ErrorWrapper, message) {
        if (isConstructable(ErrorWrapper)) {
            return new ErrorWrapper({
                message,
            });
        }
        return ErrorWrapper({
            message,
        });
    }
    /**
     * The default error class that is thrown if an assertion fails.
     */
    class AssertionError extends Error {
        constructor(options) {
            super(options.message);
            this.code = 'ERR_ASSERTION';
        }
    }
    assert$2.AssertionError = AssertionError;
    /**
     * Same as Node.js assert.
     * If the value is falsy, throws an error, does nothing otherwise.
     *
     * @throws {@link AssertionError} If value is falsy.
     * @param value - The test that should be truthy to pass.
     * @param message - Message to be passed to {@link AssertionError} or an
     * {@link Error} instance to throw.
     * @param ErrorWrapper - The error class to throw if the assertion fails.
     * Defaults to {@link AssertionError}. If a custom error class is provided for
     * the `message` argument, this argument is ignored.
     */
    function assert(value, message = 'Assertion failed.', 
    // eslint-disable-next-line @typescript-eslint/naming-convention
    ErrorWrapper = AssertionError) {
        if (!value) {
            if (message instanceof Error) {
                throw message;
            }
            throw getError(ErrorWrapper, message);
        }
    }
    assert$2.assert = assert;
    /**
     * Assert a value against a Superstruct struct.
     *
     * @param value - The value to validate.
     * @param struct - The struct to validate against.
     * @param errorPrefix - A prefix to add to the error message. Defaults to
     * "Assertion failed".
     * @param ErrorWrapper - The error class to throw if the assertion fails.
     * Defaults to {@link AssertionError}.
     * @throws If the value is not valid.
     */
    function assertStruct(value, struct, errorPrefix = 'Assertion failed', 
    // eslint-disable-next-line @typescript-eslint/naming-convention
    ErrorWrapper = AssertionError) {
        try {
            (0, superstruct_1$3.assert)(value, struct);
        }
        catch (error) {
            throw getError(ErrorWrapper, `${errorPrefix}: ${getErrorMessage(error)}.`);
        }
    }
    assert$2.assertStruct = assertStruct;
    /**
     * Use in the default case of a switch that you want to be fully exhaustive.
     * Using this function forces the compiler to enforce exhaustivity during
     * compile-time.
     *
     * @example
     * ```
     * const number = 1;
     * switch (number) {
     *   case 0:
     *     ...
     *   case 1:
     *     ...
     *   default:
     *     assertExhaustive(snapPrefix);
     * }
     * ```
     * @param _object - The object on which the switch is being operated.
     */
    function assertExhaustive(_object) {
        throw new Error('Invalid branch reached. Should be detected during compilation.');
    }
    assert$2.assertExhaustive = assertExhaustive;

    var base64$1 = {};

    Object.defineProperty(base64$1, "__esModule", { value: true });
    base64$1.base64 = void 0;
    const superstruct_1$2 = require$$1;
    const assert_1$3 = assert$2;
    /**
     * Ensure that a provided string-based struct is valid base64.
     *
     * @param struct - The string based struct.
     * @param options - Optional options to specialize base64 validation. See {@link Base64Options} documentation.
     * @returns A superstruct validating base64.
     */
    const base64 = (struct, options = {}) => {
        var _a, _b;
        const paddingRequired = (_a = options.paddingRequired) !== null && _a !== void 0 ? _a : false;
        const characterSet = (_b = options.characterSet) !== null && _b !== void 0 ? _b : 'base64';
        let letters;
        if (characterSet === 'base64') {
            letters = String.raw `[A-Za-z0-9+\/]`;
        }
        else {
            (0, assert_1$3.assert)(characterSet === 'base64url');
            letters = String.raw `[-_A-Za-z0-9]`;
        }
        let re;
        if (paddingRequired) {
            re = new RegExp(`^(?:${letters}{4})*(?:${letters}{3}=|${letters}{2}==)?$`, 'u');
        }
        else {
            re = new RegExp(`^(?:${letters}{4})*(?:${letters}{2,3}|${letters}{3}=|${letters}{2}==)?$`, 'u');
        }
        return (0, superstruct_1$2.pattern)(struct, re);
    };
    base64$1.base64 = base64;

    var bytes = {};

    var hex = {};

    (function (exports) {
    	Object.defineProperty(exports, "__esModule", { value: true });
    	exports.remove0x = exports.add0x = exports.assertIsStrictHexString = exports.assertIsHexString = exports.isStrictHexString = exports.isHexString = exports.StrictHexStruct = exports.HexStruct = void 0;
    	const superstruct_1 = require$$1;
    	const assert_1 = assert$2;
    	exports.HexStruct = (0, superstruct_1.pattern)((0, superstruct_1.string)(), /^(?:0x)?[0-9a-f]+$/iu);
    	exports.StrictHexStruct = (0, superstruct_1.pattern)((0, superstruct_1.string)(), /^0x[0-9a-f]+$/iu);
    	/**
    	 * Check if a string is a valid hex string.
    	 *
    	 * @param value - The value to check.
    	 * @returns Whether the value is a valid hex string.
    	 */
    	function isHexString(value) {
    	    return (0, superstruct_1.is)(value, exports.HexStruct);
    	}
    	exports.isHexString = isHexString;
    	/**
    	 * Strictly check if a string is a valid hex string. A valid hex string must
    	 * start with the "0x"-prefix.
    	 *
    	 * @param value - The value to check.
    	 * @returns Whether the value is a valid hex string.
    	 */
    	function isStrictHexString(value) {
    	    return (0, superstruct_1.is)(value, exports.StrictHexStruct);
    	}
    	exports.isStrictHexString = isStrictHexString;
    	/**
    	 * Assert that a value is a valid hex string.
    	 *
    	 * @param value - The value to check.
    	 * @throws If the value is not a valid hex string.
    	 */
    	function assertIsHexString(value) {
    	    (0, assert_1.assert)(isHexString(value), 'Value must be a hexadecimal string.');
    	}
    	exports.assertIsHexString = assertIsHexString;
    	/**
    	 * Assert that a value is a valid hex string. A valid hex string must start with
    	 * the "0x"-prefix.
    	 *
    	 * @param value - The value to check.
    	 * @throws If the value is not a valid hex string.
    	 */
    	function assertIsStrictHexString(value) {
    	    (0, assert_1.assert)(isStrictHexString(value), 'Value must be a hexadecimal string, starting with "0x".');
    	}
    	exports.assertIsStrictHexString = assertIsStrictHexString;
    	/**
    	 * Add the `0x`-prefix to a hexadecimal string. If the string already has the
    	 * prefix, it is returned as-is.
    	 *
    	 * @param hexadecimal - The hexadecimal string to add the prefix to.
    	 * @returns The prefixed hexadecimal string.
    	 */
    	function add0x(hexadecimal) {
    	    if (hexadecimal.startsWith('0x')) {
    	        return hexadecimal;
    	    }
    	    if (hexadecimal.startsWith('0X')) {
    	        return `0x${hexadecimal.substring(2)}`;
    	    }
    	    return `0x${hexadecimal}`;
    	}
    	exports.add0x = add0x;
    	/**
    	 * Remove the `0x`-prefix from a hexadecimal string. If the string doesn't have
    	 * the prefix, it is returned as-is.
    	 *
    	 * @param hexadecimal - The hexadecimal string to remove the prefix from.
    	 * @returns The un-prefixed hexadecimal string.
    	 */
    	function remove0x(hexadecimal) {
    	    if (hexadecimal.startsWith('0x') || hexadecimal.startsWith('0X')) {
    	        return hexadecimal.substring(2);
    	    }
    	    return hexadecimal;
    	}
    	exports.remove0x = remove0x;
    	
    } (hex));

    Object.defineProperty(bytes, "__esModule", { value: true });
    bytes.createDataView = bytes.concatBytes = bytes.valueToBytes = bytes.stringToBytes = bytes.numberToBytes = bytes.signedBigIntToBytes = bytes.bigIntToBytes = bytes.hexToBytes = bytes.bytesToString = bytes.bytesToNumber = bytes.bytesToSignedBigInt = bytes.bytesToBigInt = bytes.bytesToHex = bytes.assertIsBytes = bytes.isBytes = void 0;
    const assert_1$2 = assert$2;
    const hex_1$2 = hex;
    // '0'.charCodeAt(0) === 48
    const HEX_MINIMUM_NUMBER_CHARACTER = 48;
    // '9'.charCodeAt(0) === 57
    const HEX_MAXIMUM_NUMBER_CHARACTER = 58;
    const HEX_CHARACTER_OFFSET = 87;
    /**
     * Memoized function that returns an array to be used as a lookup table for
     * converting bytes to hexadecimal values.
     *
     * The array is created lazily and then cached for future use. The benefit of
     * this approach is that the performance of converting bytes to hex is much
     * better than if we were to call `toString(16)` on each byte.
     *
     * The downside is that the array is created once and then never garbage
     * collected. This is not a problem in practice because the array is only 256
     * elements long.
     *
     * @returns A function that returns the lookup table.
     */
    function getPrecomputedHexValuesBuilder() {
        // To avoid issues with tree shaking, we need to use a function to return the
        // array. This is because the array is only used in the `bytesToHex` function
        // and if we were to use a global variable, the array might be removed by the
        // tree shaker.
        const lookupTable = [];
        return () => {
            if (lookupTable.length === 0) {
                for (let i = 0; i < 256; i++) {
                    lookupTable.push(i.toString(16).padStart(2, '0'));
                }
            }
            return lookupTable;
        };
    }
    /**
     * Function implementation of the {@link getPrecomputedHexValuesBuilder}
     * function.
     */
    const getPrecomputedHexValues = getPrecomputedHexValuesBuilder();
    /**
     * Check if a value is a `Uint8Array`.
     *
     * @param value - The value to check.
     * @returns Whether the value is a `Uint8Array`.
     */
    function isBytes(value) {
        return value instanceof Uint8Array;
    }
    bytes.isBytes = isBytes;
    /**
     * Assert that a value is a `Uint8Array`.
     *
     * @param value - The value to check.
     * @throws If the value is not a `Uint8Array`.
     */
    function assertIsBytes(value) {
        (0, assert_1$2.assert)(isBytes(value), 'Value must be a Uint8Array.');
    }
    bytes.assertIsBytes = assertIsBytes;
    /**
     * Convert a `Uint8Array` to a hexadecimal string.
     *
     * @param bytes - The bytes to convert to a hexadecimal string.
     * @returns The hexadecimal string.
     */
    function bytesToHex(bytes) {
        assertIsBytes(bytes);
        if (bytes.length === 0) {
            return '0x';
        }
        const lookupTable = getPrecomputedHexValues();
        const hexadecimal = new Array(bytes.length);
        for (let i = 0; i < bytes.length; i++) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            hexadecimal[i] = lookupTable[bytes[i]];
        }
        return (0, hex_1$2.add0x)(hexadecimal.join(''));
    }
    bytes.bytesToHex = bytesToHex;
    /**
     * Convert a `Uint8Array` to a `bigint`.
     *
     * To convert a `Uint8Array` to a `number` instead, use {@link bytesToNumber}.
     * To convert a two's complement encoded `Uint8Array` to a `bigint`, use
     * {@link bytesToSignedBigInt}.
     *
     * @param bytes - The bytes to convert to a `bigint`.
     * @returns The `bigint`.
     */
    function bytesToBigInt(bytes) {
        assertIsBytes(bytes);
        const hexadecimal = bytesToHex(bytes);
        return BigInt(hexadecimal);
    }
    bytes.bytesToBigInt = bytesToBigInt;
    /**
     * Convert a `Uint8Array` to a signed `bigint`. This assumes that the bytes are
     * encoded in two's complement.
     *
     * To convert a `Uint8Array` to an unsigned `bigint` instead, use
     * {@link bytesToBigInt}.
     *
     * @see https://en.wikipedia.org/wiki/Two%27s_complement
     * @param bytes - The bytes to convert to a signed `bigint`.
     * @returns The signed `bigint`.
     */
    function bytesToSignedBigInt(bytes) {
        assertIsBytes(bytes);
        let value = BigInt(0);
        for (const byte of bytes) {
            // eslint-disable-next-line no-bitwise
            value = (value << BigInt(8)) + BigInt(byte);
        }
        return BigInt.asIntN(bytes.length * 8, value);
    }
    bytes.bytesToSignedBigInt = bytesToSignedBigInt;
    /**
     * Convert a `Uint8Array` to a `number`.
     *
     * To convert a `Uint8Array` to a `bigint` instead, use {@link bytesToBigInt}.
     *
     * @param bytes - The bytes to convert to a number.
     * @returns The number.
     * @throws If the resulting number is not a safe integer.
     */
    function bytesToNumber(bytes) {
        assertIsBytes(bytes);
        const bigint = bytesToBigInt(bytes);
        (0, assert_1$2.assert)(bigint <= BigInt(Number.MAX_SAFE_INTEGER), 'Number is not a safe integer. Use `bytesToBigInt` instead.');
        return Number(bigint);
    }
    bytes.bytesToNumber = bytesToNumber;
    /**
     * Convert a UTF-8 encoded `Uint8Array` to a `string`.
     *
     * @param bytes - The bytes to convert to a string.
     * @returns The string.
     */
    function bytesToString(bytes) {
        assertIsBytes(bytes);
        return new TextDecoder().decode(bytes);
    }
    bytes.bytesToString = bytesToString;
    /**
     * Convert a hexadecimal string to a `Uint8Array`. The string can optionally be
     * prefixed with `0x`. It accepts even and odd length strings.
     *
     * If the value is "0x", an empty `Uint8Array` is returned.
     *
     * @param value - The hexadecimal string to convert to bytes.
     * @returns The bytes as `Uint8Array`.
     */
    function hexToBytes(value) {
        var _a;
        // "0x" is often used as empty byte array.
        if (((_a = value === null || value === void 0 ? void 0 : value.toLowerCase) === null || _a === void 0 ? void 0 : _a.call(value)) === '0x') {
            return new Uint8Array();
        }
        (0, hex_1$2.assertIsHexString)(value);
        // Remove the `0x` prefix if it exists, and pad the string to have an even
        // number of characters.
        const strippedValue = (0, hex_1$2.remove0x)(value).toLowerCase();
        const normalizedValue = strippedValue.length % 2 === 0 ? strippedValue : `0${strippedValue}`;
        const bytes = new Uint8Array(normalizedValue.length / 2);
        for (let i = 0; i < bytes.length; i++) {
            // While this is not the prettiest way to convert a hexadecimal string to a
            // `Uint8Array`, it is a lot faster than using `parseInt` to convert each
            // character.
            const c1 = normalizedValue.charCodeAt(i * 2);
            const c2 = normalizedValue.charCodeAt(i * 2 + 1);
            const n1 = c1 -
                (c1 < HEX_MAXIMUM_NUMBER_CHARACTER
                    ? HEX_MINIMUM_NUMBER_CHARACTER
                    : HEX_CHARACTER_OFFSET);
            const n2 = c2 -
                (c2 < HEX_MAXIMUM_NUMBER_CHARACTER
                    ? HEX_MINIMUM_NUMBER_CHARACTER
                    : HEX_CHARACTER_OFFSET);
            bytes[i] = n1 * 16 + n2;
        }
        return bytes;
    }
    bytes.hexToBytes = hexToBytes;
    /**
     * Convert a `bigint` to a `Uint8Array`.
     *
     * This assumes that the `bigint` is an unsigned integer. To convert a signed
     * `bigint` instead, use {@link signedBigIntToBytes}.
     *
     * @param value - The bigint to convert to bytes.
     * @returns The bytes as `Uint8Array`.
     */
    function bigIntToBytes(value) {
        (0, assert_1$2.assert)(typeof value === 'bigint', 'Value must be a bigint.');
        (0, assert_1$2.assert)(value >= BigInt(0), 'Value must be a non-negative bigint.');
        const hexadecimal = value.toString(16);
        return hexToBytes(hexadecimal);
    }
    bytes.bigIntToBytes = bigIntToBytes;
    /**
     * Check if a `bigint` fits in a certain number of bytes.
     *
     * @param value - The `bigint` to check.
     * @param bytes - The number of bytes.
     * @returns Whether the `bigint` fits in the number of bytes.
     */
    function bigIntFits(value, bytes) {
        (0, assert_1$2.assert)(bytes > 0);
        /* eslint-disable no-bitwise */
        const mask = value >> BigInt(31);
        return !(((~value & mask) + (value & ~mask)) >> BigInt(bytes * 8 + ~0));
        /* eslint-enable no-bitwise */
    }
    /**
     * Convert a signed `bigint` to a `Uint8Array`. This uses two's complement
     * encoding to represent negative numbers.
     *
     * To convert an unsigned `bigint` to a `Uint8Array` instead, use
     * {@link bigIntToBytes}.
     *
     * @see https://en.wikipedia.org/wiki/Two%27s_complement
     * @param value - The number to convert to bytes.
     * @param byteLength - The length of the resulting `Uint8Array`. If the number
     * is larger than the maximum value that can be represented by the given length,
     * an error is thrown.
     * @returns The bytes as `Uint8Array`.
     */
    function signedBigIntToBytes(value, byteLength) {
        (0, assert_1$2.assert)(typeof value === 'bigint', 'Value must be a bigint.');
        (0, assert_1$2.assert)(typeof byteLength === 'number', 'Byte length must be a number.');
        (0, assert_1$2.assert)(byteLength > 0, 'Byte length must be greater than 0.');
        (0, assert_1$2.assert)(bigIntFits(value, byteLength), 'Byte length is too small to represent the given value.');
        // ESLint doesn't like mutating function parameters, so to avoid having to
        // disable the rule, we create a new variable.
        let numberValue = value;
        const bytes = new Uint8Array(byteLength);
        for (let i = 0; i < bytes.length; i++) {
            bytes[i] = Number(BigInt.asUintN(8, numberValue));
            // eslint-disable-next-line no-bitwise
            numberValue >>= BigInt(8);
        }
        return bytes.reverse();
    }
    bytes.signedBigIntToBytes = signedBigIntToBytes;
    /**
     * Convert a `number` to a `Uint8Array`.
     *
     * @param value - The number to convert to bytes.
     * @returns The bytes as `Uint8Array`.
     * @throws If the number is not a safe integer.
     */
    function numberToBytes(value) {
        (0, assert_1$2.assert)(typeof value === 'number', 'Value must be a number.');
        (0, assert_1$2.assert)(value >= 0, 'Value must be a non-negative number.');
        (0, assert_1$2.assert)(Number.isSafeInteger(value), 'Value is not a safe integer. Use `bigIntToBytes` instead.');
        const hexadecimal = value.toString(16);
        return hexToBytes(hexadecimal);
    }
    bytes.numberToBytes = numberToBytes;
    /**
     * Convert a `string` to a UTF-8 encoded `Uint8Array`.
     *
     * @param value - The string to convert to bytes.
     * @returns The bytes as `Uint8Array`.
     */
    function stringToBytes(value) {
        (0, assert_1$2.assert)(typeof value === 'string', 'Value must be a string.');
        return new TextEncoder().encode(value);
    }
    bytes.stringToBytes = stringToBytes;
    /**
     * Convert a byte-like value to a `Uint8Array`. The value can be a `Uint8Array`,
     * a `bigint`, a `number`, or a `string`.
     *
     * This will attempt to guess the type of the value based on its type and
     * contents. For more control over the conversion, use the more specific
     * conversion functions, such as {@link hexToBytes} or {@link stringToBytes}.
     *
     * If the value is a `string`, and it is prefixed with `0x`, it will be
     * interpreted as a hexadecimal string. Otherwise, it will be interpreted as a
     * UTF-8 string. To convert a hexadecimal string to bytes without interpreting
     * it as a UTF-8 string, use {@link hexToBytes} instead.
     *
     * If the value is a `bigint`, it is assumed to be unsigned. To convert a signed
     * `bigint` to bytes, use {@link signedBigIntToBytes} instead.
     *
     * If the value is a `Uint8Array`, it will be returned as-is.
     *
     * @param value - The value to convert to bytes.
     * @returns The bytes as `Uint8Array`.
     */
    function valueToBytes(value) {
        if (typeof value === 'bigint') {
            return bigIntToBytes(value);
        }
        if (typeof value === 'number') {
            return numberToBytes(value);
        }
        if (typeof value === 'string') {
            if (value.startsWith('0x')) {
                return hexToBytes(value);
            }
            return stringToBytes(value);
        }
        if (isBytes(value)) {
            return value;
        }
        throw new TypeError(`Unsupported value type: "${typeof value}".`);
    }
    bytes.valueToBytes = valueToBytes;
    /**
     * Concatenate multiple byte-like values into a single `Uint8Array`. The values
     * can be `Uint8Array`, `bigint`, `number`, or `string`. This uses
     * {@link valueToBytes} under the hood to convert each value to bytes. Refer to
     * the documentation of that function for more information.
     *
     * @param values - The values to concatenate.
     * @returns The concatenated bytes as `Uint8Array`.
     */
    function concatBytes(values) {
        const normalizedValues = new Array(values.length);
        let byteLength = 0;
        for (let i = 0; i < values.length; i++) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const value = valueToBytes(values[i]);
            normalizedValues[i] = value;
            byteLength += value.length;
        }
        const bytes = new Uint8Array(byteLength);
        for (let i = 0, offset = 0; i < normalizedValues.length; i++) {
            // While we could simply spread the values into an array and use
            // `Uint8Array.from`, that is a lot slower than using `Uint8Array.set`.
            bytes.set(normalizedValues[i], offset);
            offset += normalizedValues[i].length;
        }
        return bytes;
    }
    bytes.concatBytes = concatBytes;
    /**
     * Create a {@link DataView} from a {@link Uint8Array}. This is a convenience
     * function that avoids having to create a {@link DataView} manually, which
     * requires passing the `byteOffset` and `byteLength` parameters every time.
     *
     * Not passing the `byteOffset` and `byteLength` parameters can result in
     * unexpected behavior when the {@link Uint8Array} is a view of a larger
     * {@link ArrayBuffer}, e.g., when using {@link Uint8Array.subarray}.
     *
     * This function also supports Node.js {@link Buffer}s.
     *
     * @example
     * ```typescript
     * const bytes = new Uint8Array([1, 2, 3]);
     *
     * // This is equivalent to:
     * // const dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
     * const dataView = createDataView(bytes);
     * ```
     * @param bytes - The bytes to create the {@link DataView} from.
     * @returns The {@link DataView}.
     */
    function createDataView(bytes) {
        // To maintain compatibility with Node.js, we need to check if the bytes are
        // a Buffer. If so, we need to slice the buffer to get the underlying
        // ArrayBuffer.
        // eslint-disable-next-line no-restricted-globals
        if (typeof Buffer$8 !== 'undefined' && bytes instanceof Buffer$8) {
            const buffer = bytes.buffer.slice(bytes.byteOffset, bytes.byteOffset + bytes.byteLength);
            return new DataView(buffer);
        }
        return new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
    }
    bytes.createDataView = createDataView;

    var checksum = {};

    Object.defineProperty(checksum, "__esModule", { value: true });
    checksum.ChecksumStruct = void 0;
    const superstruct_1$1 = require$$1;
    const base64_1 = base64$1;
    checksum.ChecksumStruct = (0, superstruct_1$1.size)((0, base64_1.base64)((0, superstruct_1$1.string)(), { paddingRequired: true }), 44, 44);

    var coercers = {};

    Object.defineProperty(coercers, "__esModule", { value: true });
    coercers.createHex = coercers.createBytes = coercers.createBigInt = coercers.createNumber = void 0;
    const superstruct_1 = require$$1;
    const assert_1$1 = assert$2;
    const bytes_1 = bytes;
    const hex_1$1 = hex;
    const NumberLikeStruct = (0, superstruct_1.union)([(0, superstruct_1.number)(), (0, superstruct_1.bigint)(), (0, superstruct_1.string)(), hex_1$1.StrictHexStruct]);
    const NumberCoercer = (0, superstruct_1.coerce)((0, superstruct_1.number)(), NumberLikeStruct, Number);
    const BigIntCoercer = (0, superstruct_1.coerce)((0, superstruct_1.bigint)(), NumberLikeStruct, BigInt);
    (0, superstruct_1.union)([hex_1$1.StrictHexStruct, (0, superstruct_1.instance)(Uint8Array)]);
    const BytesCoercer = (0, superstruct_1.coerce)((0, superstruct_1.instance)(Uint8Array), (0, superstruct_1.union)([hex_1$1.StrictHexStruct]), bytes_1.hexToBytes);
    const HexCoercer = (0, superstruct_1.coerce)(hex_1$1.StrictHexStruct, (0, superstruct_1.instance)(Uint8Array), bytes_1.bytesToHex);
    /**
     * Create a number from a number-like value.
     *
     * - If the value is a number, it is returned as-is.
     * - If the value is a `bigint`, it is converted to a number.
     * - If the value is a string, it is interpreted as a decimal number.
     * - If the value is a hex string (i.e., it starts with "0x"), it is
     * interpreted as a hexadecimal number.
     *
     * This validates that the value is a number-like value, and that the resulting
     * number is not `NaN` or `Infinity`.
     *
     * @example
     * ```typescript
     * const value = createNumber('0x010203');
     * console.log(value); // 66051
     *
     * const otherValue = createNumber(123n);
     * console.log(otherValue); // 123
     * ```
     * @param value - The value to create the number from.
     * @returns The created number.
     * @throws If the value is not a number-like value, or if the resulting number
     * is `NaN` or `Infinity`.
     */
    function createNumber(value) {
        try {
            const result = (0, superstruct_1.create)(value, NumberCoercer);
            (0, assert_1$1.assert)(Number.isFinite(result), `Expected a number-like value, got "${value}".`);
            return result;
        }
        catch (error) {
            if (error instanceof superstruct_1.StructError) {
                throw new Error(`Expected a number-like value, got "${value}".`);
            }
            /* istanbul ignore next */
            throw error;
        }
    }
    coercers.createNumber = createNumber;
    /**
     * Create a `bigint` from a number-like value.
     *
     * - If the value is a number, it is converted to a `bigint`.
     * - If the value is a `bigint`, it is returned as-is.
     * - If the value is a string, it is interpreted as a decimal number and
     * converted to a `bigint`.
     * - If the value is a hex string (i.e., it starts with "0x"), it is
     * interpreted as a hexadecimal number and converted to a `bigint`.
     *
     * @example
     * ```typescript
     * const value = createBigInt('0x010203');
     * console.log(value); // 16909060n
     *
     * const otherValue = createBigInt(123);
     * console.log(otherValue); // 123n
     * ```
     * @param value - The value to create the bigint from.
     * @returns The created bigint.
     * @throws If the value is not a number-like value.
     */
    function createBigInt(value) {
        try {
            // The `BigInt` constructor throws if the value is not a number-like value.
            // There is no need to validate the value manually.
            return (0, superstruct_1.create)(value, BigIntCoercer);
        }
        catch (error) {
            if (error instanceof superstruct_1.StructError) {
                throw new Error(`Expected a number-like value, got "${String(error.value)}".`);
            }
            /* istanbul ignore next */
            throw error;
        }
    }
    coercers.createBigInt = createBigInt;
    /**
     * Create a byte array from a bytes-like value.
     *
     * - If the value is a byte array, it is returned as-is.
     * - If the value is a hex string (i.e., it starts with "0x"), it is interpreted
     * as a hexadecimal number and converted to a byte array.
     *
     * @example
     * ```typescript
     * const value = createBytes('0x010203');
     * console.log(value); // Uint8Array [ 1, 2, 3 ]
     *
     * const otherValue = createBytes('0x010203');
     * console.log(otherValue); // Uint8Array [ 1, 2, 3 ]
     * ```
     * @param value - The value to create the byte array from.
     * @returns The created byte array.
     * @throws If the value is not a bytes-like value.
     */
    function createBytes(value) {
        if (typeof value === 'string' && value.toLowerCase() === '0x') {
            return new Uint8Array();
        }
        try {
            return (0, superstruct_1.create)(value, BytesCoercer);
        }
        catch (error) {
            if (error instanceof superstruct_1.StructError) {
                throw new Error(`Expected a bytes-like value, got "${String(error.value)}".`);
            }
            /* istanbul ignore next */
            throw error;
        }
    }
    coercers.createBytes = createBytes;
    /**
     * Create a hexadecimal string from a bytes-like value.
     *
     * - If the value is a hex string (i.e., it starts with "0x"), it is returned
     * as-is.
     * - If the value is a `Uint8Array`, it is converted to a hex string.
     *
     * @example
     * ```typescript
     * const value = createHex(new Uint8Array([1, 2, 3]));
     * console.log(value); // '0x010203'
     *
     * const otherValue = createHex('0x010203');
     * console.log(otherValue); // '0x010203'
     * ```
     * @param value - The value to create the hex string from.
     * @returns The created hex string.
     * @throws If the value is not a bytes-like value.
     */
    function createHex(value) {
        if ((value instanceof Uint8Array && value.length === 0) ||
            (typeof value === 'string' && value.toLowerCase() === '0x')) {
            return '0x';
        }
        try {
            return (0, superstruct_1.create)(value, HexCoercer);
        }
        catch (error) {
            if (error instanceof superstruct_1.StructError) {
                throw new Error(`Expected a bytes-like value, got "${String(error.value)}".`);
            }
            /* istanbul ignore next */
            throw error;
        }
    }
    coercers.createHex = createHex;

    var collections = {};

    var __classPrivateFieldSet = (commonjsGlobal && commonjsGlobal.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    };
    var __classPrivateFieldGet = (commonjsGlobal && commonjsGlobal.__classPrivateFieldGet) || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _FrozenMap_map, _FrozenSet_set;
    Object.defineProperty(collections, "__esModule", { value: true });
    collections.FrozenSet = collections.FrozenMap = void 0;
    /**
     * A {@link ReadonlyMap} that cannot be modified after instantiation.
     * The implementation uses an inner map hidden via a private field, and the
     * immutability guarantee relies on it being impossible to get a reference
     * to this map.
     */
    class FrozenMap {
        constructor(entries) {
            _FrozenMap_map.set(this, void 0);
            __classPrivateFieldSet(this, _FrozenMap_map, new Map(entries), "f");
            Object.freeze(this);
        }
        get size() {
            return __classPrivateFieldGet(this, _FrozenMap_map, "f").size;
        }
        [(_FrozenMap_map = new WeakMap(), Symbol.iterator)]() {
            return __classPrivateFieldGet(this, _FrozenMap_map, "f")[Symbol.iterator]();
        }
        entries() {
            return __classPrivateFieldGet(this, _FrozenMap_map, "f").entries();
        }
        forEach(callbackfn, thisArg) {
            // We have to wrap the specified callback in order to prevent it from
            // receiving a reference to the inner map.
            return __classPrivateFieldGet(this, _FrozenMap_map, "f").forEach((value, key, _map) => callbackfn.call(thisArg, value, key, this));
        }
        get(key) {
            return __classPrivateFieldGet(this, _FrozenMap_map, "f").get(key);
        }
        has(key) {
            return __classPrivateFieldGet(this, _FrozenMap_map, "f").has(key);
        }
        keys() {
            return __classPrivateFieldGet(this, _FrozenMap_map, "f").keys();
        }
        values() {
            return __classPrivateFieldGet(this, _FrozenMap_map, "f").values();
        }
        toString() {
            return `FrozenMap(${this.size}) {${this.size > 0
            ? ` ${[...this.entries()]
                .map(([key, value]) => `${String(key)} => ${String(value)}`)
                .join(', ')} `
            : ''}}`;
        }
    }
    collections.FrozenMap = FrozenMap;
    /**
     * A {@link ReadonlySet} that cannot be modified after instantiation.
     * The implementation uses an inner set hidden via a private field, and the
     * immutability guarantee relies on it being impossible to get a reference
     * to this set.
     */
    class FrozenSet {
        constructor(values) {
            _FrozenSet_set.set(this, void 0);
            __classPrivateFieldSet(this, _FrozenSet_set, new Set(values), "f");
            Object.freeze(this);
        }
        get size() {
            return __classPrivateFieldGet(this, _FrozenSet_set, "f").size;
        }
        [(_FrozenSet_set = new WeakMap(), Symbol.iterator)]() {
            return __classPrivateFieldGet(this, _FrozenSet_set, "f")[Symbol.iterator]();
        }
        entries() {
            return __classPrivateFieldGet(this, _FrozenSet_set, "f").entries();
        }
        forEach(callbackfn, thisArg) {
            // We have to wrap the specified callback in order to prevent it from
            // receiving a reference to the inner set.
            return __classPrivateFieldGet(this, _FrozenSet_set, "f").forEach((value, value2, _set) => callbackfn.call(thisArg, value, value2, this));
        }
        has(value) {
            return __classPrivateFieldGet(this, _FrozenSet_set, "f").has(value);
        }
        keys() {
            return __classPrivateFieldGet(this, _FrozenSet_set, "f").keys();
        }
        values() {
            return __classPrivateFieldGet(this, _FrozenSet_set, "f").values();
        }
        toString() {
            return `FrozenSet(${this.size}) {${this.size > 0
            ? ` ${[...this.values()].map((member) => String(member)).join(', ')} `
            : ''}}`;
        }
    }
    collections.FrozenSet = FrozenSet;
    Object.freeze(FrozenMap);
    Object.freeze(FrozenMap.prototype);
    Object.freeze(FrozenSet);
    Object.freeze(FrozenSet.prototype);

    var encryptionTypes = {};

    Object.defineProperty(encryptionTypes, "__esModule", { value: true });

    var json = {};

    (function (exports) {
    	Object.defineProperty(exports, "__esModule", { value: true });
    	exports.getJsonRpcIdValidator = exports.assertIsJsonRpcError = exports.isJsonRpcError = exports.assertIsJsonRpcFailure = exports.isJsonRpcFailure = exports.assertIsJsonRpcSuccess = exports.isJsonRpcSuccess = exports.assertIsJsonRpcResponse = exports.isJsonRpcResponse = exports.assertIsPendingJsonRpcResponse = exports.isPendingJsonRpcResponse = exports.JsonRpcResponseStruct = exports.JsonRpcFailureStruct = exports.JsonRpcSuccessStruct = exports.PendingJsonRpcResponseStruct = exports.assertIsJsonRpcRequest = exports.isJsonRpcRequest = exports.assertIsJsonRpcNotification = exports.isJsonRpcNotification = exports.JsonRpcNotificationStruct = exports.JsonRpcRequestStruct = exports.JsonRpcParamsStruct = exports.JsonRpcErrorStruct = exports.JsonRpcIdStruct = exports.JsonRpcVersionStruct = exports.jsonrpc2 = exports.getJsonSize = exports.isValidJson = exports.JsonStruct = exports.UnsafeJsonStruct = void 0;
    	const superstruct_1 = require$$1;
    	const assert_1 = assert$2;
    	/**
    	 * A struct to check if the given value is finite number. Superstruct's
    	 * `number()` struct does not check if the value is finite.
    	 *
    	 * @returns A struct to check if the given value is finite number.
    	 */
    	const finiteNumber = () => (0, superstruct_1.define)('finite number', (value) => {
    	    return (0, superstruct_1.is)(value, (0, superstruct_1.number)()) && Number.isFinite(value);
    	});
    	/**
    	 * A struct to check if the given value is a valid JSON-serializable value.
    	 *
    	 * Note that this struct is unsafe. For safe validation, use {@link JsonStruct}.
    	 */
    	// We cannot infer the type of the struct, because it is recursive.
    	exports.UnsafeJsonStruct = (0, superstruct_1.union)([
    	    (0, superstruct_1.literal)(null),
    	    (0, superstruct_1.boolean)(),
    	    finiteNumber(),
    	    (0, superstruct_1.string)(),
    	    (0, superstruct_1.array)((0, superstruct_1.lazy)(() => exports.UnsafeJsonStruct)),
    	    (0, superstruct_1.record)((0, superstruct_1.string)(), (0, superstruct_1.lazy)(() => exports.UnsafeJsonStruct)),
    	]);
    	/**
    	 * A struct to check if the given value is a valid JSON-serializable value.
    	 *
    	 * This struct sanitizes the value before validating it, so that it is safe to
    	 * use with untrusted input.
    	 */
    	exports.JsonStruct = (0, superstruct_1.define)('Json', (value, context) => {
    	    /**
    	     * Helper function that runs the given struct validator and returns the
    	     * validation errors, if any. If the value is valid, it returns `true`.
    	     *
    	     * @param innerValue - The value to validate.
    	     * @param struct - The struct to use for validation.
    	     * @returns The validation errors, or `true` if the value is valid.
    	     */
    	    function checkStruct(innerValue, struct) {
    	        const iterator = struct.validator(innerValue, context);
    	        const errors = [...iterator];
    	        if (errors.length > 0) {
    	            return errors;
    	        }
    	        return true;
    	    }
    	    try {
    	        // The plain value must be a valid JSON value, but it may be altered in the
    	        // process of JSON serialization, so we need to validate it again after
    	        // serialization. This has the added benefit that the returned error messages
    	        // will be more helpful, as they will point to the exact location of the
    	        // invalid value.
    	        //
    	        // This seems overcomplicated, but without checking the plain value first,
    	        // there are some cases where the validation passes, even though the value is
    	        // not valid JSON. For example, `undefined` is not valid JSON, but serializing
    	        // it will remove it from the object, so the validation will pass.
    	        const unsafeResult = checkStruct(value, exports.UnsafeJsonStruct);
    	        if (unsafeResult !== true) {
    	            return unsafeResult;
    	        }
    	        // JavaScript engines are highly optimized for this specific use case of
    	        // JSON parsing and stringifying, so there should be no performance impact.
    	        return checkStruct(JSON.parse(JSON.stringify(value)), exports.UnsafeJsonStruct);
    	    }
    	    catch (error) {
    	        if (error instanceof RangeError) {
    	            return 'Circular reference detected';
    	        }
    	        return false;
    	    }
    	});
    	/**
    	 * Check if the given value is a valid {@link Json} value, i.e., a value that is
    	 * serializable to JSON.
    	 *
    	 * @param value - The value to check.
    	 * @returns Whether the value is a valid {@link Json} value.
    	 */
    	function isValidJson(value) {
    	    return (0, superstruct_1.is)(value, exports.JsonStruct);
    	}
    	exports.isValidJson = isValidJson;
    	/**
    	 * Get the size of a JSON value in bytes. This also validates the value.
    	 *
    	 * @param value - The JSON value to get the size of.
    	 * @returns The size of the JSON value in bytes.
    	 */
    	function getJsonSize(value) {
    	    (0, assert_1.assertStruct)(value, exports.JsonStruct, 'Invalid JSON value');
    	    const json = JSON.stringify(value);
    	    return new TextEncoder().encode(json).byteLength;
    	}
    	exports.getJsonSize = getJsonSize;
    	/**
    	 * The string '2.0'.
    	 */
    	exports.jsonrpc2 = '2.0';
    	exports.JsonRpcVersionStruct = (0, superstruct_1.literal)(exports.jsonrpc2);
    	exports.JsonRpcIdStruct = (0, superstruct_1.nullable)((0, superstruct_1.union)([(0, superstruct_1.number)(), (0, superstruct_1.string)()]));
    	exports.JsonRpcErrorStruct = (0, superstruct_1.object)({
    	    code: (0, superstruct_1.integer)(),
    	    message: (0, superstruct_1.string)(),
    	    data: (0, superstruct_1.optional)(exports.JsonStruct),
    	    stack: (0, superstruct_1.optional)((0, superstruct_1.string)()),
    	});
    	exports.JsonRpcParamsStruct = (0, superstruct_1.optional)((0, superstruct_1.union)([(0, superstruct_1.record)((0, superstruct_1.string)(), exports.JsonStruct), (0, superstruct_1.array)(exports.JsonStruct)]));
    	exports.JsonRpcRequestStruct = (0, superstruct_1.object)({
    	    id: exports.JsonRpcIdStruct,
    	    jsonrpc: exports.JsonRpcVersionStruct,
    	    method: (0, superstruct_1.string)(),
    	    params: exports.JsonRpcParamsStruct,
    	});
    	exports.JsonRpcNotificationStruct = (0, superstruct_1.omit)(exports.JsonRpcRequestStruct, ['id']);
    	/**
    	 * Check if the given value is a valid {@link JsonRpcNotification} object.
    	 *
    	 * @param value - The value to check.
    	 * @returns Whether the given value is a valid {@link JsonRpcNotification}
    	 * object.
    	 */
    	function isJsonRpcNotification(value) {
    	    return (0, superstruct_1.is)(value, exports.JsonRpcNotificationStruct);
    	}
    	exports.isJsonRpcNotification = isJsonRpcNotification;
    	/**
    	 * Assert that the given value is a valid {@link JsonRpcNotification} object.
    	 *
    	 * @param value - The value to check.
    	 * @param ErrorWrapper - The error class to throw if the assertion fails.
    	 * Defaults to {@link AssertionError}.
    	 * @throws If the given value is not a valid {@link JsonRpcNotification} object.
    	 */
    	function assertIsJsonRpcNotification(value, 
    	// eslint-disable-next-line @typescript-eslint/naming-convention
    	ErrorWrapper) {
    	    (0, assert_1.assertStruct)(value, exports.JsonRpcNotificationStruct, 'Invalid JSON-RPC notification', ErrorWrapper);
    	}
    	exports.assertIsJsonRpcNotification = assertIsJsonRpcNotification;
    	/**
    	 * Check if the given value is a valid {@link JsonRpcRequest} object.
    	 *
    	 * @param value - The value to check.
    	 * @returns Whether the given value is a valid {@link JsonRpcRequest} object.
    	 */
    	function isJsonRpcRequest(value) {
    	    return (0, superstruct_1.is)(value, exports.JsonRpcRequestStruct);
    	}
    	exports.isJsonRpcRequest = isJsonRpcRequest;
    	/**
    	 * Assert that the given value is a valid {@link JsonRpcRequest} object.
    	 *
    	 * @param value - The JSON-RPC request or notification to check.
    	 * @param ErrorWrapper - The error class to throw if the assertion fails.
    	 * Defaults to {@link AssertionError}.
    	 * @throws If the given value is not a valid {@link JsonRpcRequest} object.
    	 */
    	function assertIsJsonRpcRequest(value, 
    	// eslint-disable-next-line @typescript-eslint/naming-convention
    	ErrorWrapper) {
    	    (0, assert_1.assertStruct)(value, exports.JsonRpcRequestStruct, 'Invalid JSON-RPC request', ErrorWrapper);
    	}
    	exports.assertIsJsonRpcRequest = assertIsJsonRpcRequest;
    	exports.PendingJsonRpcResponseStruct = (0, superstruct_1.object)({
    	    id: exports.JsonRpcIdStruct,
    	    jsonrpc: exports.JsonRpcVersionStruct,
    	    result: (0, superstruct_1.optional)((0, superstruct_1.unknown)()),
    	    error: (0, superstruct_1.optional)(exports.JsonRpcErrorStruct),
    	});
    	exports.JsonRpcSuccessStruct = (0, superstruct_1.object)({
    	    id: exports.JsonRpcIdStruct,
    	    jsonrpc: exports.JsonRpcVersionStruct,
    	    result: exports.JsonStruct,
    	});
    	exports.JsonRpcFailureStruct = (0, superstruct_1.object)({
    	    id: exports.JsonRpcIdStruct,
    	    jsonrpc: exports.JsonRpcVersionStruct,
    	    error: exports.JsonRpcErrorStruct,
    	});
    	exports.JsonRpcResponseStruct = (0, superstruct_1.union)([
    	    exports.JsonRpcSuccessStruct,
    	    exports.JsonRpcFailureStruct,
    	]);
    	/**
    	 * Type guard to check whether specified JSON-RPC response is a
    	 * {@link PendingJsonRpcResponse}.
    	 *
    	 * @param response - The JSON-RPC response to check.
    	 * @returns Whether the specified JSON-RPC response is pending.
    	 */
    	function isPendingJsonRpcResponse(response) {
    	    return (0, superstruct_1.is)(response, exports.PendingJsonRpcResponseStruct);
    	}
    	exports.isPendingJsonRpcResponse = isPendingJsonRpcResponse;
    	/**
    	 * Assert that the given value is a valid {@link PendingJsonRpcResponse} object.
    	 *
    	 * @param response - The JSON-RPC response to check.
    	 * @param ErrorWrapper - The error class to throw if the assertion fails.
    	 * Defaults to {@link AssertionError}.
    	 * @throws If the given value is not a valid {@link PendingJsonRpcResponse}
    	 * object.
    	 */
    	function assertIsPendingJsonRpcResponse(response, 
    	// eslint-disable-next-line @typescript-eslint/naming-convention
    	ErrorWrapper) {
    	    (0, assert_1.assertStruct)(response, exports.PendingJsonRpcResponseStruct, 'Invalid pending JSON-RPC response', ErrorWrapper);
    	}
    	exports.assertIsPendingJsonRpcResponse = assertIsPendingJsonRpcResponse;
    	/**
    	 * Type guard to check if a value is a {@link JsonRpcResponse}.
    	 *
    	 * @param response - The object to check.
    	 * @returns Whether the object is a JsonRpcResponse.
    	 */
    	function isJsonRpcResponse(response) {
    	    return (0, superstruct_1.is)(response, exports.JsonRpcResponseStruct);
    	}
    	exports.isJsonRpcResponse = isJsonRpcResponse;
    	/**
    	 * Assert that the given value is a valid {@link JsonRpcResponse} object.
    	 *
    	 * @param value - The value to check.
    	 * @param ErrorWrapper - The error class to throw if the assertion fails.
    	 * Defaults to {@link AssertionError}.
    	 * @throws If the given value is not a valid {@link JsonRpcResponse} object.
    	 */
    	function assertIsJsonRpcResponse(value, 
    	// eslint-disable-next-line @typescript-eslint/naming-convention
    	ErrorWrapper) {
    	    (0, assert_1.assertStruct)(value, exports.JsonRpcResponseStruct, 'Invalid JSON-RPC response', ErrorWrapper);
    	}
    	exports.assertIsJsonRpcResponse = assertIsJsonRpcResponse;
    	/**
    	 * Check if the given value is a valid {@link JsonRpcSuccess} object.
    	 *
    	 * @param value - The value to check.
    	 * @returns Whether the given value is a valid {@link JsonRpcSuccess} object.
    	 */
    	function isJsonRpcSuccess(value) {
    	    return (0, superstruct_1.is)(value, exports.JsonRpcSuccessStruct);
    	}
    	exports.isJsonRpcSuccess = isJsonRpcSuccess;
    	/**
    	 * Assert that the given value is a valid {@link JsonRpcSuccess} object.
    	 *
    	 * @param value - The value to check.
    	 * @param ErrorWrapper - The error class to throw if the assertion fails.
    	 * Defaults to {@link AssertionError}.
    	 * @throws If the given value is not a valid {@link JsonRpcSuccess} object.
    	 */
    	function assertIsJsonRpcSuccess(value, 
    	// eslint-disable-next-line @typescript-eslint/naming-convention
    	ErrorWrapper) {
    	    (0, assert_1.assertStruct)(value, exports.JsonRpcSuccessStruct, 'Invalid JSON-RPC success response', ErrorWrapper);
    	}
    	exports.assertIsJsonRpcSuccess = assertIsJsonRpcSuccess;
    	/**
    	 * Check if the given value is a valid {@link JsonRpcFailure} object.
    	 *
    	 * @param value - The value to check.
    	 * @returns Whether the given value is a valid {@link JsonRpcFailure} object.
    	 */
    	function isJsonRpcFailure(value) {
    	    return (0, superstruct_1.is)(value, exports.JsonRpcFailureStruct);
    	}
    	exports.isJsonRpcFailure = isJsonRpcFailure;
    	/**
    	 * Assert that the given value is a valid {@link JsonRpcFailure} object.
    	 *
    	 * @param value - The value to check.
    	 * @param ErrorWrapper - The error class to throw if the assertion fails.
    	 * Defaults to {@link AssertionError}.
    	 * @throws If the given value is not a valid {@link JsonRpcFailure} object.
    	 */
    	function assertIsJsonRpcFailure(value, 
    	// eslint-disable-next-line @typescript-eslint/naming-convention
    	ErrorWrapper) {
    	    (0, assert_1.assertStruct)(value, exports.JsonRpcFailureStruct, 'Invalid JSON-RPC failure response', ErrorWrapper);
    	}
    	exports.assertIsJsonRpcFailure = assertIsJsonRpcFailure;
    	/**
    	 * Check if the given value is a valid {@link JsonRpcError} object.
    	 *
    	 * @param value - The value to check.
    	 * @returns Whether the given value is a valid {@link JsonRpcError} object.
    	 */
    	function isJsonRpcError(value) {
    	    return (0, superstruct_1.is)(value, exports.JsonRpcErrorStruct);
    	}
    	exports.isJsonRpcError = isJsonRpcError;
    	/**
    	 * Assert that the given value is a valid {@link JsonRpcError} object.
    	 *
    	 * @param value - The value to check.
    	 * @param ErrorWrapper - The error class to throw if the assertion fails.
    	 * Defaults to {@link AssertionError}.
    	 * @throws If the given value is not a valid {@link JsonRpcError} object.
    	 */
    	function assertIsJsonRpcError(value, 
    	// eslint-disable-next-line @typescript-eslint/naming-convention
    	ErrorWrapper) {
    	    (0, assert_1.assertStruct)(value, exports.JsonRpcErrorStruct, 'Invalid JSON-RPC error', ErrorWrapper);
    	}
    	exports.assertIsJsonRpcError = assertIsJsonRpcError;
    	/**
    	 * Gets a function for validating JSON-RPC request / response `id` values.
    	 *
    	 * By manipulating the options of this factory, you can control the behavior
    	 * of the resulting validator for some edge cases. This is useful because e.g.
    	 * `null` should sometimes but not always be permitted.
    	 *
    	 * Note that the empty string (`''`) is always permitted by the JSON-RPC
    	 * specification, but that kind of sucks and you may want to forbid it in some
    	 * instances anyway.
    	 *
    	 * For more details, see the
    	 * [JSON-RPC Specification](https://www.jsonrpc.org/specification).
    	 *
    	 * @param options - An options object.
    	 * @param options.permitEmptyString - Whether the empty string (i.e. `''`)
    	 * should be treated as a valid ID. Default: `true`
    	 * @param options.permitFractions - Whether fractional numbers (e.g. `1.2`)
    	 * should be treated as valid IDs. Default: `false`
    	 * @param options.permitNull - Whether `null` should be treated as a valid ID.
    	 * Default: `true`
    	 * @returns The JSON-RPC ID validator function.
    	 */
    	function getJsonRpcIdValidator(options) {
    	    const { permitEmptyString, permitFractions, permitNull } = Object.assign({ permitEmptyString: true, permitFractions: false, permitNull: true }, options);
    	    /**
    	     * Type guard for {@link JsonRpcId}.
    	     *
    	     * @param id - The JSON-RPC ID value to check.
    	     * @returns Whether the given ID is valid per the options given to the
    	     * factory.
    	     */
    	    const isValidJsonRpcId = (id) => {
    	        return Boolean((typeof id === 'number' && (permitFractions || Number.isInteger(id))) ||
    	            (typeof id === 'string' && (permitEmptyString || id.length > 0)) ||
    	            (permitNull && id === null));
    	    };
    	    return isValidJsonRpcId;
    	}
    	exports.getJsonRpcIdValidator = getJsonRpcIdValidator;
    	
    } (json));

    var keyring = {};

    Object.defineProperty(keyring, "__esModule", { value: true });

    var logging = {};

    var browser = {exports: {}};

    /**
     * Helpers.
     */

    var ms;
    var hasRequiredMs;

    function requireMs () {
    	if (hasRequiredMs) return ms;
    	hasRequiredMs = 1;
    	var s = 1000;
    	var m = s * 60;
    	var h = m * 60;
    	var d = h * 24;
    	var w = d * 7;
    	var y = d * 365.25;

    	/**
    	 * Parse or format the given `val`.
    	 *
    	 * Options:
    	 *
    	 *  - `long` verbose formatting [false]
    	 *
    	 * @param {String|Number} val
    	 * @param {Object} [options]
    	 * @throws {Error} throw an error if val is not a non-empty string or a number
    	 * @return {String|Number}
    	 * @api public
    	 */

    	ms = function(val, options) {
    	  options = options || {};
    	  var type = typeof val;
    	  if (type === 'string' && val.length > 0) {
    	    return parse(val);
    	  } else if (type === 'number' && isFinite(val)) {
    	    return options.long ? fmtLong(val) : fmtShort(val);
    	  }
    	  throw new Error(
    	    'val is not a non-empty string or a valid number. val=' +
    	      JSON.stringify(val)
    	  );
    	};

    	/**
    	 * Parse the given `str` and return milliseconds.
    	 *
    	 * @param {String} str
    	 * @return {Number}
    	 * @api private
    	 */

    	function parse(str) {
    	  str = String(str);
    	  if (str.length > 100) {
    	    return;
    	  }
    	  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    	    str
    	  );
    	  if (!match) {
    	    return;
    	  }
    	  var n = parseFloat(match[1]);
    	  var type = (match[2] || 'ms').toLowerCase();
    	  switch (type) {
    	    case 'years':
    	    case 'year':
    	    case 'yrs':
    	    case 'yr':
    	    case 'y':
    	      return n * y;
    	    case 'weeks':
    	    case 'week':
    	    case 'w':
    	      return n * w;
    	    case 'days':
    	    case 'day':
    	    case 'd':
    	      return n * d;
    	    case 'hours':
    	    case 'hour':
    	    case 'hrs':
    	    case 'hr':
    	    case 'h':
    	      return n * h;
    	    case 'minutes':
    	    case 'minute':
    	    case 'mins':
    	    case 'min':
    	    case 'm':
    	      return n * m;
    	    case 'seconds':
    	    case 'second':
    	    case 'secs':
    	    case 'sec':
    	    case 's':
    	      return n * s;
    	    case 'milliseconds':
    	    case 'millisecond':
    	    case 'msecs':
    	    case 'msec':
    	    case 'ms':
    	      return n;
    	    default:
    	      return undefined;
    	  }
    	}

    	/**
    	 * Short format for `ms`.
    	 *
    	 * @param {Number} ms
    	 * @return {String}
    	 * @api private
    	 */

    	function fmtShort(ms) {
    	  var msAbs = Math.abs(ms);
    	  if (msAbs >= d) {
    	    return Math.round(ms / d) + 'd';
    	  }
    	  if (msAbs >= h) {
    	    return Math.round(ms / h) + 'h';
    	  }
    	  if (msAbs >= m) {
    	    return Math.round(ms / m) + 'm';
    	  }
    	  if (msAbs >= s) {
    	    return Math.round(ms / s) + 's';
    	  }
    	  return ms + 'ms';
    	}

    	/**
    	 * Long format for `ms`.
    	 *
    	 * @param {Number} ms
    	 * @return {String}
    	 * @api private
    	 */

    	function fmtLong(ms) {
    	  var msAbs = Math.abs(ms);
    	  if (msAbs >= d) {
    	    return plural(ms, msAbs, d, 'day');
    	  }
    	  if (msAbs >= h) {
    	    return plural(ms, msAbs, h, 'hour');
    	  }
    	  if (msAbs >= m) {
    	    return plural(ms, msAbs, m, 'minute');
    	  }
    	  if (msAbs >= s) {
    	    return plural(ms, msAbs, s, 'second');
    	  }
    	  return ms + ' ms';
    	}

    	/**
    	 * Pluralization helper.
    	 */

    	function plural(ms, msAbs, n, name) {
    	  var isPlural = msAbs >= n * 1.5;
    	  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
    	}
    	return ms;
    }

    /**
     * This is the common logic for both the Node.js and web browser
     * implementations of `debug()`.
     */

    function setup(env) {
    	createDebug.debug = createDebug;
    	createDebug.default = createDebug;
    	createDebug.coerce = coerce;
    	createDebug.disable = disable;
    	createDebug.enable = enable;
    	createDebug.enabled = enabled;
    	createDebug.humanize = requireMs();
    	createDebug.destroy = destroy;

    	Object.keys(env).forEach(key => {
    		createDebug[key] = env[key];
    	});

    	/**
    	* The currently active debug mode names, and names to skip.
    	*/

    	createDebug.names = [];
    	createDebug.skips = [];

    	/**
    	* Map of special "%n" handling functions, for the debug "format" argument.
    	*
    	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
    	*/
    	createDebug.formatters = {};

    	/**
    	* Selects a color for a debug namespace
    	* @param {String} namespace The namespace string for the debug instance to be colored
    	* @return {Number|String} An ANSI color code for the given namespace
    	* @api private
    	*/
    	function selectColor(namespace) {
    		let hash = 0;

    		for (let i = 0; i < namespace.length; i++) {
    			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
    			hash |= 0; // Convert to 32bit integer
    		}

    		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    	}
    	createDebug.selectColor = selectColor;

    	/**
    	* Create a debugger with the given `namespace`.
    	*
    	* @param {String} namespace
    	* @return {Function}
    	* @api public
    	*/
    	function createDebug(namespace) {
    		let prevTime;
    		let enableOverride = null;
    		let namespacesCache;
    		let enabledCache;

    		function debug(...args) {
    			// Disabled?
    			if (!debug.enabled) {
    				return;
    			}

    			const self = debug;

    			// Set `diff` timestamp
    			const curr = Number(new Date());
    			const ms = curr - (prevTime || curr);
    			self.diff = ms;
    			self.prev = prevTime;
    			self.curr = curr;
    			prevTime = curr;

    			args[0] = createDebug.coerce(args[0]);

    			if (typeof args[0] !== 'string') {
    				// Anything else let's inspect with %O
    				args.unshift('%O');
    			}

    			// Apply any `formatters` transformations
    			let index = 0;
    			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
    				// If we encounter an escaped % then don't increase the array index
    				if (match === '%%') {
    					return '%';
    				}
    				index++;
    				const formatter = createDebug.formatters[format];
    				if (typeof formatter === 'function') {
    					const val = args[index];
    					match = formatter.call(self, val);

    					// Now we need to remove `args[index]` since it's inlined in the `format`
    					args.splice(index, 1);
    					index--;
    				}
    				return match;
    			});

    			// Apply env-specific formatting (colors, etc.)
    			createDebug.formatArgs.call(self, args);

    			const logFn = self.log || createDebug.log;
    			logFn.apply(self, args);
    		}

    		debug.namespace = namespace;
    		debug.useColors = createDebug.useColors();
    		debug.color = createDebug.selectColor(namespace);
    		debug.extend = extend;
    		debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

    		Object.defineProperty(debug, 'enabled', {
    			enumerable: true,
    			configurable: false,
    			get: () => {
    				if (enableOverride !== null) {
    					return enableOverride;
    				}
    				if (namespacesCache !== createDebug.namespaces) {
    					namespacesCache = createDebug.namespaces;
    					enabledCache = createDebug.enabled(namespace);
    				}

    				return enabledCache;
    			},
    			set: v => {
    				enableOverride = v;
    			}
    		});

    		// Env-specific initialization logic for debug instances
    		if (typeof createDebug.init === 'function') {
    			createDebug.init(debug);
    		}

    		return debug;
    	}

    	function extend(namespace, delimiter) {
    		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
    		newDebug.log = this.log;
    		return newDebug;
    	}

    	/**
    	* Enables a debug mode by namespaces. This can include modes
    	* separated by a colon and wildcards.
    	*
    	* @param {String} namespaces
    	* @api public
    	*/
    	function enable(namespaces) {
    		createDebug.save(namespaces);
    		createDebug.namespaces = namespaces;

    		createDebug.names = [];
    		createDebug.skips = [];

    		let i;
    		const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
    		const len = split.length;

    		for (i = 0; i < len; i++) {
    			if (!split[i]) {
    				// ignore empty strings
    				continue;
    			}

    			namespaces = split[i].replace(/\*/g, '.*?');

    			if (namespaces[0] === '-') {
    				createDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));
    			} else {
    				createDebug.names.push(new RegExp('^' + namespaces + '$'));
    			}
    		}
    	}

    	/**
    	* Disable debug output.
    	*
    	* @return {String} namespaces
    	* @api public
    	*/
    	function disable() {
    		const namespaces = [
    			...createDebug.names.map(toNamespace),
    			...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
    		].join(',');
    		createDebug.enable('');
    		return namespaces;
    	}

    	/**
    	* Returns true if the given mode name is enabled, false otherwise.
    	*
    	* @param {String} name
    	* @return {Boolean}
    	* @api public
    	*/
    	function enabled(name) {
    		if (name[name.length - 1] === '*') {
    			return true;
    		}

    		let i;
    		let len;

    		for (i = 0, len = createDebug.skips.length; i < len; i++) {
    			if (createDebug.skips[i].test(name)) {
    				return false;
    			}
    		}

    		for (i = 0, len = createDebug.names.length; i < len; i++) {
    			if (createDebug.names[i].test(name)) {
    				return true;
    			}
    		}

    		return false;
    	}

    	/**
    	* Convert regexp to namespace
    	*
    	* @param {RegExp} regxep
    	* @return {String} namespace
    	* @api private
    	*/
    	function toNamespace(regexp) {
    		return regexp.toString()
    			.substring(2, regexp.toString().length - 2)
    			.replace(/\.\*\?$/, '*');
    	}

    	/**
    	* Coerce `val`.
    	*
    	* @param {Mixed} val
    	* @return {Mixed}
    	* @api private
    	*/
    	function coerce(val) {
    		if (val instanceof Error) {
    			return val.stack || val.message;
    		}
    		return val;
    	}

    	/**
    	* XXX DO NOT USE. This is a temporary stub function.
    	* XXX It WILL be removed in the next major release.
    	*/
    	function destroy() {
    		console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
    	}

    	createDebug.enable(createDebug.load());

    	return createDebug;
    }

    var common = setup;

    (function (module, exports) {
    	/**
    	 * This is the web browser implementation of `debug()`.
    	 */

    	exports.formatArgs = formatArgs;
    	exports.save = save;
    	exports.load = load;
    	exports.useColors = useColors;
    	exports.storage = localstorage();
    	exports.destroy = (() => {
    		let warned = false;

    		return () => {
    			if (!warned) {
    				warned = true;
    				console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
    			}
    		};
    	})();

    	/**
    	 * Colors.
    	 */

    	exports.colors = [
    		'#0000CC',
    		'#0000FF',
    		'#0033CC',
    		'#0033FF',
    		'#0066CC',
    		'#0066FF',
    		'#0099CC',
    		'#0099FF',
    		'#00CC00',
    		'#00CC33',
    		'#00CC66',
    		'#00CC99',
    		'#00CCCC',
    		'#00CCFF',
    		'#3300CC',
    		'#3300FF',
    		'#3333CC',
    		'#3333FF',
    		'#3366CC',
    		'#3366FF',
    		'#3399CC',
    		'#3399FF',
    		'#33CC00',
    		'#33CC33',
    		'#33CC66',
    		'#33CC99',
    		'#33CCCC',
    		'#33CCFF',
    		'#6600CC',
    		'#6600FF',
    		'#6633CC',
    		'#6633FF',
    		'#66CC00',
    		'#66CC33',
    		'#9900CC',
    		'#9900FF',
    		'#9933CC',
    		'#9933FF',
    		'#99CC00',
    		'#99CC33',
    		'#CC0000',
    		'#CC0033',
    		'#CC0066',
    		'#CC0099',
    		'#CC00CC',
    		'#CC00FF',
    		'#CC3300',
    		'#CC3333',
    		'#CC3366',
    		'#CC3399',
    		'#CC33CC',
    		'#CC33FF',
    		'#CC6600',
    		'#CC6633',
    		'#CC9900',
    		'#CC9933',
    		'#CCCC00',
    		'#CCCC33',
    		'#FF0000',
    		'#FF0033',
    		'#FF0066',
    		'#FF0099',
    		'#FF00CC',
    		'#FF00FF',
    		'#FF3300',
    		'#FF3333',
    		'#FF3366',
    		'#FF3399',
    		'#FF33CC',
    		'#FF33FF',
    		'#FF6600',
    		'#FF6633',
    		'#FF9900',
    		'#FF9933',
    		'#FFCC00',
    		'#FFCC33'
    	];

    	/**
    	 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
    	 * and the Firebug extension (any Firefox version) are known
    	 * to support "%c" CSS customizations.
    	 *
    	 * TODO: add a `localStorage` variable to explicitly enable/disable colors
    	 */

    	// eslint-disable-next-line complexity
    	function useColors() {
    		// NB: In an Electron preload script, document will be defined but not fully
    		// initialized. Since we know we're in Chrome, we'll just detect this case
    		// explicitly
    		if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
    			return true;
    		}

    		// Internet Explorer and Edge do not support colors.
    		if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
    			return false;
    		}

    		// Is webkit? http://stackoverflow.com/a/16459606/376773
    		// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
    		return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
    			// Is firebug? http://stackoverflow.com/a/398120/376773
    			(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
    			// Is firefox >= v31?
    			// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    			(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
    			// Double check webkit in userAgent just in case we are in a worker
    			(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
    	}

    	/**
    	 * Colorize log arguments if enabled.
    	 *
    	 * @api public
    	 */

    	function formatArgs(args) {
    		args[0] = (this.useColors ? '%c' : '') +
    			this.namespace +
    			(this.useColors ? ' %c' : ' ') +
    			args[0] +
    			(this.useColors ? '%c ' : ' ') +
    			'+' + module.exports.humanize(this.diff);

    		if (!this.useColors) {
    			return;
    		}

    		const c = 'color: ' + this.color;
    		args.splice(1, 0, c, 'color: inherit');

    		// The final "%c" is somewhat tricky, because there could be other
    		// arguments passed either before or after the %c, so we need to
    		// figure out the correct index to insert the CSS into
    		let index = 0;
    		let lastC = 0;
    		args[0].replace(/%[a-zA-Z%]/g, match => {
    			if (match === '%%') {
    				return;
    			}
    			index++;
    			if (match === '%c') {
    				// We only are interested in the *last* %c
    				// (the user may have provided their own)
    				lastC = index;
    			}
    		});

    		args.splice(lastC, 0, c);
    	}

    	/**
    	 * Invokes `console.debug()` when available.
    	 * No-op when `console.debug` is not a "function".
    	 * If `console.debug` is not available, falls back
    	 * to `console.log`.
    	 *
    	 * @api public
    	 */
    	exports.log = console.debug || console.log || (() => {});

    	/**
    	 * Save `namespaces`.
    	 *
    	 * @param {String} namespaces
    	 * @api private
    	 */
    	function save(namespaces) {
    		try {
    			if (namespaces) {
    				exports.storage.setItem('debug', namespaces);
    			} else {
    				exports.storage.removeItem('debug');
    			}
    		} catch (error) {
    			// Swallow
    			// XXX (@Qix-) should we be logging these?
    		}
    	}

    	/**
    	 * Load `namespaces`.
    	 *
    	 * @return {String} returns the previously persisted debug modes
    	 * @api private
    	 */
    	function load() {
    		let r;
    		try {
    			r = exports.storage.getItem('debug');
    		} catch (error) {
    			// Swallow
    			// XXX (@Qix-) should we be logging these?
    		}

    		// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
    		if (!r && typeof browser$1$1 !== 'undefined' && 'env' in browser$1$1) {
    			r = browser$1$1.env.DEBUG;
    		}

    		return r;
    	}

    	/**
    	 * Localstorage attempts to return the localstorage.
    	 *
    	 * This is necessary because safari throws
    	 * when a user disables cookies/localstorage
    	 * and you attempt to access it.
    	 *
    	 * @return {LocalStorage}
    	 * @api private
    	 */

    	function localstorage() {
    		try {
    			// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
    			// The Browser also has localStorage in the global context.
    			return localStorage;
    		} catch (error) {
    			// Swallow
    			// XXX (@Qix-) should we be logging these?
    		}
    	}

    	module.exports = common(exports);

    	const {formatters} = module.exports;

    	/**
    	 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
    	 */

    	formatters.j = function (v) {
    		try {
    			return JSON.stringify(v);
    		} catch (error) {
    			return '[UnexpectedJSONParseError]: ' + error.message;
    		}
    	}; 
    } (browser, browser.exports));

    var browserExports = browser.exports;

    var __importDefault$4 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };
    Object.defineProperty(logging, "__esModule", { value: true });
    logging.createModuleLogger = logging.createProjectLogger = void 0;
    const debug_1$1 = __importDefault$4(browserExports);
    const globalLogger = (0, debug_1$1.default)('metamask');
    /**
     * Creates a logger via the `debug` library whose log messages will be tagged
     * using the name of your project. By default, such messages will be
     * suppressed, but you can reveal them by setting the `DEBUG` environment
     * variable to `metamask:<projectName>`. You can also set this variable to
     * `metamask:*` if you want to see log messages from all MetaMask projects that
     * are also using this function to create their loggers.
     *
     * @param projectName - The name of your project. This should be the name of
     * your NPM package if you're developing one.
     * @returns An instance of `debug`.
     */
    function createProjectLogger(projectName) {
        return globalLogger.extend(projectName);
    }
    logging.createProjectLogger = createProjectLogger;
    /**
     * Creates a logger via the `debug` library which is derived from the logger for
     * the whole project whose log messages will be tagged using the name of your
     * module. By default, such messages will be suppressed, but you can reveal them
     * by setting the `DEBUG` environment variable to
     * `metamask:<projectName>:<moduleName>`. You can also set this variable to
     * `metamask:<projectName>:*` if you want to see log messages from the project,
     * or `metamask:*` if you want to see log messages from all MetaMask projects.
     *
     * @param projectLogger - The logger created via {@link createProjectLogger}.
     * @param moduleName - The name of your module. You could use the name of the
     * file where you're using this logger or some other name.
     * @returns An instance of `debug`.
     */
    function createModuleLogger(projectLogger, moduleName) {
        return projectLogger.extend(moduleName);
    }
    logging.createModuleLogger = createModuleLogger;

    var misc = {};

    (function (exports) {
    	//
    	// Types
    	//
    	Object.defineProperty(exports, "__esModule", { value: true });
    	exports.calculateNumberSize = exports.calculateStringSize = exports.isASCII = exports.isPlainObject = exports.ESCAPE_CHARACTERS_REGEXP = exports.JsonSize = exports.hasProperty = exports.isObject = exports.isNullOrUndefined = exports.isNonEmptyArray = void 0;
    	//
    	// Type Guards
    	//
    	/**
    	 * A {@link NonEmptyArray} type guard.
    	 *
    	 * @template Element - The non-empty array member type.
    	 * @param value - The value to check.
    	 * @returns Whether the value is a non-empty array.
    	 */
    	function isNonEmptyArray(value) {
    	    return Array.isArray(value) && value.length > 0;
    	}
    	exports.isNonEmptyArray = isNonEmptyArray;
    	/**
    	 * Type guard for "nullishness".
    	 *
    	 * @param value - Any value.
    	 * @returns `true` if the value is null or undefined, `false` otherwise.
    	 */
    	function isNullOrUndefined(value) {
    	    return value === null || value === undefined;
    	}
    	exports.isNullOrUndefined = isNullOrUndefined;
    	/**
    	 * A type guard for {@link RuntimeObject}.
    	 *
    	 * @param value - The value to check.
    	 * @returns Whether the specified value has a runtime type of `object` and is
    	 * neither `null` nor an `Array`.
    	 */
    	function isObject(value) {
    	    return Boolean(value) && typeof value === 'object' && !Array.isArray(value);
    	}
    	exports.isObject = isObject;
    	//
    	// Other utility functions
    	//
    	/**
    	 * A type guard for ensuring an object has a property.
    	 *
    	 * @param objectToCheck - The object to check.
    	 * @param name - The property name to check for.
    	 * @returns Whether the specified object has an own property with the specified
    	 * name, regardless of whether it is enumerable or not.
    	 */
    	const hasProperty = (objectToCheck, name) => Object.hasOwnProperty.call(objectToCheck, name);
    	exports.hasProperty = hasProperty;
    	(function (JsonSize) {
    	    JsonSize[JsonSize["Null"] = 4] = "Null";
    	    JsonSize[JsonSize["Comma"] = 1] = "Comma";
    	    JsonSize[JsonSize["Wrapper"] = 1] = "Wrapper";
    	    JsonSize[JsonSize["True"] = 4] = "True";
    	    JsonSize[JsonSize["False"] = 5] = "False";
    	    JsonSize[JsonSize["Quote"] = 1] = "Quote";
    	    JsonSize[JsonSize["Colon"] = 1] = "Colon";
    	    // eslint-disable-next-line @typescript-eslint/no-shadow
    	    JsonSize[JsonSize["Date"] = 24] = "Date";
    	})(exports.JsonSize || (exports.JsonSize = {}));
    	/**
    	 * Regular expression with pattern matching for (special) escaped characters.
    	 */
    	exports.ESCAPE_CHARACTERS_REGEXP = /"|\\|\n|\r|\t/gu;
    	/**
    	 * Check if the value is plain object.
    	 *
    	 * @param value - Value to be checked.
    	 * @returns True if an object is the plain JavaScript object,
    	 * false if the object is not plain (e.g. function).
    	 */
    	function isPlainObject(value) {
    	    if (typeof value !== 'object' || value === null) {
    	        return false;
    	    }
    	    try {
    	        let proto = value;
    	        while (Object.getPrototypeOf(proto) !== null) {
    	            proto = Object.getPrototypeOf(proto);
    	        }
    	        return Object.getPrototypeOf(value) === proto;
    	    }
    	    catch (_) {
    	        return false;
    	    }
    	}
    	exports.isPlainObject = isPlainObject;
    	/**
    	 * Check if character is ASCII.
    	 *
    	 * @param character - Character.
    	 * @returns True if a character code is ASCII, false if not.
    	 */
    	function isASCII(character) {
    	    return character.charCodeAt(0) <= 127;
    	}
    	exports.isASCII = isASCII;
    	/**
    	 * Calculate string size.
    	 *
    	 * @param value - String value to calculate size.
    	 * @returns Number of bytes used to store whole string value.
    	 */
    	function calculateStringSize(value) {
    	    var _a;
    	    const size = value.split('').reduce((total, character) => {
    	        if (isASCII(character)) {
    	            return total + 1;
    	        }
    	        return total + 2;
    	    }, 0);
    	    // Also detect characters that need backslash escape
    	    return size + ((_a = value.match(exports.ESCAPE_CHARACTERS_REGEXP)) !== null && _a !== void 0 ? _a : []).length;
    	}
    	exports.calculateStringSize = calculateStringSize;
    	/**
    	 * Calculate size of a number ofter JSON serialization.
    	 *
    	 * @param value - Number value to calculate size.
    	 * @returns Number of bytes used to store whole number in JSON.
    	 */
    	function calculateNumberSize(value) {
    	    return value.toString().length;
    	}
    	exports.calculateNumberSize = calculateNumberSize;
    	
    } (misc));

    var number = {};

    Object.defineProperty(number, "__esModule", { value: true });
    number.hexToBigInt = number.hexToNumber = number.bigIntToHex = number.numberToHex = void 0;
    const assert_1 = assert$2;
    const hex_1 = hex;
    /**
     * Convert a number to a hexadecimal string. This verifies that the number is a
     * non-negative safe integer.
     *
     * To convert a `bigint` to a hexadecimal string instead, use
     * {@link bigIntToHex}.
     *
     * @example
     * ```typescript
     * numberToHex(0); // '0x0'
     * numberToHex(1); // '0x1'
     * numberToHex(16); // '0x10'
     * ```
     * @param value - The number to convert to a hexadecimal string.
     * @returns The hexadecimal string, with the "0x"-prefix.
     * @throws If the number is not a non-negative safe integer.
     */
    const numberToHex = (value) => {
        (0, assert_1.assert)(typeof value === 'number', 'Value must be a number.');
        (0, assert_1.assert)(value >= 0, 'Value must be a non-negative number.');
        (0, assert_1.assert)(Number.isSafeInteger(value), 'Value is not a safe integer. Use `bigIntToHex` instead.');
        return (0, hex_1.add0x)(value.toString(16));
    };
    number.numberToHex = numberToHex;
    /**
     * Convert a `bigint` to a hexadecimal string. This verifies that the `bigint`
     * is a non-negative integer.
     *
     * To convert a number to a hexadecimal string instead, use {@link numberToHex}.
     *
     * @example
     * ```typescript
     * bigIntToHex(0n); // '0x0'
     * bigIntToHex(1n); // '0x1'
     * bigIntToHex(16n); // '0x10'
     * ```
     * @param value - The `bigint` to convert to a hexadecimal string.
     * @returns The hexadecimal string, with the "0x"-prefix.
     * @throws If the `bigint` is not a non-negative integer.
     */
    const bigIntToHex = (value) => {
        (0, assert_1.assert)(typeof value === 'bigint', 'Value must be a bigint.');
        (0, assert_1.assert)(value >= 0, 'Value must be a non-negative bigint.');
        return (0, hex_1.add0x)(value.toString(16));
    };
    number.bigIntToHex = bigIntToHex;
    /**
     * Convert a hexadecimal string to a number. This verifies that the string is a
     * valid hex string, and that the resulting number is a safe integer. Both
     * "0x"-prefixed and unprefixed strings are supported.
     *
     * To convert a hexadecimal string to a `bigint` instead, use
     * {@link hexToBigInt}.
     *
     * @example
     * ```typescript
     * hexToNumber('0x0'); // 0
     * hexToNumber('0x1'); // 1
     * hexToNumber('0x10'); // 16
     * ```
     * @param value - The hexadecimal string to convert to a number.
     * @returns The number.
     * @throws If the value is not a valid hexadecimal string, or if the resulting
     * number is not a safe integer.
     */
    const hexToNumber = (value) => {
        (0, hex_1.assertIsHexString)(value);
        // `parseInt` accepts values without the "0x"-prefix, whereas `Number` does
        // not. Using this is slightly faster than `Number(add0x(value))`.
        const numberValue = parseInt(value, 16);
        (0, assert_1.assert)(Number.isSafeInteger(numberValue), 'Value is not a safe integer. Use `hexToBigInt` instead.');
        return numberValue;
    };
    number.hexToNumber = hexToNumber;
    /**
     * Convert a hexadecimal string to a `bigint`. This verifies that the string is
     * a valid hex string. Both "0x"-prefixed and unprefixed strings are supported.
     *
     * To convert a hexadecimal string to a number instead, use {@link hexToNumber}.
     *
     * @example
     * ```typescript
     * hexToBigInt('0x0'); // 0n
     * hexToBigInt('0x1'); // 1n
     * hexToBigInt('0x10'); // 16n
     * ```
     * @param value - The hexadecimal string to convert to a `bigint`.
     * @returns The `bigint`.
     * @throws If the value is not a valid hexadecimal string.
     */
    const hexToBigInt = (value) => {
        (0, hex_1.assertIsHexString)(value);
        // The `BigInt` constructor requires the "0x"-prefix to parse a hex string.
        return BigInt((0, hex_1.add0x)(value));
    };
    number.hexToBigInt = hexToBigInt;

    var opaque = {};

    Object.defineProperty(opaque, "__esModule", { value: true });

    var time$1 = {};

    (function (exports) {
    	Object.defineProperty(exports, "__esModule", { value: true });
    	exports.timeSince = exports.inMilliseconds = exports.Duration = void 0;
    	(function (Duration) {
    	    /**
    	     * A millisecond.
    	     */
    	    Duration[Duration["Millisecond"] = 1] = "Millisecond";
    	    /**
    	     * A second, in milliseconds.
    	     */
    	    Duration[Duration["Second"] = 1000] = "Second";
    	    /**
    	     * A minute, in milliseconds.
    	     */
    	    Duration[Duration["Minute"] = 60000] = "Minute";
    	    /**
    	     * An hour, in milliseconds.
    	     */
    	    Duration[Duration["Hour"] = 3600000] = "Hour";
    	    /**
    	     * A day, in milliseconds.
    	     */
    	    Duration[Duration["Day"] = 86400000] = "Day";
    	    /**
    	     * A week, in milliseconds.
    	     */
    	    Duration[Duration["Week"] = 604800000] = "Week";
    	    /**
    	     * A year, in milliseconds.
    	     */
    	    Duration[Duration["Year"] = 31536000000] = "Year";
    	})(exports.Duration || (exports.Duration = {}));
    	const isNonNegativeInteger = (number) => Number.isInteger(number) && number >= 0;
    	const assertIsNonNegativeInteger = (number, name) => {
    	    if (!isNonNegativeInteger(number)) {
    	        throw new Error(`"${name}" must be a non-negative integer. Received: "${number}".`);
    	    }
    	};
    	/**
    	 * Calculates the millisecond value of the specified number of units of time.
    	 *
    	 * @param count - The number of units of time.
    	 * @param duration - The unit of time to count.
    	 * @returns The count multiplied by the specified duration.
    	 */
    	function inMilliseconds(count, duration) {
    	    assertIsNonNegativeInteger(count, 'count');
    	    return count * duration;
    	}
    	exports.inMilliseconds = inMilliseconds;
    	/**
    	 * Gets the milliseconds since a particular Unix epoch timestamp.
    	 *
    	 * @param timestamp - A Unix millisecond timestamp.
    	 * @returns The number of milliseconds elapsed since the specified timestamp.
    	 */
    	function timeSince(timestamp) {
    	    assertIsNonNegativeInteger(timestamp, 'timestamp');
    	    return Date.now() - timestamp;
    	}
    	exports.timeSince = timeSince;
    	
    } (time$1));

    var transactionTypes = {};

    Object.defineProperty(transactionTypes, "__esModule", { value: true });

    var versions = {};

    var re$3 = {exports: {}};

    // Note: this is the semver.org version of the spec that it implements
    // Not necessarily the package version of this code.
    const SEMVER_SPEC_VERSION = '2.0.0';

    const MAX_LENGTH$1 = 256;
    const MAX_SAFE_INTEGER$1 = Number.MAX_SAFE_INTEGER ||
    /* istanbul ignore next */ 9007199254740991;

    // Max safe segment length for coercion.
    const MAX_SAFE_COMPONENT_LENGTH = 16;

    // Max safe length for a build identifier. The max length minus 6 characters for
    // the shortest version with a build 0.0.0+BUILD.
    const MAX_SAFE_BUILD_LENGTH = MAX_LENGTH$1 - 6;

    const RELEASE_TYPES = [
      'major',
      'premajor',
      'minor',
      'preminor',
      'patch',
      'prepatch',
      'prerelease',
    ];

    var constants$1 = {
      MAX_LENGTH: MAX_LENGTH$1,
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_SAFE_INTEGER: MAX_SAFE_INTEGER$1,
      RELEASE_TYPES,
      SEMVER_SPEC_VERSION,
      FLAG_INCLUDE_PRERELEASE: 0b001,
      FLAG_LOOSE: 0b010,
    };

    const debug$1 = (
      typeof browser$1$1 === 'object' &&
      browser$1$1.env &&
      browser$1$1.env.NODE_DEBUG &&
      /\bsemver\b/i.test(browser$1$1.env.NODE_DEBUG)
    ) ? (...args) => console.error('SEMVER', ...args)
      : () => {};

    var debug_1 = debug$1;

    (function (module, exports) {
    	const {
    	  MAX_SAFE_COMPONENT_LENGTH,
    	  MAX_SAFE_BUILD_LENGTH,
    	  MAX_LENGTH,
    	} = constants$1;
    	const debug = debug_1;
    	exports = module.exports = {};

    	// The actual regexps go on exports.re
    	const re = exports.re = [];
    	const safeRe = exports.safeRe = [];
    	const src = exports.src = [];
    	const t = exports.t = {};
    	let R = 0;

    	const LETTERDASHNUMBER = '[a-zA-Z0-9-]';

    	// Replace some greedy regex tokens to prevent regex dos issues. These regex are
    	// used internally via the safeRe object since all inputs in this library get
    	// normalized first to trim and collapse all extra whitespace. The original
    	// regexes are exported for userland consumption and lower level usage. A
    	// future breaking change could export the safer regex only with a note that
    	// all input should have extra whitespace removed.
    	const safeRegexReplacements = [
    	  ['\\s', 1],
    	  ['\\d', MAX_LENGTH],
    	  [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH],
    	];

    	const makeSafeRegex = (value) => {
    	  for (const [token, max] of safeRegexReplacements) {
    	    value = value
    	      .split(`${token}*`).join(`${token}{0,${max}}`)
    	      .split(`${token}+`).join(`${token}{1,${max}}`);
    	  }
    	  return value
    	};

    	const createToken = (name, value, isGlobal) => {
    	  const safe = makeSafeRegex(value);
    	  const index = R++;
    	  debug(name, index, value);
    	  t[name] = index;
    	  src[index] = value;
    	  re[index] = new RegExp(value, isGlobal ? 'g' : undefined);
    	  safeRe[index] = new RegExp(safe, isGlobal ? 'g' : undefined);
    	};

    	// The following Regular Expressions can be used for tokenizing,
    	// validating, and parsing SemVer version strings.

    	// ## Numeric Identifier
    	// A single `0`, or a non-zero digit followed by zero or more digits.

    	createToken('NUMERICIDENTIFIER', '0|[1-9]\\d*');
    	createToken('NUMERICIDENTIFIERLOOSE', '\\d+');

    	// ## Non-numeric Identifier
    	// Zero or more digits, followed by a letter or hyphen, and then zero or
    	// more letters, digits, or hyphens.

    	createToken('NONNUMERICIDENTIFIER', `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);

    	// ## Main Version
    	// Three dot-separated numeric identifiers.

    	createToken('MAINVERSION', `(${src[t.NUMERICIDENTIFIER]})\\.` +
    	                   `(${src[t.NUMERICIDENTIFIER]})\\.` +
    	                   `(${src[t.NUMERICIDENTIFIER]})`);

    	createToken('MAINVERSIONLOOSE', `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` +
    	                        `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` +
    	                        `(${src[t.NUMERICIDENTIFIERLOOSE]})`);

    	// ## Pre-release Version Identifier
    	// A numeric identifier, or a non-numeric identifier.

    	createToken('PRERELEASEIDENTIFIER', `(?:${src[t.NUMERICIDENTIFIER]
	}|${src[t.NONNUMERICIDENTIFIER]})`);

    	createToken('PRERELEASEIDENTIFIERLOOSE', `(?:${src[t.NUMERICIDENTIFIERLOOSE]
	}|${src[t.NONNUMERICIDENTIFIER]})`);

    	// ## Pre-release Version
    	// Hyphen, followed by one or more dot-separated pre-release version
    	// identifiers.

    	createToken('PRERELEASE', `(?:-(${src[t.PRERELEASEIDENTIFIER]
	}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);

    	createToken('PRERELEASELOOSE', `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]
	}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);

    	// ## Build Metadata Identifier
    	// Any combination of digits, letters, or hyphens.

    	createToken('BUILDIDENTIFIER', `${LETTERDASHNUMBER}+`);

    	// ## Build Metadata
    	// Plus sign, followed by one or more period-separated build metadata
    	// identifiers.

    	createToken('BUILD', `(?:\\+(${src[t.BUILDIDENTIFIER]
	}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);

    	// ## Full Version String
    	// A main version, followed optionally by a pre-release version and
    	// build metadata.

    	// Note that the only major, minor, patch, and pre-release sections of
    	// the version string are capturing groups.  The build metadata is not a
    	// capturing group, because it should not ever be used in version
    	// comparison.

    	createToken('FULLPLAIN', `v?${src[t.MAINVERSION]
	}${src[t.PRERELEASE]}?${
	  src[t.BUILD]}?`);

    	createToken('FULL', `^${src[t.FULLPLAIN]}$`);

    	// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
    	// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
    	// common in the npm registry.
    	createToken('LOOSEPLAIN', `[v=\\s]*${src[t.MAINVERSIONLOOSE]
	}${src[t.PRERELEASELOOSE]}?${
	  src[t.BUILD]}?`);

    	createToken('LOOSE', `^${src[t.LOOSEPLAIN]}$`);

    	createToken('GTLT', '((?:<|>)?=?)');

    	// Something like "2.*" or "1.2.x".
    	// Note that "x.x" is a valid xRange identifer, meaning "any version"
    	// Only the first item is strictly required.
    	createToken('XRANGEIDENTIFIERLOOSE', `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    	createToken('XRANGEIDENTIFIER', `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);

    	createToken('XRANGEPLAIN', `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})` +
    	                   `(?:\\.(${src[t.XRANGEIDENTIFIER]})` +
    	                   `(?:\\.(${src[t.XRANGEIDENTIFIER]})` +
    	                   `(?:${src[t.PRERELEASE]})?${
	                     src[t.BUILD]}?` +
    	                   `)?)?`);

    	createToken('XRANGEPLAINLOOSE', `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` +
    	                        `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +
    	                        `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +
    	                        `(?:${src[t.PRERELEASELOOSE]})?${
	                          src[t.BUILD]}?` +
    	                        `)?)?`);

    	createToken('XRANGE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
    	createToken('XRANGELOOSE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);

    	// Coercion.
    	// Extract anything that could conceivably be a part of a valid semver
    	createToken('COERCEPLAIN', `${'(^|[^\\d])' +
	              '(\\d{1,'}${MAX_SAFE_COMPONENT_LENGTH}})` +
    	              `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +
    	              `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
    	createToken('COERCE', `${src[t.COERCEPLAIN]}(?:$|[^\\d])`);
    	createToken('COERCEFULL', src[t.COERCEPLAIN] +
    	              `(?:${src[t.PRERELEASE]})?` +
    	              `(?:${src[t.BUILD]})?` +
    	              `(?:$|[^\\d])`);
    	createToken('COERCERTL', src[t.COERCE], true);
    	createToken('COERCERTLFULL', src[t.COERCEFULL], true);

    	// Tilde ranges.
    	// Meaning is "reasonably at or greater than"
    	createToken('LONETILDE', '(?:~>?)');

    	createToken('TILDETRIM', `(\\s*)${src[t.LONETILDE]}\\s+`, true);
    	exports.tildeTrimReplace = '$1~';

    	createToken('TILDE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
    	createToken('TILDELOOSE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);

    	// Caret ranges.
    	// Meaning is "at least and backwards compatible with"
    	createToken('LONECARET', '(?:\\^)');

    	createToken('CARETTRIM', `(\\s*)${src[t.LONECARET]}\\s+`, true);
    	exports.caretTrimReplace = '$1^';

    	createToken('CARET', `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
    	createToken('CARETLOOSE', `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);

    	// A simple gt/lt/eq thing, or just "" to indicate "any version"
    	createToken('COMPARATORLOOSE', `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
    	createToken('COMPARATOR', `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);

    	// An expression to strip any whitespace between the gtlt and the thing
    	// it modifies, so that `> 1.2.3` ==> `>1.2.3`
    	createToken('COMPARATORTRIM', `(\\s*)${src[t.GTLT]
	}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
    	exports.comparatorTrimReplace = '$1$2$3';

    	// Something like `1.2.3 - 1.2.4`
    	// Note that these all use the loose form, because they'll be
    	// checked against either the strict or loose comparator form
    	// later.
    	createToken('HYPHENRANGE', `^\\s*(${src[t.XRANGEPLAIN]})` +
    	                   `\\s+-\\s+` +
    	                   `(${src[t.XRANGEPLAIN]})` +
    	                   `\\s*$`);

    	createToken('HYPHENRANGELOOSE', `^\\s*(${src[t.XRANGEPLAINLOOSE]})` +
    	                        `\\s+-\\s+` +
    	                        `(${src[t.XRANGEPLAINLOOSE]})` +
    	                        `\\s*$`);

    	// Star ranges basically just allow anything at all.
    	createToken('STAR', '(<|>)?=?\\s*\\*');
    	// >=0.0.0 is like a star
    	createToken('GTE0', '^\\s*>=\\s*0\\.0\\.0\\s*$');
    	createToken('GTE0PRE', '^\\s*>=\\s*0\\.0\\.0-0\\s*$'); 
    } (re$3, re$3.exports));

    var reExports = re$3.exports;

    // parse out just the options we care about
    const looseOption = Object.freeze({ loose: true });
    const emptyOpts = Object.freeze({ });
    const parseOptions$1 = options => {
      if (!options) {
        return emptyOpts
      }

      if (typeof options !== 'object') {
        return looseOption
      }

      return options
    };
    var parseOptions_1 = parseOptions$1;

    const numeric = /^[0-9]+$/;
    const compareIdentifiers$1 = (a, b) => {
      const anum = numeric.test(a);
      const bnum = numeric.test(b);

      if (anum && bnum) {
        a = +a;
        b = +b;
      }

      return a === b ? 0
        : (anum && !bnum) ? -1
        : (bnum && !anum) ? 1
        : a < b ? -1
        : 1
    };

    const rcompareIdentifiers = (a, b) => compareIdentifiers$1(b, a);

    var identifiers$1 = {
      compareIdentifiers: compareIdentifiers$1,
      rcompareIdentifiers,
    };

    const debug = debug_1;
    const { MAX_LENGTH, MAX_SAFE_INTEGER } = constants$1;
    const { safeRe: re$2, t: t$7 } = reExports;

    const parseOptions = parseOptions_1;
    const { compareIdentifiers } = identifiers$1;
    let SemVer$d = class SemVer {
      constructor (version, options) {
        options = parseOptions(options);

        if (version instanceof SemVer) {
          if (version.loose === !!options.loose &&
              version.includePrerelease === !!options.includePrerelease) {
            return version
          } else {
            version = version.version;
          }
        } else if (typeof version !== 'string') {
          throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version}".`)
        }

        if (version.length > MAX_LENGTH) {
          throw new TypeError(
            `version is longer than ${MAX_LENGTH} characters`
          )
        }

        debug('SemVer', version, options);
        this.options = options;
        this.loose = !!options.loose;
        // this isn't actually relevant for versions, but keep it so that we
        // don't run into trouble passing this.options around.
        this.includePrerelease = !!options.includePrerelease;

        const m = version.trim().match(options.loose ? re$2[t$7.LOOSE] : re$2[t$7.FULL]);

        if (!m) {
          throw new TypeError(`Invalid Version: ${version}`)
        }

        this.raw = version;

        // these are actually numbers
        this.major = +m[1];
        this.minor = +m[2];
        this.patch = +m[3];

        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
          throw new TypeError('Invalid major version')
        }

        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
          throw new TypeError('Invalid minor version')
        }

        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
          throw new TypeError('Invalid patch version')
        }

        // numberify any prerelease numeric ids
        if (!m[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m[4].split('.').map((id) => {
            if (/^[0-9]+$/.test(id)) {
              const num = +id;
              if (num >= 0 && num < MAX_SAFE_INTEGER) {
                return num
              }
            }
            return id
          });
        }

        this.build = m[5] ? m[5].split('.') : [];
        this.format();
      }

      format () {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
          this.version += `-${this.prerelease.join('.')}`;
        }
        return this.version
      }

      toString () {
        return this.version
      }

      compare (other) {
        debug('SemVer.compare', this.version, this.options, other);
        if (!(other instanceof SemVer)) {
          if (typeof other === 'string' && other === this.version) {
            return 0
          }
          other = new SemVer(other, this.options);
        }

        if (other.version === this.version) {
          return 0
        }

        return this.compareMain(other) || this.comparePre(other)
      }

      compareMain (other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }

        return (
          compareIdentifiers(this.major, other.major) ||
          compareIdentifiers(this.minor, other.minor) ||
          compareIdentifiers(this.patch, other.patch)
        )
      }

      comparePre (other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }

        // NOT having a prerelease is > having one
        if (this.prerelease.length && !other.prerelease.length) {
          return -1
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0
        }

        let i = 0;
        do {
          const a = this.prerelease[i];
          const b = other.prerelease[i];
          debug('prerelease compare', i, a, b);
          if (a === undefined && b === undefined) {
            return 0
          } else if (b === undefined) {
            return 1
          } else if (a === undefined) {
            return -1
          } else if (a === b) {
            continue
          } else {
            return compareIdentifiers(a, b)
          }
        } while (++i)
      }

      compareBuild (other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }

        let i = 0;
        do {
          const a = this.build[i];
          const b = other.build[i];
          debug('prerelease compare', i, a, b);
          if (a === undefined && b === undefined) {
            return 0
          } else if (b === undefined) {
            return 1
          } else if (a === undefined) {
            return -1
          } else if (a === b) {
            continue
          } else {
            return compareIdentifiers(a, b)
          }
        } while (++i)
      }

      // preminor will bump the version up to the next minor release, and immediately
      // down to pre-release. premajor and prepatch work the same way.
      inc (release, identifier, identifierBase) {
        switch (release) {
          case 'premajor':
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc('pre', identifier, identifierBase);
            break
          case 'preminor':
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc('pre', identifier, identifierBase);
            break
          case 'prepatch':
            // If this is already a prerelease, it will bump to the next version
            // drop any prereleases that might already exist, since they are not
            // relevant at this point.
            this.prerelease.length = 0;
            this.inc('patch', identifier, identifierBase);
            this.inc('pre', identifier, identifierBase);
            break
          // If the input is a non-prerelease version, this acts the same as
          // prepatch.
          case 'prerelease':
            if (this.prerelease.length === 0) {
              this.inc('patch', identifier, identifierBase);
            }
            this.inc('pre', identifier, identifierBase);
            break

          case 'major':
            // If this is a pre-major version, bump up to the same major version.
            // Otherwise increment major.
            // 1.0.0-5 bumps to 1.0.0
            // 1.1.0 bumps to 2.0.0
            if (
              this.minor !== 0 ||
              this.patch !== 0 ||
              this.prerelease.length === 0
            ) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break
          case 'minor':
            // If this is a pre-minor version, bump up to the same minor version.
            // Otherwise increment minor.
            // 1.2.0-5 bumps to 1.2.0
            // 1.2.1 bumps to 1.3.0
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break
          case 'patch':
            // If this is not a pre-release version, it will increment the patch.
            // If it is a pre-release it will bump up to the same patch version.
            // 1.2.0-5 patches to 1.2.0
            // 1.2.0 patches to 1.2.1
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break
          // This probably shouldn't be used publicly.
          // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
          case 'pre': {
            const base = Number(identifierBase) ? 1 : 0;

            if (!identifier && identifierBase === false) {
              throw new Error('invalid increment argument: identifier is empty')
            }

            if (this.prerelease.length === 0) {
              this.prerelease = [base];
            } else {
              let i = this.prerelease.length;
              while (--i >= 0) {
                if (typeof this.prerelease[i] === 'number') {
                  this.prerelease[i]++;
                  i = -2;
                }
              }
              if (i === -1) {
                // didn't increment anything
                if (identifier === this.prerelease.join('.') && identifierBase === false) {
                  throw new Error('invalid increment argument: identifier already exists')
                }
                this.prerelease.push(base);
              }
            }
            if (identifier) {
              // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
              // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
              let prerelease = [identifier, base];
              if (identifierBase === false) {
                prerelease = [identifier];
              }
              if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = prerelease;
                }
              } else {
                this.prerelease = prerelease;
              }
            }
            break
          }
          default:
            throw new Error(`invalid increment argument: ${release}`)
        }
        this.raw = this.format();
        if (this.build.length) {
          this.raw += `+${this.build.join('.')}`;
        }
        return this
      }
    };

    var semver$1 = SemVer$d;

    const SemVer$c = semver$1;
    const parse$6 = (version, options, throwErrors = false) => {
      if (version instanceof SemVer$c) {
        return version
      }
      try {
        return new SemVer$c(version, options)
      } catch (er) {
        if (!throwErrors) {
          return null
        }
        throw er
      }
    };

    var parse_1 = parse$6;

    const parse$5 = parse_1;
    const valid$2 = (version, options) => {
      const v = parse$5(version, options);
      return v ? v.version : null
    };
    var valid_1 = valid$2;

    const parse$4 = parse_1;
    const clean$1 = (version, options) => {
      const s = parse$4(version.trim().replace(/^[=v]+/, ''), options);
      return s ? s.version : null
    };
    var clean_1 = clean$1;

    const SemVer$b = semver$1;

    const inc$1 = (version, release, options, identifier, identifierBase) => {
      if (typeof (options) === 'string') {
        identifierBase = identifier;
        identifier = options;
        options = undefined;
      }

      try {
        return new SemVer$b(
          version instanceof SemVer$b ? version.version : version,
          options
        ).inc(release, identifier, identifierBase).version
      } catch (er) {
        return null
      }
    };
    var inc_1 = inc$1;

    const parse$3 = parse_1;

    const diff$1 = (version1, version2) => {
      const v1 = parse$3(version1, null, true);
      const v2 = parse$3(version2, null, true);
      const comparison = v1.compare(v2);

      if (comparison === 0) {
        return null
      }

      const v1Higher = comparison > 0;
      const highVersion = v1Higher ? v1 : v2;
      const lowVersion = v1Higher ? v2 : v1;
      const highHasPre = !!highVersion.prerelease.length;
      const lowHasPre = !!lowVersion.prerelease.length;

      if (lowHasPre && !highHasPre) {
        // Going from prerelease -> no prerelease requires some special casing

        // If the low version has only a major, then it will always be a major
        // Some examples:
        // 1.0.0-1 -> 1.0.0
        // 1.0.0-1 -> 1.1.1
        // 1.0.0-1 -> 2.0.0
        if (!lowVersion.patch && !lowVersion.minor) {
          return 'major'
        }

        // Otherwise it can be determined by checking the high version

        if (highVersion.patch) {
          // anything higher than a patch bump would result in the wrong version
          return 'patch'
        }

        if (highVersion.minor) {
          // anything higher than a minor bump would result in the wrong version
          return 'minor'
        }

        // bumping major/minor/patch all have same result
        return 'major'
      }

      // add the `pre` prefix if we are going to a prerelease version
      const prefix = highHasPre ? 'pre' : '';

      if (v1.major !== v2.major) {
        return prefix + 'major'
      }

      if (v1.minor !== v2.minor) {
        return prefix + 'minor'
      }

      if (v1.patch !== v2.patch) {
        return prefix + 'patch'
      }

      // high and low are preleases
      return 'prerelease'
    };

    var diff_1 = diff$1;

    const SemVer$a = semver$1;
    const major$1 = (a, loose) => new SemVer$a(a, loose).major;
    var major_1 = major$1;

    const SemVer$9 = semver$1;
    const minor$1 = (a, loose) => new SemVer$9(a, loose).minor;
    var minor_1 = minor$1;

    const SemVer$8 = semver$1;
    const patch$1 = (a, loose) => new SemVer$8(a, loose).patch;
    var patch_1 = patch$1;

    const parse$2 = parse_1;
    const prerelease$1 = (version, options) => {
      const parsed = parse$2(version, options);
      return (parsed && parsed.prerelease.length) ? parsed.prerelease : null
    };
    var prerelease_1 = prerelease$1;

    const SemVer$7 = semver$1;
    const compare$b = (a, b, loose) =>
      new SemVer$7(a, loose).compare(new SemVer$7(b, loose));

    var compare_1 = compare$b;

    const compare$a = compare_1;
    const rcompare$1 = (a, b, loose) => compare$a(b, a, loose);
    var rcompare_1 = rcompare$1;

    const compare$9 = compare_1;
    const compareLoose$1 = (a, b) => compare$9(a, b, true);
    var compareLoose_1 = compareLoose$1;

    const SemVer$6 = semver$1;
    const compareBuild$3 = (a, b, loose) => {
      const versionA = new SemVer$6(a, loose);
      const versionB = new SemVer$6(b, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB)
    };
    var compareBuild_1 = compareBuild$3;

    const compareBuild$2 = compareBuild_1;
    const sort$1 = (list, loose) => list.sort((a, b) => compareBuild$2(a, b, loose));
    var sort_1 = sort$1;

    const compareBuild$1 = compareBuild_1;
    const rsort$1 = (list, loose) => list.sort((a, b) => compareBuild$1(b, a, loose));
    var rsort_1 = rsort$1;

    const compare$8 = compare_1;
    const gt$5 = (a, b, loose) => compare$8(a, b, loose) > 0;
    var gt_1 = gt$5;

    const compare$7 = compare_1;
    const lt$4 = (a, b, loose) => compare$7(a, b, loose) < 0;
    var lt_1 = lt$4;

    const compare$6 = compare_1;
    const eq$2 = (a, b, loose) => compare$6(a, b, loose) === 0;
    var eq_1 = eq$2;

    const compare$5 = compare_1;
    const neq$2 = (a, b, loose) => compare$5(a, b, loose) !== 0;
    var neq_1 = neq$2;

    const compare$4 = compare_1;
    const gte$3 = (a, b, loose) => compare$4(a, b, loose) >= 0;
    var gte_1 = gte$3;

    const compare$3 = compare_1;
    const lte$3 = (a, b, loose) => compare$3(a, b, loose) <= 0;
    var lte_1 = lte$3;

    const eq$1 = eq_1;
    const neq$1 = neq_1;
    const gt$4 = gt_1;
    const gte$2 = gte_1;
    const lt$3 = lt_1;
    const lte$2 = lte_1;

    const cmp$1 = (a, op, b, loose) => {
      switch (op) {
        case '===':
          if (typeof a === 'object') {
            a = a.version;
          }
          if (typeof b === 'object') {
            b = b.version;
          }
          return a === b

        case '!==':
          if (typeof a === 'object') {
            a = a.version;
          }
          if (typeof b === 'object') {
            b = b.version;
          }
          return a !== b

        case '':
        case '=':
        case '==':
          return eq$1(a, b, loose)

        case '!=':
          return neq$1(a, b, loose)

        case '>':
          return gt$4(a, b, loose)

        case '>=':
          return gte$2(a, b, loose)

        case '<':
          return lt$3(a, b, loose)

        case '<=':
          return lte$2(a, b, loose)

        default:
          throw new TypeError(`Invalid operator: ${op}`)
      }
    };
    var cmp_1 = cmp$1;

    const SemVer$5 = semver$1;
    const parse$1 = parse_1;
    const { safeRe: re$1, t: t$6 } = reExports;

    const coerce$1 = (version, options) => {
      if (version instanceof SemVer$5) {
        return version
      }

      if (typeof version === 'number') {
        version = String(version);
      }

      if (typeof version !== 'string') {
        return null
      }

      options = options || {};

      let match = null;
      if (!options.rtl) {
        match = version.match(options.includePrerelease ? re$1[t$6.COERCEFULL] : re$1[t$6.COERCE]);
      } else {
        // Find the right-most coercible string that does not share
        // a terminus with a more left-ward coercible string.
        // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'
        // With includePrerelease option set, '1.2.3.4-rc' wants to coerce '2.3.4-rc', not '2.3.4'
        //
        // Walk through the string checking with a /g regexp
        // Manually set the index so as to pick up overlapping matches.
        // Stop when we get a match that ends at the string end, since no
        // coercible string can be more right-ward without the same terminus.
        const coerceRtlRegex = options.includePrerelease ? re$1[t$6.COERCERTLFULL] : re$1[t$6.COERCERTL];
        let next;
        while ((next = coerceRtlRegex.exec(version)) &&
            (!match || match.index + match[0].length !== version.length)
        ) {
          if (!match ||
                next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }
          coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
        }
        // leave it in a clean state
        coerceRtlRegex.lastIndex = -1;
      }

      if (match === null) {
        return null
      }

      const major = match[2];
      const minor = match[3] || '0';
      const patch = match[4] || '0';
      const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : '';
      const build = options.includePrerelease && match[6] ? `+${match[6]}` : '';

      return parse$1(`${major}.${minor}.${patch}${prerelease}${build}`, options)
    };
    var coerce_1 = coerce$1;

    var iterator;
    var hasRequiredIterator;

    function requireIterator () {
    	if (hasRequiredIterator) return iterator;
    	hasRequiredIterator = 1;
    	iterator = function (Yallist) {
    	  Yallist.prototype[Symbol.iterator] = function* () {
    	    for (let walker = this.head; walker; walker = walker.next) {
    	      yield walker.value;
    	    }
    	  };
    	};
    	return iterator;
    }

    var yallist;
    var hasRequiredYallist;

    function requireYallist () {
    	if (hasRequiredYallist) return yallist;
    	hasRequiredYallist = 1;
    	yallist = Yallist;

    	Yallist.Node = Node;
    	Yallist.create = Yallist;

    	function Yallist (list) {
    	  var self = this;
    	  if (!(self instanceof Yallist)) {
    	    self = new Yallist();
    	  }

    	  self.tail = null;
    	  self.head = null;
    	  self.length = 0;

    	  if (list && typeof list.forEach === 'function') {
    	    list.forEach(function (item) {
    	      self.push(item);
    	    });
    	  } else if (arguments.length > 0) {
    	    for (var i = 0, l = arguments.length; i < l; i++) {
    	      self.push(arguments[i]);
    	    }
    	  }

    	  return self
    	}

    	Yallist.prototype.removeNode = function (node) {
    	  if (node.list !== this) {
    	    throw new Error('removing node which does not belong to this list')
    	  }

    	  var next = node.next;
    	  var prev = node.prev;

    	  if (next) {
    	    next.prev = prev;
    	  }

    	  if (prev) {
    	    prev.next = next;
    	  }

    	  if (node === this.head) {
    	    this.head = next;
    	  }
    	  if (node === this.tail) {
    	    this.tail = prev;
    	  }

    	  node.list.length--;
    	  node.next = null;
    	  node.prev = null;
    	  node.list = null;

    	  return next
    	};

    	Yallist.prototype.unshiftNode = function (node) {
    	  if (node === this.head) {
    	    return
    	  }

    	  if (node.list) {
    	    node.list.removeNode(node);
    	  }

    	  var head = this.head;
    	  node.list = this;
    	  node.next = head;
    	  if (head) {
    	    head.prev = node;
    	  }

    	  this.head = node;
    	  if (!this.tail) {
    	    this.tail = node;
    	  }
    	  this.length++;
    	};

    	Yallist.prototype.pushNode = function (node) {
    	  if (node === this.tail) {
    	    return
    	  }

    	  if (node.list) {
    	    node.list.removeNode(node);
    	  }

    	  var tail = this.tail;
    	  node.list = this;
    	  node.prev = tail;
    	  if (tail) {
    	    tail.next = node;
    	  }

    	  this.tail = node;
    	  if (!this.head) {
    	    this.head = node;
    	  }
    	  this.length++;
    	};

    	Yallist.prototype.push = function () {
    	  for (var i = 0, l = arguments.length; i < l; i++) {
    	    push(this, arguments[i]);
    	  }
    	  return this.length
    	};

    	Yallist.prototype.unshift = function () {
    	  for (var i = 0, l = arguments.length; i < l; i++) {
    	    unshift(this, arguments[i]);
    	  }
    	  return this.length
    	};

    	Yallist.prototype.pop = function () {
    	  if (!this.tail) {
    	    return undefined
    	  }

    	  var res = this.tail.value;
    	  this.tail = this.tail.prev;
    	  if (this.tail) {
    	    this.tail.next = null;
    	  } else {
    	    this.head = null;
    	  }
    	  this.length--;
    	  return res
    	};

    	Yallist.prototype.shift = function () {
    	  if (!this.head) {
    	    return undefined
    	  }

    	  var res = this.head.value;
    	  this.head = this.head.next;
    	  if (this.head) {
    	    this.head.prev = null;
    	  } else {
    	    this.tail = null;
    	  }
    	  this.length--;
    	  return res
    	};

    	Yallist.prototype.forEach = function (fn, thisp) {
    	  thisp = thisp || this;
    	  for (var walker = this.head, i = 0; walker !== null; i++) {
    	    fn.call(thisp, walker.value, i, this);
    	    walker = walker.next;
    	  }
    	};

    	Yallist.prototype.forEachReverse = function (fn, thisp) {
    	  thisp = thisp || this;
    	  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
    	    fn.call(thisp, walker.value, i, this);
    	    walker = walker.prev;
    	  }
    	};

    	Yallist.prototype.get = function (n) {
    	  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
    	    // abort out of the list early if we hit a cycle
    	    walker = walker.next;
    	  }
    	  if (i === n && walker !== null) {
    	    return walker.value
    	  }
    	};

    	Yallist.prototype.getReverse = function (n) {
    	  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
    	    // abort out of the list early if we hit a cycle
    	    walker = walker.prev;
    	  }
    	  if (i === n && walker !== null) {
    	    return walker.value
    	  }
    	};

    	Yallist.prototype.map = function (fn, thisp) {
    	  thisp = thisp || this;
    	  var res = new Yallist();
    	  for (var walker = this.head; walker !== null;) {
    	    res.push(fn.call(thisp, walker.value, this));
    	    walker = walker.next;
    	  }
    	  return res
    	};

    	Yallist.prototype.mapReverse = function (fn, thisp) {
    	  thisp = thisp || this;
    	  var res = new Yallist();
    	  for (var walker = this.tail; walker !== null;) {
    	    res.push(fn.call(thisp, walker.value, this));
    	    walker = walker.prev;
    	  }
    	  return res
    	};

    	Yallist.prototype.reduce = function (fn, initial) {
    	  var acc;
    	  var walker = this.head;
    	  if (arguments.length > 1) {
    	    acc = initial;
    	  } else if (this.head) {
    	    walker = this.head.next;
    	    acc = this.head.value;
    	  } else {
    	    throw new TypeError('Reduce of empty list with no initial value')
    	  }

    	  for (var i = 0; walker !== null; i++) {
    	    acc = fn(acc, walker.value, i);
    	    walker = walker.next;
    	  }

    	  return acc
    	};

    	Yallist.prototype.reduceReverse = function (fn, initial) {
    	  var acc;
    	  var walker = this.tail;
    	  if (arguments.length > 1) {
    	    acc = initial;
    	  } else if (this.tail) {
    	    walker = this.tail.prev;
    	    acc = this.tail.value;
    	  } else {
    	    throw new TypeError('Reduce of empty list with no initial value')
    	  }

    	  for (var i = this.length - 1; walker !== null; i--) {
    	    acc = fn(acc, walker.value, i);
    	    walker = walker.prev;
    	  }

    	  return acc
    	};

    	Yallist.prototype.toArray = function () {
    	  var arr = new Array(this.length);
    	  for (var i = 0, walker = this.head; walker !== null; i++) {
    	    arr[i] = walker.value;
    	    walker = walker.next;
    	  }
    	  return arr
    	};

    	Yallist.prototype.toArrayReverse = function () {
    	  var arr = new Array(this.length);
    	  for (var i = 0, walker = this.tail; walker !== null; i++) {
    	    arr[i] = walker.value;
    	    walker = walker.prev;
    	  }
    	  return arr
    	};

    	Yallist.prototype.slice = function (from, to) {
    	  to = to || this.length;
    	  if (to < 0) {
    	    to += this.length;
    	  }
    	  from = from || 0;
    	  if (from < 0) {
    	    from += this.length;
    	  }
    	  var ret = new Yallist();
    	  if (to < from || to < 0) {
    	    return ret
    	  }
    	  if (from < 0) {
    	    from = 0;
    	  }
    	  if (to > this.length) {
    	    to = this.length;
    	  }
    	  for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
    	    walker = walker.next;
    	  }
    	  for (; walker !== null && i < to; i++, walker = walker.next) {
    	    ret.push(walker.value);
    	  }
    	  return ret
    	};

    	Yallist.prototype.sliceReverse = function (from, to) {
    	  to = to || this.length;
    	  if (to < 0) {
    	    to += this.length;
    	  }
    	  from = from || 0;
    	  if (from < 0) {
    	    from += this.length;
    	  }
    	  var ret = new Yallist();
    	  if (to < from || to < 0) {
    	    return ret
    	  }
    	  if (from < 0) {
    	    from = 0;
    	  }
    	  if (to > this.length) {
    	    to = this.length;
    	  }
    	  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
    	    walker = walker.prev;
    	  }
    	  for (; walker !== null && i > from; i--, walker = walker.prev) {
    	    ret.push(walker.value);
    	  }
    	  return ret
    	};

    	Yallist.prototype.splice = function (start, deleteCount, ...nodes) {
    	  if (start > this.length) {
    	    start = this.length - 1;
    	  }
    	  if (start < 0) {
    	    start = this.length + start;
    	  }

    	  for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
    	    walker = walker.next;
    	  }

    	  var ret = [];
    	  for (var i = 0; walker && i < deleteCount; i++) {
    	    ret.push(walker.value);
    	    walker = this.removeNode(walker);
    	  }
    	  if (walker === null) {
    	    walker = this.tail;
    	  }

    	  if (walker !== this.head && walker !== this.tail) {
    	    walker = walker.prev;
    	  }

    	  for (var i = 0; i < nodes.length; i++) {
    	    walker = insert(this, walker, nodes[i]);
    	  }
    	  return ret;
    	};

    	Yallist.prototype.reverse = function () {
    	  var head = this.head;
    	  var tail = this.tail;
    	  for (var walker = head; walker !== null; walker = walker.prev) {
    	    var p = walker.prev;
    	    walker.prev = walker.next;
    	    walker.next = p;
    	  }
    	  this.head = tail;
    	  this.tail = head;
    	  return this
    	};

    	function insert (self, node, value) {
    	  var inserted = node === self.head ?
    	    new Node(value, null, node, self) :
    	    new Node(value, node, node.next, self);

    	  if (inserted.next === null) {
    	    self.tail = inserted;
    	  }
    	  if (inserted.prev === null) {
    	    self.head = inserted;
    	  }

    	  self.length++;

    	  return inserted
    	}

    	function push (self, item) {
    	  self.tail = new Node(item, self.tail, null, self);
    	  if (!self.head) {
    	    self.head = self.tail;
    	  }
    	  self.length++;
    	}

    	function unshift (self, item) {
    	  self.head = new Node(item, null, self.head, self);
    	  if (!self.tail) {
    	    self.tail = self.head;
    	  }
    	  self.length++;
    	}

    	function Node (value, prev, next, list) {
    	  if (!(this instanceof Node)) {
    	    return new Node(value, prev, next, list)
    	  }

    	  this.list = list;
    	  this.value = value;

    	  if (prev) {
    	    prev.next = this;
    	    this.prev = prev;
    	  } else {
    	    this.prev = null;
    	  }

    	  if (next) {
    	    next.prev = this;
    	    this.next = next;
    	  } else {
    	    this.next = null;
    	  }
    	}

    	try {
    	  // add if support for Symbol.iterator is present
    	  requireIterator()(Yallist);
    	} catch (er) {}
    	return yallist;
    }

    var lruCache;
    var hasRequiredLruCache;

    function requireLruCache () {
    	if (hasRequiredLruCache) return lruCache;
    	hasRequiredLruCache = 1;

    	// A linked list to keep track of recently-used-ness
    	const Yallist = requireYallist();

    	const MAX = Symbol('max');
    	const LENGTH = Symbol('length');
    	const LENGTH_CALCULATOR = Symbol('lengthCalculator');
    	const ALLOW_STALE = Symbol('allowStale');
    	const MAX_AGE = Symbol('maxAge');
    	const DISPOSE = Symbol('dispose');
    	const NO_DISPOSE_ON_SET = Symbol('noDisposeOnSet');
    	const LRU_LIST = Symbol('lruList');
    	const CACHE = Symbol('cache');
    	const UPDATE_AGE_ON_GET = Symbol('updateAgeOnGet');

    	const naiveLength = () => 1;

    	// lruList is a yallist where the head is the youngest
    	// item, and the tail is the oldest.  the list contains the Hit
    	// objects as the entries.
    	// Each Hit object has a reference to its Yallist.Node.  This
    	// never changes.
    	//
    	// cache is a Map (or PseudoMap) that matches the keys to
    	// the Yallist.Node object.
    	class LRUCache {
    	  constructor (options) {
    	    if (typeof options === 'number')
    	      options = { max: options };

    	    if (!options)
    	      options = {};

    	    if (options.max && (typeof options.max !== 'number' || options.max < 0))
    	      throw new TypeError('max must be a non-negative number')
    	    // Kind of weird to have a default max of Infinity, but oh well.
    	    this[MAX] = options.max || Infinity;

    	    const lc = options.length || naiveLength;
    	    this[LENGTH_CALCULATOR] = (typeof lc !== 'function') ? naiveLength : lc;
    	    this[ALLOW_STALE] = options.stale || false;
    	    if (options.maxAge && typeof options.maxAge !== 'number')
    	      throw new TypeError('maxAge must be a number')
    	    this[MAX_AGE] = options.maxAge || 0;
    	    this[DISPOSE] = options.dispose;
    	    this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
    	    this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
    	    this.reset();
    	  }

    	  // resize the cache when the max changes.
    	  set max (mL) {
    	    if (typeof mL !== 'number' || mL < 0)
    	      throw new TypeError('max must be a non-negative number')

    	    this[MAX] = mL || Infinity;
    	    trim(this);
    	  }
    	  get max () {
    	    return this[MAX]
    	  }

    	  set allowStale (allowStale) {
    	    this[ALLOW_STALE] = !!allowStale;
    	  }
    	  get allowStale () {
    	    return this[ALLOW_STALE]
    	  }

    	  set maxAge (mA) {
    	    if (typeof mA !== 'number')
    	      throw new TypeError('maxAge must be a non-negative number')

    	    this[MAX_AGE] = mA;
    	    trim(this);
    	  }
    	  get maxAge () {
    	    return this[MAX_AGE]
    	  }

    	  // resize the cache when the lengthCalculator changes.
    	  set lengthCalculator (lC) {
    	    if (typeof lC !== 'function')
    	      lC = naiveLength;

    	    if (lC !== this[LENGTH_CALCULATOR]) {
    	      this[LENGTH_CALCULATOR] = lC;
    	      this[LENGTH] = 0;
    	      this[LRU_LIST].forEach(hit => {
    	        hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
    	        this[LENGTH] += hit.length;
    	      });
    	    }
    	    trim(this);
    	  }
    	  get lengthCalculator () { return this[LENGTH_CALCULATOR] }

    	  get length () { return this[LENGTH] }
    	  get itemCount () { return this[LRU_LIST].length }

    	  rforEach (fn, thisp) {
    	    thisp = thisp || this;
    	    for (let walker = this[LRU_LIST].tail; walker !== null;) {
    	      const prev = walker.prev;
    	      forEachStep(this, fn, walker, thisp);
    	      walker = prev;
    	    }
    	  }

    	  forEach (fn, thisp) {
    	    thisp = thisp || this;
    	    for (let walker = this[LRU_LIST].head; walker !== null;) {
    	      const next = walker.next;
    	      forEachStep(this, fn, walker, thisp);
    	      walker = next;
    	    }
    	  }

    	  keys () {
    	    return this[LRU_LIST].toArray().map(k => k.key)
    	  }

    	  values () {
    	    return this[LRU_LIST].toArray().map(k => k.value)
    	  }

    	  reset () {
    	    if (this[DISPOSE] &&
    	        this[LRU_LIST] &&
    	        this[LRU_LIST].length) {
    	      this[LRU_LIST].forEach(hit => this[DISPOSE](hit.key, hit.value));
    	    }

    	    this[CACHE] = new Map(); // hash of items by key
    	    this[LRU_LIST] = new Yallist(); // list of items in order of use recency
    	    this[LENGTH] = 0; // length of items in the list
    	  }

    	  dump () {
    	    return this[LRU_LIST].map(hit =>
    	      isStale(this, hit) ? false : {
    	        k: hit.key,
    	        v: hit.value,
    	        e: hit.now + (hit.maxAge || 0)
    	      }).toArray().filter(h => h)
    	  }

    	  dumpLru () {
    	    return this[LRU_LIST]
    	  }

    	  set (key, value, maxAge) {
    	    maxAge = maxAge || this[MAX_AGE];

    	    if (maxAge && typeof maxAge !== 'number')
    	      throw new TypeError('maxAge must be a number')

    	    const now = maxAge ? Date.now() : 0;
    	    const len = this[LENGTH_CALCULATOR](value, key);

    	    if (this[CACHE].has(key)) {
    	      if (len > this[MAX]) {
    	        del(this, this[CACHE].get(key));
    	        return false
    	      }

    	      const node = this[CACHE].get(key);
    	      const item = node.value;

    	      // dispose of the old one before overwriting
    	      // split out into 2 ifs for better coverage tracking
    	      if (this[DISPOSE]) {
    	        if (!this[NO_DISPOSE_ON_SET])
    	          this[DISPOSE](key, item.value);
    	      }

    	      item.now = now;
    	      item.maxAge = maxAge;
    	      item.value = value;
    	      this[LENGTH] += len - item.length;
    	      item.length = len;
    	      this.get(key);
    	      trim(this);
    	      return true
    	    }

    	    const hit = new Entry(key, value, len, now, maxAge);

    	    // oversized objects fall out of cache automatically.
    	    if (hit.length > this[MAX]) {
    	      if (this[DISPOSE])
    	        this[DISPOSE](key, value);

    	      return false
    	    }

    	    this[LENGTH] += hit.length;
    	    this[LRU_LIST].unshift(hit);
    	    this[CACHE].set(key, this[LRU_LIST].head);
    	    trim(this);
    	    return true
    	  }

    	  has (key) {
    	    if (!this[CACHE].has(key)) return false
    	    const hit = this[CACHE].get(key).value;
    	    return !isStale(this, hit)
    	  }

    	  get (key) {
    	    return get(this, key, true)
    	  }

    	  peek (key) {
    	    return get(this, key, false)
    	  }

    	  pop () {
    	    const node = this[LRU_LIST].tail;
    	    if (!node)
    	      return null

    	    del(this, node);
    	    return node.value
    	  }

    	  del (key) {
    	    del(this, this[CACHE].get(key));
    	  }

    	  load (arr) {
    	    // reset the cache
    	    this.reset();

    	    const now = Date.now();
    	    // A previous serialized cache has the most recent items first
    	    for (let l = arr.length - 1; l >= 0; l--) {
    	      const hit = arr[l];
    	      const expiresAt = hit.e || 0;
    	      if (expiresAt === 0)
    	        // the item was created without expiration in a non aged cache
    	        this.set(hit.k, hit.v);
    	      else {
    	        const maxAge = expiresAt - now;
    	        // dont add already expired items
    	        if (maxAge > 0) {
    	          this.set(hit.k, hit.v, maxAge);
    	        }
    	      }
    	    }
    	  }

    	  prune () {
    	    this[CACHE].forEach((value, key) => get(this, key, false));
    	  }
    	}

    	const get = (self, key, doUse) => {
    	  const node = self[CACHE].get(key);
    	  if (node) {
    	    const hit = node.value;
    	    if (isStale(self, hit)) {
    	      del(self, node);
    	      if (!self[ALLOW_STALE])
    	        return undefined
    	    } else {
    	      if (doUse) {
    	        if (self[UPDATE_AGE_ON_GET])
    	          node.value.now = Date.now();
    	        self[LRU_LIST].unshiftNode(node);
    	      }
    	    }
    	    return hit.value
    	  }
    	};

    	const isStale = (self, hit) => {
    	  if (!hit || (!hit.maxAge && !self[MAX_AGE]))
    	    return false

    	  const diff = Date.now() - hit.now;
    	  return hit.maxAge ? diff > hit.maxAge
    	    : self[MAX_AGE] && (diff > self[MAX_AGE])
    	};

    	const trim = self => {
    	  if (self[LENGTH] > self[MAX]) {
    	    for (let walker = self[LRU_LIST].tail;
    	      self[LENGTH] > self[MAX] && walker !== null;) {
    	      // We know that we're about to delete this one, and also
    	      // what the next least recently used key will be, so just
    	      // go ahead and set it now.
    	      const prev = walker.prev;
    	      del(self, walker);
    	      walker = prev;
    	    }
    	  }
    	};

    	const del = (self, node) => {
    	  if (node) {
    	    const hit = node.value;
    	    if (self[DISPOSE])
    	      self[DISPOSE](hit.key, hit.value);

    	    self[LENGTH] -= hit.length;
    	    self[CACHE].delete(hit.key);
    	    self[LRU_LIST].removeNode(node);
    	  }
    	};

    	class Entry {
    	  constructor (key, value, length, now, maxAge) {
    	    this.key = key;
    	    this.value = value;
    	    this.length = length;
    	    this.now = now;
    	    this.maxAge = maxAge || 0;
    	  }
    	}

    	const forEachStep = (self, fn, node, thisp) => {
    	  let hit = node.value;
    	  if (isStale(self, hit)) {
    	    del(self, node);
    	    if (!self[ALLOW_STALE])
    	      hit = undefined;
    	  }
    	  if (hit)
    	    fn.call(thisp, hit.value, hit.key, self);
    	};

    	lruCache = LRUCache;
    	return lruCache;
    }

    var range;
    var hasRequiredRange;

    function requireRange () {
    	if (hasRequiredRange) return range;
    	hasRequiredRange = 1;
    	// hoisted class for cyclic dependency
    	class Range {
    	  constructor (range, options) {
    	    options = parseOptions(options);

    	    if (range instanceof Range) {
    	      if (
    	        range.loose === !!options.loose &&
    	        range.includePrerelease === !!options.includePrerelease
    	      ) {
    	        return range
    	      } else {
    	        return new Range(range.raw, options)
    	      }
    	    }

    	    if (range instanceof Comparator) {
    	      // just put it in the set and return
    	      this.raw = range.value;
    	      this.set = [[range]];
    	      this.format();
    	      return this
    	    }

    	    this.options = options;
    	    this.loose = !!options.loose;
    	    this.includePrerelease = !!options.includePrerelease;

    	    // First reduce all whitespace as much as possible so we do not have to rely
    	    // on potentially slow regexes like \s*. This is then stored and used for
    	    // future error messages as well.
    	    this.raw = range
    	      .trim()
    	      .split(/\s+/)
    	      .join(' ');

    	    // First, split on ||
    	    this.set = this.raw
    	      .split('||')
    	      // map the range to a 2d array of comparators
    	      .map(r => this.parseRange(r.trim()))
    	      // throw out any comparator lists that are empty
    	      // this generally means that it was not a valid range, which is allowed
    	      // in loose mode, but will still throw if the WHOLE range is invalid.
    	      .filter(c => c.length);

    	    if (!this.set.length) {
    	      throw new TypeError(`Invalid SemVer Range: ${this.raw}`)
    	    }

    	    // if we have any that are not the null set, throw out null sets.
    	    if (this.set.length > 1) {
    	      // keep the first one, in case they're all null sets
    	      const first = this.set[0];
    	      this.set = this.set.filter(c => !isNullSet(c[0]));
    	      if (this.set.length === 0) {
    	        this.set = [first];
    	      } else if (this.set.length > 1) {
    	        // if we have any that are *, then the range is just *
    	        for (const c of this.set) {
    	          if (c.length === 1 && isAny(c[0])) {
    	            this.set = [c];
    	            break
    	          }
    	        }
    	      }
    	    }

    	    this.format();
    	  }

    	  format () {
    	    this.range = this.set
    	      .map((comps) => comps.join(' ').trim())
    	      .join('||')
    	      .trim();
    	    return this.range
    	  }

    	  toString () {
    	    return this.range
    	  }

    	  parseRange (range) {
    	    // memoize range parsing for performance.
    	    // this is a very hot path, and fully deterministic.
    	    const memoOpts =
    	      (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) |
    	      (this.options.loose && FLAG_LOOSE);
    	    const memoKey = memoOpts + ':' + range;
    	    const cached = cache.get(memoKey);
    	    if (cached) {
    	      return cached
    	    }

    	    const loose = this.options.loose;
    	    // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
    	    const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
    	    range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
    	    debug('hyphen replace', range);

    	    // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
    	    range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
    	    debug('comparator trim', range);

    	    // `~ 1.2.3` => `~1.2.3`
    	    range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
    	    debug('tilde trim', range);

    	    // `^ 1.2.3` => `^1.2.3`
    	    range = range.replace(re[t.CARETTRIM], caretTrimReplace);
    	    debug('caret trim', range);

    	    // At this point, the range is completely trimmed and
    	    // ready to be split into comparators.

    	    let rangeList = range
    	      .split(' ')
    	      .map(comp => parseComparator(comp, this.options))
    	      .join(' ')
    	      .split(/\s+/)
    	      // >=0.0.0 is equivalent to *
    	      .map(comp => replaceGTE0(comp, this.options));

    	    if (loose) {
    	      // in loose mode, throw out any that are not valid comparators
    	      rangeList = rangeList.filter(comp => {
    	        debug('loose invalid filter', comp, this.options);
    	        return !!comp.match(re[t.COMPARATORLOOSE])
    	      });
    	    }
    	    debug('range list', rangeList);

    	    // if any comparators are the null set, then replace with JUST null set
    	    // if more than one comparator, remove any * comparators
    	    // also, don't include the same comparator more than once
    	    const rangeMap = new Map();
    	    const comparators = rangeList.map(comp => new Comparator(comp, this.options));
    	    for (const comp of comparators) {
    	      if (isNullSet(comp)) {
    	        return [comp]
    	      }
    	      rangeMap.set(comp.value, comp);
    	    }
    	    if (rangeMap.size > 1 && rangeMap.has('')) {
    	      rangeMap.delete('');
    	    }

    	    const result = [...rangeMap.values()];
    	    cache.set(memoKey, result);
    	    return result
    	  }

    	  intersects (range, options) {
    	    if (!(range instanceof Range)) {
    	      throw new TypeError('a Range is required')
    	    }

    	    return this.set.some((thisComparators) => {
    	      return (
    	        isSatisfiable(thisComparators, options) &&
    	        range.set.some((rangeComparators) => {
    	          return (
    	            isSatisfiable(rangeComparators, options) &&
    	            thisComparators.every((thisComparator) => {
    	              return rangeComparators.every((rangeComparator) => {
    	                return thisComparator.intersects(rangeComparator, options)
    	              })
    	            })
    	          )
    	        })
    	      )
    	    })
    	  }

    	  // if ANY of the sets match ALL of its comparators, then pass
    	  test (version) {
    	    if (!version) {
    	      return false
    	    }

    	    if (typeof version === 'string') {
    	      try {
    	        version = new SemVer(version, this.options);
    	      } catch (er) {
    	        return false
    	      }
    	    }

    	    for (let i = 0; i < this.set.length; i++) {
    	      if (testSet(this.set[i], version, this.options)) {
    	        return true
    	      }
    	    }
    	    return false
    	  }
    	}

    	range = Range;

    	const LRU = requireLruCache();
    	const cache = new LRU({ max: 1000 });

    	const parseOptions = parseOptions_1;
    	const Comparator = requireComparator();
    	const debug = debug_1;
    	const SemVer = semver$1;
    	const {
    	  safeRe: re,
    	  t,
    	  comparatorTrimReplace,
    	  tildeTrimReplace,
    	  caretTrimReplace,
    	} = reExports;
    	const { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = constants$1;

    	const isNullSet = c => c.value === '<0.0.0-0';
    	const isAny = c => c.value === '';

    	// take a set of comparators and determine whether there
    	// exists a version which can satisfy it
    	const isSatisfiable = (comparators, options) => {
    	  let result = true;
    	  const remainingComparators = comparators.slice();
    	  let testComparator = remainingComparators.pop();

    	  while (result && remainingComparators.length) {
    	    result = remainingComparators.every((otherComparator) => {
    	      return testComparator.intersects(otherComparator, options)
    	    });

    	    testComparator = remainingComparators.pop();
    	  }

    	  return result
    	};

    	// comprised of xranges, tildes, stars, and gtlt's at this point.
    	// already replaced the hyphen ranges
    	// turn into a set of JUST comparators.
    	const parseComparator = (comp, options) => {
    	  debug('comp', comp, options);
    	  comp = replaceCarets(comp, options);
    	  debug('caret', comp);
    	  comp = replaceTildes(comp, options);
    	  debug('tildes', comp);
    	  comp = replaceXRanges(comp, options);
    	  debug('xrange', comp);
    	  comp = replaceStars(comp, options);
    	  debug('stars', comp);
    	  return comp
    	};

    	const isX = id => !id || id.toLowerCase() === 'x' || id === '*';

    	// ~, ~> --> * (any, kinda silly)
    	// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0-0
    	// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0-0
    	// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0-0
    	// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0-0
    	// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0-0
    	// ~0.0.1 --> >=0.0.1 <0.1.0-0
    	const replaceTildes = (comp, options) => {
    	  return comp
    	    .trim()
    	    .split(/\s+/)
    	    .map((c) => replaceTilde(c, options))
    	    .join(' ')
    	};

    	const replaceTilde = (comp, options) => {
    	  const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
    	  return comp.replace(r, (_, M, m, p, pr) => {
    	    debug('tilde', comp, _, M, m, p, pr);
    	    let ret;

    	    if (isX(M)) {
    	      ret = '';
    	    } else if (isX(m)) {
    	      ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
    	    } else if (isX(p)) {
    	      // ~1.2 == >=1.2.0 <1.3.0-0
    	      ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
    	    } else if (pr) {
    	      debug('replaceTilde pr', pr);
    	      ret = `>=${M}.${m}.${p}-${pr
	      } <${M}.${+m + 1}.0-0`;
    	    } else {
    	      // ~1.2.3 == >=1.2.3 <1.3.0-0
    	      ret = `>=${M}.${m}.${p
	      } <${M}.${+m + 1}.0-0`;
    	    }

    	    debug('tilde return', ret);
    	    return ret
    	  })
    	};

    	// ^ --> * (any, kinda silly)
    	// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0-0
    	// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0-0
    	// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0-0
    	// ^1.2.3 --> >=1.2.3 <2.0.0-0
    	// ^1.2.0 --> >=1.2.0 <2.0.0-0
    	// ^0.0.1 --> >=0.0.1 <0.0.2-0
    	// ^0.1.0 --> >=0.1.0 <0.2.0-0
    	const replaceCarets = (comp, options) => {
    	  return comp
    	    .trim()
    	    .split(/\s+/)
    	    .map((c) => replaceCaret(c, options))
    	    .join(' ')
    	};

    	const replaceCaret = (comp, options) => {
    	  debug('caret', comp, options);
    	  const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
    	  const z = options.includePrerelease ? '-0' : '';
    	  return comp.replace(r, (_, M, m, p, pr) => {
    	    debug('caret', comp, _, M, m, p, pr);
    	    let ret;

    	    if (isX(M)) {
    	      ret = '';
    	    } else if (isX(m)) {
    	      ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
    	    } else if (isX(p)) {
    	      if (M === '0') {
    	        ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
    	      } else {
    	        ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
    	      }
    	    } else if (pr) {
    	      debug('replaceCaret pr', pr);
    	      if (M === '0') {
    	        if (m === '0') {
    	          ret = `>=${M}.${m}.${p}-${pr
	          } <${M}.${m}.${+p + 1}-0`;
    	        } else {
    	          ret = `>=${M}.${m}.${p}-${pr
	          } <${M}.${+m + 1}.0-0`;
    	        }
    	      } else {
    	        ret = `>=${M}.${m}.${p}-${pr
	        } <${+M + 1}.0.0-0`;
    	      }
    	    } else {
    	      debug('no pr');
    	      if (M === '0') {
    	        if (m === '0') {
    	          ret = `>=${M}.${m}.${p
	          }${z} <${M}.${m}.${+p + 1}-0`;
    	        } else {
    	          ret = `>=${M}.${m}.${p
	          }${z} <${M}.${+m + 1}.0-0`;
    	        }
    	      } else {
    	        ret = `>=${M}.${m}.${p
	        } <${+M + 1}.0.0-0`;
    	      }
    	    }

    	    debug('caret return', ret);
    	    return ret
    	  })
    	};

    	const replaceXRanges = (comp, options) => {
    	  debug('replaceXRanges', comp, options);
    	  return comp
    	    .split(/\s+/)
    	    .map((c) => replaceXRange(c, options))
    	    .join(' ')
    	};

    	const replaceXRange = (comp, options) => {
    	  comp = comp.trim();
    	  const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
    	  return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
    	    debug('xRange', comp, ret, gtlt, M, m, p, pr);
    	    const xM = isX(M);
    	    const xm = xM || isX(m);
    	    const xp = xm || isX(p);
    	    const anyX = xp;

    	    if (gtlt === '=' && anyX) {
    	      gtlt = '';
    	    }

    	    // if we're including prereleases in the match, then we need
    	    // to fix this to -0, the lowest possible prerelease value
    	    pr = options.includePrerelease ? '-0' : '';

    	    if (xM) {
    	      if (gtlt === '>' || gtlt === '<') {
    	        // nothing is allowed
    	        ret = '<0.0.0-0';
    	      } else {
    	        // nothing is forbidden
    	        ret = '*';
    	      }
    	    } else if (gtlt && anyX) {
    	      // we know patch is an x, because we have any x at all.
    	      // replace X with 0
    	      if (xm) {
    	        m = 0;
    	      }
    	      p = 0;

    	      if (gtlt === '>') {
    	        // >1 => >=2.0.0
    	        // >1.2 => >=1.3.0
    	        gtlt = '>=';
    	        if (xm) {
    	          M = +M + 1;
    	          m = 0;
    	          p = 0;
    	        } else {
    	          m = +m + 1;
    	          p = 0;
    	        }
    	      } else if (gtlt === '<=') {
    	        // <=0.7.x is actually <0.8.0, since any 0.7.x should
    	        // pass.  Similarly, <=7.x is actually <8.0.0, etc.
    	        gtlt = '<';
    	        if (xm) {
    	          M = +M + 1;
    	        } else {
    	          m = +m + 1;
    	        }
    	      }

    	      if (gtlt === '<') {
    	        pr = '-0';
    	      }

    	      ret = `${gtlt + M}.${m}.${p}${pr}`;
    	    } else if (xm) {
    	      ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
    	    } else if (xp) {
    	      ret = `>=${M}.${m}.0${pr
	      } <${M}.${+m + 1}.0-0`;
    	    }

    	    debug('xRange return', ret);

    	    return ret
    	  })
    	};

    	// Because * is AND-ed with everything else in the comparator,
    	// and '' means "any version", just remove the *s entirely.
    	const replaceStars = (comp, options) => {
    	  debug('replaceStars', comp, options);
    	  // Looseness is ignored here.  star is always as loose as it gets!
    	  return comp
    	    .trim()
    	    .replace(re[t.STAR], '')
    	};

    	const replaceGTE0 = (comp, options) => {
    	  debug('replaceGTE0', comp, options);
    	  return comp
    	    .trim()
    	    .replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], '')
    	};

    	// This function is passed to string.replace(re[t.HYPHENRANGE])
    	// M, m, patch, prerelease, build
    	// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
    	// 1.2.3 - 3.4 => >=1.2.0 <3.5.0-0 Any 3.4.x will do
    	// 1.2 - 3.4 => >=1.2.0 <3.5.0-0
    	const hyphenReplace = incPr => ($0,
    	  from, fM, fm, fp, fpr, fb,
    	  to, tM, tm, tp, tpr, tb) => {
    	  if (isX(fM)) {
    	    from = '';
    	  } else if (isX(fm)) {
    	    from = `>=${fM}.0.0${incPr ? '-0' : ''}`;
    	  } else if (isX(fp)) {
    	    from = `>=${fM}.${fm}.0${incPr ? '-0' : ''}`;
    	  } else if (fpr) {
    	    from = `>=${from}`;
    	  } else {
    	    from = `>=${from}${incPr ? '-0' : ''}`;
    	  }

    	  if (isX(tM)) {
    	    to = '';
    	  } else if (isX(tm)) {
    	    to = `<${+tM + 1}.0.0-0`;
    	  } else if (isX(tp)) {
    	    to = `<${tM}.${+tm + 1}.0-0`;
    	  } else if (tpr) {
    	    to = `<=${tM}.${tm}.${tp}-${tpr}`;
    	  } else if (incPr) {
    	    to = `<${tM}.${tm}.${+tp + 1}-0`;
    	  } else {
    	    to = `<=${to}`;
    	  }

    	  return `${from} ${to}`.trim()
    	};

    	const testSet = (set, version, options) => {
    	  for (let i = 0; i < set.length; i++) {
    	    if (!set[i].test(version)) {
    	      return false
    	    }
    	  }

    	  if (version.prerelease.length && !options.includePrerelease) {
    	    // Find the set of versions that are allowed to have prereleases
    	    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
    	    // That should allow `1.2.3-pr.2` to pass.
    	    // However, `1.2.4-alpha.notready` should NOT be allowed,
    	    // even though it's within the range set by the comparators.
    	    for (let i = 0; i < set.length; i++) {
    	      debug(set[i].semver);
    	      if (set[i].semver === Comparator.ANY) {
    	        continue
    	      }

    	      if (set[i].semver.prerelease.length > 0) {
    	        const allowed = set[i].semver;
    	        if (allowed.major === version.major &&
    	            allowed.minor === version.minor &&
    	            allowed.patch === version.patch) {
    	          return true
    	        }
    	      }
    	    }

    	    // Version has a -pre, but it's not one of the ones we like.
    	    return false
    	  }

    	  return true
    	};
    	return range;
    }

    var comparator;
    var hasRequiredComparator;

    function requireComparator () {
    	if (hasRequiredComparator) return comparator;
    	hasRequiredComparator = 1;
    	const ANY = Symbol('SemVer ANY');
    	// hoisted class for cyclic dependency
    	class Comparator {
    	  static get ANY () {
    	    return ANY
    	  }

    	  constructor (comp, options) {
    	    options = parseOptions(options);

    	    if (comp instanceof Comparator) {
    	      if (comp.loose === !!options.loose) {
    	        return comp
    	      } else {
    	        comp = comp.value;
    	      }
    	    }

    	    comp = comp.trim().split(/\s+/).join(' ');
    	    debug('comparator', comp, options);
    	    this.options = options;
    	    this.loose = !!options.loose;
    	    this.parse(comp);

    	    if (this.semver === ANY) {
    	      this.value = '';
    	    } else {
    	      this.value = this.operator + this.semver.version;
    	    }

    	    debug('comp', this);
    	  }

    	  parse (comp) {
    	    const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
    	    const m = comp.match(r);

    	    if (!m) {
    	      throw new TypeError(`Invalid comparator: ${comp}`)
    	    }

    	    this.operator = m[1] !== undefined ? m[1] : '';
    	    if (this.operator === '=') {
    	      this.operator = '';
    	    }

    	    // if it literally is just '>' or '' then allow anything.
    	    if (!m[2]) {
    	      this.semver = ANY;
    	    } else {
    	      this.semver = new SemVer(m[2], this.options.loose);
    	    }
    	  }

    	  toString () {
    	    return this.value
    	  }

    	  test (version) {
    	    debug('Comparator.test', version, this.options.loose);

    	    if (this.semver === ANY || version === ANY) {
    	      return true
    	    }

    	    if (typeof version === 'string') {
    	      try {
    	        version = new SemVer(version, this.options);
    	      } catch (er) {
    	        return false
    	      }
    	    }

    	    return cmp(version, this.operator, this.semver, this.options)
    	  }

    	  intersects (comp, options) {
    	    if (!(comp instanceof Comparator)) {
    	      throw new TypeError('a Comparator is required')
    	    }

    	    if (this.operator === '') {
    	      if (this.value === '') {
    	        return true
    	      }
    	      return new Range(comp.value, options).test(this.value)
    	    } else if (comp.operator === '') {
    	      if (comp.value === '') {
    	        return true
    	      }
    	      return new Range(this.value, options).test(comp.semver)
    	    }

    	    options = parseOptions(options);

    	    // Special cases where nothing can possibly be lower
    	    if (options.includePrerelease &&
    	      (this.value === '<0.0.0-0' || comp.value === '<0.0.0-0')) {
    	      return false
    	    }
    	    if (!options.includePrerelease &&
    	      (this.value.startsWith('<0.0.0') || comp.value.startsWith('<0.0.0'))) {
    	      return false
    	    }

    	    // Same direction increasing (> or >=)
    	    if (this.operator.startsWith('>') && comp.operator.startsWith('>')) {
    	      return true
    	    }
    	    // Same direction decreasing (< or <=)
    	    if (this.operator.startsWith('<') && comp.operator.startsWith('<')) {
    	      return true
    	    }
    	    // same SemVer and both sides are inclusive (<= or >=)
    	    if (
    	      (this.semver.version === comp.semver.version) &&
    	      this.operator.includes('=') && comp.operator.includes('=')) {
    	      return true
    	    }
    	    // opposite directions less than
    	    if (cmp(this.semver, '<', comp.semver, options) &&
    	      this.operator.startsWith('>') && comp.operator.startsWith('<')) {
    	      return true
    	    }
    	    // opposite directions greater than
    	    if (cmp(this.semver, '>', comp.semver, options) &&
    	      this.operator.startsWith('<') && comp.operator.startsWith('>')) {
    	      return true
    	    }
    	    return false
    	  }
    	}

    	comparator = Comparator;

    	const parseOptions = parseOptions_1;
    	const { safeRe: re, t } = reExports;
    	const cmp = cmp_1;
    	const debug = debug_1;
    	const SemVer = semver$1;
    	const Range = requireRange();
    	return comparator;
    }

    const Range$9 = requireRange();
    const satisfies$4 = (version, range, options) => {
      try {
        range = new Range$9(range, options);
      } catch (er) {
        return false
      }
      return range.test(version)
    };
    var satisfies_1 = satisfies$4;

    const Range$8 = requireRange();

    // Mostly just for testing and legacy API reasons
    const toComparators$1 = (range, options) =>
      new Range$8(range, options).set
        .map(comp => comp.map(c => c.value).join(' ').trim().split(' '));

    var toComparators_1 = toComparators$1;

    const SemVer$4 = semver$1;
    const Range$7 = requireRange();

    const maxSatisfying$1 = (versions, range, options) => {
      let max = null;
      let maxSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range$7(range, options);
      } catch (er) {
        return null
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          // satisfies(v, range, options)
          if (!max || maxSV.compare(v) === -1) {
            // compare(max, v, true)
            max = v;
            maxSV = new SemVer$4(max, options);
          }
        }
      });
      return max
    };
    var maxSatisfying_1 = maxSatisfying$1;

    const SemVer$3 = semver$1;
    const Range$6 = requireRange();
    const minSatisfying$1 = (versions, range, options) => {
      let min = null;
      let minSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range$6(range, options);
      } catch (er) {
        return null
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          // satisfies(v, range, options)
          if (!min || minSV.compare(v) === 1) {
            // compare(min, v, true)
            min = v;
            minSV = new SemVer$3(min, options);
          }
        }
      });
      return min
    };
    var minSatisfying_1 = minSatisfying$1;

    const SemVer$2 = semver$1;
    const Range$5 = requireRange();
    const gt$3 = gt_1;

    const minVersion$1 = (range, loose) => {
      range = new Range$5(range, loose);

      let minver = new SemVer$2('0.0.0');
      if (range.test(minver)) {
        return minver
      }

      minver = new SemVer$2('0.0.0-0');
      if (range.test(minver)) {
        return minver
      }

      minver = null;
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];

        let setMin = null;
        comparators.forEach((comparator) => {
          // Clone to avoid manipulating the comparator's semver object.
          const compver = new SemVer$2(comparator.semver.version);
          switch (comparator.operator) {
            case '>':
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
              /* fallthrough */
            case '':
            case '>=':
              if (!setMin || gt$3(compver, setMin)) {
                setMin = compver;
              }
              break
            case '<':
            case '<=':
              /* Ignore maximum versions */
              break
            /* istanbul ignore next */
            default:
              throw new Error(`Unexpected operation: ${comparator.operator}`)
          }
        });
        if (setMin && (!minver || gt$3(minver, setMin))) {
          minver = setMin;
        }
      }

      if (minver && range.test(minver)) {
        return minver
      }

      return null
    };
    var minVersion_1 = minVersion$1;

    const Range$4 = requireRange();
    const validRange$1 = (range, options) => {
      try {
        // Return '*' instead of '' so that truthiness works.
        // This will throw if it's invalid anyway
        return new Range$4(range, options).range || '*'
      } catch (er) {
        return null
      }
    };
    var valid$1 = validRange$1;

    const SemVer$1 = semver$1;
    const Comparator$2 = requireComparator();
    const { ANY: ANY$1 } = Comparator$2;
    const Range$3 = requireRange();
    const satisfies$3 = satisfies_1;
    const gt$2 = gt_1;
    const lt$2 = lt_1;
    const lte$1 = lte_1;
    const gte$1 = gte_1;

    const outside$3 = (version, range, hilo, options) => {
      version = new SemVer$1(version, options);
      range = new Range$3(range, options);

      let gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case '>':
          gtfn = gt$2;
          ltefn = lte$1;
          ltfn = lt$2;
          comp = '>';
          ecomp = '>=';
          break
        case '<':
          gtfn = lt$2;
          ltefn = gte$1;
          ltfn = gt$2;
          comp = '<';
          ecomp = '<=';
          break
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"')
      }

      // If it satisfies the range it is not outside
      if (satisfies$3(version, range, options)) {
        return false
      }

      // From now on, variable terms are as if we're in "gtr" mode.
      // but note that everything is flipped for the "ltr" function.

      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];

        let high = null;
        let low = null;

        comparators.forEach((comparator) => {
          if (comparator.semver === ANY$1) {
            comparator = new Comparator$2('>=0.0.0');
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });

        // If the edge version comparator has a operator then our version
        // isn't outside it
        if (high.operator === comp || high.operator === ecomp) {
          return false
        }

        // If the lowest version comparator has an operator and our version
        // is less than it then it isn't higher than the range
        if ((!low.operator || low.operator === comp) &&
            ltefn(version, low.semver)) {
          return false
        } else if (low.operator === ecomp && ltfn(version, low.semver)) {
          return false
        }
      }
      return true
    };

    var outside_1 = outside$3;

    // Determine if version is greater than all the versions possible in the range.
    const outside$2 = outside_1;
    const gtr$1 = (version, range, options) => outside$2(version, range, '>', options);
    var gtr_1 = gtr$1;

    const outside$1 = outside_1;
    // Determine if version is less than all the versions possible in the range
    const ltr$1 = (version, range, options) => outside$1(version, range, '<', options);
    var ltr_1 = ltr$1;

    const Range$2 = requireRange();
    const intersects$1 = (r1, r2, options) => {
      r1 = new Range$2(r1, options);
      r2 = new Range$2(r2, options);
      return r1.intersects(r2, options)
    };
    var intersects_1 = intersects$1;

    // given a set of versions and a range, create a "simplified" range
    // that includes the same versions that the original range does
    // If the original range is shorter than the simplified one, return that.
    const satisfies$2 = satisfies_1;
    const compare$2 = compare_1;
    var simplify = (versions, range, options) => {
      const set = [];
      let first = null;
      let prev = null;
      const v = versions.sort((a, b) => compare$2(a, b, options));
      for (const version of v) {
        const included = satisfies$2(version, range, options);
        if (included) {
          prev = version;
          if (!first) {
            first = version;
          }
        } else {
          if (prev) {
            set.push([first, prev]);
          }
          prev = null;
          first = null;
        }
      }
      if (first) {
        set.push([first, null]);
      }

      const ranges = [];
      for (const [min, max] of set) {
        if (min === max) {
          ranges.push(min);
        } else if (!max && min === v[0]) {
          ranges.push('*');
        } else if (!max) {
          ranges.push(`>=${min}`);
        } else if (min === v[0]) {
          ranges.push(`<=${max}`);
        } else {
          ranges.push(`${min} - ${max}`);
        }
      }
      const simplified = ranges.join(' || ');
      const original = typeof range.raw === 'string' ? range.raw : String(range);
      return simplified.length < original.length ? simplified : range
    };

    const Range$1 = requireRange();
    const Comparator$1 = requireComparator();
    const { ANY } = Comparator$1;
    const satisfies$1 = satisfies_1;
    const compare$1 = compare_1;

    // Complex range `r1 || r2 || ...` is a subset of `R1 || R2 || ...` iff:
    // - Every simple range `r1, r2, ...` is a null set, OR
    // - Every simple range `r1, r2, ...` which is not a null set is a subset of
    //   some `R1, R2, ...`
    //
    // Simple range `c1 c2 ...` is a subset of simple range `C1 C2 ...` iff:
    // - If c is only the ANY comparator
    //   - If C is only the ANY comparator, return true
    //   - Else if in prerelease mode, return false
    //   - else replace c with `[>=0.0.0]`
    // - If C is only the ANY comparator
    //   - if in prerelease mode, return true
    //   - else replace C with `[>=0.0.0]`
    // - Let EQ be the set of = comparators in c
    // - If EQ is more than one, return true (null set)
    // - Let GT be the highest > or >= comparator in c
    // - Let LT be the lowest < or <= comparator in c
    // - If GT and LT, and GT.semver > LT.semver, return true (null set)
    // - If any C is a = range, and GT or LT are set, return false
    // - If EQ
    //   - If GT, and EQ does not satisfy GT, return true (null set)
    //   - If LT, and EQ does not satisfy LT, return true (null set)
    //   - If EQ satisfies every C, return true
    //   - Else return false
    // - If GT
    //   - If GT.semver is lower than any > or >= comp in C, return false
    //   - If GT is >=, and GT.semver does not satisfy every C, return false
    //   - If GT.semver has a prerelease, and not in prerelease mode
    //     - If no C has a prerelease and the GT.semver tuple, return false
    // - If LT
    //   - If LT.semver is greater than any < or <= comp in C, return false
    //   - If LT is <=, and LT.semver does not satisfy every C, return false
    //   - If GT.semver has a prerelease, and not in prerelease mode
    //     - If no C has a prerelease and the LT.semver tuple, return false
    // - Else return true

    const subset$1 = (sub, dom, options = {}) => {
      if (sub === dom) {
        return true
      }

      sub = new Range$1(sub, options);
      dom = new Range$1(dom, options);
      let sawNonNull = false;

      OUTER: for (const simpleSub of sub.set) {
        for (const simpleDom of dom.set) {
          const isSub = simpleSubset(simpleSub, simpleDom, options);
          sawNonNull = sawNonNull || isSub !== null;
          if (isSub) {
            continue OUTER
          }
        }
        // the null set is a subset of everything, but null simple ranges in
        // a complex range should be ignored.  so if we saw a non-null range,
        // then we know this isn't a subset, but if EVERY simple range was null,
        // then it is a subset.
        if (sawNonNull) {
          return false
        }
      }
      return true
    };

    const minimumVersionWithPreRelease = [new Comparator$1('>=0.0.0-0')];
    const minimumVersion = [new Comparator$1('>=0.0.0')];

    const simpleSubset = (sub, dom, options) => {
      if (sub === dom) {
        return true
      }

      if (sub.length === 1 && sub[0].semver === ANY) {
        if (dom.length === 1 && dom[0].semver === ANY) {
          return true
        } else if (options.includePrerelease) {
          sub = minimumVersionWithPreRelease;
        } else {
          sub = minimumVersion;
        }
      }

      if (dom.length === 1 && dom[0].semver === ANY) {
        if (options.includePrerelease) {
          return true
        } else {
          dom = minimumVersion;
        }
      }

      const eqSet = new Set();
      let gt, lt;
      for (const c of sub) {
        if (c.operator === '>' || c.operator === '>=') {
          gt = higherGT(gt, c, options);
        } else if (c.operator === '<' || c.operator === '<=') {
          lt = lowerLT(lt, c, options);
        } else {
          eqSet.add(c.semver);
        }
      }

      if (eqSet.size > 1) {
        return null
      }

      let gtltComp;
      if (gt && lt) {
        gtltComp = compare$1(gt.semver, lt.semver, options);
        if (gtltComp > 0) {
          return null
        } else if (gtltComp === 0 && (gt.operator !== '>=' || lt.operator !== '<=')) {
          return null
        }
      }

      // will iterate one or zero times
      for (const eq of eqSet) {
        if (gt && !satisfies$1(eq, String(gt), options)) {
          return null
        }

        if (lt && !satisfies$1(eq, String(lt), options)) {
          return null
        }

        for (const c of dom) {
          if (!satisfies$1(eq, String(c), options)) {
            return false
          }
        }

        return true
      }

      let higher, lower;
      let hasDomLT, hasDomGT;
      // if the subset has a prerelease, we need a comparator in the superset
      // with the same tuple and a prerelease, or it's not a subset
      let needDomLTPre = lt &&
        !options.includePrerelease &&
        lt.semver.prerelease.length ? lt.semver : false;
      let needDomGTPre = gt &&
        !options.includePrerelease &&
        gt.semver.prerelease.length ? gt.semver : false;
      // exception: <1.2.3-0 is the same as <1.2.3
      if (needDomLTPre && needDomLTPre.prerelease.length === 1 &&
          lt.operator === '<' && needDomLTPre.prerelease[0] === 0) {
        needDomLTPre = false;
      }

      for (const c of dom) {
        hasDomGT = hasDomGT || c.operator === '>' || c.operator === '>=';
        hasDomLT = hasDomLT || c.operator === '<' || c.operator === '<=';
        if (gt) {
          if (needDomGTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length &&
                c.semver.major === needDomGTPre.major &&
                c.semver.minor === needDomGTPre.minor &&
                c.semver.patch === needDomGTPre.patch) {
              needDomGTPre = false;
            }
          }
          if (c.operator === '>' || c.operator === '>=') {
            higher = higherGT(gt, c, options);
            if (higher === c && higher !== gt) {
              return false
            }
          } else if (gt.operator === '>=' && !satisfies$1(gt.semver, String(c), options)) {
            return false
          }
        }
        if (lt) {
          if (needDomLTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length &&
                c.semver.major === needDomLTPre.major &&
                c.semver.minor === needDomLTPre.minor &&
                c.semver.patch === needDomLTPre.patch) {
              needDomLTPre = false;
            }
          }
          if (c.operator === '<' || c.operator === '<=') {
            lower = lowerLT(lt, c, options);
            if (lower === c && lower !== lt) {
              return false
            }
          } else if (lt.operator === '<=' && !satisfies$1(lt.semver, String(c), options)) {
            return false
          }
        }
        if (!c.operator && (lt || gt) && gtltComp !== 0) {
          return false
        }
      }

      // if there was a < or >, and nothing in the dom, then must be false
      // UNLESS it was limited by another range in the other direction.
      // Eg, >1.0.0 <1.0.1 is still a subset of <2.0.0
      if (gt && hasDomLT && !lt && gtltComp !== 0) {
        return false
      }

      if (lt && hasDomGT && !gt && gtltComp !== 0) {
        return false
      }

      // we needed a prerelease range in a specific tuple, but didn't get one
      // then this isn't a subset.  eg >=1.2.3-pre is not a subset of >=1.0.0,
      // because it includes prereleases in the 1.2.3 tuple
      if (needDomGTPre || needDomLTPre) {
        return false
      }

      return true
    };

    // >=1.2.3 is lower than >1.2.3
    const higherGT = (a, b, options) => {
      if (!a) {
        return b
      }
      const comp = compare$1(a.semver, b.semver, options);
      return comp > 0 ? a
        : comp < 0 ? b
        : b.operator === '>' && a.operator === '>=' ? b
        : a
    };

    // <=1.2.3 is higher than <1.2.3
    const lowerLT = (a, b, options) => {
      if (!a) {
        return b
      }
      const comp = compare$1(a.semver, b.semver, options);
      return comp < 0 ? a
        : comp > 0 ? b
        : b.operator === '<' && a.operator === '<=' ? b
        : a
    };

    var subset_1 = subset$1;

    // just pre-load all the stuff that index.js lazily exports
    const internalRe = reExports;
    const constants = constants$1;
    const SemVer = semver$1;
    const identifiers = identifiers$1;
    const parse = parse_1;
    const valid = valid_1;
    const clean = clean_1;
    const inc = inc_1;
    const diff = diff_1;
    const major = major_1;
    const minor = minor_1;
    const patch = patch_1;
    const prerelease = prerelease_1;
    const compare = compare_1;
    const rcompare = rcompare_1;
    const compareLoose = compareLoose_1;
    const compareBuild = compareBuild_1;
    const sort = sort_1;
    const rsort = rsort_1;
    const gt$1 = gt_1;
    const lt$1 = lt_1;
    const eq = eq_1;
    const neq = neq_1;
    const gte = gte_1;
    const lte = lte_1;
    const cmp = cmp_1;
    const coerce = coerce_1;
    const Comparator = requireComparator();
    const Range = requireRange();
    const satisfies = satisfies_1;
    const toComparators = toComparators_1;
    const maxSatisfying = maxSatisfying_1;
    const minSatisfying = minSatisfying_1;
    const minVersion = minVersion_1;
    const validRange = valid$1;
    const outside = outside_1;
    const gtr = gtr_1;
    const ltr = ltr_1;
    const intersects = intersects_1;
    const simplifyRange = simplify;
    const subset = subset_1;
    var semver = {
      parse,
      valid,
      clean,
      inc,
      diff,
      major,
      minor,
      patch,
      prerelease,
      compare,
      rcompare,
      compareLoose,
      compareBuild,
      sort,
      rsort,
      gt: gt$1,
      lt: lt$1,
      eq,
      neq,
      gte,
      lte,
      cmp,
      coerce,
      Comparator,
      Range,
      satisfies,
      toComparators,
      maxSatisfying,
      minSatisfying,
      minVersion,
      validRange,
      outside,
      gtr,
      ltr,
      intersects,
      simplifyRange,
      subset,
      SemVer,
      re: internalRe.re,
      src: internalRe.src,
      tokens: internalRe.t,
      SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
      RELEASE_TYPES: constants.RELEASE_TYPES,
      compareIdentifiers: identifiers.compareIdentifiers,
      rcompareIdentifiers: identifiers.rcompareIdentifiers,
    };

    (function (exports) {
    	Object.defineProperty(exports, "__esModule", { value: true });
    	exports.satisfiesVersionRange = exports.gtRange = exports.gtVersion = exports.assertIsSemVerRange = exports.assertIsSemVerVersion = exports.isValidSemVerRange = exports.isValidSemVerVersion = exports.VersionRangeStruct = exports.VersionStruct = void 0;
    	const semver_1 = semver;
    	const superstruct_1 = require$$1;
    	const assert_1 = assert$2;
    	/**
    	 * A struct for validating a version string.
    	 */
    	exports.VersionStruct = (0, superstruct_1.refine)((0, superstruct_1.string)(), 'Version', (value) => {
    	    if ((0, semver_1.valid)(value) === null) {
    	        return `Expected SemVer version, got "${value}"`;
    	    }
    	    return true;
    	});
    	exports.VersionRangeStruct = (0, superstruct_1.refine)((0, superstruct_1.string)(), 'Version range', (value) => {
    	    if ((0, semver_1.validRange)(value) === null) {
    	        return `Expected SemVer range, got "${value}"`;
    	    }
    	    return true;
    	});
    	/**
    	 * Checks whether a SemVer version is valid.
    	 *
    	 * @param version - A potential version.
    	 * @returns `true` if the version is valid, and `false` otherwise.
    	 */
    	function isValidSemVerVersion(version) {
    	    return (0, superstruct_1.is)(version, exports.VersionStruct);
    	}
    	exports.isValidSemVerVersion = isValidSemVerVersion;
    	/**
    	 * Checks whether a SemVer version range is valid.
    	 *
    	 * @param versionRange - A potential version range.
    	 * @returns `true` if the version range is valid, and `false` otherwise.
    	 */
    	function isValidSemVerRange(versionRange) {
    	    return (0, superstruct_1.is)(versionRange, exports.VersionRangeStruct);
    	}
    	exports.isValidSemVerRange = isValidSemVerRange;
    	/**
    	 * Asserts that a value is a valid concrete SemVer version.
    	 *
    	 * @param version - A potential SemVer concrete version.
    	 */
    	function assertIsSemVerVersion(version) {
    	    (0, assert_1.assertStruct)(version, exports.VersionStruct);
    	}
    	exports.assertIsSemVerVersion = assertIsSemVerVersion;
    	/**
    	 * Asserts that a value is a valid SemVer range.
    	 *
    	 * @param range - A potential SemVer range.
    	 */
    	function assertIsSemVerRange(range) {
    	    (0, assert_1.assertStruct)(range, exports.VersionRangeStruct);
    	}
    	exports.assertIsSemVerRange = assertIsSemVerRange;
    	/**
    	 * Checks whether a SemVer version is greater than another.
    	 *
    	 * @param version1 - The left-hand version.
    	 * @param version2 - The right-hand version.
    	 * @returns `version1 > version2`.
    	 */
    	function gtVersion(version1, version2) {
    	    return (0, semver_1.gt)(version1, version2);
    	}
    	exports.gtVersion = gtVersion;
    	/**
    	 * Checks whether a SemVer version is greater than all possibilities in a range.
    	 *
    	 * @param version - A SemvVer version.
    	 * @param range - The range to check against.
    	 * @returns `version > range`.
    	 */
    	function gtRange(version, range) {
    	    return (0, semver_1.gtr)(version, range);
    	}
    	exports.gtRange = gtRange;
    	/**
    	 * Returns whether a SemVer version satisfies a SemVer range.
    	 *
    	 * @param version - The SemVer version to check.
    	 * @param versionRange - The SemVer version range to check against.
    	 * @returns Whether the version satisfied the version range.
    	 */
    	function satisfiesVersionRange(version, versionRange) {
    	    return (0, semver_1.satisfies)(version, versionRange, {
    	        includePrerelease: true,
    	    });
    	}
    	exports.satisfiesVersionRange = satisfiesVersionRange;
    	
    } (versions));

    (function (exports) {
    	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    	    if (k2 === undefined) k2 = k;
    	    var desc = Object.getOwnPropertyDescriptor(m, k);
    	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    	      desc = { enumerable: true, get: function() { return m[k]; } };
    	    }
    	    Object.defineProperty(o, k2, desc);
    	}) : (function(o, m, k, k2) {
    	    if (k2 === undefined) k2 = k;
    	    o[k2] = m[k];
    	}));
    	var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
    	    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
    	};
    	Object.defineProperty(exports, "__esModule", { value: true });
    	__exportStar(assert$2, exports);
    	__exportStar(base64$1, exports);
    	__exportStar(bytes, exports);
    	__exportStar(checksum, exports);
    	__exportStar(coercers, exports);
    	__exportStar(collections, exports);
    	__exportStar(encryptionTypes, exports);
    	__exportStar(hex, exports);
    	__exportStar(json, exports);
    	__exportStar(keyring, exports);
    	__exportStar(logging, exports);
    	__exportStar(misc, exports);
    	__exportStar(number, exports);
    	__exportStar(opaque, exports);
    	__exportStar(time$1, exports);
    	__exportStar(transactionTypes, exports);
    	__exportStar(versions, exports);
    	
    } (dist$3));

    (function (exports) {
    	Object.defineProperty(exports, "__esModule", { value: true });
    	exports.createModuleLogger = exports.projectLogger = void 0;
    	const utils_1 = dist$3;
    	Object.defineProperty(exports, "createModuleLogger", { enumerable: true, get: function () { return utils_1.createModuleLogger; } });
    	exports.projectLogger = (0, utils_1.createProjectLogger)('eth-block-tracker');
    	
    } (loggingUtils));

    var __importDefault$3 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };
    Object.defineProperty(PollingBlockTracker$1, "__esModule", { value: true });
    PollingBlockTracker$1.PollingBlockTracker = void 0;
    const json_rpc_random_id_1$1 = __importDefault$3(jsonRpcRandomId);
    const pify_1 = __importDefault$3(pify$2);
    const BaseBlockTracker_1$1 = BaseBlockTracker$1;
    const logging_utils_1 = loggingUtils;
    const log = (0, logging_utils_1.createModuleLogger)(logging_utils_1.projectLogger, 'polling-block-tracker');
    const createRandomId$2 = (0, json_rpc_random_id_1$1.default)();
    const sec = 1000;
    class PollingBlockTracker extends BaseBlockTracker_1$1.BaseBlockTracker {
        constructor(opts = {}) {
            var _a;
            // parse + validate args
            if (!opts.provider) {
                throw new Error('PollingBlockTracker - no provider specified.');
            }
            super(Object.assign(Object.assign({}, opts), { blockResetDuration: (_a = opts.blockResetDuration) !== null && _a !== void 0 ? _a : opts.pollingInterval }));
            // config
            this._provider = opts.provider;
            this._pollingInterval = opts.pollingInterval || 20 * sec;
            this._retryTimeout = opts.retryTimeout || this._pollingInterval / 10;
            this._keepEventLoopActive =
                opts.keepEventLoopActive === undefined ? true : opts.keepEventLoopActive;
            this._setSkipCacheFlag = opts.setSkipCacheFlag || false;
        }
        // trigger block polling
        async checkForLatestBlock() {
            await this._updateLatestBlock();
            return await this.getLatestBlock();
        }
        async _start() {
            this._synchronize();
        }
        async _end() {
            // No-op
        }
        async _synchronize() {
            var _a;
            while (this._isRunning) {
                try {
                    await this._updateLatestBlock();
                    const promise = timeout(this._pollingInterval, !this._keepEventLoopActive);
                    this.emit('_waitingForNextIteration');
                    await promise;
                }
                catch (err) {
                    const newErr = new Error(`PollingBlockTracker - encountered an error while attempting to update latest block:\n${(_a = err.stack) !== null && _a !== void 0 ? _a : err}`);
                    try {
                        this.emit('error', newErr);
                    }
                    catch (emitErr) {
                        console.error(newErr);
                    }
                    const promise = timeout(this._retryTimeout, !this._keepEventLoopActive);
                    this.emit('_waitingForNextIteration');
                    await promise;
                }
            }
        }
        async _updateLatestBlock() {
            // fetch + set latest block
            const latestBlock = await this._fetchLatestBlock();
            this._newPotentialLatest(latestBlock);
        }
        async _fetchLatestBlock() {
            const req = {
                jsonrpc: '2.0',
                id: createRandomId$2(),
                method: 'eth_blockNumber',
                params: [],
            };
            if (this._setSkipCacheFlag) {
                req.skipCache = true;
            }
            log('Making request', req);
            const res = await (0, pify_1.default)((cb) => this._provider.sendAsync(req, cb))();
            log('Got response', res);
            if (res.error) {
                throw new Error(`PollingBlockTracker - encountered error fetching block:\n${res.error.message}`);
            }
            return res.result;
        }
    }
    PollingBlockTracker$1.PollingBlockTracker = PollingBlockTracker;
    /**
     * Waits for the specified amount of time.
     *
     * @param duration - The amount of time in milliseconds.
     * @param unref - Assuming this function is run in a Node context, governs
     * whether Node should wait before the `setTimeout` has completed before ending
     * the process (true for no, false for yes). Defaults to false.
     * @returns A promise that can be used to wait.
     */
    function timeout(duration, unref) {
        return new Promise((resolve) => {
            const timeoutRef = setTimeout(resolve, duration);
            // don't keep process open
            if (timeoutRef.unref && unref) {
                timeoutRef.unref();
            }
        });
    }

    var SubscribeBlockTracker$1 = {};

    var __importDefault$2 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };
    Object.defineProperty(SubscribeBlockTracker$1, "__esModule", { value: true });
    SubscribeBlockTracker$1.SubscribeBlockTracker = void 0;
    const json_rpc_random_id_1 = __importDefault$2(jsonRpcRandomId);
    const BaseBlockTracker_1 = BaseBlockTracker$1;
    const createRandomId$1 = (0, json_rpc_random_id_1.default)();
    class SubscribeBlockTracker extends BaseBlockTracker_1.BaseBlockTracker {
        constructor(opts = {}) {
            // parse + validate args
            if (!opts.provider) {
                throw new Error('SubscribeBlockTracker - no provider specified.');
            }
            // BaseBlockTracker constructor
            super(opts);
            // config
            this._provider = opts.provider;
            this._subscriptionId = null;
        }
        async checkForLatestBlock() {
            return await this.getLatestBlock();
        }
        async _start() {
            if (this._subscriptionId === undefined || this._subscriptionId === null) {
                try {
                    const blockNumber = (await this._call('eth_blockNumber'));
                    this._subscriptionId = (await this._call('eth_subscribe', 'newHeads'));
                    this._provider.on('data', this._handleSubData.bind(this));
                    this._newPotentialLatest(blockNumber);
                }
                catch (e) {
                    this.emit('error', e);
                }
            }
        }
        async _end() {
            if (this._subscriptionId !== null && this._subscriptionId !== undefined) {
                try {
                    await this._call('eth_unsubscribe', this._subscriptionId);
                    this._subscriptionId = null;
                }
                catch (e) {
                    this.emit('error', e);
                }
            }
        }
        _call(method, ...params) {
            return new Promise((resolve, reject) => {
                this._provider.sendAsync({
                    id: createRandomId$1(),
                    method,
                    params,
                    jsonrpc: '2.0',
                }, (err, res) => {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve(res.result);
                    }
                });
            });
        }
        _handleSubData(_, response) {
            var _a;
            if (response.method === 'eth_subscription' &&
                ((_a = response.params) === null || _a === void 0 ? void 0 : _a.subscription) === this._subscriptionId) {
                this._newPotentialLatest(response.params.result.number);
            }
        }
    }
    SubscribeBlockTracker$1.SubscribeBlockTracker = SubscribeBlockTracker;

    (function (exports) {
    	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    	    if (k2 === undefined) k2 = k;
    	    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
    	}) : (function(o, m, k, k2) {
    	    if (k2 === undefined) k2 = k;
    	    o[k2] = m[k];
    	}));
    	var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
    	    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
    	};
    	Object.defineProperty(exports, "__esModule", { value: true });
    	__exportStar(PollingBlockTracker$1, exports);
    	__exportStar(SubscribeBlockTracker$1, exports);
    	
    } (dist$4));

    var cjs = {};

    Object.defineProperty(cjs, "__esModule", { value: true });
    const events_1$1 = require$$0$3;
    function safeApply$1(handler, context, args) {
        try {
            Reflect.apply(handler, context, args);
        }
        catch (err) {
            // Throw error after timeout so as not to interrupt the stack
            setTimeout(() => {
                throw err;
            });
        }
    }
    function arrayClone$1(arr) {
        const n = arr.length;
        const copy = new Array(n);
        for (let i = 0; i < n; i += 1) {
            copy[i] = arr[i];
        }
        return copy;
    }
    let SafeEventEmitter$3 = class SafeEventEmitter extends events_1$1.EventEmitter {
        emit(type, ...args) {
            let doError = type === 'error';
            const events = this._events;
            if (events !== undefined) {
                doError = doError && events.error === undefined;
            }
            else if (!doError) {
                return false;
            }
            // If there is no 'error' event listener then throw.
            if (doError) {
                let er;
                if (args.length > 0) {
                    [er] = args;
                }
                if (er instanceof Error) {
                    // Note: The comments on the `throw` lines are intentional, they show
                    // up in Node's output if this results in an unhandled exception.
                    throw er; // Unhandled 'error' event
                }
                // At least give some kind of context to the user
                const err = new Error(`Unhandled error.${er ? ` (${er.message})` : ''}`);
                err.context = er;
                throw err; // Unhandled 'error' event
            }
            const handler = events[type];
            if (handler === undefined) {
                return false;
            }
            if (typeof handler === 'function') {
                safeApply$1(handler, this, args);
            }
            else {
                const len = handler.length;
                const listeners = arrayClone$1(handler);
                for (let i = 0; i < len; i += 1) {
                    safeApply$1(listeners[i], this, args);
                }
            }
            return true;
        }
    };
    cjs.default = SafeEventEmitter$3;

    var dist$1 = {};

    var idRemapMiddleware = {};

    var getUniqueId$1 = {};

    Object.defineProperty(getUniqueId$1, "__esModule", { value: true });
    getUniqueId$1.getUniqueId = void 0;
    // uint32 (two's complement) max
    // more conservative than Number.MAX_SAFE_INTEGER
    const MAX = 4294967295;
    let idCounter = Math.floor(Math.random() * MAX);
    function getUniqueId() {
        idCounter = (idCounter + 1) % MAX;
        return idCounter;
    }
    getUniqueId$1.getUniqueId = getUniqueId;

    Object.defineProperty(idRemapMiddleware, "__esModule", { value: true });
    idRemapMiddleware.createIdRemapMiddleware = void 0;
    const getUniqueId_1 = getUniqueId$1;
    function createIdRemapMiddleware() {
        return (req, res, next, _end) => {
            const originalId = req.id;
            const newId = getUniqueId_1.getUniqueId();
            req.id = newId;
            res.id = newId;
            next((done) => {
                req.id = originalId;
                res.id = originalId;
                done();
            });
        };
    }
    idRemapMiddleware.createIdRemapMiddleware = createIdRemapMiddleware;

    var createAsyncMiddleware$3 = {};

    Object.defineProperty(createAsyncMiddleware$3, "__esModule", { value: true });
    createAsyncMiddleware$3.createAsyncMiddleware = void 0;
    /**
     * JsonRpcEngine only accepts callback-based middleware directly.
     * createAsyncMiddleware exists to enable consumers to pass in async middleware
     * functions.
     *
     * Async middleware have no "end" function. Instead, they "end" if they return
     * without calling "next". Rather than passing in explicit return handlers,
     * async middleware can simply await "next", and perform operations on the
     * response object when execution resumes.
     *
     * To accomplish this, createAsyncMiddleware passes the async middleware a
     * wrapped "next" function. That function calls the internal JsonRpcEngine
     * "next" function with a return handler that resolves a promise when called.
     *
     * The return handler will always be called. Its resolution of the promise
     * enables the control flow described above.
     */
    function createAsyncMiddleware$2(asyncMiddleware) {
        return async (req, res, next, end) => {
            // nextPromise is the key to the implementation
            // it is resolved by the return handler passed to the
            // "next" function
            let resolveNextPromise;
            const nextPromise = new Promise((resolve) => {
                resolveNextPromise = resolve;
            });
            let returnHandlerCallback = null;
            let nextWasCalled = false;
            // This will be called by the consumer's async middleware.
            const asyncNext = async () => {
                nextWasCalled = true;
                // We pass a return handler to next(). When it is called by the engine,
                // the consumer's async middleware will resume executing.
                // eslint-disable-next-line node/callback-return
                next((runReturnHandlersCallback) => {
                    // This callback comes from JsonRpcEngine._runReturnHandlers
                    returnHandlerCallback = runReturnHandlersCallback;
                    resolveNextPromise();
                });
                await nextPromise;
            };
            try {
                await asyncMiddleware(req, res, asyncNext);
                if (nextWasCalled) {
                    await nextPromise; // we must wait until the return handler is called
                    returnHandlerCallback(null);
                }
                else {
                    end(null);
                }
            }
            catch (error) {
                if (returnHandlerCallback) {
                    returnHandlerCallback(error);
                }
                else {
                    end(error);
                }
            }
        };
    }
    createAsyncMiddleware$3.createAsyncMiddleware = createAsyncMiddleware$2;

    var createScaffoldMiddleware$3 = {};

    Object.defineProperty(createScaffoldMiddleware$3, "__esModule", { value: true });
    createScaffoldMiddleware$3.createScaffoldMiddleware = void 0;
    function createScaffoldMiddleware$2(handlers) {
        return (req, res, next, end) => {
            const handler = handlers[req.method];
            // if no handler, return
            if (handler === undefined) {
                return next();
            }
            // if handler is fn, call as middleware
            if (typeof handler === 'function') {
                return handler(req, res, next, end);
            }
            // if handler is some other value, use as result
            res.result = handler;
            return end();
        };
    }
    createScaffoldMiddleware$3.createScaffoldMiddleware = createScaffoldMiddleware$2;

    var JsonRpcEngine$1 = {};

    var safeEventEmitter = {};

    Object.defineProperty(safeEventEmitter, "__esModule", { value: true });
    const events_1 = require$$0$3;
    function safeApply(handler, context, args) {
        try {
            Reflect.apply(handler, context, args);
        }
        catch (err) {
            // Throw error after timeout so as not to interrupt the stack
            setTimeout(() => {
                throw err;
            });
        }
    }
    function arrayClone(arr) {
        const n = arr.length;
        const copy = new Array(n);
        for (let i = 0; i < n; i += 1) {
            copy[i] = arr[i];
        }
        return copy;
    }
    let SafeEventEmitter$2 = class SafeEventEmitter extends events_1.EventEmitter {
        emit(type, ...args) {
            let doError = type === 'error';
            const events = this._events;
            if (events !== undefined) {
                doError = doError && events.error === undefined;
            }
            else if (!doError) {
                return false;
            }
            // If there is no 'error' event listener then throw.
            if (doError) {
                let er;
                if (args.length > 0) {
                    [er] = args;
                }
                if (er instanceof Error) {
                    // Note: The comments on the `throw` lines are intentional, they show
                    // up in Node's output if this results in an unhandled exception.
                    throw er; // Unhandled 'error' event
                }
                // At least give some kind of context to the user
                const err = new Error(`Unhandled error.${er ? ` (${er.message})` : ''}`);
                err.context = er;
                throw err; // Unhandled 'error' event
            }
            const handler = events[type];
            if (handler === undefined) {
                return false;
            }
            if (typeof handler === 'function') {
                safeApply(handler, this, args);
            }
            else {
                const len = handler.length;
                const listeners = arrayClone(handler);
                for (let i = 0; i < len; i += 1) {
                    safeApply(listeners[i], this, args);
                }
            }
            return true;
        }
    };
    safeEventEmitter.default = SafeEventEmitter$2;

    var dist = {};

    var classes = {};

    var fastSafeStringify = stringify;
    stringify.default = stringify;
    stringify.stable = deterministicStringify;
    stringify.stableStringify = deterministicStringify;

    var LIMIT_REPLACE_NODE = '[...]';
    var CIRCULAR_REPLACE_NODE = '[Circular]';

    var arr = [];
    var replacerStack = [];

    function defaultOptions () {
      return {
        depthLimit: Number.MAX_SAFE_INTEGER,
        edgesLimit: Number.MAX_SAFE_INTEGER
      }
    }

    // Regular stringify
    function stringify (obj, replacer, spacer, options) {
      if (typeof options === 'undefined') {
        options = defaultOptions();
      }

      decirc(obj, '', 0, [], undefined, 0, options);
      var res;
      try {
        if (replacerStack.length === 0) {
          res = JSON.stringify(obj, replacer, spacer);
        } else {
          res = JSON.stringify(obj, replaceGetterValues(replacer), spacer);
        }
      } catch (_) {
        return JSON.stringify('[unable to serialize, circular reference is too complex to analyze]')
      } finally {
        while (arr.length !== 0) {
          var part = arr.pop();
          if (part.length === 4) {
            Object.defineProperty(part[0], part[1], part[3]);
          } else {
            part[0][part[1]] = part[2];
          }
        }
      }
      return res
    }

    function setReplace (replace, val, k, parent) {
      var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k);
      if (propertyDescriptor.get !== undefined) {
        if (propertyDescriptor.configurable) {
          Object.defineProperty(parent, k, { value: replace });
          arr.push([parent, k, val, propertyDescriptor]);
        } else {
          replacerStack.push([val, k, replace]);
        }
      } else {
        parent[k] = replace;
        arr.push([parent, k, val]);
      }
    }

    function decirc (val, k, edgeIndex, stack, parent, depth, options) {
      depth += 1;
      var i;
      if (typeof val === 'object' && val !== null) {
        for (i = 0; i < stack.length; i++) {
          if (stack[i] === val) {
            setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);
            return
          }
        }

        if (
          typeof options.depthLimit !== 'undefined' &&
          depth > options.depthLimit
        ) {
          setReplace(LIMIT_REPLACE_NODE, val, k, parent);
          return
        }

        if (
          typeof options.edgesLimit !== 'undefined' &&
          edgeIndex + 1 > options.edgesLimit
        ) {
          setReplace(LIMIT_REPLACE_NODE, val, k, parent);
          return
        }

        stack.push(val);
        // Optimize for Arrays. Big arrays could kill the performance otherwise!
        if (Array.isArray(val)) {
          for (i = 0; i < val.length; i++) {
            decirc(val[i], i, i, stack, val, depth, options);
          }
        } else {
          var keys = Object.keys(val);
          for (i = 0; i < keys.length; i++) {
            var key = keys[i];
            decirc(val[key], key, i, stack, val, depth, options);
          }
        }
        stack.pop();
      }
    }

    // Stable-stringify
    function compareFunction (a, b) {
      if (a < b) {
        return -1
      }
      if (a > b) {
        return 1
      }
      return 0
    }

    function deterministicStringify (obj, replacer, spacer, options) {
      if (typeof options === 'undefined') {
        options = defaultOptions();
      }

      var tmp = deterministicDecirc(obj, '', 0, [], undefined, 0, options) || obj;
      var res;
      try {
        if (replacerStack.length === 0) {
          res = JSON.stringify(tmp, replacer, spacer);
        } else {
          res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer);
        }
      } catch (_) {
        return JSON.stringify('[unable to serialize, circular reference is too complex to analyze]')
      } finally {
        // Ensure that we restore the object as it was.
        while (arr.length !== 0) {
          var part = arr.pop();
          if (part.length === 4) {
            Object.defineProperty(part[0], part[1], part[3]);
          } else {
            part[0][part[1]] = part[2];
          }
        }
      }
      return res
    }

    function deterministicDecirc (val, k, edgeIndex, stack, parent, depth, options) {
      depth += 1;
      var i;
      if (typeof val === 'object' && val !== null) {
        for (i = 0; i < stack.length; i++) {
          if (stack[i] === val) {
            setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);
            return
          }
        }
        try {
          if (typeof val.toJSON === 'function') {
            return
          }
        } catch (_) {
          return
        }

        if (
          typeof options.depthLimit !== 'undefined' &&
          depth > options.depthLimit
        ) {
          setReplace(LIMIT_REPLACE_NODE, val, k, parent);
          return
        }

        if (
          typeof options.edgesLimit !== 'undefined' &&
          edgeIndex + 1 > options.edgesLimit
        ) {
          setReplace(LIMIT_REPLACE_NODE, val, k, parent);
          return
        }

        stack.push(val);
        // Optimize for Arrays. Big arrays could kill the performance otherwise!
        if (Array.isArray(val)) {
          for (i = 0; i < val.length; i++) {
            deterministicDecirc(val[i], i, i, stack, val, depth, options);
          }
        } else {
          // Create a temporary object in the required way
          var tmp = {};
          var keys = Object.keys(val).sort(compareFunction);
          for (i = 0; i < keys.length; i++) {
            var key = keys[i];
            deterministicDecirc(val[key], key, i, stack, val, depth, options);
            tmp[key] = val[key];
          }
          if (typeof parent !== 'undefined') {
            arr.push([parent, k, val]);
            parent[k] = tmp;
          } else {
            return tmp
          }
        }
        stack.pop();
      }
    }

    // wraps replacer function to handle values we couldn't replace
    // and mark them as replaced value
    function replaceGetterValues (replacer) {
      replacer =
        typeof replacer !== 'undefined'
          ? replacer
          : function (k, v) {
            return v
          };
      return function (key, val) {
        if (replacerStack.length > 0) {
          for (var i = 0; i < replacerStack.length; i++) {
            var part = replacerStack[i];
            if (part[1] === key && part[0] === val) {
              val = part[2];
              replacerStack.splice(i, 1);
              break
            }
          }
        }
        return replacer.call(this, key, val)
      }
    }

    Object.defineProperty(classes, "__esModule", { value: true });
    classes.EthereumProviderError = classes.EthereumRpcError = void 0;
    const fast_safe_stringify_1 = fastSafeStringify;
    /**
     * Error subclass implementing JSON RPC 2.0 errors and Ethereum RPC errors
     * per EIP-1474.
     * Permits any integer error code.
     */
    class EthereumRpcError extends Error {
        constructor(code, message, data) {
            if (!Number.isInteger(code)) {
                throw new Error('"code" must be an integer.');
            }
            if (!message || typeof message !== 'string') {
                throw new Error('"message" must be a nonempty string.');
            }
            super(message);
            this.code = code;
            if (data !== undefined) {
                this.data = data;
            }
        }
        /**
         * Returns a plain object with all public class properties.
         */
        serialize() {
            const serialized = {
                code: this.code,
                message: this.message,
            };
            if (this.data !== undefined) {
                serialized.data = this.data;
            }
            if (this.stack) {
                serialized.stack = this.stack;
            }
            return serialized;
        }
        /**
         * Return a string representation of the serialized error, omitting
         * any circular references.
         */
        toString() {
            return fast_safe_stringify_1.default(this.serialize(), stringifyReplacer, 2);
        }
    }
    classes.EthereumRpcError = EthereumRpcError;
    /**
     * Error subclass implementing Ethereum Provider errors per EIP-1193.
     * Permits integer error codes in the [ 1000 <= 4999 ] range.
     */
    class EthereumProviderError extends EthereumRpcError {
        /**
         * Create an Ethereum Provider JSON-RPC error.
         * `code` must be an integer in the 1000 <= 4999 range.
         */
        constructor(code, message, data) {
            if (!isValidEthProviderCode(code)) {
                throw new Error('"code" must be an integer such that: 1000 <= code <= 4999');
            }
            super(code, message, data);
        }
    }
    classes.EthereumProviderError = EthereumProviderError;
    // Internal
    function isValidEthProviderCode(code) {
        return Number.isInteger(code) && code >= 1000 && code <= 4999;
    }
    function stringifyReplacer(_, value) {
        if (value === '[Circular]') {
            return undefined;
        }
        return value;
    }

    var utils = {};

    var errorConstants = {};

    Object.defineProperty(errorConstants, "__esModule", { value: true });
    errorConstants.errorValues = errorConstants.errorCodes = void 0;
    errorConstants.errorCodes = {
        rpc: {
            invalidInput: -32000,
            resourceNotFound: -32001,
            resourceUnavailable: -32002,
            transactionRejected: -32003,
            methodNotSupported: -32004,
            limitExceeded: -32005,
            parse: -32700,
            invalidRequest: -32600,
            methodNotFound: -32601,
            invalidParams: -32602,
            internal: -32603,
        },
        provider: {
            userRejectedRequest: 4001,
            unauthorized: 4100,
            unsupportedMethod: 4200,
            disconnected: 4900,
            chainDisconnected: 4901,
        },
    };
    errorConstants.errorValues = {
        '-32700': {
            standard: 'JSON RPC 2.0',
            message: 'Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text.',
        },
        '-32600': {
            standard: 'JSON RPC 2.0',
            message: 'The JSON sent is not a valid Request object.',
        },
        '-32601': {
            standard: 'JSON RPC 2.0',
            message: 'The method does not exist / is not available.',
        },
        '-32602': {
            standard: 'JSON RPC 2.0',
            message: 'Invalid method parameter(s).',
        },
        '-32603': {
            standard: 'JSON RPC 2.0',
            message: 'Internal JSON-RPC error.',
        },
        '-32000': {
            standard: 'EIP-1474',
            message: 'Invalid input.',
        },
        '-32001': {
            standard: 'EIP-1474',
            message: 'Resource not found.',
        },
        '-32002': {
            standard: 'EIP-1474',
            message: 'Resource unavailable.',
        },
        '-32003': {
            standard: 'EIP-1474',
            message: 'Transaction rejected.',
        },
        '-32004': {
            standard: 'EIP-1474',
            message: 'Method not supported.',
        },
        '-32005': {
            standard: 'EIP-1474',
            message: 'Request limit exceeded.',
        },
        '4001': {
            standard: 'EIP-1193',
            message: 'User rejected the request.',
        },
        '4100': {
            standard: 'EIP-1193',
            message: 'The requested account and/or method has not been authorized by the user.',
        },
        '4200': {
            standard: 'EIP-1193',
            message: 'The requested method is not supported by this Ethereum provider.',
        },
        '4900': {
            standard: 'EIP-1193',
            message: 'The provider is disconnected from all chains.',
        },
        '4901': {
            standard: 'EIP-1193',
            message: 'The provider is disconnected from the specified chain.',
        },
    };

    (function (exports) {
    	Object.defineProperty(exports, "__esModule", { value: true });
    	exports.serializeError = exports.isValidCode = exports.getMessageFromCode = exports.JSON_RPC_SERVER_ERROR_MESSAGE = void 0;
    	const error_constants_1 = errorConstants;
    	const classes_1 = classes;
    	const FALLBACK_ERROR_CODE = error_constants_1.errorCodes.rpc.internal;
    	const FALLBACK_MESSAGE = 'Unspecified error message. This is a bug, please report it.';
    	const FALLBACK_ERROR = {
    	    code: FALLBACK_ERROR_CODE,
    	    message: getMessageFromCode(FALLBACK_ERROR_CODE),
    	};
    	exports.JSON_RPC_SERVER_ERROR_MESSAGE = 'Unspecified server error.';
    	/**
    	 * Gets the message for a given code, or a fallback message if the code has
    	 * no corresponding message.
    	 */
    	function getMessageFromCode(code, fallbackMessage = FALLBACK_MESSAGE) {
    	    if (Number.isInteger(code)) {
    	        const codeString = code.toString();
    	        if (hasKey(error_constants_1.errorValues, codeString)) {
    	            return error_constants_1.errorValues[codeString].message;
    	        }
    	        if (isJsonRpcServerError(code)) {
    	            return exports.JSON_RPC_SERVER_ERROR_MESSAGE;
    	        }
    	    }
    	    return fallbackMessage;
    	}
    	exports.getMessageFromCode = getMessageFromCode;
    	/**
    	 * Returns whether the given code is valid.
    	 * A code is only valid if it has a message.
    	 */
    	function isValidCode(code) {
    	    if (!Number.isInteger(code)) {
    	        return false;
    	    }
    	    const codeString = code.toString();
    	    if (error_constants_1.errorValues[codeString]) {
    	        return true;
    	    }
    	    if (isJsonRpcServerError(code)) {
    	        return true;
    	    }
    	    return false;
    	}
    	exports.isValidCode = isValidCode;
    	/**
    	 * Serializes the given error to an Ethereum JSON RPC-compatible error object.
    	 * Merely copies the given error's values if it is already compatible.
    	 * If the given error is not fully compatible, it will be preserved on the
    	 * returned object's data.originalError property.
    	 */
    	function serializeError(error, { fallbackError = FALLBACK_ERROR, shouldIncludeStack = false, } = {}) {
    	    var _a, _b;
    	    if (!fallbackError ||
    	        !Number.isInteger(fallbackError.code) ||
    	        typeof fallbackError.message !== 'string') {
    	        throw new Error('Must provide fallback error with integer number code and string message.');
    	    }
    	    if (error instanceof classes_1.EthereumRpcError) {
    	        return error.serialize();
    	    }
    	    const serialized = {};
    	    if (error &&
    	        typeof error === 'object' &&
    	        !Array.isArray(error) &&
    	        hasKey(error, 'code') &&
    	        isValidCode(error.code)) {
    	        const _error = error;
    	        serialized.code = _error.code;
    	        if (_error.message && typeof _error.message === 'string') {
    	            serialized.message = _error.message;
    	            if (hasKey(_error, 'data')) {
    	                serialized.data = _error.data;
    	            }
    	        }
    	        else {
    	            serialized.message = getMessageFromCode(serialized.code);
    	            serialized.data = { originalError: assignOriginalError(error) };
    	        }
    	    }
    	    else {
    	        serialized.code = fallbackError.code;
    	        const message = (_a = error) === null || _a === void 0 ? void 0 : _a.message;
    	        serialized.message = (message && typeof message === 'string'
    	            ? message
    	            : fallbackError.message);
    	        serialized.data = { originalError: assignOriginalError(error) };
    	    }
    	    const stack = (_b = error) === null || _b === void 0 ? void 0 : _b.stack;
    	    if (shouldIncludeStack && error && stack && typeof stack === 'string') {
    	        serialized.stack = stack;
    	    }
    	    return serialized;
    	}
    	exports.serializeError = serializeError;
    	// Internal
    	function isJsonRpcServerError(code) {
    	    return code >= -32099 && code <= -32000;
    	}
    	function assignOriginalError(error) {
    	    if (error && typeof error === 'object' && !Array.isArray(error)) {
    	        return Object.assign({}, error);
    	    }
    	    return error;
    	}
    	function hasKey(obj, key) {
    	    return Object.prototype.hasOwnProperty.call(obj, key);
    	}
    	
    } (utils));

    var errors = {};

    Object.defineProperty(errors, "__esModule", { value: true });
    errors.ethErrors = void 0;
    const classes_1 = classes;
    const utils_1 = utils;
    const error_constants_1 = errorConstants;
    errors.ethErrors = {
        rpc: {
            /**
             * Get a JSON RPC 2.0 Parse (-32700) error.
             */
            parse: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.parse, arg),
            /**
             * Get a JSON RPC 2.0 Invalid Request (-32600) error.
             */
            invalidRequest: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidRequest, arg),
            /**
             * Get a JSON RPC 2.0 Invalid Params (-32602) error.
             */
            invalidParams: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidParams, arg),
            /**
             * Get a JSON RPC 2.0 Method Not Found (-32601) error.
             */
            methodNotFound: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.methodNotFound, arg),
            /**
             * Get a JSON RPC 2.0 Internal (-32603) error.
             */
            internal: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.internal, arg),
            /**
             * Get a JSON RPC 2.0 Server error.
             * Permits integer error codes in the [ -32099 <= -32005 ] range.
             * Codes -32000 through -32004 are reserved by EIP-1474.
             */
            server: (opts) => {
                if (!opts || typeof opts !== 'object' || Array.isArray(opts)) {
                    throw new Error('Ethereum RPC Server errors must provide single object argument.');
                }
                const { code } = opts;
                if (!Number.isInteger(code) || code > -32005 || code < -32099) {
                    throw new Error('"code" must be an integer such that: -32099 <= code <= -32005');
                }
                return getEthJsonRpcError(code, opts);
            },
            /**
             * Get an Ethereum JSON RPC Invalid Input (-32000) error.
             */
            invalidInput: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidInput, arg),
            /**
             * Get an Ethereum JSON RPC Resource Not Found (-32001) error.
             */
            resourceNotFound: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.resourceNotFound, arg),
            /**
             * Get an Ethereum JSON RPC Resource Unavailable (-32002) error.
             */
            resourceUnavailable: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.resourceUnavailable, arg),
            /**
             * Get an Ethereum JSON RPC Transaction Rejected (-32003) error.
             */
            transactionRejected: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.transactionRejected, arg),
            /**
             * Get an Ethereum JSON RPC Method Not Supported (-32004) error.
             */
            methodNotSupported: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.methodNotSupported, arg),
            /**
             * Get an Ethereum JSON RPC Limit Exceeded (-32005) error.
             */
            limitExceeded: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.limitExceeded, arg),
        },
        provider: {
            /**
             * Get an Ethereum Provider User Rejected Request (4001) error.
             */
            userRejectedRequest: (arg) => {
                return getEthProviderError(error_constants_1.errorCodes.provider.userRejectedRequest, arg);
            },
            /**
             * Get an Ethereum Provider Unauthorized (4100) error.
             */
            unauthorized: (arg) => {
                return getEthProviderError(error_constants_1.errorCodes.provider.unauthorized, arg);
            },
            /**
             * Get an Ethereum Provider Unsupported Method (4200) error.
             */
            unsupportedMethod: (arg) => {
                return getEthProviderError(error_constants_1.errorCodes.provider.unsupportedMethod, arg);
            },
            /**
             * Get an Ethereum Provider Not Connected (4900) error.
             */
            disconnected: (arg) => {
                return getEthProviderError(error_constants_1.errorCodes.provider.disconnected, arg);
            },
            /**
             * Get an Ethereum Provider Chain Not Connected (4901) error.
             */
            chainDisconnected: (arg) => {
                return getEthProviderError(error_constants_1.errorCodes.provider.chainDisconnected, arg);
            },
            /**
             * Get a custom Ethereum Provider error.
             */
            custom: (opts) => {
                if (!opts || typeof opts !== 'object' || Array.isArray(opts)) {
                    throw new Error('Ethereum Provider custom errors must provide single object argument.');
                }
                const { code, message, data } = opts;
                if (!message || typeof message !== 'string') {
                    throw new Error('"message" must be a nonempty string');
                }
                return new classes_1.EthereumProviderError(code, message, data);
            },
        },
    };
    // Internal
    function getEthJsonRpcError(code, arg) {
        const [message, data] = parseOpts(arg);
        return new classes_1.EthereumRpcError(code, message || utils_1.getMessageFromCode(code), data);
    }
    function getEthProviderError(code, arg) {
        const [message, data] = parseOpts(arg);
        return new classes_1.EthereumProviderError(code, message || utils_1.getMessageFromCode(code), data);
    }
    function parseOpts(arg) {
        if (arg) {
            if (typeof arg === 'string') {
                return [arg];
            }
            else if (typeof arg === 'object' && !Array.isArray(arg)) {
                const { message, data } = arg;
                if (message && typeof message !== 'string') {
                    throw new Error('Must specify string message.');
                }
                return [message || undefined, data];
            }
        }
        return [];
    }

    (function (exports) {
    	Object.defineProperty(exports, "__esModule", { value: true });
    	exports.getMessageFromCode = exports.serializeError = exports.EthereumProviderError = exports.EthereumRpcError = exports.ethErrors = exports.errorCodes = void 0;
    	const classes_1 = classes;
    	Object.defineProperty(exports, "EthereumRpcError", { enumerable: true, get: function () { return classes_1.EthereumRpcError; } });
    	Object.defineProperty(exports, "EthereumProviderError", { enumerable: true, get: function () { return classes_1.EthereumProviderError; } });
    	const utils_1 = utils;
    	Object.defineProperty(exports, "serializeError", { enumerable: true, get: function () { return utils_1.serializeError; } });
    	Object.defineProperty(exports, "getMessageFromCode", { enumerable: true, get: function () { return utils_1.getMessageFromCode; } });
    	const errors_1 = errors;
    	Object.defineProperty(exports, "ethErrors", { enumerable: true, get: function () { return errors_1.ethErrors; } });
    	const error_constants_1 = errorConstants;
    	Object.defineProperty(exports, "errorCodes", { enumerable: true, get: function () { return error_constants_1.errorCodes; } });
    	
    } (dist));

    var __importDefault$1 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };
    Object.defineProperty(JsonRpcEngine$1, "__esModule", { value: true });
    JsonRpcEngine$1.JsonRpcEngine = void 0;
    const safe_event_emitter_1 = __importDefault$1(safeEventEmitter);
    const eth_rpc_errors_1 = dist;
    /**
     * A JSON-RPC request and response processor.
     * Give it a stack of middleware, pass it requests, and get back responses.
     */
    class JsonRpcEngine extends safe_event_emitter_1.default {
        constructor() {
            super();
            this._middleware = [];
        }
        /**
         * Add a middleware function to the engine's middleware stack.
         *
         * @param middleware - The middleware function to add.
         */
        push(middleware) {
            this._middleware.push(middleware);
        }
        handle(req, cb) {
            if (cb && typeof cb !== 'function') {
                throw new Error('"callback" must be a function if provided.');
            }
            if (Array.isArray(req)) {
                if (cb) {
                    return this._handleBatch(req, cb);
                }
                return this._handleBatch(req);
            }
            if (cb) {
                return this._handle(req, cb);
            }
            return this._promiseHandle(req);
        }
        /**
         * Returns this engine as a middleware function that can be pushed to other
         * engines.
         *
         * @returns This engine as a middleware function.
         */
        asMiddleware() {
            return async (req, res, next, end) => {
                try {
                    const [middlewareError, isComplete, returnHandlers,] = await JsonRpcEngine._runAllMiddleware(req, res, this._middleware);
                    if (isComplete) {
                        await JsonRpcEngine._runReturnHandlers(returnHandlers);
                        return end(middlewareError);
                    }
                    return next(async (handlerCallback) => {
                        try {
                            await JsonRpcEngine._runReturnHandlers(returnHandlers);
                        }
                        catch (error) {
                            return handlerCallback(error);
                        }
                        return handlerCallback();
                    });
                }
                catch (error) {
                    return end(error);
                }
            };
        }
        async _handleBatch(reqs, cb) {
            // The order here is important
            try {
                // 2. Wait for all requests to finish, or throw on some kind of fatal
                // error
                const responses = await Promise.all(
                // 1. Begin executing each request in the order received
                reqs.map(this._promiseHandle.bind(this)));
                // 3. Return batch response
                if (cb) {
                    return cb(null, responses);
                }
                return responses;
            }
            catch (error) {
                if (cb) {
                    return cb(error);
                }
                throw error;
            }
        }
        /**
         * A promise-wrapped _handle.
         */
        _promiseHandle(req) {
            return new Promise((resolve) => {
                this._handle(req, (_err, res) => {
                    // There will always be a response, and it will always have any error
                    // that is caught and propagated.
                    resolve(res);
                });
            });
        }
        /**
         * Ensures that the request object is valid, processes it, and passes any
         * error and the response object to the given callback.
         *
         * Does not reject.
         */
        async _handle(callerReq, cb) {
            if (!callerReq ||
                Array.isArray(callerReq) ||
                typeof callerReq !== 'object') {
                const error = new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.invalidRequest, `Requests must be plain objects. Received: ${typeof callerReq}`, { request: callerReq });
                return cb(error, { id: undefined, jsonrpc: '2.0', error });
            }
            if (typeof callerReq.method !== 'string') {
                const error = new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.invalidRequest, `Must specify a string method. Received: ${typeof callerReq.method}`, { request: callerReq });
                return cb(error, { id: callerReq.id, jsonrpc: '2.0', error });
            }
            const req = Object.assign({}, callerReq);
            const res = {
                id: req.id,
                jsonrpc: req.jsonrpc,
            };
            let error = null;
            try {
                await this._processRequest(req, res);
            }
            catch (_error) {
                // A request handler error, a re-thrown middleware error, or something
                // unexpected.
                error = _error;
            }
            if (error) {
                // Ensure no result is present on an errored response
                delete res.result;
                if (!res.error) {
                    res.error = eth_rpc_errors_1.serializeError(error);
                }
            }
            return cb(error, res);
        }
        /**
         * For the given request and response, runs all middleware and their return
         * handlers, if any, and ensures that internal request processing semantics
         * are satisfied.
         */
        async _processRequest(req, res) {
            const [error, isComplete, returnHandlers,] = await JsonRpcEngine._runAllMiddleware(req, res, this._middleware);
            // Throw if "end" was not called, or if the response has neither a result
            // nor an error.
            JsonRpcEngine._checkForCompletion(req, res, isComplete);
            // The return handlers should run even if an error was encountered during
            // middleware processing.
            await JsonRpcEngine._runReturnHandlers(returnHandlers);
            // Now we re-throw the middleware processing error, if any, to catch it
            // further up the call chain.
            if (error) {
                throw error;
            }
        }
        /**
         * Serially executes the given stack of middleware.
         *
         * @returns An array of any error encountered during middleware execution,
         * a boolean indicating whether the request was completed, and an array of
         * middleware-defined return handlers.
         */
        static async _runAllMiddleware(req, res, middlewareStack) {
            const returnHandlers = [];
            let error = null;
            let isComplete = false;
            // Go down stack of middleware, call and collect optional returnHandlers
            for (const middleware of middlewareStack) {
                [error, isComplete] = await JsonRpcEngine._runMiddleware(req, res, middleware, returnHandlers);
                if (isComplete) {
                    break;
                }
            }
            return [error, isComplete, returnHandlers.reverse()];
        }
        /**
         * Runs an individual middleware.
         *
         * @returns An array of any error encountered during middleware exection,
         * and a boolean indicating whether the request should end.
         */
        static _runMiddleware(req, res, middleware, returnHandlers) {
            return new Promise((resolve) => {
                const end = (err) => {
                    const error = err || res.error;
                    if (error) {
                        res.error = eth_rpc_errors_1.serializeError(error);
                    }
                    // True indicates that the request should end
                    resolve([error, true]);
                };
                const next = (returnHandler) => {
                    if (res.error) {
                        end(res.error);
                    }
                    else {
                        if (returnHandler) {
                            if (typeof returnHandler !== 'function') {
                                end(new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.internal, `JsonRpcEngine: "next" return handlers must be functions. ` +
                                    `Received "${typeof returnHandler}" for request:\n${jsonify(req)}`, { request: req }));
                            }
                            returnHandlers.push(returnHandler);
                        }
                        // False indicates that the request should not end
                        resolve([null, false]);
                    }
                };
                try {
                    middleware(req, res, next, end);
                }
                catch (error) {
                    end(error);
                }
            });
        }
        /**
         * Serially executes array of return handlers. The request and response are
         * assumed to be in their scope.
         */
        static async _runReturnHandlers(handlers) {
            for (const handler of handlers) {
                await new Promise((resolve, reject) => {
                    handler((err) => (err ? reject(err) : resolve()));
                });
            }
        }
        /**
         * Throws an error if the response has neither a result nor an error, or if
         * the "isComplete" flag is falsy.
         */
        static _checkForCompletion(req, res, isComplete) {
            if (!('result' in res) && !('error' in res)) {
                throw new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.internal, `JsonRpcEngine: Response has no error or result for request:\n${jsonify(req)}`, { request: req });
            }
            if (!isComplete) {
                throw new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.internal, `JsonRpcEngine: Nothing ended request:\n${jsonify(req)}`, { request: req });
            }
        }
    }
    JsonRpcEngine$1.JsonRpcEngine = JsonRpcEngine;
    function jsonify(request) {
        return JSON.stringify(request, null, 2);
    }

    var mergeMiddleware$1 = {};

    Object.defineProperty(mergeMiddleware$1, "__esModule", { value: true });
    mergeMiddleware$1.mergeMiddleware = void 0;
    const JsonRpcEngine_1 = JsonRpcEngine$1;
    function mergeMiddleware(middlewareStack) {
        const engine = new JsonRpcEngine_1.JsonRpcEngine();
        middlewareStack.forEach((middleware) => engine.push(middleware));
        return engine.asMiddleware();
    }
    mergeMiddleware$1.mergeMiddleware = mergeMiddleware;

    (function (exports) {
    	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    	    if (k2 === undefined) k2 = k;
    	    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
    	}) : (function(o, m, k, k2) {
    	    if (k2 === undefined) k2 = k;
    	    o[k2] = m[k];
    	}));
    	var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
    	    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
    	};
    	Object.defineProperty(exports, "__esModule", { value: true });
    	__exportStar(idRemapMiddleware, exports);
    	__exportStar(createAsyncMiddleware$3, exports);
    	__exportStar(createScaffoldMiddleware$3, exports);
    	__exportStar(getUniqueId$1, exports);
    	__exportStar(JsonRpcEngine$1, exports);
    	__exportStar(mergeMiddleware$1, exports);
    	
    } (dist$1));

    var lib = {};

    var Mutex$2 = {};

    var Semaphore$1 = {};

    Object.defineProperty(Semaphore$1, "__esModule", { value: true });
    var tslib_1$2 = require$$0$4;
    var Semaphore = /** @class */ (function () {
        function Semaphore(_maxConcurrency) {
            this._maxConcurrency = _maxConcurrency;
            this._queue = [];
            if (_maxConcurrency <= 0) {
                throw new Error('semaphore must be initialized to a positive value');
            }
            this._value = _maxConcurrency;
        }
        Semaphore.prototype.acquire = function () {
            var _this = this;
            var locked = this.isLocked();
            var ticket = new Promise(function (r) { return _this._queue.push(r); });
            if (!locked)
                this._dispatch();
            return ticket;
        };
        Semaphore.prototype.runExclusive = function (callback) {
            return tslib_1$2.__awaiter(this, void 0, void 0, function () {
                var _a, value, release;
                return tslib_1$2.__generator(this, function (_b) {
                    switch (_b.label) {
                        case 0: return [4 /*yield*/, this.acquire()];
                        case 1:
                            _a = _b.sent(), value = _a[0], release = _a[1];
                            _b.label = 2;
                        case 2:
                            _b.trys.push([2, , 4, 5]);
                            return [4 /*yield*/, callback(value)];
                        case 3: return [2 /*return*/, _b.sent()];
                        case 4:
                            release();
                            return [7 /*endfinally*/];
                        case 5: return [2 /*return*/];
                    }
                });
            });
        };
        Semaphore.prototype.isLocked = function () {
            return this._value <= 0;
        };
        Semaphore.prototype.release = function () {
            if (this._maxConcurrency > 1) {
                throw new Error('this method is unavailabel on semaphores with concurrency > 1; use the scoped release returned by acquire instead');
            }
            if (this._currentReleaser) {
                var releaser = this._currentReleaser;
                this._currentReleaser = undefined;
                releaser();
            }
        };
        Semaphore.prototype._dispatch = function () {
            var _this = this;
            var nextConsumer = this._queue.shift();
            if (!nextConsumer)
                return;
            var released = false;
            this._currentReleaser = function () {
                if (released)
                    return;
                released = true;
                _this._value++;
                _this._dispatch();
            };
            nextConsumer([this._value--, this._currentReleaser]);
        };
        return Semaphore;
    }());
    Semaphore$1.default = Semaphore;

    Object.defineProperty(Mutex$2, "__esModule", { value: true });
    var tslib_1$1 = require$$0$4;
    var Semaphore_1 = Semaphore$1;
    var Mutex$1 = /** @class */ (function () {
        function Mutex() {
            this._semaphore = new Semaphore_1.default(1);
        }
        Mutex.prototype.acquire = function () {
            return tslib_1$1.__awaiter(this, void 0, void 0, function () {
                var _a, releaser;
                return tslib_1$1.__generator(this, function (_b) {
                    switch (_b.label) {
                        case 0: return [4 /*yield*/, this._semaphore.acquire()];
                        case 1:
                            _a = _b.sent(), releaser = _a[1];
                            return [2 /*return*/, releaser];
                    }
                });
            });
        };
        Mutex.prototype.runExclusive = function (callback) {
            return this._semaphore.runExclusive(function () { return callback(); });
        };
        Mutex.prototype.isLocked = function () {
            return this._semaphore.isLocked();
        };
        Mutex.prototype.release = function () {
            this._semaphore.release();
        };
        return Mutex;
    }());
    Mutex$2.default = Mutex$1;

    var withTimeout$1 = {};

    Object.defineProperty(withTimeout$1, "__esModule", { value: true });
    withTimeout$1.withTimeout = void 0;
    var tslib_1 = require$$0$4;
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    function withTimeout(sync, timeout, timeoutError) {
        var _this = this;
        if (timeoutError === void 0) { timeoutError = new Error('timeout'); }
        return {
            acquire: function () {
                return new Promise(function (resolve, reject) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                    var isTimeout, ticket, release;
                    return tslib_1.__generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                isTimeout = false;
                                setTimeout(function () {
                                    isTimeout = true;
                                    reject(timeoutError);
                                }, timeout);
                                return [4 /*yield*/, sync.acquire()];
                            case 1:
                                ticket = _a.sent();
                                if (isTimeout) {
                                    release = Array.isArray(ticket) ? ticket[1] : ticket;
                                    release();
                                }
                                else {
                                    resolve(ticket);
                                }
                                return [2 /*return*/];
                        }
                    });
                }); });
            },
            runExclusive: function (callback) {
                return tslib_1.__awaiter(this, void 0, void 0, function () {
                    var release, ticket;
                    return tslib_1.__generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                release = function () { return undefined; };
                                _a.label = 1;
                            case 1:
                                _a.trys.push([1, , 7, 8]);
                                return [4 /*yield*/, this.acquire()];
                            case 2:
                                ticket = _a.sent();
                                if (!Array.isArray(ticket)) return [3 /*break*/, 4];
                                release = ticket[1];
                                return [4 /*yield*/, callback(ticket[0])];
                            case 3: return [2 /*return*/, _a.sent()];
                            case 4:
                                release = ticket;
                                return [4 /*yield*/, callback()];
                            case 5: return [2 /*return*/, _a.sent()];
                            case 6: return [3 /*break*/, 8];
                            case 7:
                                release();
                                return [7 /*endfinally*/];
                            case 8: return [2 /*return*/];
                        }
                    });
                });
            },
            release: function () {
                sync.release();
            },
            isLocked: function () { return sync.isLocked(); },
        };
    }
    withTimeout$1.withTimeout = withTimeout;

    (function (exports) {
    	Object.defineProperty(exports, "__esModule", { value: true });
    	exports.withTimeout = exports.Semaphore = exports.Mutex = void 0;
    	var Mutex_1 = Mutex$2;
    	Object.defineProperty(exports, "Mutex", { enumerable: true, get: function () { return Mutex_1.default; } });
    	var Semaphore_1 = Semaphore$1;
    	Object.defineProperty(exports, "Semaphore", { enumerable: true, get: function () { return Semaphore_1.default; } });
    	var withTimeout_1 = withTimeout$1;
    	Object.defineProperty(exports, "withTimeout", { enumerable: true, get: function () { return withTimeout_1.withTimeout; } }); 
    } (lib));

    var immutable = extend$1;

    var hasOwnProperty = Object.prototype.hasOwnProperty;

    function extend$1() {
        var target = {};

        for (var i = 0; i < arguments.length; i++) {
            var source = arguments[i];

            for (var key in source) {
                if (hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }

        return target
    }

    const extend = immutable;
    const createRandomId = jsonRpcRandomId();

    var ethQuery = EthQuery$1;


    function EthQuery$1(provider){
      const self = this;
      self.currentProvider = provider;
    }

    //
    // base queries
    //

    // default block
    EthQuery$1.prototype.getBalance =                          generateFnWithDefaultBlockFor(2, 'eth_getBalance');
    EthQuery$1.prototype.getCode =                             generateFnWithDefaultBlockFor(2, 'eth_getCode');
    EthQuery$1.prototype.getTransactionCount =                 generateFnWithDefaultBlockFor(2, 'eth_getTransactionCount');
    EthQuery$1.prototype.getStorageAt =                        generateFnWithDefaultBlockFor(3, 'eth_getStorageAt');
    EthQuery$1.prototype.call =                                generateFnWithDefaultBlockFor(2, 'eth_call');
    // standard
    EthQuery$1.prototype.protocolVersion =                     generateFnFor('eth_protocolVersion');
    EthQuery$1.prototype.syncing =                             generateFnFor('eth_syncing');
    EthQuery$1.prototype.coinbase =                            generateFnFor('eth_coinbase');
    EthQuery$1.prototype.mining =                              generateFnFor('eth_mining');
    EthQuery$1.prototype.hashrate =                            generateFnFor('eth_hashrate');
    EthQuery$1.prototype.gasPrice =                            generateFnFor('eth_gasPrice');
    EthQuery$1.prototype.accounts =                            generateFnFor('eth_accounts');
    EthQuery$1.prototype.blockNumber =                         generateFnFor('eth_blockNumber');
    EthQuery$1.prototype.getBlockTransactionCountByHash =      generateFnFor('eth_getBlockTransactionCountByHash');
    EthQuery$1.prototype.getBlockTransactionCountByNumber =    generateFnFor('eth_getBlockTransactionCountByNumber');
    EthQuery$1.prototype.getUncleCountByBlockHash =            generateFnFor('eth_getUncleCountByBlockHash');
    EthQuery$1.prototype.getUncleCountByBlockNumber =          generateFnFor('eth_getUncleCountByBlockNumber');
    EthQuery$1.prototype.sign =                                generateFnFor('eth_sign');
    EthQuery$1.prototype.sendTransaction =                     generateFnFor('eth_sendTransaction');
    EthQuery$1.prototype.sendRawTransaction =                  generateFnFor('eth_sendRawTransaction');
    EthQuery$1.prototype.estimateGas =                         generateFnFor('eth_estimateGas');
    EthQuery$1.prototype.getBlockByHash =                      generateFnFor('eth_getBlockByHash');
    EthQuery$1.prototype.getBlockByNumber =                    generateFnFor('eth_getBlockByNumber');
    EthQuery$1.prototype.getTransactionByHash =                generateFnFor('eth_getTransactionByHash');
    EthQuery$1.prototype.getTransactionByBlockHashAndIndex =   generateFnFor('eth_getTransactionByBlockHashAndIndex');
    EthQuery$1.prototype.getTransactionByBlockNumberAndIndex = generateFnFor('eth_getTransactionByBlockNumberAndIndex');
    EthQuery$1.prototype.getTransactionReceipt =               generateFnFor('eth_getTransactionReceipt');
    EthQuery$1.prototype.getUncleByBlockHashAndIndex =         generateFnFor('eth_getUncleByBlockHashAndIndex');
    EthQuery$1.prototype.getUncleByBlockNumberAndIndex =       generateFnFor('eth_getUncleByBlockNumberAndIndex');
    EthQuery$1.prototype.getCompilers =                        generateFnFor('eth_getCompilers');
    EthQuery$1.prototype.compileLLL =                          generateFnFor('eth_compileLLL');
    EthQuery$1.prototype.compileSolidity =                     generateFnFor('eth_compileSolidity');
    EthQuery$1.prototype.compileSerpent =                      generateFnFor('eth_compileSerpent');
    EthQuery$1.prototype.newFilter =                           generateFnFor('eth_newFilter');
    EthQuery$1.prototype.newBlockFilter =                      generateFnFor('eth_newBlockFilter');
    EthQuery$1.prototype.newPendingTransactionFilter =         generateFnFor('eth_newPendingTransactionFilter');
    EthQuery$1.prototype.uninstallFilter =                     generateFnFor('eth_uninstallFilter');
    EthQuery$1.prototype.getFilterChanges =                    generateFnFor('eth_getFilterChanges');
    EthQuery$1.prototype.getFilterLogs =                       generateFnFor('eth_getFilterLogs');
    EthQuery$1.prototype.getLogs =                             generateFnFor('eth_getLogs');
    EthQuery$1.prototype.getWork =                             generateFnFor('eth_getWork');
    EthQuery$1.prototype.submitWork =                          generateFnFor('eth_submitWork');
    EthQuery$1.prototype.submitHashrate =                      generateFnFor('eth_submitHashrate');

    // network level

    EthQuery$1.prototype.sendAsync = function(opts, cb){
      const self = this;
      self.currentProvider.sendAsync(createPayload(opts), function(err, response){
        if (!err && response.error) err = new Error('EthQuery - RPC Error - '+response.error.message);
        if (err) return cb(err)
        cb(null, response.result);
      });
    };

    // util

    function generateFnFor(methodName){
      return function(){
        const self = this;
        var args = [].slice.call(arguments);
        var cb = args.pop();
        self.sendAsync({
          method: methodName,
          params: args,
        }, cb);
      }
    }

    function generateFnWithDefaultBlockFor(argCount, methodName){
      return function(){
        const self = this;
        var args = [].slice.call(arguments);
        var cb = args.pop();
        // set optional default block param
        if (args.length < argCount) args.push('latest');
        self.sendAsync({
          method: methodName,
          params: args,
        }, cb);
      }
    }

    function createPayload(data){
      return extend({
        // defaults
        id: createRandomId(),
        jsonrpc: '2.0',
        params: [],
        // user-specified
      }, data)
    }

    const processFn = (fn, options, proxy, unwrapped) => function (...arguments_) {
    	const P = options.promiseModule;

    	return new P((resolve, reject) => {
    		if (options.multiArgs) {
    			arguments_.push((...result) => {
    				if (options.errorFirst) {
    					if (result[0]) {
    						reject(result);
    					} else {
    						result.shift();
    						resolve(result);
    					}
    				} else {
    					resolve(result);
    				}
    			});
    		} else if (options.errorFirst) {
    			arguments_.push((error, result) => {
    				if (error) {
    					reject(error);
    				} else {
    					resolve(result);
    				}
    			});
    		} else {
    			arguments_.push(resolve);
    		}

    		const self = this === proxy ? unwrapped : this;
    		Reflect.apply(fn, self, arguments_);
    	});
    };

    const filterCache = new WeakMap();

    var pify$1 = (input, options) => {
    	options = {
    		exclude: [/.+(?:Sync|Stream)$/],
    		errorFirst: true,
    		promiseModule: Promise,
    		...options
    	};

    	const objectType = typeof input;
    	if (!(input !== null && (objectType === 'object' || objectType === 'function'))) {
    		throw new TypeError(`Expected \`input\` to be a \`Function\` or \`Object\`, got \`${input === null ? 'null' : objectType}\``);
    	}

    	const filter = (target, key) => {
    		let cached = filterCache.get(target);

    		if (!cached) {
    			cached = {};
    			filterCache.set(target, cached);
    		}

    		if (key in cached) {
    			return cached[key];
    		}

    		const match = pattern => (typeof pattern === 'string' || typeof key === 'symbol') ? key === pattern : pattern.test(key);
    		const desc = Reflect.getOwnPropertyDescriptor(target, key);
    		const writableOrConfigurableOwn = (desc === undefined || desc.writable || desc.configurable);
    		const included = options.include ? options.include.some(match) : !options.exclude.some(match);
    		const shouldFilter = included && writableOrConfigurableOwn;
    		cached[key] = shouldFilter;
    		return shouldFilter;
    	};

    	const cache = new WeakMap();

    	const proxy = new Proxy(input, {
    		apply(target, thisArg, args) {
    			const cached = cache.get(target);

    			if (cached) {
    				return Reflect.apply(cached, thisArg, args);
    			}

    			const pified = options.excludeMain ? target : processFn(target, options, proxy, target);
    			cache.set(target, pified);
    			return Reflect.apply(pified, thisArg, args);
    		},

    		get(target, key) {
    			const property = target[key];

    			// eslint-disable-next-line no-use-extend-native/no-use-extend-native
    			if (!filter(target, key) || property === Function.prototype[key]) {
    				return property;
    			}

    			const cached = cache.get(property);

    			if (cached) {
    				return cached;
    			}

    			if (typeof property === 'function') {
    				const pified = processFn(property, options, proxy, target);
    				cache.set(property, pified);
    				return pified;
    			}

    			return property;
    		}
    	});

    	return proxy;
    };

    const SafeEventEmitter$1 = cjs.default;

    let BaseFilter$3 = class BaseFilter extends SafeEventEmitter$1 {

      constructor () {
        super();
        this.updates = [];
      }

      async initialize () {}

      async update () {
        throw new Error('BaseFilter - no update method specified')
      }

      addResults (newResults) {
        this.updates = this.updates.concat(newResults);
        newResults.forEach(result => this.emit('update', result));
      }

      addInitialResults (newResults) {}

      getChangesAndClear () {
        const updates = this.updates;
        this.updates = [];
        return updates
      }
      
    };

    var baseFilter = BaseFilter$3;

    const BaseFilter$2 = baseFilter;

    // tracks all results ever recorded
    let BaseFilterWithHistory$1 = class BaseFilterWithHistory extends BaseFilter$2 {

      constructor () {
        super();
        this.allResults = [];
      }

      async update () {
        throw new Error('BaseFilterWithHistory - no update method specified')
      }

      addResults (newResults) {
        this.allResults = this.allResults.concat(newResults);
        super.addResults(newResults);
      }

      addInitialResults (newResults) {
        this.allResults = this.allResults.concat(newResults);
        super.addInitialResults(newResults);
      }

      getAllResults () {
        return this.allResults
      }

    };

    var baseFilterHistory = BaseFilterWithHistory$1;

    var hexUtils = {
      minBlockRef: minBlockRef$1,
      maxBlockRef,
      sortBlockRefs,
      bnToHex: bnToHex$1,
      blockRefIsNumber: blockRefIsNumber$1,
      hexToInt: hexToInt$3,
      incrementHexInt: incrementHexInt$4,
      intToHex: intToHex$2,
      unsafeRandomBytes: unsafeRandomBytes$1,
    };

    function minBlockRef$1(...refs) {
      const sortedRefs = sortBlockRefs(refs);
      return sortedRefs[0]
    }

    function maxBlockRef(...refs) {
      const sortedRefs = sortBlockRefs(refs);
      return sortedRefs[sortedRefs.length-1]
    }

    function sortBlockRefs(refs) {
      return refs.sort((refA, refB) => {
        if (refA === 'latest' || refB === 'earliest') return 1
        if (refB === 'latest' || refA === 'earliest') return -1
        return hexToInt$3(refA) - hexToInt$3(refB)
      })
    }

    function bnToHex$1(bn) {
      return '0x' + bn.toString(16)
    }

    function blockRefIsNumber$1(blockRef){
      return blockRef && !['earliest', 'latest', 'pending'].includes(blockRef)
    }

    function hexToInt$3(hexString) {
      if (hexString === undefined || hexString === null) return hexString
      return Number.parseInt(hexString, 16)
    }

    function incrementHexInt$4(hexString){
      if (hexString === undefined || hexString === null) return hexString
      const value = hexToInt$3(hexString);
      return intToHex$2(value + 1)
    }

    function intToHex$2(int) {
      if (int === undefined || int === null) return int
      let hexString = int.toString(16);
      const needsLeftPad = hexString.length % 2;
      if (needsLeftPad) hexString = '0' + hexString;
      return '0x' + hexString
    }

    function unsafeRandomBytes$1(byteCount) {
      let result = '0x';
      for (let i = 0; i < byteCount; i++) {
        result += unsafeRandomNibble();
        result += unsafeRandomNibble();
      }
      return result
    }

    function unsafeRandomNibble() {
      return Math.floor(Math.random() * 16).toString(16)
    }

    const EthQuery = ethQuery;
    const pify = pify$1;
    const BaseFilterWithHistory = baseFilterHistory;
    const { bnToHex, hexToInt: hexToInt$2, incrementHexInt: incrementHexInt$3, minBlockRef, blockRefIsNumber } = hexUtils;

    let LogFilter$1 = class LogFilter extends BaseFilterWithHistory {

      constructor ({ provider, params }) {
        super();
        this.type = 'log';
        this.ethQuery = new EthQuery(provider);
        this.params = Object.assign({
          fromBlock: 'latest',
          toBlock: 'latest',
          address: undefined,
          topics: [],
        }, params);
        // normalize address parameter
        if (this.params.address) {
          // ensure array
          if (!Array.isArray(this.params.address)) {
            this.params.address = [this.params.address];
          }
          // ensure lowercase
          this.params.address = this.params.address.map(address => address.toLowerCase());
        }
      }

      async initialize({ currentBlock }) {
        // resolve params.fromBlock
        let fromBlock = this.params.fromBlock;
        if (['latest', 'pending'].includes(fromBlock)) fromBlock = currentBlock;
        if ('earliest' === fromBlock) fromBlock = '0x0';
        this.params.fromBlock = fromBlock;
        // set toBlock for initial lookup
        const toBlock = minBlockRef(this.params.toBlock, currentBlock);
        const params = Object.assign({}, this.params, { toBlock });
        // fetch logs and add to results
        const newLogs = await this._fetchLogs(params);
        this.addInitialResults(newLogs);
      }

      async update ({ oldBlock, newBlock }) {
        // configure params for this update
        const toBlock = newBlock;
        let fromBlock;
        // oldBlock is empty on first sync
        if (oldBlock) {
          fromBlock = incrementHexInt$3(oldBlock);
        } else {
          fromBlock = newBlock;
        }
        // fetch logs
        const params = Object.assign({}, this.params, { fromBlock, toBlock });
        const newLogs = await this._fetchLogs(params);
        const matchingLogs = newLogs.filter(log => this.matchLog(log));

        // add to results
        this.addResults(matchingLogs);
      }

      async _fetchLogs (params) {
        const newLogs = await pify(cb => this.ethQuery.getLogs(params, cb))();
        // add to results
        return newLogs
      }

      matchLog(log) {
        // check if block number in bounds:
        if (hexToInt$2(this.params.fromBlock) >= hexToInt$2(log.blockNumber)) return false
        if (blockRefIsNumber(this.params.toBlock) && hexToInt$2(this.params.toBlock) <= hexToInt$2(log.blockNumber)) return false

        // address is correct:
        const normalizedLogAddress = log.address && log.address.toLowerCase();
        if (this.params.address && normalizedLogAddress && !this.params.address.includes(normalizedLogAddress)) return false

        // topics match:
        // topics are position-dependant
        // topics can be nested to represent `or` [[a || b], c]
        // topics can be null, representing a wild card for that position
        const topicsMatch = this.params.topics.every((topicPattern, index) => {
          // pattern is longer than actual topics
          let logTopic = log.topics[index];
          if (!logTopic) return false
          logTopic = logTopic.toLowerCase();
          // normalize subTopics
          let subtopicsToMatch = Array.isArray(topicPattern) ? topicPattern : [topicPattern];
          // check for wild card
          const subtopicsIncludeWildcard = subtopicsToMatch.includes(null);
          if (subtopicsIncludeWildcard) return true
          subtopicsToMatch = subtopicsToMatch.map(topic => topic.toLowerCase());
          // check each possible matching topic
          const topicDoesMatch = subtopicsToMatch.includes(logTopic);
          return topicDoesMatch
        });

        return topicsMatch
      }

    };

    var logFilter = LogFilter$1;

    var getBlocksForRange_1 = getBlocksForRange$3;

    async function getBlocksForRange$3({ provider, fromBlock, toBlock }) {
      if (!fromBlock) fromBlock = toBlock;

      const fromBlockNumber = hexToInt$1(fromBlock);
      const toBlockNumber = hexToInt$1(toBlock);
      const blockCountToQuery = toBlockNumber - fromBlockNumber + 1;
      // load all blocks from old to new (inclusive)
      const missingBlockNumbers = Array(blockCountToQuery).fill()
                                  .map((_,index) => fromBlockNumber + index)
                                  .map(intToHex$1);
      let blockBodies = await Promise.all(
        missingBlockNumbers.map(blockNum => query(provider, 'eth_getBlockByNumber', [blockNum, false]))
      );
      blockBodies = blockBodies.filter(block => block !== null);
      return blockBodies
    }

    function hexToInt$1(hexString) {
      if (hexString === undefined || hexString === null) return hexString
      return Number.parseInt(hexString, 16)
    }

    function intToHex$1(int) {
      if (int === undefined || int === null) return int
      const hexString = int.toString(16);
      return '0x' + hexString
    }

    function sendAsync(provider, request) {
      return new Promise((resolve, reject) => {
        provider.sendAsync(request, (error, response) => {
          if (error) {
            reject(error);
          } else if (response.error) {
            reject(response.error);
          } else if (response.result) {
            resolve(response.result);
          } else {
            reject(new Error("Result was empty"));
          }
        });
      });
    }

    async function query(provider, method, params) {
      for (let i = 0; i < 3; i++) {
        try {
          return await sendAsync(provider, {
            id: 1,
            jsonrpc: "2.0",
            method,
            params,
          });
        } catch (error) {
          console.error(
            `provider.sendAsync failed: ${error.stack || error.message || error}`
          );
        }
      }
      return null;
    }

    const BaseFilter$1 = baseFilter;
    const getBlocksForRange$2 = getBlocksForRange_1;
    const { incrementHexInt: incrementHexInt$2 } = hexUtils;

    let BlockFilter$1 = class BlockFilter extends BaseFilter$1 {

      constructor ({ provider, params }) {
        super();
        this.type = 'block';
        this.provider = provider;
      }

      async update ({ oldBlock, newBlock }) {
        const toBlock = newBlock;
        const fromBlock = incrementHexInt$2(oldBlock);
        const blockBodies = await getBlocksForRange$2({ provider: this.provider, fromBlock, toBlock });
        const blockHashes = blockBodies.map((block) => block.hash);
        this.addResults(blockHashes);
      }

    };

    var blockFilter = BlockFilter$1;

    const BaseFilter = baseFilter;
    const getBlocksForRange$1 = getBlocksForRange_1;
    const { incrementHexInt: incrementHexInt$1 } = hexUtils;

    let TxFilter$1 = class TxFilter extends BaseFilter {

      constructor ({ provider }) {
        super();
        this.type = 'tx';
        this.provider = provider;
      }

      async update ({ oldBlock }) {
        const toBlock = oldBlock;
        const fromBlock = incrementHexInt$1(oldBlock);
        const blocks = await getBlocksForRange$1({ provider: this.provider, fromBlock, toBlock });
        const blockTxHashes = [];
        for (const block of blocks) {
          blockTxHashes.push(...block.transactions);
        }
        // add to results
        this.addResults(blockTxHashes);
      }

    };

    var txFilter = TxFilter$1;

    const Mutex = lib.Mutex;
    const { createAsyncMiddleware: createAsyncMiddleware$1, createScaffoldMiddleware: createScaffoldMiddleware$1 } = dist$1;
    const LogFilter = logFilter;
    const BlockFilter = blockFilter;
    const TxFilter = txFilter;
    const { intToHex, hexToInt } = hexUtils;

    var ethJsonRpcFilters = createEthFilterMiddleware;

    function createEthFilterMiddleware({ blockTracker, provider }) {

      // create filter collection
      let filterIndex = 0;
      let filters = {};
      // create update mutex
      const mutex = new Mutex();
      const waitForFree = mutexMiddlewareWrapper({ mutex });

      const middleware = createScaffoldMiddleware$1({
        // install filters
        eth_newFilter:                   waitForFree(toFilterCreationMiddleware(newLogFilter)),
        eth_newBlockFilter:              waitForFree(toFilterCreationMiddleware(newBlockFilter)),
        eth_newPendingTransactionFilter: waitForFree(toFilterCreationMiddleware(newPendingTransactionFilter)),
        // uninstall filters
        eth_uninstallFilter:             waitForFree(toAsyncRpcMiddleware(uninstallFilterHandler)),
        // checking filter changes
        eth_getFilterChanges:            waitForFree(toAsyncRpcMiddleware(getFilterChanges)),
        eth_getFilterLogs:               waitForFree(toAsyncRpcMiddleware(getFilterLogs)),
      });

      // setup filter updating and destroy handler
      const filterUpdater = async ({ oldBlock, newBlock }) => {
        if (filters.length === 0) return
        // lock update reads
        const releaseLock = await mutex.acquire();
        try {
          // process all filters in parallel
          await Promise.all(objValues(filters).map(async (filter) => {
            try {
             await filter.update({ oldBlock, newBlock });
            } catch (err) {
              // handle each error individually so filter update errors don't affect other filters
              console.error(err);
            }
          }));
        } catch (err) {
          // log error so we don't skip the releaseLock
          console.error(err);
        }
        // unlock update reads
        releaseLock();
      };

      // expose filter methods directly
      middleware.newLogFilter = newLogFilter;
      middleware.newBlockFilter = newBlockFilter;
      middleware.newPendingTransactionFilter = newPendingTransactionFilter;
      middleware.uninstallFilter = uninstallFilterHandler;
      middleware.getFilterChanges = getFilterChanges;
      middleware.getFilterLogs = getFilterLogs;

      // expose destroy method for cleanup
      middleware.destroy = () => {
        uninstallAllFilters();
      };

      return middleware

      //
      // new filters
      //

      async function newLogFilter(params) {
        const filter = new LogFilter({ provider, params });
        await installFilter(filter);
        return filter
      }

      async function newBlockFilter() {
        const filter = new BlockFilter({ provider });
        await installFilter(filter);
        return filter
      }

      async function newPendingTransactionFilter() {
        const filter = new TxFilter({ provider });
        await installFilter(filter);
        return filter
      }

      //
      // get filter changes
      //

      async function getFilterChanges(filterIndexHex) {
        const filterIndex = hexToInt(filterIndexHex);
        const filter = filters[filterIndex];
        if (!filter) {
          throw new Error(`No filter for index "${filterIndex}"`)
        }
        const results = filter.getChangesAndClear();
        return results
      }

      async function getFilterLogs(filterIndexHex) {
        const filterIndex = hexToInt(filterIndexHex);
        const filter = filters[filterIndex];
        if (!filter) {
          throw new Error(`No filter for index "${filterIndex}"`)
        }
        // only return results for log filters
        let results = [];
        if (filter.type === 'log') {
          results = filter.getAllResults();
        }
        return results
      }


      //
      // remove filters
      //


      async function uninstallFilterHandler(filterIndexHex) {
        // check filter exists
        const filterIndex = hexToInt(filterIndexHex);
        const filter = filters[filterIndex];
        const result = Boolean(filter);
        // uninstall filter
        if (result) {
          await uninstallFilter(filterIndex);
        }
        return result
      }

      //
      // utils
      //

      async function installFilter(filter) {
        const prevFilterCount = objValues(filters).length;
        // install filter
        const currentBlock = await blockTracker.getLatestBlock();
        await filter.initialize({ currentBlock });
        filterIndex++;
        filters[filterIndex] = filter;
        filter.id = filterIndex;
        filter.idHex = intToHex(filterIndex);
        // update block tracker subs
        const newFilterCount = objValues(filters).length;
        updateBlockTrackerSubs({ prevFilterCount, newFilterCount });
        return filterIndex
      }

      async function uninstallFilter(filterIndex) {
        const prevFilterCount = objValues(filters).length;
        delete filters[filterIndex];
        // update block tracker subs
        const newFilterCount = objValues(filters).length;
        updateBlockTrackerSubs({ prevFilterCount, newFilterCount });
      }

      async function uninstallAllFilters() {
        const prevFilterCount = objValues(filters).length;
        filters = {};
        // update block tracker subs
        updateBlockTrackerSubs({ prevFilterCount, newFilterCount: 0 });
      }

      function updateBlockTrackerSubs({ prevFilterCount, newFilterCount }) {
        // subscribe
        if (prevFilterCount === 0 && newFilterCount > 0) {
          blockTracker.on('sync', filterUpdater);
          return
        }
        // unsubscribe
        if (prevFilterCount > 0 && newFilterCount === 0) {
          blockTracker.removeListener('sync', filterUpdater);
          return
        }
      }

    }

    // helper for turning filter constructors into rpc middleware
    function toFilterCreationMiddleware(createFilterFn) {
      return toAsyncRpcMiddleware(async (...args) => {
        const filter = await createFilterFn(...args);
        const result = intToHex(filter.id);
        return result
      })
    }

    // helper for pulling out req.params and setting res.result
    function toAsyncRpcMiddleware(asyncFn) {
      return createAsyncMiddleware$1(async (req, res) => {
        const result = await asyncFn.apply(null, req.params);
        res.result = result;
      })
    }

    function mutexMiddlewareWrapper({ mutex }) {
      return (middleware) => {
        return async (req, res, next, end) => {
          // wait for mutex available
          // we can release immediately because
          // we just need to make sure updates aren't active
          const releaseLock = await mutex.acquire();
          releaseLock();
          middleware(req, res, next, end);
        }
      }
    }

    function objValues(obj, fn){
      const values = [];
      for (let key in obj) {
        values.push(obj[key]);
      }
      return values
    }

    const SafeEventEmitter = cjs.default;
    const { createAsyncMiddleware, createScaffoldMiddleware } = dist$1;
    const createFilterMiddleware = ethJsonRpcFilters;
    const { unsafeRandomBytes, incrementHexInt } = hexUtils;
    const getBlocksForRange = getBlocksForRange_1;

    var subscriptionManager = createSubscriptionMiddleware;


    function createSubscriptionMiddleware({ blockTracker, provider }) {
      // state and utilities for handling subscriptions
      const subscriptions = {};
      const filterManager = createFilterMiddleware({ blockTracker, provider });

      // internal flag
      let isDestroyed = false;

      // create subscriptionManager api object
      const events = new SafeEventEmitter();
      const middleware = createScaffoldMiddleware({
        eth_subscribe: createAsyncMiddleware(subscribe),
        eth_unsubscribe: createAsyncMiddleware(unsubscribe),
      });
      middleware.destroy = destroy;
      return { events, middleware }

      async function subscribe(req, res) {

        if (isDestroyed) throw new Error(
          'SubscriptionManager - attempting to use after destroying'
        )

        const subscriptionType = req.params[0];
        // subId is 16 byte hex string
        const subId = unsafeRandomBytes(16);

        // create sub
        let sub;
        switch (subscriptionType) {
          case 'newHeads':
            sub = createSubNewHeads({ subId });
            break
          case 'logs':
            const filterParams = req.params[1];
            const filter = await filterManager.newLogFilter(filterParams);
            sub = createSubFromFilter({ subId, filter });
            break
          default:
            throw new Error(`SubscriptionManager - unsupported subscription type "${subscriptionType}"`)

        }
        subscriptions[subId] = sub;

        res.result = subId;
        return

        function createSubNewHeads({ subId }) {
          const sub = {
            type: subscriptionType,
            destroy: async () => {
              blockTracker.removeListener('sync', sub.update);
            },
            update: async ({ oldBlock, newBlock }) => {
              // for newHeads
              const toBlock = newBlock;
              const fromBlock = incrementHexInt(oldBlock);
              const rawBlocks = await getBlocksForRange({ provider, fromBlock, toBlock });
              const results = rawBlocks.map(normalizeBlock).filter(block => block !== null);
              results.forEach((value) => {
                _emitSubscriptionResult(subId, value);
              });
            }
          };
          // check for subscription updates on new block
          blockTracker.on('sync', sub.update);
          return sub
        }

        function createSubFromFilter({ subId, filter }) {
          filter.on('update', result => _emitSubscriptionResult(subId, result));
          const sub = {
            type: subscriptionType,
            destroy: async () => {
              return await filterManager.uninstallFilter(filter.idHex)
            },
          };
          return sub
        }
      }

      async function unsubscribe(req, res) {

        if (isDestroyed) throw new Error(
          'SubscriptionManager - attempting to use after destroying'
        )

        const id = req.params[0];
        const subscription = subscriptions[id];
        // if missing, return "false" to indicate it was not removed
        if (!subscription) {
          res.result = false;
          return
        }
        // cleanup subscription
        delete subscriptions[id];
        await subscription.destroy();
        res.result = true;
      }

      function _emitSubscriptionResult(filterIdHex, value) {
        events.emit('notification', {
          jsonrpc: '2.0',
          method: 'eth_subscription',
          params: {
            subscription: filterIdHex,
            result: value,
          },
        });
      }

      function destroy() {
        events.removeAllListeners();
        for (const id in subscriptions) {
          subscriptions[id].destroy();
          delete subscriptions[id];
        }
        isDestroyed = true;
      }
    }

    function normalizeBlock(block) {
      if (block === null || block === undefined) {
        return null;
      }
      return {
        hash: block.hash,
        parentHash: block.parentHash,
        sha3Uncles: block.sha3Uncles,
        miner: block.miner,
        stateRoot: block.stateRoot,
        transactionsRoot: block.transactionsRoot,
        receiptsRoot: block.receiptsRoot,
        logsBloom: block.logsBloom,
        difficulty: block.difficulty,
        number: block.number,
        gasLimit: block.gasLimit,
        gasUsed: block.gasUsed,
        nonce: block.nonce,
        mixHash: block.mixHash,
        timestamp: block.timestamp,
        extraData: block.extraData,
      }
    }

    Object.defineProperty(SubscriptionManager$1, "__esModule", { value: true });
    SubscriptionManager$1.SubscriptionManager = void 0;
    const eth_block_tracker_1 = dist$4;
    // TODO: When we update this package we should be able to fix this
    //  eslint-disable-next-line @typescript-eslint/no-var-requires
    const createSubscriptionManager = subscriptionManager;
    const noop$1 = () => { };
    class SubscriptionManager {
        constructor(provider) {
            const blockTracker = new eth_block_tracker_1.PollingBlockTracker({
                provider: provider,
                pollingInterval: 15000,
                setSkipCacheFlag: true,
            });
            const { events, middleware } = createSubscriptionManager({
                blockTracker,
                provider,
            });
            this.events = events;
            this.subscriptionMiddleware = middleware;
        }
        async handleRequest(request) {
            const result = {};
            await this.subscriptionMiddleware(request, result, noop$1, noop$1);
            return result;
        }
        destroy() {
            this.subscriptionMiddleware.destroy();
        }
    }
    SubscriptionManager$1.SubscriptionManager = SubscriptionManager;

    /* eslint-disable @typescript-eslint/no-explicit-any */
    // TODO: Address linting issues
    var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };
    Object.defineProperty(CoinbaseWalletProvider$1, "__esModule", { value: true });
    CoinbaseWalletProvider$1.CoinbaseWalletProvider = void 0;
    // Copyright (c) 2018-2023 Coinbase, Inc. <https://www.coinbase.com/>
    // Licensed under the Apache License, version 2.0
    const bn_js_1 = __importDefault(bnExports);
    const eventemitter3_1 = eventemitter3Exports;
    const error_1 = error;
    const util_1$2 = util$3;
    const MobileRelay_1$1 = MobileRelay$1;
    const RelayAbstract_1 = RelayAbstract$1;
    const Session_1 = Session$1;
    const Web3Response_1 = Web3Response;
    const eth_eip712_util_1 = __importDefault(ethEip712Util);
    const DiagnosticLogger_1 = DiagnosticLogger;
    const FilterPolyfill_1 = FilterPolyfill$1;
    const SubscriptionManager_1 = SubscriptionManager$1;
    const DEFAULT_CHAIN_ID_KEY = 'DefaultChainId';
    const DEFAULT_JSON_RPC_URL = 'DefaultJsonRpcUrl';
    class CoinbaseWalletProvider extends eventemitter3_1.EventEmitter {
        constructor(options) {
            var _a, _b;
            super();
            this._filterPolyfill = new FilterPolyfill_1.FilterPolyfill(this);
            this._subscriptionManager = new SubscriptionManager_1.SubscriptionManager(this);
            this._relay = null;
            this._addresses = [];
            this.hasMadeFirstChainChangedEmission = false;
            this.setProviderInfo = this.setProviderInfo.bind(this);
            this.updateProviderInfo = this.updateProviderInfo.bind(this);
            this.getChainId = this.getChainId.bind(this);
            this.setAppInfo = this.setAppInfo.bind(this);
            this.enable = this.enable.bind(this);
            this.close = this.close.bind(this);
            this.send = this.send.bind(this);
            this.sendAsync = this.sendAsync.bind(this);
            this.request = this.request.bind(this);
            this._setAddresses = this._setAddresses.bind(this);
            this.scanQRCode = this.scanQRCode.bind(this);
            this.genericRequest = this.genericRequest.bind(this);
            this._chainIdFromOpts = options.chainId;
            this._jsonRpcUrlFromOpts = options.jsonRpcUrl;
            this._overrideIsMetaMask = options.overrideIsMetaMask;
            this._relayProvider = options.relayProvider;
            this._storage = options.storage;
            this._relayEventManager = options.relayEventManager;
            this.diagnostic = options.diagnosticLogger;
            this.reloadOnDisconnect = true;
            this.isCoinbaseWallet = (_a = options.overrideIsCoinbaseWallet) !== null && _a !== void 0 ? _a : true;
            this.isCoinbaseBrowser = (_b = options.overrideIsCoinbaseBrowser) !== null && _b !== void 0 ? _b : false;
            this.qrUrl = options.qrUrl;
            const chainId = this.getChainId();
            const chainIdStr = (0, util_1$2.prepend0x)(chainId.toString(16));
            // indicate that we've connected, for EIP-1193 compliance
            this.emit('connect', { chainIdStr });
            const cachedAddresses = this._storage.getItem(RelayAbstract_1.LOCAL_STORAGE_ADDRESSES_KEY);
            if (cachedAddresses) {
                const addresses = cachedAddresses.split(' ');
                if (addresses[0] !== '') {
                    this._addresses = addresses.map((address) => (0, util_1$2.ensureAddressString)(address));
                    this.emit('accountsChanged', addresses);
                }
            }
            this._subscriptionManager.events.on('notification', (notification) => {
                this.emit('message', {
                    type: notification.method,
                    data: notification.params,
                });
            });
            if (this._isAuthorized()) {
                void this.initializeRelay();
            }
            window.addEventListener('message', (event) => {
                var _a;
                // Used to verify the source and window are correct before proceeding
                if (event.origin !== location.origin || event.source !== window) {
                    return;
                }
                if (event.data.type !== 'walletLinkMessage')
                    return; // compatibility with CBW extension
                if (event.data.data.action === 'dappChainSwitched') {
                    const _chainId = event.data.data.chainId;
                    const jsonRpcUrl = (_a = event.data.data.jsonRpcUrl) !== null && _a !== void 0 ? _a : this.jsonRpcUrl;
                    this.updateProviderInfo(jsonRpcUrl, Number(_chainId));
                }
            });
        }
        /** @deprecated Use `.request({ method: 'eth_accounts' })` instead. */
        get selectedAddress() {
            return this._addresses[0] || undefined;
        }
        /** @deprecated Use the chain ID. If you still need the network ID, use `.request({ method: 'net_version' })`. */
        get networkVersion() {
            return this.getChainId().toString(10);
        }
        /** @deprecated Use `.request({ method: 'eth_chainId' })` instead. */
        get chainId() {
            return (0, util_1$2.prepend0x)(this.getChainId().toString(16));
        }
        get isWalletLink() {
            // backward compatibility
            return true;
        }
        /**
         * Some DApps (i.e. Alpha Homora) seem to require the window.ethereum object return
         * true for this method.
         */
        get isMetaMask() {
            return this._overrideIsMetaMask;
        }
        get host() {
            return this.jsonRpcUrl;
        }
        get connected() {
            return true;
        }
        isConnected() {
            return true;
        }
        get jsonRpcUrl() {
            var _a;
            return (_a = this._storage.getItem(DEFAULT_JSON_RPC_URL)) !== null && _a !== void 0 ? _a : this._jsonRpcUrlFromOpts;
        }
        set jsonRpcUrl(value) {
            this._storage.setItem(DEFAULT_JSON_RPC_URL, value);
        }
        disableReloadOnDisconnect() {
            this.reloadOnDisconnect = false;
        }
        setProviderInfo(jsonRpcUrl, chainId) {
            if (!this.isCoinbaseBrowser) {
                this._chainIdFromOpts = chainId;
                this._jsonRpcUrlFromOpts = jsonRpcUrl;
            }
            this.updateProviderInfo(this.jsonRpcUrl, this.getChainId());
        }
        updateProviderInfo(jsonRpcUrl, chainId) {
            this.jsonRpcUrl = jsonRpcUrl;
            // emit chainChanged event if necessary
            const originalChainId = this.getChainId();
            this._storage.setItem(DEFAULT_CHAIN_ID_KEY, chainId.toString(10));
            const chainChanged = (0, util_1$2.ensureIntNumber)(chainId) !== originalChainId;
            if (chainChanged || !this.hasMadeFirstChainChangedEmission) {
                this.emit('chainChanged', this.getChainId());
                this.hasMadeFirstChainChangedEmission = true;
            }
        }
        async watchAsset(type, address, symbol, decimals, image, chainId) {
            const relay = await this.initializeRelay();
            const result = await relay.watchAsset(type, address, symbol, decimals, image, chainId === null || chainId === void 0 ? void 0 : chainId.toString()).promise;
            if ((0, Web3Response_1.isErrorResponse)(result))
                return false;
            return !!result.result;
        }
        async addEthereumChain(chainId, rpcUrls, blockExplorerUrls, chainName, iconUrls, nativeCurrency) {
            var _a, _b;
            if ((0, util_1$2.ensureIntNumber)(chainId) === this.getChainId()) {
                return false;
            }
            const relay = await this.initializeRelay();
            const isWhitelistedNetworkOrStandalone = relay.inlineAddEthereumChain(chainId.toString());
            if (!this._isAuthorized() && !isWhitelistedNetworkOrStandalone) {
                await relay.requestEthereumAccounts().promise;
            }
            const res = await relay.addEthereumChain(chainId.toString(), rpcUrls, iconUrls, blockExplorerUrls, chainName, nativeCurrency).promise;
            if ((0, Web3Response_1.isErrorResponse)(res))
                return false;
            if (((_a = res.result) === null || _a === void 0 ? void 0 : _a.isApproved) === true) {
                this.updateProviderInfo(rpcUrls[0], chainId);
            }
            return ((_b = res.result) === null || _b === void 0 ? void 0 : _b.isApproved) === true;
        }
        async switchEthereumChain(chainId) {
            const relay = await this.initializeRelay();
            const res = await relay.switchEthereumChain(chainId.toString(10), this.selectedAddress || undefined).promise;
            // backward compatibility
            if ((0, Web3Response_1.isErrorResponse)(res)) {
                if (!res.errorCode)
                    return;
                if (res.errorCode === error_1.standardErrorCodes.provider.unsupportedChain) {
                    throw error_1.standardErrors.provider.unsupportedChain();
                }
                else {
                    throw error_1.standardErrors.provider.custom({
                        message: res.errorMessage,
                        code: res.errorCode,
                    });
                }
            }
            const switchResponse = res.result;
            if (switchResponse.isApproved && switchResponse.rpcUrl.length > 0) {
                this.updateProviderInfo(switchResponse.rpcUrl, chainId);
            }
        }
        setAppInfo(appName, appLogoUrl) {
            void this.initializeRelay().then((relay) => relay.setAppInfo(appName, appLogoUrl));
        }
        /** @deprecated Use `.request({ method: 'eth_requestAccounts' })` instead. */
        async enable() {
            var _a;
            (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.ETH_ACCOUNTS_STATE, {
                method: 'provider::enable',
                addresses_length: this._addresses.length,
                sessionIdHash: this._relay ? Session_1.Session.hash(this._relay.session.id) : undefined,
            });
            if (this._isAuthorized()) {
                return [...this._addresses];
            }
            return await this.send('eth_requestAccounts');
        }
        async close() {
            const relay = await this.initializeRelay();
            relay.resetAndReload();
        }
        send(requestOrMethod, callbackOrParams) {
            // send<T>(method, params): Promise<T>
            try {
                const result = this._send(requestOrMethod, callbackOrParams);
                if (result instanceof Promise) {
                    return result.catch((error) => {
                        throw (0, error_1.serializeError)(error, requestOrMethod);
                    });
                }
            }
            catch (error) {
                throw (0, error_1.serializeError)(error, requestOrMethod);
            }
        }
        _send(requestOrMethod, callbackOrParams) {
            if (typeof requestOrMethod === 'string') {
                const method = requestOrMethod;
                const params = Array.isArray(callbackOrParams)
                    ? callbackOrParams
                    : callbackOrParams !== undefined
                        ? [callbackOrParams]
                        : [];
                const request = {
                    jsonrpc: '2.0',
                    id: 0,
                    method,
                    params,
                };
                return this._sendRequestAsync(request).then((res) => res.result);
            }
            // send(JSONRPCRequest | JSONRPCRequest[], callback): void
            if (typeof callbackOrParams === 'function') {
                const request = requestOrMethod;
                const callback = callbackOrParams;
                return this._sendAsync(request, callback);
            }
            // send(JSONRPCRequest[]): JSONRPCResponse[]
            if (Array.isArray(requestOrMethod)) {
                const requests = requestOrMethod;
                return requests.map((r) => this._sendRequest(r));
            }
            // send(JSONRPCRequest): JSONRPCResponse
            const req = requestOrMethod;
            return this._sendRequest(req);
        }
        async sendAsync(request, callback) {
            try {
                return this._sendAsync(request, callback).catch((error) => {
                    throw (0, error_1.serializeError)(error, request);
                });
            }
            catch (error) {
                return Promise.reject((0, error_1.serializeError)(error, request));
            }
        }
        async _sendAsync(request, callback) {
            if (typeof callback !== 'function') {
                throw new Error('callback is required');
            }
            // send(JSONRPCRequest[], callback): void
            if (Array.isArray(request)) {
                const arrayCb = callback;
                this._sendMultipleRequestsAsync(request)
                    .then((responses) => arrayCb(null, responses))
                    .catch((err) => arrayCb(err, null));
                return;
            }
            // send(JSONRPCRequest, callback): void
            const cb = callback;
            return this._sendRequestAsync(request)
                .then((response) => cb(null, response))
                .catch((err) => cb(err, null));
        }
        async request(args) {
            try {
                return this._request(args).catch((error) => {
                    throw (0, error_1.serializeError)(error, args.method);
                });
            }
            catch (error) {
                return Promise.reject((0, error_1.serializeError)(error, args.method));
            }
        }
        async _request(args) {
            if (!args || typeof args !== 'object' || Array.isArray(args)) {
                throw error_1.standardErrors.rpc.invalidRequest({
                    message: 'Expected a single, non-array, object argument.',
                    data: args,
                });
            }
            const { method, params } = args;
            if (typeof method !== 'string' || method.length === 0) {
                throw error_1.standardErrors.rpc.invalidRequest({
                    message: "'args.method' must be a non-empty string.",
                    data: args,
                });
            }
            if (params !== undefined &&
                !Array.isArray(params) &&
                (typeof params !== 'object' || params === null)) {
                throw error_1.standardErrors.rpc.invalidRequest({
                    message: "'args.params' must be an object or array if provided.",
                    data: args,
                });
            }
            const newParams = params === undefined ? [] : params;
            // Coinbase Wallet Requests
            const id = this._relayEventManager.makeRequestId();
            const result = await this._sendRequestAsync({
                method,
                params: newParams,
                jsonrpc: '2.0',
                id,
            });
            return result.result;
        }
        async scanQRCode(match) {
            const relay = await this.initializeRelay();
            const res = await relay.scanQRCode((0, util_1$2.ensureRegExpString)(match)).promise;
            if ((0, Web3Response_1.isErrorResponse)(res)) {
                throw (0, error_1.serializeError)(res.errorMessage, 'scanQRCode');
            }
            else if (typeof res.result !== 'string') {
                throw (0, error_1.serializeError)('result was not a string', 'scanQRCode');
            }
            return res.result;
        }
        async genericRequest(data, action) {
            const relay = await this.initializeRelay();
            const res = await relay.genericRequest(data, action).promise;
            if ((0, Web3Response_1.isErrorResponse)(res)) {
                throw (0, error_1.serializeError)(res.errorMessage, 'generic');
            }
            else if (typeof res.result !== 'string') {
                throw (0, error_1.serializeError)('result was not a string', 'generic');
            }
            return res.result;
        }
        /**
         * @beta
         * This method is currently in beta. While it is available for use, please note that it is still under testing and may undergo significant changes.
         *
         * @remarks
         * IMPORTANT: Signature validation is not performed by this method. Users of this method are advised to perform their own signature validation.
         * Common web3 frontend libraries such as ethers.js and viem provide the `verifyMessage` utility function that can be used for signature validation.
         *
         * It combines `eth_requestAccounts` and "Sign-In with Ethereum" (EIP-4361) into a single call.
         * The returned account and signed message can be used to authenticate the user.
         *
         * @param {Object} params - An object with the following properties:
         * - `nonce` {string}: A unique string to prevent replay attacks.
         * - `statement` {string}: An optional human-readable ASCII assertion that the user will sign.
         * - `resources` {string[]}: An optional list of information the user wishes to have resolved as part of authentication by the relying party.
         *
         * @returns {Promise<ConnectAndSignInResponse>} A promise that resolves to an object with the following properties:
         * - `accounts` {string[]}: The Ethereum accounts of the user.
         * - `message` {string}: The overall message that the user signed. Hex encoded.
         * - `signature` {string}: The signature of the message, signed with the user's private key. Hex encoded.
         */
        async connectAndSignIn(params) {
            // NOTE: It was intentionally built by following the pattern of the existing eth_requestAccounts method
            // to maintain consistency and avoid introducing a new pattern.
            // We acknowledge the need for a better design, and it is planned to address and improve it in a future refactor.
            var _a;
            (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.ETH_ACCOUNTS_STATE, {
                method: 'provider::connectAndSignIn',
                sessionIdHash: this._relay ? Session_1.Session.hash(this._relay.session.id) : undefined,
            });
            let res;
            try {
                const relay = await this.initializeRelay();
                if (!(relay instanceof MobileRelay_1$1.MobileRelay)) {
                    throw new Error('connectAndSignIn is only supported on mobile');
                }
                res = await relay.connectAndSignIn(params).promise;
                if ((0, Web3Response_1.isErrorResponse)(res)) {
                    throw new Error(res.errorMessage);
                }
            }
            catch (err) {
                if (typeof err.message === 'string' && err.message.match(/(denied|rejected)/i)) {
                    throw error_1.standardErrors.provider.userRejectedRequest('User denied account authorization');
                }
                throw err;
            }
            if (!res.result) {
                throw new Error('accounts received is empty');
            }
            const { accounts } = res.result;
            this._setAddresses(accounts);
            if (!this.isCoinbaseBrowser) {
                await this.switchEthereumChain(this.getChainId());
            }
            return res.result;
        }
        async selectProvider(providerOptions) {
            const relay = await this.initializeRelay();
            const res = await relay.selectProvider(providerOptions).promise;
            if ((0, Web3Response_1.isErrorResponse)(res)) {
                throw (0, error_1.serializeError)(res.errorMessage, 'selectProvider');
            }
            else if (typeof res.result !== 'string') {
                throw (0, error_1.serializeError)('result was not a string', 'selectProvider');
            }
            return res.result;
        }
        supportsSubscriptions() {
            return false;
        }
        subscribe() {
            throw new Error('Subscriptions are not supported');
        }
        unsubscribe() {
            throw new Error('Subscriptions are not supported');
        }
        disconnect() {
            return true;
        }
        _sendRequest(request) {
            const response = {
                jsonrpc: '2.0',
                id: request.id,
            };
            const { method } = request;
            response.result = this._handleSynchronousMethods(request);
            if (response.result === undefined) {
                throw new Error(`Coinbase Wallet does not support calling ${method} synchronously without ` +
                    `a callback. Please provide a callback parameter to call ${method} ` +
                    `asynchronously.`);
            }
            return response;
        }
        _setAddresses(addresses, _) {
            if (!Array.isArray(addresses)) {
                throw new Error('addresses is not an array');
            }
            const newAddresses = addresses.map((address) => (0, util_1$2.ensureAddressString)(address));
            if (JSON.stringify(newAddresses) === JSON.stringify(this._addresses)) {
                return;
            }
            this._addresses = newAddresses;
            this.emit('accountsChanged', this._addresses);
            this._storage.setItem(RelayAbstract_1.LOCAL_STORAGE_ADDRESSES_KEY, newAddresses.join(' '));
        }
        _sendRequestAsync(request) {
            return new Promise((resolve, reject) => {
                try {
                    const syncResult = this._handleSynchronousMethods(request);
                    if (syncResult !== undefined) {
                        return resolve({
                            jsonrpc: '2.0',
                            id: request.id,
                            result: syncResult,
                        });
                    }
                    const filterPromise = this._handleAsynchronousFilterMethods(request);
                    if (filterPromise !== undefined) {
                        filterPromise
                            .then((res) => resolve(Object.assign(Object.assign({}, res), { id: request.id })))
                            .catch((err) => reject(err));
                        return;
                    }
                    const subscriptionPromise = this._handleSubscriptionMethods(request);
                    if (subscriptionPromise !== undefined) {
                        subscriptionPromise
                            .then((res) => resolve({
                            jsonrpc: '2.0',
                            id: request.id,
                            result: res.result,
                        }))
                            .catch((err) => reject(err));
                        return;
                    }
                }
                catch (err) {
                    return reject(err);
                }
                this._handleAsynchronousMethods(request)
                    .then((res) => res && resolve(Object.assign(Object.assign({}, res), { id: request.id })))
                    .catch((err) => reject(err));
            });
        }
        _sendMultipleRequestsAsync(requests) {
            return Promise.all(requests.map((r) => this._sendRequestAsync(r)));
        }
        _handleSynchronousMethods(request) {
            const { method } = request;
            const params = request.params || [];
            switch (method) {
                case 'eth_accounts':
                    return this._eth_accounts();
                case 'eth_coinbase':
                    return this._eth_coinbase();
                case 'eth_uninstallFilter':
                    return this._eth_uninstallFilter(params);
                case 'net_version':
                    return this._net_version();
                case 'eth_chainId':
                    return this._eth_chainId();
                default:
                    return undefined;
            }
        }
        async _handleAsynchronousMethods(request) {
            const { method } = request;
            const params = request.params || [];
            switch (method) {
                case 'eth_requestAccounts':
                    return this._eth_requestAccounts();
                case 'eth_sign':
                    return this._eth_sign(params);
                case 'eth_ecRecover':
                    return this._eth_ecRecover(params);
                case 'personal_sign':
                    return this._personal_sign(params);
                case 'personal_ecRecover':
                    return this._personal_ecRecover(params);
                case 'eth_signTransaction':
                    return this._eth_signTransaction(params);
                case 'eth_sendRawTransaction':
                    return this._eth_sendRawTransaction(params);
                case 'eth_sendTransaction':
                    return this._eth_sendTransaction(params);
                case 'eth_signTypedData_v1':
                    return this._eth_signTypedData_v1(params);
                case 'eth_signTypedData_v2':
                    return this._throwUnsupportedMethodError();
                case 'eth_signTypedData_v3':
                    return this._eth_signTypedData_v3(params);
                case 'eth_signTypedData_v4':
                case 'eth_signTypedData':
                    return this._eth_signTypedData_v4(params);
                case 'cbWallet_arbitrary':
                    return this._cbwallet_arbitrary(params);
                case 'wallet_addEthereumChain':
                    return this._wallet_addEthereumChain(params);
                case 'wallet_switchEthereumChain':
                    return this._wallet_switchEthereumChain(params);
                case 'wallet_watchAsset':
                    return this._wallet_watchAsset(params);
            }
            const relay = await this.initializeRelay();
            return relay.makeEthereumJSONRPCRequest(request, this.jsonRpcUrl).catch((err) => {
                var _a;
                if (err.code === error_1.standardErrorCodes.rpc.methodNotFound ||
                    err.code === error_1.standardErrorCodes.rpc.methodNotSupported) {
                    (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.METHOD_NOT_IMPLEMENTED, {
                        method: request.method,
                        sessionIdHash: this._relay ? Session_1.Session.hash(this._relay.session.id) : undefined,
                    });
                }
                throw err;
            });
        }
        _handleAsynchronousFilterMethods(request) {
            const { method } = request;
            const params = request.params || [];
            switch (method) {
                case 'eth_newFilter':
                    return this._eth_newFilter(params);
                case 'eth_newBlockFilter':
                    return this._eth_newBlockFilter();
                case 'eth_newPendingTransactionFilter':
                    return this._eth_newPendingTransactionFilter();
                case 'eth_getFilterChanges':
                    return this._eth_getFilterChanges(params);
                case 'eth_getFilterLogs':
                    return this._eth_getFilterLogs(params);
            }
            return undefined;
        }
        _handleSubscriptionMethods(request) {
            switch (request.method) {
                case 'eth_subscribe':
                case 'eth_unsubscribe':
                    return this._subscriptionManager.handleRequest(request);
            }
            return undefined;
        }
        _isKnownAddress(addressString) {
            try {
                const addressStr = (0, util_1$2.ensureAddressString)(addressString);
                const lowercaseAddresses = this._addresses.map((address) => (0, util_1$2.ensureAddressString)(address));
                return lowercaseAddresses.includes(addressStr);
            }
            catch (_a) {
                // noop
            }
            return false;
        }
        _ensureKnownAddress(addressString) {
            var _a;
            if (!this._isKnownAddress(addressString)) {
                (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.UNKNOWN_ADDRESS_ENCOUNTERED);
                throw new Error('Unknown Ethereum address');
            }
        }
        _prepareTransactionParams(tx) {
            const fromAddress = tx.from ? (0, util_1$2.ensureAddressString)(tx.from) : this.selectedAddress;
            if (!fromAddress) {
                throw new Error('Ethereum address is unavailable');
            }
            this._ensureKnownAddress(fromAddress);
            const toAddress = tx.to ? (0, util_1$2.ensureAddressString)(tx.to) : null;
            const weiValue = tx.value != null ? (0, util_1$2.ensureBN)(tx.value) : new bn_js_1.default(0);
            const data = tx.data ? (0, util_1$2.ensureBuffer)(tx.data) : Buffer$8.alloc(0);
            const nonce = tx.nonce != null ? (0, util_1$2.ensureIntNumber)(tx.nonce) : null;
            const gasPriceInWei = tx.gasPrice != null ? (0, util_1$2.ensureBN)(tx.gasPrice) : null;
            const maxFeePerGas = tx.maxFeePerGas != null ? (0, util_1$2.ensureBN)(tx.maxFeePerGas) : null;
            const maxPriorityFeePerGas = tx.maxPriorityFeePerGas != null ? (0, util_1$2.ensureBN)(tx.maxPriorityFeePerGas) : null;
            const gasLimit = tx.gas != null ? (0, util_1$2.ensureBN)(tx.gas) : null;
            const chainId = tx.chainId ? (0, util_1$2.ensureIntNumber)(tx.chainId) : this.getChainId();
            return {
                fromAddress,
                toAddress,
                weiValue,
                data,
                nonce,
                gasPriceInWei,
                maxFeePerGas,
                maxPriorityFeePerGas,
                gasLimit,
                chainId,
            };
        }
        _isAuthorized() {
            return this._addresses.length > 0;
        }
        _requireAuthorization() {
            if (!this._isAuthorized()) {
                throw error_1.standardErrors.provider.unauthorized({});
            }
        }
        _throwUnsupportedMethodError() {
            throw error_1.standardErrors.provider.unsupportedMethod({});
        }
        async _signEthereumMessage(message, address, addPrefix, typedDataJson) {
            this._ensureKnownAddress(address);
            try {
                const relay = await this.initializeRelay();
                const res = await relay.signEthereumMessage(message, address, addPrefix, typedDataJson)
                    .promise;
                if ((0, Web3Response_1.isErrorResponse)(res)) {
                    throw new Error(res.errorMessage);
                }
                return { jsonrpc: '2.0', id: 0, result: res.result };
            }
            catch (err) {
                if (typeof err.message === 'string' && err.message.match(/(denied|rejected)/i)) {
                    throw error_1.standardErrors.provider.userRejectedRequest('User denied message signature');
                }
                throw err;
            }
        }
        async _ethereumAddressFromSignedMessage(message, signature, addPrefix) {
            const relay = await this.initializeRelay();
            const res = await relay.ethereumAddressFromSignedMessage(message, signature, addPrefix).promise;
            if ((0, Web3Response_1.isErrorResponse)(res)) {
                throw new Error(res.errorMessage);
            }
            return { jsonrpc: '2.0', id: 0, result: res.result };
        }
        _eth_accounts() {
            return [...this._addresses];
        }
        _eth_coinbase() {
            return this.selectedAddress || null;
        }
        _net_version() {
            return this.getChainId().toString(10);
        }
        _eth_chainId() {
            return (0, util_1$2.hexStringFromIntNumber)(this.getChainId());
        }
        getChainId() {
            const chainIdStr = this._storage.getItem(DEFAULT_CHAIN_ID_KEY);
            if (!chainIdStr) {
                return (0, util_1$2.ensureIntNumber)(this._chainIdFromOpts);
            }
            const chainId = parseInt(chainIdStr, 10);
            return (0, util_1$2.ensureIntNumber)(chainId);
        }
        async _eth_requestAccounts() {
            var _a;
            (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.ETH_ACCOUNTS_STATE, {
                method: 'provider::_eth_requestAccounts',
                addresses_length: this._addresses.length,
                sessionIdHash: this._relay ? Session_1.Session.hash(this._relay.session.id) : undefined,
            });
            if (this._isAuthorized()) {
                return Promise.resolve({
                    jsonrpc: '2.0',
                    id: 0,
                    result: this._addresses,
                });
            }
            let res;
            try {
                const relay = await this.initializeRelay();
                res = await relay.requestEthereumAccounts().promise;
                if ((0, Web3Response_1.isErrorResponse)(res)) {
                    throw new Error(res.errorMessage);
                }
            }
            catch (err) {
                if (typeof err.message === 'string' && err.message.match(/(denied|rejected)/i)) {
                    throw error_1.standardErrors.provider.userRejectedRequest('User denied account authorization');
                }
                throw err;
            }
            if (!res.result) {
                throw new Error('accounts received is empty');
            }
            this._setAddresses(res.result);
            if (!this.isCoinbaseBrowser) {
                await this.switchEthereumChain(this.getChainId());
            }
            return { jsonrpc: '2.0', id: 0, result: this._addresses };
        }
        _eth_sign(params) {
            this._requireAuthorization();
            const address = (0, util_1$2.ensureAddressString)(params[0]);
            const message = (0, util_1$2.ensureBuffer)(params[1]);
            return this._signEthereumMessage(message, address, false);
        }
        _eth_ecRecover(params) {
            const message = (0, util_1$2.ensureBuffer)(params[0]);
            const signature = (0, util_1$2.ensureBuffer)(params[1]);
            return this._ethereumAddressFromSignedMessage(message, signature, false);
        }
        _personal_sign(params) {
            this._requireAuthorization();
            const message = (0, util_1$2.ensureBuffer)(params[0]);
            const address = (0, util_1$2.ensureAddressString)(params[1]);
            return this._signEthereumMessage(message, address, true);
        }
        _personal_ecRecover(params) {
            const message = (0, util_1$2.ensureBuffer)(params[0]);
            const signature = (0, util_1$2.ensureBuffer)(params[1]);
            return this._ethereumAddressFromSignedMessage(message, signature, true);
        }
        async _eth_signTransaction(params) {
            this._requireAuthorization();
            const tx = this._prepareTransactionParams(params[0] || {});
            try {
                const relay = await this.initializeRelay();
                const res = await relay.signEthereumTransaction(tx).promise;
                if ((0, Web3Response_1.isErrorResponse)(res)) {
                    throw new Error(res.errorMessage);
                }
                return { jsonrpc: '2.0', id: 0, result: res.result };
            }
            catch (err) {
                if (typeof err.message === 'string' && err.message.match(/(denied|rejected)/i)) {
                    throw error_1.standardErrors.provider.userRejectedRequest('User denied transaction signature');
                }
                throw err;
            }
        }
        async _eth_sendRawTransaction(params) {
            const signedTransaction = (0, util_1$2.ensureBuffer)(params[0]);
            const relay = await this.initializeRelay();
            const res = await relay.submitEthereumTransaction(signedTransaction, this.getChainId()).promise;
            if ((0, Web3Response_1.isErrorResponse)(res)) {
                throw new Error(res.errorMessage);
            }
            return { jsonrpc: '2.0', id: 0, result: res.result };
        }
        async _eth_sendTransaction(params) {
            this._requireAuthorization();
            const tx = this._prepareTransactionParams(params[0] || {});
            try {
                const relay = await this.initializeRelay();
                const res = await relay.signAndSubmitEthereumTransaction(tx).promise;
                if ((0, Web3Response_1.isErrorResponse)(res)) {
                    throw new Error(res.errorMessage);
                }
                return { jsonrpc: '2.0', id: 0, result: res.result };
            }
            catch (err) {
                if (typeof err.message === 'string' && err.message.match(/(denied|rejected)/i)) {
                    throw error_1.standardErrors.provider.userRejectedRequest('User denied transaction signature');
                }
                throw err;
            }
        }
        async _eth_signTypedData_v1(params) {
            this._requireAuthorization();
            const typedData = (0, util_1$2.ensureParsedJSONObject)(params[0]);
            const address = (0, util_1$2.ensureAddressString)(params[1]);
            this._ensureKnownAddress(address);
            const message = eth_eip712_util_1.default.hashForSignTypedDataLegacy({ data: typedData });
            const typedDataJSON = JSON.stringify(typedData, null, 2);
            return this._signEthereumMessage(message, address, false, typedDataJSON);
        }
        async _eth_signTypedData_v3(params) {
            this._requireAuthorization();
            const address = (0, util_1$2.ensureAddressString)(params[0]);
            const typedData = (0, util_1$2.ensureParsedJSONObject)(params[1]);
            this._ensureKnownAddress(address);
            const message = eth_eip712_util_1.default.hashForSignTypedData_v3({ data: typedData });
            const typedDataJSON = JSON.stringify(typedData, null, 2);
            return this._signEthereumMessage(message, address, false, typedDataJSON);
        }
        async _eth_signTypedData_v4(params) {
            this._requireAuthorization();
            const address = (0, util_1$2.ensureAddressString)(params[0]);
            const typedData = (0, util_1$2.ensureParsedJSONObject)(params[1]);
            this._ensureKnownAddress(address);
            const message = eth_eip712_util_1.default.hashForSignTypedData_v4({ data: typedData });
            const typedDataJSON = JSON.stringify(typedData, null, 2);
            return this._signEthereumMessage(message, address, false, typedDataJSON);
        }
        /** @deprecated */
        async _cbwallet_arbitrary(params) {
            const action = params[0];
            const data = params[1];
            if (typeof data !== 'string') {
                throw new Error('parameter must be a string');
            }
            if (typeof action !== 'object' || action === null) {
                throw new Error('parameter must be an object');
            }
            const result = await this.genericRequest(action, data);
            return { jsonrpc: '2.0', id: 0, result };
        }
        async _wallet_addEthereumChain(params) {
            var _a, _b, _c, _d;
            const request = params[0];
            if (((_a = request.rpcUrls) === null || _a === void 0 ? void 0 : _a.length) === 0) {
                return {
                    jsonrpc: '2.0',
                    id: 0,
                    error: { code: 2, message: `please pass in at least 1 rpcUrl` },
                };
            }
            if (!request.chainName || request.chainName.trim() === '') {
                throw error_1.standardErrors.rpc.invalidParams('chainName is a required field');
            }
            if (!request.nativeCurrency) {
                throw error_1.standardErrors.rpc.invalidParams('nativeCurrency is a required field');
            }
            const chainIdNumber = parseInt(request.chainId, 16);
            const success = await this.addEthereumChain(chainIdNumber, (_b = request.rpcUrls) !== null && _b !== void 0 ? _b : [], (_c = request.blockExplorerUrls) !== null && _c !== void 0 ? _c : [], request.chainName, (_d = request.iconUrls) !== null && _d !== void 0 ? _d : [], request.nativeCurrency);
            if (success) {
                return { jsonrpc: '2.0', id: 0, result: null };
            }
            return {
                jsonrpc: '2.0',
                id: 0,
                error: { code: 2, message: `unable to add ethereum chain` },
            };
        }
        async _wallet_switchEthereumChain(params) {
            const request = params[0];
            await this.switchEthereumChain(parseInt(request.chainId, 16));
            return { jsonrpc: '2.0', id: 0, result: null };
        }
        async _wallet_watchAsset(params) {
            const request = (Array.isArray(params) ? params[0] : params);
            if (!request.type) {
                throw error_1.standardErrors.rpc.invalidParams('Type is required');
            }
            if ((request === null || request === void 0 ? void 0 : request.type) !== 'ERC20') {
                throw error_1.standardErrors.rpc.invalidParams(`Asset of type '${request.type}' is not supported`);
            }
            if (!(request === null || request === void 0 ? void 0 : request.options)) {
                throw error_1.standardErrors.rpc.invalidParams('Options are required');
            }
            if (!(request === null || request === void 0 ? void 0 : request.options.address)) {
                throw error_1.standardErrors.rpc.invalidParams('Address is required');
            }
            const chainId = this.getChainId();
            const { address, symbol, image, decimals } = request.options;
            const res = await this.watchAsset(request.type, address, symbol, decimals, image, chainId);
            return { jsonrpc: '2.0', id: 0, result: res };
        }
        _eth_uninstallFilter(params) {
            const filterId = (0, util_1$2.ensureHexString)(params[0]);
            return this._filterPolyfill.uninstallFilter(filterId);
        }
        async _eth_newFilter(params) {
            const param = params[0];
            const filterId = await this._filterPolyfill.newFilter(param);
            return { jsonrpc: '2.0', id: 0, result: filterId };
        }
        async _eth_newBlockFilter() {
            const filterId = await this._filterPolyfill.newBlockFilter();
            return { jsonrpc: '2.0', id: 0, result: filterId };
        }
        async _eth_newPendingTransactionFilter() {
            const filterId = await this._filterPolyfill.newPendingTransactionFilter();
            return { jsonrpc: '2.0', id: 0, result: filterId };
        }
        _eth_getFilterChanges(params) {
            const filterId = (0, util_1$2.ensureHexString)(params[0]);
            return this._filterPolyfill.getFilterChanges(filterId);
        }
        _eth_getFilterLogs(params) {
            const filterId = (0, util_1$2.ensureHexString)(params[0]);
            return this._filterPolyfill.getFilterLogs(filterId);
        }
        initializeRelay() {
            if (this._relay) {
                return Promise.resolve(this._relay);
            }
            return this._relayProvider().then((relay) => {
                relay.setAccountsCallback((accounts, isDisconnect) => this._setAddresses(accounts, isDisconnect));
                relay.setChainCallback((chainId, jsonRpcUrl) => {
                    this.updateProviderInfo(jsonRpcUrl, parseInt(chainId, 10));
                });
                relay.setDappDefaultChainCallback(this._chainIdFromOpts);
                this._relay = relay;
                return relay;
            });
        }
    }
    CoinbaseWalletProvider$1.CoinbaseWalletProvider = CoinbaseWalletProvider;

    var RelayEventManager$1 = {};

    Object.defineProperty(RelayEventManager$1, "__esModule", { value: true });
    RelayEventManager$1.RelayEventManager = void 0;
    const util_1$1 = util$3;
    class RelayEventManager {
        constructor() {
            this._nextRequestId = 0;
            this.callbacks = new Map();
        }
        makeRequestId() {
            // max nextId == max int32 for compatibility with mobile
            this._nextRequestId = (this._nextRequestId + 1) % 0x7fffffff;
            const id = this._nextRequestId;
            const idStr = (0, util_1$1.prepend0x)(id.toString(16));
            // unlikely that this will ever be an issue, but just to be safe
            const callback = this.callbacks.get(idStr);
            if (callback) {
                this.callbacks.delete(idStr);
            }
            return id;
        }
    }
    RelayEventManager$1.RelayEventManager = RelayEventManager;

    // Copyright (c) 2018-2023 Coinbase, Inc. <https://www.coinbase.com/>
    // Licensed under the Apache License, version 2.0
    Object.defineProperty(CoinbaseWalletSDK$1, "__esModule", { value: true });
    CoinbaseWalletSDK$1.CoinbaseWalletSDK = void 0;
    const wallet_logo_1 = walletLogo$1;
    const constants_1 = constants$3;
    const util_1 = util$3;
    const ScopedLocalStorage_1 = ScopedLocalStorage$1;
    const CoinbaseWalletProvider_1 = CoinbaseWalletProvider$1;
    const MobileRelay_1 = MobileRelay$1;
    const MobileRelayUI_1 = MobileRelayUI$1;
    const RelayEventManager_1 = RelayEventManager$1;
    const WalletLinkRelayUI_1 = WalletLinkRelayUI$1;
    const WalletLinkRelay_1 = WalletLinkRelay$1;
    const version_1 = version;
    class CoinbaseWalletSDK {
        /**
         * Constructor
         * @param options Coinbase Wallet SDK constructor options
         */
        constructor(options) {
            var _a, _b, _c;
            this._appName = '';
            this._appLogoUrl = null;
            this._relay = null;
            this._relayEventManager = null;
            const linkAPIUrl = options.linkAPIUrl || constants_1.LINK_API_URL;
            if (typeof options.overrideIsMetaMask === 'undefined') {
                this._overrideIsMetaMask = false;
            }
            else {
                this._overrideIsMetaMask = options.overrideIsMetaMask;
            }
            this._overrideIsCoinbaseWallet = (_a = options.overrideIsCoinbaseWallet) !== null && _a !== void 0 ? _a : true;
            this._overrideIsCoinbaseBrowser = (_b = options.overrideIsCoinbaseBrowser) !== null && _b !== void 0 ? _b : false;
            this._diagnosticLogger = options.diagnosticLogger;
            this._reloadOnDisconnect = (_c = options.reloadOnDisconnect) !== null && _c !== void 0 ? _c : true;
            const url = new URL(linkAPIUrl);
            const origin = `${url.protocol}//${url.host}`;
            this._storage = new ScopedLocalStorage_1.ScopedLocalStorage(`-walletlink:${origin}`); // needs migration to preserve local states
            this._storage.setItem('version', CoinbaseWalletSDK.VERSION);
            if (this.walletExtension || this.coinbaseBrowser) {
                return;
            }
            this._relayEventManager = new RelayEventManager_1.RelayEventManager();
            const isMobile = (0, util_1.isMobileWeb)();
            const uiConstructor = options.uiConstructor ||
                ((opts) => (isMobile ? new MobileRelayUI_1.MobileRelayUI(opts) : new WalletLinkRelayUI_1.WalletLinkRelayUI(opts)));
            const relayOption = {
                linkAPIUrl,
                version: version_1.LIB_VERSION,
                darkMode: !!options.darkMode,
                uiConstructor,
                storage: this._storage,
                relayEventManager: this._relayEventManager,
                diagnosticLogger: this._diagnosticLogger,
                reloadOnDisconnect: this._reloadOnDisconnect,
                enableMobileWalletLink: options.enableMobileWalletLink,
            };
            this._relay = isMobile ? new MobileRelay_1.MobileRelay(relayOption) : new WalletLinkRelay_1.WalletLinkRelay(relayOption);
            this.setAppInfo(options.appName, options.appLogoUrl);
            if (options.headlessMode)
                return;
            this._relay.attachUI();
        }
        /**
         * Create a Web3 Provider object
         * @param jsonRpcUrl Ethereum JSON RPC URL (Default: "")
         * @param chainId Ethereum Chain ID (Default: 1)
         * @returns A Web3 Provider
         */
        makeWeb3Provider(jsonRpcUrl = '', chainId = 1) {
            const extension = this.walletExtension;
            if (extension) {
                if (!this.isCipherProvider(extension)) {
                    extension.setProviderInfo(jsonRpcUrl, chainId);
                }
                if (this._reloadOnDisconnect === false &&
                    typeof extension.disableReloadOnDisconnect === 'function')
                    extension.disableReloadOnDisconnect();
                return extension;
            }
            const dappBrowser = this.coinbaseBrowser;
            if (dappBrowser) {
                return dappBrowser;
            }
            const relay = this._relay;
            if (!relay || !this._relayEventManager || !this._storage) {
                throw new Error('Relay not initialized, should never happen');
            }
            if (!jsonRpcUrl)
                relay.setConnectDisabled(true);
            return new CoinbaseWalletProvider_1.CoinbaseWalletProvider({
                relayProvider: () => Promise.resolve(relay),
                relayEventManager: this._relayEventManager,
                storage: this._storage,
                jsonRpcUrl,
                chainId,
                qrUrl: this.getQrUrl(),
                diagnosticLogger: this._diagnosticLogger,
                overrideIsMetaMask: this._overrideIsMetaMask,
                overrideIsCoinbaseWallet: this._overrideIsCoinbaseWallet,
                overrideIsCoinbaseBrowser: this._overrideIsCoinbaseBrowser,
            });
        }
        /**
         * Set application information
         * @param appName Application name
         * @param appLogoUrl Application logo image URL
         */
        setAppInfo(appName, appLogoUrl) {
            var _a;
            this._appName = appName || 'DApp';
            this._appLogoUrl = appLogoUrl || (0, util_1.getFavicon)();
            const extension = this.walletExtension;
            if (extension) {
                if (!this.isCipherProvider(extension)) {
                    extension.setAppInfo(this._appName, this._appLogoUrl);
                }
            }
            else {
                (_a = this._relay) === null || _a === void 0 ? void 0 : _a.setAppInfo(this._appName, this._appLogoUrl);
            }
        }
        /**
         * Disconnect. After disconnecting, this will reload the web page to ensure
         * all potential stale state is cleared.
         */
        disconnect() {
            var _a;
            const extension = this === null || this === void 0 ? void 0 : this.walletExtension;
            if (extension) {
                void extension.close();
            }
            else {
                (_a = this._relay) === null || _a === void 0 ? void 0 : _a.resetAndReload();
            }
        }
        /**
         * Return QR URL for mobile wallet connection, will return null if extension is installed
         */
        getQrUrl() {
            var _a, _b;
            return (_b = (_a = this._relay) === null || _a === void 0 ? void 0 : _a.getQRCodeUrl()) !== null && _b !== void 0 ? _b : null;
        }
        /**
         * Official Coinbase Wallet logo for developers to use on their frontend
         * @param type Type of wallet logo: "standard" | "circle" | "text" | "textWithLogo" | "textLight" | "textWithLogoLight"
         * @param width Width of the logo (Optional)
         * @returns SVG Data URI
         */
        getCoinbaseWalletLogo(type, width = 240) {
            return (0, wallet_logo_1.walletLogo)(type, width);
        }
        get walletExtension() {
            var _a;
            return (_a = window.coinbaseWalletExtension) !== null && _a !== void 0 ? _a : window.walletLinkExtension;
        }
        get coinbaseBrowser() {
            var _a, _b;
            try {
                // Coinbase DApp browser does not inject into iframes so grab provider from top frame if it exists
                const ethereum = (_a = window.ethereum) !== null && _a !== void 0 ? _a : (_b = window.top) === null || _b === void 0 ? void 0 : _b.ethereum;
                if (!ethereum) {
                    return undefined;
                }
                if ('isCoinbaseBrowser' in ethereum && ethereum.isCoinbaseBrowser) {
                    return ethereum;
                }
                return undefined;
            }
            catch (e) {
                return undefined;
            }
        }
        isCipherProvider(provider) {
            // @ts-expect-error isCipher walletlink property
            return typeof provider.isCipher === 'boolean' && provider.isCipher;
        }
    }
    CoinbaseWalletSDK$1.CoinbaseWalletSDK = CoinbaseWalletSDK;
    CoinbaseWalletSDK.VERSION = version_1.LIB_VERSION;

    (function (exports) {
    	// Copyright (c) 2018-2023 Coinbase, Inc. <https://www.coinbase.com/>
    	// Licensed under the Apache License, version 2.0
    	Object.defineProperty(exports, "__esModule", { value: true });
    	exports.CoinbaseWalletProvider = exports.CoinbaseWalletSDK = void 0;
    	const CoinbaseWalletSDK_1 = CoinbaseWalletSDK$1;
    	const CoinbaseWalletProvider_1 = CoinbaseWalletProvider$1;
    	var CoinbaseWalletSDK_2 = CoinbaseWalletSDK$1;
    	Object.defineProperty(exports, "CoinbaseWalletSDK", { enumerable: true, get: function () { return CoinbaseWalletSDK_2.CoinbaseWalletSDK; } });
    	var CoinbaseWalletProvider_2 = CoinbaseWalletProvider$1;
    	Object.defineProperty(exports, "CoinbaseWalletProvider", { enumerable: true, get: function () { return CoinbaseWalletProvider_2.CoinbaseWalletProvider; } });
    	exports.default = CoinbaseWalletSDK_1.CoinbaseWalletSDK;
    	if (typeof window !== 'undefined') {
    	    window.CoinbaseWalletSDK = CoinbaseWalletSDK_1.CoinbaseWalletSDK;
    	    window.CoinbaseWalletProvider = CoinbaseWalletProvider_1.CoinbaseWalletProvider;
    	    /**
    	     * @deprecated Use `window.CoinbaseWalletSDK`
    	     */
    	    window.WalletLink = CoinbaseWalletSDK_1.CoinbaseWalletSDK;
    	    /**
    	     * @deprecated Use `window.CoinbaseWalletProvider`
    	     */
    	    window.WalletLinkProvider = CoinbaseWalletProvider_1.CoinbaseWalletProvider;
    	} 
    } (dist$5));

    var index$3 = /*@__PURE__*/getDefaultExportFromCjs(dist$5);

    var index$4 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        default: index$3
    });

    coinbaseWallet.type = 'coinbaseWallet';
    function coinbaseWallet(parameters) {
        const reloadOnDisconnect = false;
        let sdk;
        let walletProvider;
        return createConnector((config) => ({
            id: 'coinbaseWalletSDK',
            name: 'Coinbase Wallet',
            type: coinbaseWallet.type,
            async connect({ chainId } = {}) {
                try {
                    const provider = await this.getProvider();
                    const accounts = (await provider.request({
                        method: 'eth_requestAccounts',
                    })).map((x) => getAddress(x));
                    provider.on('accountsChanged', this.onAccountsChanged);
                    provider.on('chainChanged', this.onChainChanged);
                    provider.on('disconnect', this.onDisconnect.bind(this));
                    // Switch to chain if provided
                    let currentChainId = await this.getChainId();
                    if (chainId && currentChainId !== chainId) {
                        const chain = await this.switchChain({ chainId }).catch((error) => {
                            if (error.code === UserRejectedRequestError.code)
                                throw error;
                            return { id: currentChainId };
                        });
                        currentChainId = chain?.id ?? currentChainId;
                    }
                    return { accounts, chainId: currentChainId };
                }
                catch (error) {
                    if (/(user closed modal|accounts received is empty|user denied account)/i.test(error.message))
                        throw new UserRejectedRequestError(error);
                    throw error;
                }
            },
            async disconnect() {
                const provider = await this.getProvider();
                provider.removeListener('accountsChanged', this.onAccountsChanged);
                provider.removeListener('chainChanged', this.onChainChanged);
                provider.removeListener('disconnect', this.onDisconnect.bind(this));
                provider.disconnect();
                provider.close();
            },
            async getAccounts() {
                const provider = await this.getProvider();
                return (await provider.request({
                    method: 'eth_accounts',
                })).map((x) => getAddress(x));
            },
            async getChainId() {
                const provider = await this.getProvider();
                const chainId = await provider.request({ method: 'eth_chainId' });
                return Number(chainId);
            },
            async getProvider() {
                if (!walletProvider) {
                    const { default: CoinbaseWalletSDK } = await Promise.resolve().then(function () { return index$4; });
                    let SDK;
                    if (typeof CoinbaseWalletSDK !== 'function' &&
                        typeof CoinbaseWalletSDK.default === 'function')
                        SDK = CoinbaseWalletSDK.default;
                    else
                        SDK = CoinbaseWalletSDK;
                    sdk = new SDK({ reloadOnDisconnect, ...parameters });
                    // Force types to retrieve private `walletExtension` method from the Coinbase Wallet SDK.
                    const walletExtensionChainId = sdk.walletExtension?.getChainId();
                    const chain = config.chains.find((chain) => parameters.chainId
                        ? chain.id === parameters.chainId
                        : chain.id === walletExtensionChainId) || config.chains[0];
                    const chainId = parameters.chainId || chain?.id;
                    const jsonRpcUrl = parameters.jsonRpcUrl || chain?.rpcUrls.default.http[0];
                    walletProvider = sdk.makeWeb3Provider(jsonRpcUrl, chainId);
                }
                return walletProvider;
            },
            async isAuthorized() {
                try {
                    const accounts = await this.getAccounts();
                    return !!accounts.length;
                }
                catch {
                    return false;
                }
            },
            async switchChain({ chainId }) {
                const chain = config.chains.find((chain) => chain.id === chainId);
                if (!chain)
                    throw new SwitchChainError(new ChainNotConfiguredError());
                const provider = await this.getProvider();
                const chainId_ = numberToHex$1(chain.id);
                try {
                    await provider.request({
                        method: 'wallet_switchEthereumChain',
                        params: [{ chainId: chainId_ }],
                    });
                    return chain;
                }
                catch (error) {
                    // Indicates chain is not added to provider
                    if (error.code === 4902) {
                        try {
                            await provider.request({
                                method: 'wallet_addEthereumChain',
                                params: [
                                    {
                                        chainId: chainId_,
                                        chainName: chain.name,
                                        nativeCurrency: chain.nativeCurrency,
                                        rpcUrls: [chain.rpcUrls.default?.http[0] ?? ''],
                                        blockExplorerUrls: [chain.blockExplorers?.default.url],
                                    },
                                ],
                            });
                            return chain;
                        }
                        catch (error) {
                            throw new UserRejectedRequestError(error);
                        }
                    }
                    throw new SwitchChainError(error);
                }
            },
            onAccountsChanged(accounts) {
                if (accounts.length === 0)
                    config.emitter.emit('disconnect');
                else
                    config.emitter.emit('change', {
                        accounts: accounts.map((x) => getAddress(x)),
                    });
            },
            onChainChanged(chain) {
                const chainId = Number(chain);
                config.emitter.emit('change', { chainId });
            },
            async onDisconnect(_error) {
                config.emitter.emit('disconnect');
                const provider = await this.getProvider();
                provider.removeListener('accountsChanged', this.onAccountsChanged);
                provider.removeListener('chainChanged', this.onChainChanged);
                provider.removeListener('disconnect', this.onDisconnect.bind(this));
            },
        }));
    }

    walletConnect.type = 'walletConnect';
    function walletConnect(parameters) {
        const isNewChainsStale = parameters.isNewChainsStale ?? true;
        let provider_;
        let providerPromise;
        const NAMESPACE = 'eip155';
        return createConnector((config) => ({
            id: 'walletConnect',
            name: 'WalletConnect',
            type: walletConnect.type,
            async setup() {
                const provider = await this.getProvider().catch(() => null);
                if (!provider)
                    return;
                provider.on('connect', this.onConnect.bind(this));
                provider.on('session_delete', this.onSessionDelete.bind(this));
            },
            async connect({ chainId, ...rest } = {}) {
                try {
                    const provider = await this.getProvider();
                    if (!provider)
                        throw new ProviderNotFoundError();
                    provider.on('display_uri', this.onDisplayUri);
                    let targetChainId = chainId;
                    if (!targetChainId) {
                        const state = (await config.storage?.getItem('state')) ?? {};
                        const isChainSupported = config.chains.some((x) => x.id === state.chainId);
                        if (isChainSupported)
                            targetChainId = state.chainId;
                        else
                            targetChainId = config.chains[0]?.id;
                    }
                    if (!targetChainId)
                        throw new Error('No chains found on connector.');
                    const isChainsStale = await this.isChainsStale();
                    // If there is an active session with stale chains, disconnect current session.
                    if (provider.session && isChainsStale)
                        await provider.disconnect();
                    // If there isn't an active session or chains are stale, connect.
                    if (!provider.session || isChainsStale) {
                        const optionalChains = config.chains
                            .filter((chain) => chain.id !== targetChainId)
                            .map((optionalChain) => optionalChain.id);
                        await provider.connect({
                            optionalChains: [targetChainId, ...optionalChains],
                            ...('pairingTopic' in rest
                                ? { pairingTopic: rest.pairingTopic }
                                : {}),
                        });
                        this.setRequestedChainsIds(config.chains.map((x) => x.id));
                    }
                    // If session exists and chains are authorized, enable provider for required chain
                    const accounts = (await provider.enable()).map((x) => getAddress(x));
                    const currentChainId = await this.getChainId();
                    provider.removeListener('display_uri', this.onDisplayUri);
                    provider.removeListener('connect', this.onConnect.bind(this));
                    provider.on('accountsChanged', this.onAccountsChanged.bind(this));
                    provider.on('chainChanged', this.onChainChanged);
                    provider.on('disconnect', this.onDisconnect.bind(this));
                    provider.on('session_delete', this.onSessionDelete.bind(this));
                    return { accounts, chainId: currentChainId };
                }
                catch (error) {
                    if (/(user rejected|connection request reset)/i.test(error?.message)) {
                        throw new UserRejectedRequestError(error);
                    }
                    throw error;
                }
            },
            async disconnect() {
                const provider = await this.getProvider();
                try {
                    await provider?.disconnect();
                }
                catch (error) {
                    if (!/No matching key/i.test(error.message))
                        throw error;
                }
                finally {
                    provider?.removeListener('accountsChanged', this.onAccountsChanged.bind(this));
                    provider?.removeListener('chainChanged', this.onChainChanged);
                    provider?.removeListener('disconnect', this.onDisconnect.bind(this));
                    provider?.removeListener('session_delete', this.onSessionDelete.bind(this));
                    provider?.on('connect', this.onConnect.bind(this));
                    this.setRequestedChainsIds([]);
                }
            },
            async getAccounts() {
                const provider = await this.getProvider();
                return provider.accounts.map((x) => getAddress(x));
            },
            async getProvider({ chainId } = {}) {
                async function initProvider() {
                    const optionalChains = config.chains.map((x) => x.id);
                    if (!optionalChains.length)
                        return;
                    const { EthereumProvider } = await Promise.resolve().then(function () { return index_es; });
                    return await EthereumProvider.init({
                        ...parameters,
                        disableProviderPing: true,
                        optionalChains,
                        projectId: parameters.projectId,
                        rpcMap: Object.fromEntries(config.chains.map((chain) => [
                            chain.id,
                            chain.rpcUrls.default.http[0],
                        ])),
                        showQrModal: parameters.showQrModal ?? true,
                    });
                }
                if (!provider_) {
                    if (!providerPromise)
                        providerPromise = initProvider();
                    provider_ = await providerPromise;
                    provider_?.events.setMaxListeners(Infinity);
                }
                if (chainId)
                    await this.switchChain?.({ chainId });
                return provider_;
            },
            async getChainId() {
                const provider = await this.getProvider();
                return provider.chainId;
            },
            async isAuthorized() {
                try {
                    const [accounts, provider] = await Promise.all([
                        this.getAccounts(),
                        this.getProvider(),
                    ]);
                    // If an account does not exist on the session, then the connector is unauthorized.
                    if (!accounts.length)
                        return false;
                    // If the chains are stale on the session, then the connector is unauthorized.
                    const isChainsStale = await this.isChainsStale();
                    if (isChainsStale && provider.session) {
                        await provider.disconnect().catch(() => { });
                        return false;
                    }
                    return true;
                }
                catch {
                    return false;
                }
            },
            async switchChain({ chainId }) {
                const chain = config.chains.find((chain) => chain.id === chainId);
                if (!chain)
                    throw new SwitchChainError(new ChainNotConfiguredError());
                try {
                    const provider = await this.getProvider();
                    const namespaceChains = this.getNamespaceChainsIds();
                    const namespaceMethods = this.getNamespaceMethods();
                    const isChainApproved = namespaceChains.includes(chainId);
                    if (!isChainApproved &&
                        namespaceMethods.includes('wallet_addEthereumChain')) {
                        await provider.request({
                            method: 'wallet_addEthereumChain',
                            params: [
                                {
                                    chainId: numberToHex$1(chain.id),
                                    blockExplorerUrls: [chain.blockExplorers?.default.url],
                                    chainName: chain.name,
                                    nativeCurrency: chain.nativeCurrency,
                                    rpcUrls: [...chain.rpcUrls.default.http],
                                },
                            ],
                        });
                        const requestedChains = await this.getRequestedChainsIds();
                        this.setRequestedChainsIds([...requestedChains, chainId]);
                    }
                    await provider.request({
                        method: 'wallet_switchEthereumChain',
                        params: [{ chainId: numberToHex$1(chainId) }],
                    });
                    return chain;
                }
                catch (error) {
                    const message = typeof error === 'string'
                        ? error
                        : error?.message;
                    if (/user rejected request/i.test(message))
                        throw new UserRejectedRequestError(error);
                    throw new SwitchChainError(error);
                }
            },
            onAccountsChanged(accounts) {
                if (accounts.length === 0)
                    this.onDisconnect();
                else
                    config.emitter.emit('change', {
                        accounts: accounts.map((x) => getAddress(x)),
                    });
            },
            onChainChanged(chain) {
                const chainId = Number(chain);
                config.emitter.emit('change', { chainId });
            },
            async onConnect(connectInfo) {
                const chainId = Number(connectInfo.chainId);
                const accounts = await this.getAccounts();
                config.emitter.emit('connect', { accounts, chainId });
            },
            async onDisconnect(_error) {
                this.setRequestedChainsIds([]);
                config.emitter.emit('disconnect');
                const provider = await this.getProvider();
                provider.removeListener('accountsChanged', this.onAccountsChanged.bind(this));
                provider.removeListener('chainChanged', this.onChainChanged);
                provider.removeListener('disconnect', this.onDisconnect.bind(this));
                provider.removeListener('session_delete', this.onSessionDelete.bind(this));
                provider.on('connect', this.onConnect.bind(this));
            },
            onDisplayUri(uri) {
                config.emitter.emit('message', { type: 'display_uri', data: uri });
            },
            onSessionDelete() {
                this.onDisconnect();
            },
            getNamespaceChainsIds() {
                if (!provider_)
                    return [];
                const chainIds = provider_.session?.namespaces[NAMESPACE]?.chains?.map((chain) => parseInt(chain.split(':')[1] || ''));
                return chainIds ?? [];
            },
            getNamespaceMethods() {
                if (!provider_)
                    return [];
                const methods = provider_.session?.namespaces[NAMESPACE]
                    ?.methods;
                return methods ?? [];
            },
            async getRequestedChainsIds() {
                return ((await config.storage?.getItem(this.requestedChainsStorageKey)) ?? []);
            },
            /**
             * Checks if the target chains match the chains that were
             * initially requested by the connector for the WalletConnect session.
             * If there is a mismatch, this means that the chains on the connector
             * are considered stale, and need to be revalidated at a later point (via
             * connection).
             *
             * There may be a scenario where a dapp adds a chain to the
             * connector later on, however, this chain will not have been approved or rejected
             * by the wallet. In this case, the chain is considered stale.
             *
             * There are exceptions however:
             * -  If the wallet supports dynamic chain addition via `eth_addEthereumChain`,
             *    then the chain is not considered stale.
             * -  If the `isNewChainsStale` flag is falsy on the connector, then the chain is
             *    not considered stale.
             *
             * For the above cases, chain validation occurs dynamically when the user
             * attempts to switch chain.
             *
             * Also check that dapp supports at least 1 chain from previously approved session.
             */
            async isChainsStale() {
                const namespaceMethods = this.getNamespaceMethods();
                if (namespaceMethods.includes('wallet_addEthereumChain'))
                    return false;
                if (!isNewChainsStale)
                    return false;
                const connectorChains = config.chains.map((x) => x.id);
                const namespaceChains = this.getNamespaceChainsIds();
                if (namespaceChains.length &&
                    !namespaceChains.some((id) => connectorChains.includes(id)))
                    return false;
                const requestedChains = await this.getRequestedChainsIds();
                return !connectorChains.every((id) => requestedChains.includes(id));
            },
            async setRequestedChainsIds(chains) {
                await config.storage?.setItem(this.requestedChainsStorageKey, chains);
            },
            get requestedChainsStorageKey() {
                return `${this.id}.requestedChains`;
            },
        }));
    }

    function emailConnector(parameters) {
        return createConnector(config => ({
            id: ConstantsUtil.EMAIL_CONNECTOR_ID,
            name: 'Web3Modal Email',
            type: 'w3mEmail',
            async connect(options = {}) {
                const provider = await this.getProvider();
                const { address, chainId } = await provider.connect({ chainId: options.chainId });
                const { isDeployed, address: smartAccountAddress } = await this.initSmartAccount();
                if (isDeployed && smartAccountAddress) {
                    return {
                        accounts: [smartAccountAddress],
                        account: smartAccountAddress,
                        chainId,
                        chain: {
                            id: chainId,
                            unsuported: false
                        }
                    };
                }
                return {
                    accounts: [address],
                    account: address,
                    chainId,
                    chain: {
                        id: chainId,
                        unsuported: false
                    }
                };
            },
            async initSmartAccount() {
                if (!parameters.options.enableSmartAccounts) {
                    return { isDeployed: false };
                }
                const provider = await this.getProvider();
                const chainId = await this.getChainId();
                const { smartAccountEnabledNetworks } = await provider.getSmartAccountEnabledNetworks();
                if (smartAccountEnabledNetworks.includes(chainId)) {
                    return (await provider.initSmartAccount());
                }
                return { isDeployed: false };
            },
            async disconnect() {
                const provider = await this.getProvider();
                await provider.disconnect();
            },
            async getAccounts() {
                const provider = await this.getProvider();
                const { address } = await provider.connect();
                return [address];
            },
            async getProvider() {
                if (!this.provider) {
                    this.provider = new W3mFrameProvider(parameters.options.projectId);
                }
                return Promise.resolve(this.provider);
            },
            async getChainId() {
                const provider = await this.getProvider();
                const { chainId } = await provider.getChainId();
                return chainId;
            },
            async isAuthorized() {
                const provider = await this.getProvider();
                const { isConnected } = await provider.isConnected();
                return isConnected;
            },
            async switchChain({ chainId }) {
                try {
                    const chain = config.chains.find(c => c.id === chainId);
                    if (!chain) {
                        throw new SwitchChainError(new Error('chain not found on connector.'));
                    }
                    const provider = await this.getProvider();
                    await provider.switchNetwork(chainId);
                    config.emitter.emit('change', { chainId: normalizeChainId(chainId) });
                    return chain;
                }
                catch (error) {
                    if (error instanceof Error) {
                        throw new SwitchChainError(error);
                    }
                    throw error;
                }
            },
            onAccountsChanged(accounts) {
                if (accounts.length === 0) {
                    this.onDisconnect();
                }
                else {
                    config.emitter.emit('change', { accounts: accounts.map(getAddress) });
                }
            },
            onChainChanged(chain) {
                const chainId = normalizeChainId(chain);
                config.emitter.emit('change', { chainId });
            },
            async onConnect(connectInfo) {
                const chainId = normalizeChainId(connectInfo.chainId);
                const accounts = await this.getAccounts();
                config.emitter.emit('connect', { accounts, chainId });
            },
            async onDisconnect(_error) {
                const provider = await this.getProvider();
                await provider.disconnect();
            }
        }));
    }

    function defaultWagmiConfig({ projectId, chains, metadata, enableInjected, enableCoinbase, enableEmail, enableWalletConnect, enableEIP6963, enableSmartAccounts, ...wagmiConfig }) {
        const connectors = [];
        const transportsArr = chains.map(chain => [
            chain.id,
            getTransport({ chainId: chain.id, projectId })
        ]);
        const transports = Object.fromEntries(transportsArr);
        if (enableWalletConnect !== false) {
            connectors.push(walletConnect({ projectId, metadata, showQrModal: false }));
        }
        if (enableInjected !== false) {
            connectors.push(injected({ shimDisconnect: true }));
        }
        if (enableCoinbase !== false) {
            connectors.push(coinbaseWallet({
                appName: metadata?.name ?? 'Unknown',
                appLogoUrl: metadata?.icons[0] ?? 'Unknown',
                enableMobileWalletLink: true
            }));
        }
        if (enableEmail === true) {
            connectors.push(emailConnector({ chains: [...chains], options: { projectId, enableSmartAccounts } }));
        }
        return createConfig({
            chains,
            multiInjectedProviderDiscovery: enableEIP6963 !== false,
            transports,
            ...wagmiConfig,
            connectors
        });
    }

    function createWeb3Modal(options) {
        return new Web3Modal({ ...options, _sdkVersion: `html-wagmi-${ConstantsUtil.VERSION}` });
    }

    var defaultMetadata = {
        name: 'Further',
        description: 'Further wallet connect',
        url: 'https://web3modal.com', // origin must match your domain & subdomain.
        icons: [
            'https://pbs.twimg.com/profile_images/1538910460245856256/EVS8v1Dh_400x400.jpg',
        ],
    };
    var initializeWalletConnect = function (_a) {
        var projectId = _a.projectId, _b = _a.metadata, metadata = _b === void 0 ? defaultMetadata : _b, onChangeAccount = _a.onChangeAccount;
        var finalMetadata = __assign(__assign({}, defaultMetadata), { metadata: metadata });
        var chains = [mainnet, arbitrum];
        var config = defaultWagmiConfig({
            chains: chains,
            projectId: projectId,
            metadata: finalMetadata,
        });
        reconnect(config);
        // 3. Create modal
        var modal = createWeb3Modal({
            wagmiConfig: config,
            projectId: projectId,
        });
        // listening for account changes
        watchAccount(config, {
            onChange: function (account, prevAccount) {
                onChangeAccount === null || onChangeAccount === void 0 ? void 0 : onChangeAccount(account, prevAccount);
            },
        });
        function connect() {
            if (getAccount(config).isConnected) {
                disconnect(config);
            }
            else {
                modal.open();
            }
        }
        return connect;
    };
    window.initializeWalletConnect = initializeWalletConnect;

    const o$9=proxy({history:["ConnectWallet"],view:"ConnectWallet",data:void 0}),T$3={state:o$9,subscribe(e){return subscribe(o$9,()=>e(o$9))},push(e,t){e!==o$9.view&&(o$9.view=e,t&&(o$9.data=t),o$9.history.push(e));},reset(e){o$9.view=e,o$9.history=[e];},replace(e){o$9.history.length>1&&(o$9.history[o$9.history.length-1]=e,o$9.view=e);},goBack(){if(o$9.history.length>1){o$9.history.pop();const[e]=o$9.history.slice(-1);o$9.view=e;}},setData(e){o$9.data=e;}},a$4={WALLETCONNECT_DEEPLINK_CHOICE:"WALLETCONNECT_DEEPLINK_CHOICE",WCM_VERSION:"WCM_VERSION",RECOMMENDED_WALLET_AMOUNT:9,isMobile(){return typeof window<"u"?Boolean(window.matchMedia("(pointer:coarse)").matches||/Android|webOS|iPhone|iPad|iPod|BlackBerry|Opera Mini/u.test(navigator.userAgent)):!1},isAndroid(){return a$4.isMobile()&&navigator.userAgent.toLowerCase().includes("android")},isIos(){const e=navigator.userAgent.toLowerCase();return a$4.isMobile()&&(e.includes("iphone")||e.includes("ipad"))},isHttpUrl(e){return e.startsWith("http://")||e.startsWith("https://")},isArray(e){return Array.isArray(e)&&e.length>0},formatNativeUrl(e,t,s){if(a$4.isHttpUrl(e))return this.formatUniversalUrl(e,t,s);let n=e;n.includes("://")||(n=e.replaceAll("/","").replaceAll(":",""),n=`${n}://`),n.endsWith("/")||(n=`${n}/`),this.setWalletConnectDeepLink(n,s);const i=encodeURIComponent(t);return `${n}wc?uri=${i}`},formatUniversalUrl(e,t,s){if(!a$4.isHttpUrl(e))return this.formatNativeUrl(e,t,s);let n=e;n.endsWith("/")||(n=`${n}/`),this.setWalletConnectDeepLink(n,s);const i=encodeURIComponent(t);return `${n}wc?uri=${i}`},async wait(e){return new Promise(t=>{setTimeout(t,e);})},openHref(e,t){window.open(e,t,"noreferrer noopener");},setWalletConnectDeepLink(e,t){try{localStorage.setItem(a$4.WALLETCONNECT_DEEPLINK_CHOICE,JSON.stringify({href:e,name:t}));}catch{console.info("Unable to set WalletConnect deep link");}},setWalletConnectAndroidDeepLink(e){try{const[t]=e.split("?");localStorage.setItem(a$4.WALLETCONNECT_DEEPLINK_CHOICE,JSON.stringify({href:t,name:"Android"}));}catch{console.info("Unable to set WalletConnect android deep link");}},removeWalletConnectDeepLink(){try{localStorage.removeItem(a$4.WALLETCONNECT_DEEPLINK_CHOICE);}catch{console.info("Unable to remove WalletConnect deep link");}},setModalVersionInStorage(){try{typeof localStorage<"u"&&localStorage.setItem(a$4.WCM_VERSION,"2.6.2");}catch{console.info("Unable to set Web3Modal version in storage");}},getWalletRouterData(){var e;const t=(e=T$3.state.data)==null?void 0:e.Wallet;if(!t)throw new Error('Missing "Wallet" view data');return t}},_$3=typeof location<"u"&&(location.hostname.includes("localhost")||location.protocol.includes("https")),r$9=proxy({enabled:_$3,userSessionId:"",events:[],connectedWalletId:void 0}),R$2={state:r$9,subscribe(e){return subscribe(r$9.events,()=>e(snapshot(r$9.events[r$9.events.length-1])))},initialize(){r$9.enabled&&typeof(crypto==null?void 0:crypto.randomUUID)<"u"&&(r$9.userSessionId=crypto.randomUUID());},setConnectedWalletId(e){r$9.connectedWalletId=e;},click(e){if(r$9.enabled){const t={type:"CLICK",name:e.name,userSessionId:r$9.userSessionId,timestamp:Date.now(),data:e};r$9.events.push(t);}},track(e){if(r$9.enabled){const t={type:"TRACK",name:e.name,userSessionId:r$9.userSessionId,timestamp:Date.now(),data:e};r$9.events.push(t);}},view(e){if(r$9.enabled){const t={type:"VIEW",name:e.name,userSessionId:r$9.userSessionId,timestamp:Date.now(),data:e};r$9.events.push(t);}}},c$6=proxy({chains:void 0,walletConnectUri:void 0,isAuth:!1,isCustomDesktop:!1,isCustomMobile:!1,isDataLoaded:!1,isUiLoaded:!1}),p$3={state:c$6,subscribe(e){return subscribe(c$6,()=>e(c$6))},setChains(e){c$6.chains=e;},setWalletConnectUri(e){c$6.walletConnectUri=e;},setIsCustomDesktop(e){c$6.isCustomDesktop=e;},setIsCustomMobile(e){c$6.isCustomMobile=e;},setIsDataLoaded(e){c$6.isDataLoaded=e;},setIsUiLoaded(e){c$6.isUiLoaded=e;},setIsAuth(e){c$6.isAuth=e;}},W=proxy({projectId:"",mobileWallets:void 0,desktopWallets:void 0,walletImages:void 0,chains:void 0,enableAuthMode:!1,enableExplorer:!0,explorerExcludedWalletIds:void 0,explorerRecommendedWalletIds:void 0,termsOfServiceUrl:void 0,privacyPolicyUrl:void 0}),y$3={state:W,subscribe(e){return subscribe(W,()=>e(W))},setConfig(e){var t,s;R$2.initialize(),p$3.setChains(e.chains),p$3.setIsAuth(Boolean(e.enableAuthMode)),p$3.setIsCustomMobile(Boolean((t=e.mobileWallets)==null?void 0:t.length)),p$3.setIsCustomDesktop(Boolean((s=e.desktopWallets)==null?void 0:s.length)),a$4.setModalVersionInStorage(),Object.assign(W,e);}};var V$2=Object.defineProperty,D$2=Object.getOwnPropertySymbols,H$2=Object.prototype.hasOwnProperty,B$2=Object.prototype.propertyIsEnumerable,M$2=(e,t,s)=>t in e?V$2(e,t,{enumerable:!0,configurable:!0,writable:!0,value:s}):e[t]=s,K$1=(e,t)=>{for(var s in t||(t={}))H$2.call(t,s)&&M$2(e,s,t[s]);if(D$2)for(var s of D$2(t))B$2.call(t,s)&&M$2(e,s,t[s]);return e};const L$3="https://explorer-api.walletconnect.com",E$2="wcm",O="js-2.6.2";async function w$2(e,t){const s=K$1({sdkType:E$2,sdkVersion:O},t),n=new URL(e,L$3);return n.searchParams.append("projectId",y$3.state.projectId),Object.entries(s).forEach(([i,l])=>{l&&n.searchParams.append(i,String(l));}),(await fetch(n)).json()}const m$2={async getDesktopListings(e){return w$2("/w3m/v1/getDesktopListings",e)},async getMobileListings(e){return w$2("/w3m/v1/getMobileListings",e)},async getInjectedListings(e){return w$2("/w3m/v1/getInjectedListings",e)},async getAllListings(e){return w$2("/w3m/v1/getAllListings",e)},getWalletImageUrl(e){return `${L$3}/w3m/v1/getWalletImage/${e}?projectId=${y$3.state.projectId}&sdkType=${E$2}&sdkVersion=${O}`},getAssetImageUrl(e){return `${L$3}/w3m/v1/getAssetImage/${e}?projectId=${y$3.state.projectId}&sdkType=${E$2}&sdkVersion=${O}`}};var z$1=Object.defineProperty,j$2=Object.getOwnPropertySymbols,J=Object.prototype.hasOwnProperty,q$1=Object.prototype.propertyIsEnumerable,k$2=(e,t,s)=>t in e?z$1(e,t,{enumerable:!0,configurable:!0,writable:!0,value:s}):e[t]=s,F$1=(e,t)=>{for(var s in t||(t={}))J.call(t,s)&&k$2(e,s,t[s]);if(j$2)for(var s of j$2(t))q$1.call(t,s)&&k$2(e,s,t[s]);return e};const N$2=a$4.isMobile(),d$5=proxy({wallets:{listings:[],total:0,page:1},search:{listings:[],total:0,page:1},recomendedWallets:[]}),te$1={state:d$5,async getRecomendedWallets(){const{explorerRecommendedWalletIds:e,explorerExcludedWalletIds:t}=y$3.state;if(e==="NONE"||t==="ALL"&&!e)return d$5.recomendedWallets;if(a$4.isArray(e)){const s={recommendedIds:e.join(",")},{listings:n}=await m$2.getAllListings(s),i=Object.values(n);i.sort((l,v)=>{const b=e.indexOf(l.id),f=e.indexOf(v.id);return b-f}),d$5.recomendedWallets=i;}else {const{chains:s,isAuth:n}=p$3.state,i=s?.join(","),l=a$4.isArray(t),v={page:1,sdks:n?"auth_v1":void 0,entries:a$4.RECOMMENDED_WALLET_AMOUNT,chains:i,version:2,excludedIds:l?t.join(","):void 0},{listings:b}=N$2?await m$2.getMobileListings(v):await m$2.getDesktopListings(v);d$5.recomendedWallets=Object.values(b);}return d$5.recomendedWallets},async getWallets(e){const t=F$1({},e),{explorerRecommendedWalletIds:s,explorerExcludedWalletIds:n}=y$3.state,{recomendedWallets:i}=d$5;if(n==="ALL")return d$5.wallets;i.length?t.excludedIds=i.map(x=>x.id).join(","):a$4.isArray(s)&&(t.excludedIds=s.join(",")),a$4.isArray(n)&&(t.excludedIds=[t.excludedIds,n].filter(Boolean).join(",")),p$3.state.isAuth&&(t.sdks="auth_v1");const{page:l,search:v}=e,{listings:b,total:f}=N$2?await m$2.getMobileListings(t):await m$2.getDesktopListings(t),A=Object.values(b),U=v?"search":"wallets";return d$5[U]={listings:[...d$5[U].listings,...A],total:f,page:l??1},{listings:A,total:f}},getWalletImageUrl(e){return m$2.getWalletImageUrl(e)},getAssetImageUrl(e){return m$2.getAssetImageUrl(e)},resetSearch(){d$5.search={listings:[],total:0,page:1};}},I$2=proxy({open:!1}),se$1={state:I$2,subscribe(e){return subscribe(I$2,()=>e(I$2))},async open(e){return new Promise(t=>{const{isUiLoaded:s,isDataLoaded:n}=p$3.state;if(a$4.removeWalletConnectDeepLink(),p$3.setWalletConnectUri(e?.uri),p$3.setChains(e?.chains),T$3.reset("ConnectWallet"),s&&n)I$2.open=!0,t();else {const i=setInterval(()=>{const l=p$3.state;l.isUiLoaded&&l.isDataLoaded&&(clearInterval(i),I$2.open=!0,t());},200);}})},close(){I$2.open=!1;}};var G$1=Object.defineProperty,$$2=Object.getOwnPropertySymbols,Q$1=Object.prototype.hasOwnProperty,X=Object.prototype.propertyIsEnumerable,S$5=(e,t,s)=>t in e?G$1(e,t,{enumerable:!0,configurable:!0,writable:!0,value:s}):e[t]=s,Y$1=(e,t)=>{for(var s in t||(t={}))Q$1.call(t,s)&&S$5(e,s,t[s]);if($$2)for(var s of $$2(t))X.call(t,s)&&S$5(e,s,t[s]);return e};function Z$3(){return typeof matchMedia<"u"&&matchMedia("(prefers-color-scheme: dark)").matches}const C$2=proxy({themeMode:Z$3()?"dark":"light"}),ne$1={state:C$2,subscribe(e){return subscribe(C$2,()=>e(C$2))},setThemeConfig(e){const{themeMode:t,themeVariables:s}=e;t&&(C$2.themeMode=t),s&&(C$2.themeVariables=Y$1({},s));}},g$2=proxy({open:!1,message:"",variant:"success"}),oe$1={state:g$2,subscribe(e){return subscribe(g$2,()=>e(g$2))},openToast(e,t){g$2.open=!0,g$2.message=e,g$2.variant=t;},closeToast(){g$2.open=!1;}};

    let d$4 = class d{constructor(e){this.openModal=se$1.open,this.closeModal=se$1.close,this.subscribeModal=se$1.subscribe,this.setTheme=ne$1.setThemeConfig,ne$1.setThemeConfig(e),y$3.setConfig(e),this.initUi();}async initUi(){if(typeof window<"u"){await Promise.resolve().then(function () { return index; });const e=document.createElement("wcm-modal");document.body.insertAdjacentElement("beforeend",e),p$3.setIsUiLoaded(!0);}}};

    var index$2 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        WalletConnectModal: d$4
    });

    const state = proxy({
        status: 'uninitialized'
    });
    const SIWEController = {
        state,
        subscribeKey(key, callback) {
            return subscribeKey(state, key, callback);
        },
        subscribe(callback) {
            return subscribe(state, () => callback(state));
        },
        _getClient() {
            if (!state._client) {
                throw new Error('SIWEController client not set');
            }
            return state._client;
        },
        async getNonce(address) {
            const client = this._getClient();
            const nonce = await client.getNonce(address);
            this.setNonce(nonce);
            return nonce;
        },
        async getSession() {
            const client = this._getClient();
            const session = await client.getSession();
            if (session) {
                this.setSession(session);
                this.setStatus('success');
            }
            return session;
        },
        createMessage(args) {
            const client = this._getClient();
            const message = client.createMessage(args);
            this.setMessage(message);
            return message;
        },
        async verifyMessage(args) {
            const client = this._getClient();
            const isValid = await client.verifyMessage(args);
            return isValid;
        },
        async signIn() {
            const client = this._getClient();
            const session = await client.signIn();
            return session;
        },
        async signOut() {
            const client = this._getClient();
            await client.signOut();
            this.setStatus('ready');
            client.onSignOut?.();
        },
        onSignIn(args) {
            const client = this._getClient();
            client.onSignIn?.(args);
        },
        onSignOut() {
            const client = this._getClient();
            client.onSignOut?.();
        },
        setSIWEClient(client) {
            state._client = ref(client);
            state.status = 'ready';
            OptionsController.setIsSiweEnabled(client.options.enabled);
        },
        setNonce(nonce) {
            state.nonce = nonce;
        },
        setStatus(status) {
            state.status = status;
        },
        setMessage(message) {
            state.message = message;
        },
        setSession(session) {
            state.session = session;
        }
    };

    /**
     * @license
     * Copyright 2019 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */
    const t$5=globalThis,e$8=t$5.ShadowRoot&&(void 0===t$5.ShadyCSS||t$5.ShadyCSS.nativeShadow)&&"adoptedStyleSheets"in Document.prototype&&"replace"in CSSStyleSheet.prototype,s$6=Symbol(),o$8=new WeakMap;let n$9 = class n{constructor(t,e,o){if(this._$cssResult$=!0,o!==s$6)throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");this.cssText=t,this.t=e;}get styleSheet(){let t=this.o;const s=this.t;if(e$8&&void 0===t){const e=void 0!==s&&1===s.length;e&&(t=o$8.get(s)),void 0===t&&((this.o=t=new CSSStyleSheet).replaceSync(this.cssText),e&&o$8.set(s,t));}return t}toString(){return this.cssText}};const r$8=t=>new n$9("string"==typeof t?t:t+"",void 0,s$6),i$6=(t,...e)=>{const o=1===t.length?t[0]:e.reduce(((e,s,o)=>e+(t=>{if(!0===t._$cssResult$)return t.cssText;if("number"==typeof t)return t;throw Error("Value passed to 'css' function must be a 'css' function result: "+t+". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.")})(s)+t[o+1]),t[0]);return new n$9(o,t,s$6)},S$4=(s,o)=>{if(e$8)s.adoptedStyleSheets=o.map((t=>t instanceof CSSStyleSheet?t:t.styleSheet));else for(const e of o){const o=document.createElement("style"),n=t$5.litNonce;void 0!==n&&o.setAttribute("nonce",n),o.textContent=e.cssText,s.appendChild(o);}},c$5=e$8?t=>t:t=>t instanceof CSSStyleSheet?(t=>{let e="";for(const s of t.cssRules)e+=s.cssText;return r$8(e)})(t):t;

    /**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */const{is:i$5,defineProperty:e$7,getOwnPropertyDescriptor:r$7,getOwnPropertyNames:h$4,getOwnPropertySymbols:o$7,getPrototypeOf:n$8}=Object,a$3=globalThis,c$4=a$3.trustedTypes,l$5=c$4?c$4.emptyScript:"",p$2=a$3.reactiveElementPolyfillSupport,d$3=(t,s)=>t,u$3={toAttribute(t,s){switch(s){case Boolean:t=t?l$5:null;break;case Object:case Array:t=null==t?t:JSON.stringify(t);}return t},fromAttribute(t,s){let i=t;switch(s){case Boolean:i=null!==t;break;case Number:i=null===t?null:Number(t);break;case Object:case Array:try{i=JSON.parse(t);}catch(t){i=null;}}return i}},f$2=(t,s)=>!i$5(t,s),y$2={attribute:!0,type:String,converter:u$3,reflect:!1,hasChanged:f$2};Symbol.metadata??=Symbol("metadata"),a$3.litPropertyMetadata??=new WeakMap;let b$1 = class b extends HTMLElement{static addInitializer(t){this._$Ei(),(this.l??=[]).push(t);}static get observedAttributes(){return this.finalize(),this._$Eh&&[...this._$Eh.keys()]}static createProperty(t,s=y$2){if(s.state&&(s.attribute=!1),this._$Ei(),this.elementProperties.set(t,s),!s.noAccessor){const i=Symbol(),r=this.getPropertyDescriptor(t,i,s);void 0!==r&&e$7(this.prototype,t,r);}}static getPropertyDescriptor(t,s,i){const{get:e,set:h}=r$7(this.prototype,t)??{get(){return this[s]},set(t){this[s]=t;}};return {get(){return e?.call(this)},set(s){const r=e?.call(this);h.call(this,s),this.requestUpdate(t,r,i);},configurable:!0,enumerable:!0}}static getPropertyOptions(t){return this.elementProperties.get(t)??y$2}static _$Ei(){if(this.hasOwnProperty(d$3("elementProperties")))return;const t=n$8(this);t.finalize(),void 0!==t.l&&(this.l=[...t.l]),this.elementProperties=new Map(t.elementProperties);}static finalize(){if(this.hasOwnProperty(d$3("finalized")))return;if(this.finalized=!0,this._$Ei(),this.hasOwnProperty(d$3("properties"))){const t=this.properties,s=[...h$4(t),...o$7(t)];for(const i of s)this.createProperty(i,t[i]);}const t=this[Symbol.metadata];if(null!==t){const s=litPropertyMetadata.get(t);if(void 0!==s)for(const[t,i]of s)this.elementProperties.set(t,i);}this._$Eh=new Map;for(const[t,s]of this.elementProperties){const i=this._$Eu(t,s);void 0!==i&&this._$Eh.set(i,t);}this.elementStyles=this.finalizeStyles(this.styles);}static finalizeStyles(s){const i=[];if(Array.isArray(s)){const e=new Set(s.flat(1/0).reverse());for(const s of e)i.unshift(c$5(s));}else void 0!==s&&i.push(c$5(s));return i}static _$Eu(t,s){const i=s.attribute;return !1===i?void 0:"string"==typeof i?i:"string"==typeof t?t.toLowerCase():void 0}constructor(){super(),this._$Ep=void 0,this.isUpdatePending=!1,this.hasUpdated=!1,this._$Em=null,this._$Ev();}_$Ev(){this._$ES=new Promise((t=>this.enableUpdating=t)),this._$AL=new Map,this._$E_(),this.requestUpdate(),this.constructor.l?.forEach((t=>t(this)));}addController(t){(this._$EO??=new Set).add(t),void 0!==this.renderRoot&&this.isConnected&&t.hostConnected?.();}removeController(t){this._$EO?.delete(t);}_$E_(){const t=new Map,s=this.constructor.elementProperties;for(const i of s.keys())this.hasOwnProperty(i)&&(t.set(i,this[i]),delete this[i]);t.size>0&&(this._$Ep=t);}createRenderRoot(){const t=this.shadowRoot??this.attachShadow(this.constructor.shadowRootOptions);return S$4(t,this.constructor.elementStyles),t}connectedCallback(){this.renderRoot??=this.createRenderRoot(),this.enableUpdating(!0),this._$EO?.forEach((t=>t.hostConnected?.()));}enableUpdating(t){}disconnectedCallback(){this._$EO?.forEach((t=>t.hostDisconnected?.()));}attributeChangedCallback(t,s,i){this._$AK(t,i);}_$EC(t,s){const i=this.constructor.elementProperties.get(t),e=this.constructor._$Eu(t,i);if(void 0!==e&&!0===i.reflect){const r=(void 0!==i.converter?.toAttribute?i.converter:u$3).toAttribute(s,i.type);this._$Em=t,null==r?this.removeAttribute(e):this.setAttribute(e,r),this._$Em=null;}}_$AK(t,s){const i=this.constructor,e=i._$Eh.get(t);if(void 0!==e&&this._$Em!==e){const t=i.getPropertyOptions(e),r="function"==typeof t.converter?{fromAttribute:t.converter}:void 0!==t.converter?.fromAttribute?t.converter:u$3;this._$Em=e,this[e]=r.fromAttribute(s,t.type),this._$Em=null;}}requestUpdate(t,s,i){if(void 0!==t){if(i??=this.constructor.getPropertyOptions(t),!(i.hasChanged??f$2)(this[t],s))return;this.P(t,s,i);}!1===this.isUpdatePending&&(this._$ES=this._$ET());}P(t,s,i){this._$AL.has(t)||this._$AL.set(t,s),!0===i.reflect&&this._$Em!==t&&(this._$Ej??=new Set).add(t);}async _$ET(){this.isUpdatePending=!0;try{await this._$ES;}catch(t){Promise.reject(t);}const t=this.scheduleUpdate();return null!=t&&await t,!this.isUpdatePending}scheduleUpdate(){return this.performUpdate()}performUpdate(){if(!this.isUpdatePending)return;if(!this.hasUpdated){if(this.renderRoot??=this.createRenderRoot(),this._$Ep){for(const[t,s]of this._$Ep)this[t]=s;this._$Ep=void 0;}const t=this.constructor.elementProperties;if(t.size>0)for(const[s,i]of t)!0!==i.wrapped||this._$AL.has(s)||void 0===this[s]||this.P(s,this[s],i);}let t=!1;const s=this._$AL;try{t=this.shouldUpdate(s),t?(this.willUpdate(s),this._$EO?.forEach((t=>t.hostUpdate?.())),this.update(s)):this._$EU();}catch(s){throw t=!1,this._$EU(),s}t&&this._$AE(s);}willUpdate(t){}_$AE(t){this._$EO?.forEach((t=>t.hostUpdated?.())),this.hasUpdated||(this.hasUpdated=!0,this.firstUpdated(t)),this.updated(t);}_$EU(){this._$AL=new Map,this.isUpdatePending=!1;}get updateComplete(){return this.getUpdateComplete()}getUpdateComplete(){return this._$ES}shouldUpdate(t){return !0}update(t){this._$Ej&&=this._$Ej.forEach((t=>this._$EC(t,this[t]))),this._$EU();}updated(t){}firstUpdated(t){}};b$1.elementStyles=[],b$1.shadowRootOptions={mode:"open"},b$1[d$3("elementProperties")]=new Map,b$1[d$3("finalized")]=new Map,p$2?.({ReactiveElement:b$1}),(a$3.reactiveElementVersions??=[]).push("2.0.4");

    /**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */
    const t$4=globalThis,i$4=t$4.trustedTypes,s$5=i$4?i$4.createPolicy("lit-html",{createHTML:t=>t}):void 0,e$6="$lit$",h$3=`lit$${(Math.random()+"").slice(9)}$`,o$6="?"+h$3,n$7=`<${o$6}>`,r$6=document,l$4=()=>r$6.createComment(""),c$3=t=>null===t||"object"!=typeof t&&"function"!=typeof t,a$2=Array.isArray,u$2=t=>a$2(t)||"function"==typeof t?.[Symbol.iterator],d$2="[ \t\n\f\r]",f$1=/<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g,v$2=/-->/g,_$2=/>/g,m$1=RegExp(`>|${d$2}(?:([^\\s"'>=/]+)(${d$2}*=${d$2}*(?:[^ \t\n\f\r"'\`<>=]|("|')|))|$)`,"g"),p$1=/'/g,g$1=/"/g,$$1=/^(?:script|style|textarea|title)$/i,y$1=t=>(i,...s)=>({_$litType$:t,strings:i,values:s}),x$1=y$1(1),w$1=Symbol.for("lit-noChange"),T$2=Symbol.for("lit-nothing"),A$2=new WeakMap,E$1=r$6.createTreeWalker(r$6,129);function C$1(t,i){if(!Array.isArray(t)||!t.hasOwnProperty("raw"))throw Error("invalid template strings array");return void 0!==s$5?s$5.createHTML(i):i}const P$1=(t,i)=>{const s=t.length-1,o=[];let r,l=2===i?"<svg>":"",c=f$1;for(let i=0;i<s;i++){const s=t[i];let a,u,d=-1,y=0;for(;y<s.length&&(c.lastIndex=y,u=c.exec(s),null!==u);)y=c.lastIndex,c===f$1?"!--"===u[1]?c=v$2:void 0!==u[1]?c=_$2:void 0!==u[2]?($$1.test(u[2])&&(r=RegExp("</"+u[2],"g")),c=m$1):void 0!==u[3]&&(c=m$1):c===m$1?">"===u[0]?(c=r??f$1,d=-1):void 0===u[1]?d=-2:(d=c.lastIndex-u[2].length,a=u[1],c=void 0===u[3]?m$1:'"'===u[3]?g$1:p$1):c===g$1||c===p$1?c=m$1:c===v$2||c===_$2?c=f$1:(c=m$1,r=void 0);const x=c===m$1&&t[i+1].startsWith("/>")?" ":"";l+=c===f$1?s+n$7:d>=0?(o.push(a),s.slice(0,d)+e$6+s.slice(d)+h$3+x):s+h$3+(-2===d?i:x);}return [C$1(t,l+(t[s]||"<?>")+(2===i?"</svg>":"")),o]};let V$1 = class V{constructor({strings:t,_$litType$:s},n){let r;this.parts=[];let c=0,a=0;const u=t.length-1,d=this.parts,[f,v]=P$1(t,s);if(this.el=V.createElement(f,n),E$1.currentNode=this.el.content,2===s){const t=this.el.content.firstChild;t.replaceWith(...t.childNodes);}for(;null!==(r=E$1.nextNode())&&d.length<u;){if(1===r.nodeType){if(r.hasAttributes())for(const t of r.getAttributeNames())if(t.endsWith(e$6)){const i=v[a++],s=r.getAttribute(t).split(h$3),e=/([.?@])?(.*)/.exec(i);d.push({type:1,index:c,name:e[2],strings:s,ctor:"."===e[1]?k$1:"?"===e[1]?H$1:"@"===e[1]?I$1:R$1}),r.removeAttribute(t);}else t.startsWith(h$3)&&(d.push({type:6,index:c}),r.removeAttribute(t));if($$1.test(r.tagName)){const t=r.textContent.split(h$3),s=t.length-1;if(s>0){r.textContent=i$4?i$4.emptyScript:"";for(let i=0;i<s;i++)r.append(t[i],l$4()),E$1.nextNode(),d.push({type:2,index:++c});r.append(t[s],l$4());}}}else if(8===r.nodeType)if(r.data===o$6)d.push({type:2,index:c});else {let t=-1;for(;-1!==(t=r.data.indexOf(h$3,t+1));)d.push({type:7,index:c}),t+=h$3.length-1;}c++;}}static createElement(t,i){const s=r$6.createElement("template");return s.innerHTML=t,s}};function N$1(t,i,s=t,e){if(i===w$1)return i;let h=void 0!==e?s._$Co?.[e]:s._$Cl;const o=c$3(i)?void 0:i._$litDirective$;return h?.constructor!==o&&(h?._$AO?.(!1),void 0===o?h=void 0:(h=new o(t),h._$AT(t,s,e)),void 0!==e?(s._$Co??=[])[e]=h:s._$Cl=h),void 0!==h&&(i=N$1(t,h._$AS(t,i.values),h,e)),i}let S$3 = class S{constructor(t,i){this._$AV=[],this._$AN=void 0,this._$AD=t,this._$AM=i;}get parentNode(){return this._$AM.parentNode}get _$AU(){return this._$AM._$AU}u(t){const{el:{content:i},parts:s}=this._$AD,e=(t?.creationScope??r$6).importNode(i,!0);E$1.currentNode=e;let h=E$1.nextNode(),o=0,n=0,l=s[0];for(;void 0!==l;){if(o===l.index){let i;2===l.type?i=new M$1(h,h.nextSibling,this,t):1===l.type?i=new l.ctor(h,l.name,l.strings,this,t):6===l.type&&(i=new L$2(h,this,t)),this._$AV.push(i),l=s[++n];}o!==l?.index&&(h=E$1.nextNode(),o++);}return E$1.currentNode=r$6,e}p(t){let i=0;for(const s of this._$AV)void 0!==s&&(void 0!==s.strings?(s._$AI(t,s,i),i+=s.strings.length-2):s._$AI(t[i])),i++;}};let M$1 = class M{get _$AU(){return this._$AM?._$AU??this._$Cv}constructor(t,i,s,e){this.type=2,this._$AH=T$2,this._$AN=void 0,this._$AA=t,this._$AB=i,this._$AM=s,this.options=e,this._$Cv=e?.isConnected??!0;}get parentNode(){let t=this._$AA.parentNode;const i=this._$AM;return void 0!==i&&11===t?.nodeType&&(t=i.parentNode),t}get startNode(){return this._$AA}get endNode(){return this._$AB}_$AI(t,i=this){t=N$1(this,t,i),c$3(t)?t===T$2||null==t||""===t?(this._$AH!==T$2&&this._$AR(),this._$AH=T$2):t!==this._$AH&&t!==w$1&&this._(t):void 0!==t._$litType$?this.$(t):void 0!==t.nodeType?this.T(t):u$2(t)?this.k(t):this._(t);}S(t){return this._$AA.parentNode.insertBefore(t,this._$AB)}T(t){this._$AH!==t&&(this._$AR(),this._$AH=this.S(t));}_(t){this._$AH!==T$2&&c$3(this._$AH)?this._$AA.nextSibling.data=t:this.T(r$6.createTextNode(t)),this._$AH=t;}$(t){const{values:i,_$litType$:s}=t,e="number"==typeof s?this._$AC(t):(void 0===s.el&&(s.el=V$1.createElement(C$1(s.h,s.h[0]),this.options)),s);if(this._$AH?._$AD===e)this._$AH.p(i);else {const t=new S$3(e,this),s=t.u(this.options);t.p(i),this.T(s),this._$AH=t;}}_$AC(t){let i=A$2.get(t.strings);return void 0===i&&A$2.set(t.strings,i=new V$1(t)),i}k(t){a$2(this._$AH)||(this._$AH=[],this._$AR());const i=this._$AH;let s,e=0;for(const h of t)e===i.length?i.push(s=new M(this.S(l$4()),this.S(l$4()),this,this.options)):s=i[e],s._$AI(h),e++;e<i.length&&(this._$AR(s&&s._$AB.nextSibling,e),i.length=e);}_$AR(t=this._$AA.nextSibling,i){for(this._$AP?.(!1,!0,i);t&&t!==this._$AB;){const i=t.nextSibling;t.remove(),t=i;}}setConnected(t){void 0===this._$AM&&(this._$Cv=t,this._$AP?.(t));}};let R$1 = class R{get tagName(){return this.element.tagName}get _$AU(){return this._$AM._$AU}constructor(t,i,s,e,h){this.type=1,this._$AH=T$2,this._$AN=void 0,this.element=t,this.name=i,this._$AM=e,this.options=h,s.length>2||""!==s[0]||""!==s[1]?(this._$AH=Array(s.length-1).fill(new String),this.strings=s):this._$AH=T$2;}_$AI(t,i=this,s,e){const h=this.strings;let o=!1;if(void 0===h)t=N$1(this,t,i,0),o=!c$3(t)||t!==this._$AH&&t!==w$1,o&&(this._$AH=t);else {const e=t;let n,r;for(t=h[0],n=0;n<h.length-1;n++)r=N$1(this,e[s+n],i,n),r===w$1&&(r=this._$AH[n]),o||=!c$3(r)||r!==this._$AH[n],r===T$2?t=T$2:t!==T$2&&(t+=(r??"")+h[n+1]),this._$AH[n]=r;}o&&!e&&this.j(t);}j(t){t===T$2?this.element.removeAttribute(this.name):this.element.setAttribute(this.name,t??"");}};let k$1 = class k extends R$1{constructor(){super(...arguments),this.type=3;}j(t){this.element[this.name]=t===T$2?void 0:t;}};let H$1 = class H extends R$1{constructor(){super(...arguments),this.type=4;}j(t){this.element.toggleAttribute(this.name,!!t&&t!==T$2);}};let I$1 = class I extends R$1{constructor(t,i,s,e,h){super(t,i,s,e,h),this.type=5;}_$AI(t,i=this){if((t=N$1(this,t,i,0)??T$2)===w$1)return;const s=this._$AH,e=t===T$2&&s!==T$2||t.capture!==s.capture||t.once!==s.once||t.passive!==s.passive,h=t!==T$2&&(s===T$2||e);e&&this.element.removeEventListener(this.name,this,s),h&&this.element.addEventListener(this.name,this,t),this._$AH=t;}handleEvent(t){"function"==typeof this._$AH?this._$AH.call(this.options?.host??this.element,t):this._$AH.handleEvent(t);}};let L$2 = class L{constructor(t,i,s){this.element=t,this.type=6,this._$AN=void 0,this._$AM=i,this.options=s;}get _$AU(){return this._$AM._$AU}_$AI(t){N$1(this,t);}};const Z$2=t$4.litHtmlPolyfillSupport;Z$2?.(V$1,M$1),(t$4.litHtmlVersions??=[]).push("3.1.2");const j$1=(t,i,s)=>{const e=s?.renderBefore??i;let h=e._$litPart$;if(void 0===h){const t=s?.renderBefore??null;e._$litPart$=h=new M$1(i.insertBefore(l$4(),t),t,void 0,s??{});}return h._$AI(t),h};

    /**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */let s$4 = class s extends b$1{constructor(){super(...arguments),this.renderOptions={host:this},this._$Do=void 0;}createRenderRoot(){const t=super.createRenderRoot();return this.renderOptions.renderBefore??=t.firstChild,t}update(t){const i=this.render();this.hasUpdated||(this.renderOptions.isConnected=this.isConnected),super.update(t),this._$Do=j$1(i,this.renderRoot,this.renderOptions);}connectedCallback(){super.connectedCallback(),this._$Do?.setConnected(!0);}disconnectedCallback(){super.disconnectedCallback(),this._$Do?.setConnected(!1);}render(){return w$1}};s$4._$litElement$=!0,s$4[("finalized")]=!0,globalThis.litElementHydrateSupport?.({LitElement:s$4});const r$5=globalThis.litElementPolyfillSupport;r$5?.({LitElement:s$4});(globalThis.litElementVersions??=[]).push("4.0.4");

    var styles = i$6 `
  :host {
    display: flex;
    justify-content: center;
    gap: var(--wui-spacing-2xl);
  }

  wui-visual-thumbnail:nth-child(1) {
    z-index: 1;
  }
`;

    var __decorate$1 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let W3mConnectingSiwe = class W3mConnectingSiwe extends s$4 {
        constructor() {
            super(...arguments);
            this.dappImageUrl = OptionsController.state.metadata?.icons;
            this.walletImageUrl = StorageUtil.getConnectedWalletImageUrl();
        }
        firstUpdated() {
            const visuals = this.shadowRoot?.querySelectorAll('wui-visual-thumbnail');
            if (visuals?.[0]) {
                this.createAnimation(visuals[0], 'translate(18px)');
            }
            if (visuals?.[1]) {
                this.createAnimation(visuals[1], 'translate(-18px)');
            }
        }
        render() {
            return x$1 `
      <wui-visual-thumbnail
        ?borderRadiusFull=${true}
        .imageSrc=${this.dappImageUrl?.[0]}
      ></wui-visual-thumbnail>
      <wui-visual-thumbnail .imageSrc=${this.walletImageUrl}></wui-visual-thumbnail>
    `;
        }
        createAnimation(element, translation) {
            element.animate([{ transform: 'translateX(0px)' }, { transform: translation }], {
                duration: 1600,
                easing: 'cubic-bezier(0.56, 0, 0.48, 1)',
                direction: 'alternate',
                iterations: Infinity
            });
        }
    };
    W3mConnectingSiwe.styles = styles;
    W3mConnectingSiwe = __decorate$1([
        customElement('w3m-connecting-siwe')
    ], W3mConnectingSiwe);

    /**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */const o$5={attribute:!0,type:String,converter:u$3,reflect:!1,hasChanged:f$2},r$4=(t=o$5,e,r)=>{const{kind:n,metadata:i}=r;let s=globalThis.litPropertyMetadata.get(i);if(void 0===s&&globalThis.litPropertyMetadata.set(i,s=new Map),s.set(r.name,t),"accessor"===n){const{name:o}=r;return {set(r){const n=e.get.call(this);e.set.call(this,r),this.requestUpdate(o,n,t);},init(e){return void 0!==e&&this.P(o,void 0,t),e}}}if("setter"===n){const{name:o}=r;return function(r){const n=this[o];e.call(this,r),this.requestUpdate(o,n,t);}}throw Error("Unsupported decorator location: "+n)};function n$6(t){return (e,o)=>"object"==typeof o?r$4(t,e,o):((t,e,o)=>{const r=e.hasOwnProperty(o);return e.constructor.createProperty(o,r?{...t,wrapped:!0}:t),r?Object.getOwnPropertyDescriptor(e,o):void 0})(t,e,o)}

    /**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */function r$3(r){return n$6({...r,state:!0,attribute:!1})}

    var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let W3mConnectingSiweView = class W3mConnectingSiweView extends s$4 {
        constructor() {
            super(...arguments);
            this.dappName = OptionsController.state.metadata?.name;
            this.isSigning = false;
        }
        render() {
            return x$1 `
      <wui-flex justifyContent="center" .padding=${['2xl', '0', 'xxl', '0']}>
        <w3m-connecting-siwe></w3m-connecting-siwe>
      </wui-flex>
      <wui-flex
        .padding=${['0', '4xl', 'l', '4xl']}
        gap="s"
        justifyContent="space-between"
      >
        <wui-text variant="paragraph-500" align="center" color="fg-100"
          >${this.dappName ?? 'Dapp'} needs to connect to your wallet</wui-text
        >
      </wui-flex>
      <wui-flex
        .padding=${['0', '3xl', 'l', '3xl']}
        gap="s"
        justifyContent="space-between"
      >
        <wui-text variant="small-400" align="center" color="fg-200"
          >Sign this message to prove you own this wallet and proceed. Canceling will disconnect
          you.</wui-text
        >
      </wui-flex>
      <wui-flex .padding=${['l', 'xl', 'xl', 'xl']} gap="s" justifyContent="space-between">
        <wui-button
          size="md"
          ?fullwidth=${true}
          variant="shade"
          @click=${this.onCancel.bind(this)}
          data-testid="w3m-connecting-siwe-cancel"
        >
          Cancel
        </wui-button>
        <wui-button
          size="md"
          ?fullwidth=${true}
          variant="fill"
          @click=${this.onSign.bind(this)}
          ?loading=${this.isSigning}
          data-testid="w3m-connecting-siwe-sign"
        >
          ${this.isSigning ? 'Signing...' : 'Sign'}
        </wui-button>
      </wui-flex>
    `;
        }
        async onSign() {
            this.isSigning = true;
            EventsController.sendEvent({
                event: 'CLICK_SIGN_SIWE_MESSAGE',
                type: 'track'
            });
            try {
                SIWEController.setStatus('loading');
                const session = await SIWEController.signIn();
                SIWEController.setStatus('success');
                EventsController.sendEvent({
                    event: 'SIWE_AUTH_SUCCESS',
                    type: 'track'
                });
                return session;
            }
            catch (error) {
                SnackController.showError('Signature declined');
                SIWEController.setStatus('error');
                return EventsController.sendEvent({
                    event: 'SIWE_AUTH_ERROR',
                    type: 'track'
                });
            }
            finally {
                this.isSigning = false;
            }
        }
        async onCancel() {
            const { isConnected } = AccountController.state;
            if (isConnected) {
                await ConnectionController.disconnect();
                ModalController.close();
            }
            else {
                RouterController.push('Connect');
            }
            EventsController.sendEvent({
                event: 'CLICK_CANCEL_SIWE',
                type: 'track'
            });
        }
    };
    __decorate([
        r$3()
    ], W3mConnectingSiweView.prototype, "isSigning", void 0);
    W3mConnectingSiweView = __decorate([
        customElement('w3m-connecting-siwe-view')
    ], W3mConnectingSiweView);

    var index$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        SIWEController: SIWEController,
        get W3mConnectingSiwe () { return W3mConnectingSiwe; },
        get W3mConnectingSiweView () { return W3mConnectingSiweView; }
    });

    /**
     * @license
     * Copyright 2019 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */
    const t$3=window,e$5=t$3.ShadowRoot&&(void 0===t$3.ShadyCSS||t$3.ShadyCSS.nativeShadow)&&"adoptedStyleSheets"in Document.prototype&&"replace"in CSSStyleSheet.prototype,s$3=Symbol(),n$5=new WeakMap;let o$4 = class o{constructor(t,e,n){if(this._$cssResult$=!0,n!==s$3)throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");this.cssText=t,this.t=e;}get styleSheet(){let t=this.o;const s=this.t;if(e$5&&void 0===t){const e=void 0!==s&&1===s.length;e&&(t=n$5.get(s)),void 0===t&&((this.o=t=new CSSStyleSheet).replaceSync(this.cssText),e&&n$5.set(s,t));}return t}toString(){return this.cssText}};const r$2=t=>new o$4("string"==typeof t?t:t+"",void 0,s$3),i$3=(t,...e)=>{const n=1===t.length?t[0]:e.reduce(((e,s,n)=>e+(t=>{if(!0===t._$cssResult$)return t.cssText;if("number"==typeof t)return t;throw Error("Value passed to 'css' function must be a 'css' function result: "+t+". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.")})(s)+t[n+1]),t[0]);return new o$4(n,t,s$3)},S$2=(s,n)=>{e$5?s.adoptedStyleSheets=n.map((t=>t instanceof CSSStyleSheet?t:t.styleSheet)):n.forEach((e=>{const n=document.createElement("style"),o=t$3.litNonce;void 0!==o&&n.setAttribute("nonce",o),n.textContent=e.cssText,s.appendChild(n);}));},c$2=e$5?t=>t:t=>t instanceof CSSStyleSheet?(t=>{let e="";for(const s of t.cssRules)e+=s.cssText;return r$2(e)})(t):t;

    /**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */var s$2;const e$4=window,r$1=e$4.trustedTypes,h$2=r$1?r$1.emptyScript:"",o$3=e$4.reactiveElementPolyfillSupport,n$4={toAttribute(t,i){switch(i){case Boolean:t=t?h$2:null;break;case Object:case Array:t=null==t?t:JSON.stringify(t);}return t},fromAttribute(t,i){let s=t;switch(i){case Boolean:s=null!==t;break;case Number:s=null===t?null:Number(t);break;case Object:case Array:try{s=JSON.parse(t);}catch(t){s=null;}}return s}},a$1=(t,i)=>i!==t&&(i==i||t==t),l$3={attribute:!0,type:String,converter:n$4,reflect:!1,hasChanged:a$1},d$1="finalized";let u$1 = class u extends HTMLElement{constructor(){super(),this._$Ei=new Map,this.isUpdatePending=!1,this.hasUpdated=!1,this._$El=null,this._$Eu();}static addInitializer(t){var i;this.finalize(),(null!==(i=this.h)&&void 0!==i?i:this.h=[]).push(t);}static get observedAttributes(){this.finalize();const t=[];return this.elementProperties.forEach(((i,s)=>{const e=this._$Ep(s,i);void 0!==e&&(this._$Ev.set(e,s),t.push(e));})),t}static createProperty(t,i=l$3){if(i.state&&(i.attribute=!1),this.finalize(),this.elementProperties.set(t,i),!i.noAccessor&&!this.prototype.hasOwnProperty(t)){const s="symbol"==typeof t?Symbol():"__"+t,e=this.getPropertyDescriptor(t,s,i);void 0!==e&&Object.defineProperty(this.prototype,t,e);}}static getPropertyDescriptor(t,i,s){return {get(){return this[i]},set(e){const r=this[t];this[i]=e,this.requestUpdate(t,r,s);},configurable:!0,enumerable:!0}}static getPropertyOptions(t){return this.elementProperties.get(t)||l$3}static finalize(){if(this.hasOwnProperty(d$1))return !1;this[d$1]=!0;const t=Object.getPrototypeOf(this);if(t.finalize(),void 0!==t.h&&(this.h=[...t.h]),this.elementProperties=new Map(t.elementProperties),this._$Ev=new Map,this.hasOwnProperty("properties")){const t=this.properties,i=[...Object.getOwnPropertyNames(t),...Object.getOwnPropertySymbols(t)];for(const s of i)this.createProperty(s,t[s]);}return this.elementStyles=this.finalizeStyles(this.styles),!0}static finalizeStyles(i){const s=[];if(Array.isArray(i)){const e=new Set(i.flat(1/0).reverse());for(const i of e)s.unshift(c$2(i));}else void 0!==i&&s.push(c$2(i));return s}static _$Ep(t,i){const s=i.attribute;return !1===s?void 0:"string"==typeof s?s:"string"==typeof t?t.toLowerCase():void 0}_$Eu(){var t;this._$E_=new Promise((t=>this.enableUpdating=t)),this._$AL=new Map,this._$Eg(),this.requestUpdate(),null===(t=this.constructor.h)||void 0===t||t.forEach((t=>t(this)));}addController(t){var i,s;(null!==(i=this._$ES)&&void 0!==i?i:this._$ES=[]).push(t),void 0!==this.renderRoot&&this.isConnected&&(null===(s=t.hostConnected)||void 0===s||s.call(t));}removeController(t){var i;null===(i=this._$ES)||void 0===i||i.splice(this._$ES.indexOf(t)>>>0,1);}_$Eg(){this.constructor.elementProperties.forEach(((t,i)=>{this.hasOwnProperty(i)&&(this._$Ei.set(i,this[i]),delete this[i]);}));}createRenderRoot(){var t;const s=null!==(t=this.shadowRoot)&&void 0!==t?t:this.attachShadow(this.constructor.shadowRootOptions);return S$2(s,this.constructor.elementStyles),s}connectedCallback(){var t;void 0===this.renderRoot&&(this.renderRoot=this.createRenderRoot()),this.enableUpdating(!0),null===(t=this._$ES)||void 0===t||t.forEach((t=>{var i;return null===(i=t.hostConnected)||void 0===i?void 0:i.call(t)}));}enableUpdating(t){}disconnectedCallback(){var t;null===(t=this._$ES)||void 0===t||t.forEach((t=>{var i;return null===(i=t.hostDisconnected)||void 0===i?void 0:i.call(t)}));}attributeChangedCallback(t,i,s){this._$AK(t,s);}_$EO(t,i,s=l$3){var e;const r=this.constructor._$Ep(t,s);if(void 0!==r&&!0===s.reflect){const h=(void 0!==(null===(e=s.converter)||void 0===e?void 0:e.toAttribute)?s.converter:n$4).toAttribute(i,s.type);this._$El=t,null==h?this.removeAttribute(r):this.setAttribute(r,h),this._$El=null;}}_$AK(t,i){var s;const e=this.constructor,r=e._$Ev.get(t);if(void 0!==r&&this._$El!==r){const t=e.getPropertyOptions(r),h="function"==typeof t.converter?{fromAttribute:t.converter}:void 0!==(null===(s=t.converter)||void 0===s?void 0:s.fromAttribute)?t.converter:n$4;this._$El=r,this[r]=h.fromAttribute(i,t.type),this._$El=null;}}requestUpdate(t,i,s){let e=!0;void 0!==t&&(((s=s||this.constructor.getPropertyOptions(t)).hasChanged||a$1)(this[t],i)?(this._$AL.has(t)||this._$AL.set(t,i),!0===s.reflect&&this._$El!==t&&(void 0===this._$EC&&(this._$EC=new Map),this._$EC.set(t,s))):e=!1),!this.isUpdatePending&&e&&(this._$E_=this._$Ej());}async _$Ej(){this.isUpdatePending=!0;try{await this._$E_;}catch(t){Promise.reject(t);}const t=this.scheduleUpdate();return null!=t&&await t,!this.isUpdatePending}scheduleUpdate(){return this.performUpdate()}performUpdate(){var t;if(!this.isUpdatePending)return;this.hasUpdated,this._$Ei&&(this._$Ei.forEach(((t,i)=>this[i]=t)),this._$Ei=void 0);let i=!1;const s=this._$AL;try{i=this.shouldUpdate(s),i?(this.willUpdate(s),null===(t=this._$ES)||void 0===t||t.forEach((t=>{var i;return null===(i=t.hostUpdate)||void 0===i?void 0:i.call(t)})),this.update(s)):this._$Ek();}catch(t){throw i=!1,this._$Ek(),t}i&&this._$AE(s);}willUpdate(t){}_$AE(t){var i;null===(i=this._$ES)||void 0===i||i.forEach((t=>{var i;return null===(i=t.hostUpdated)||void 0===i?void 0:i.call(t)})),this.hasUpdated||(this.hasUpdated=!0,this.firstUpdated(t)),this.updated(t);}_$Ek(){this._$AL=new Map,this.isUpdatePending=!1;}get updateComplete(){return this.getUpdateComplete()}getUpdateComplete(){return this._$E_}shouldUpdate(t){return !0}update(t){void 0!==this._$EC&&(this._$EC.forEach(((t,i)=>this._$EO(i,this[i],t))),this._$EC=void 0),this._$Ek();}updated(t){}firstUpdated(t){}};u$1[d$1]=!0,u$1.elementProperties=new Map,u$1.elementStyles=[],u$1.shadowRootOptions={mode:"open"},null==o$3||o$3({ReactiveElement:u$1}),(null!==(s$2=e$4.reactiveElementVersions)&&void 0!==s$2?s$2:e$4.reactiveElementVersions=[]).push("1.6.3");

    /**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */
    var t$2;const i$2=window,s$1=i$2.trustedTypes,e$3=s$1?s$1.createPolicy("lit-html",{createHTML:t=>t}):void 0,o$2="$lit$",n$3=`lit$${(Math.random()+"").slice(9)}$`,l$2="?"+n$3,h$1=`<${l$2}>`,r=document,u=()=>r.createComment(""),d=t=>null===t||"object"!=typeof t&&"function"!=typeof t,c$1=Array.isArray,v$1=t=>c$1(t)||"function"==typeof(null==t?void 0:t[Symbol.iterator]),a="[ \t\n\f\r]",f=/<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g,_$1=/-->/g,m=/>/g,p=RegExp(`>|${a}(?:([^\\s"'>=/]+)(${a}*=${a}*(?:[^ \t\n\f\r"'\`<>=]|("|')|))|$)`,"g"),g=/'/g,$=/"/g,y=/^(?:script|style|textarea|title)$/i,w=t=>(i,...s)=>({_$litType$:t,strings:i,values:s}),x=w(1),b=w(2),T$1=Symbol.for("lit-noChange"),A$1=Symbol.for("lit-nothing"),E=new WeakMap,C=r.createTreeWalker(r,129,null,!1);function P(t,i){if(!Array.isArray(t)||!t.hasOwnProperty("raw"))throw Error("invalid template strings array");return void 0!==e$3?e$3.createHTML(i):i}const V=(t,i)=>{const s=t.length-1,e=[];let l,r=2===i?"<svg>":"",u=f;for(let i=0;i<s;i++){const s=t[i];let d,c,v=-1,a=0;for(;a<s.length&&(u.lastIndex=a,c=u.exec(s),null!==c);)a=u.lastIndex,u===f?"!--"===c[1]?u=_$1:void 0!==c[1]?u=m:void 0!==c[2]?(y.test(c[2])&&(l=RegExp("</"+c[2],"g")),u=p):void 0!==c[3]&&(u=p):u===p?">"===c[0]?(u=null!=l?l:f,v=-1):void 0===c[1]?v=-2:(v=u.lastIndex-c[2].length,d=c[1],u=void 0===c[3]?p:'"'===c[3]?$:g):u===$||u===g?u=p:u===_$1||u===m?u=f:(u=p,l=void 0);const w=u===p&&t[i+1].startsWith("/>")?" ":"";r+=u===f?s+h$1:v>=0?(e.push(d),s.slice(0,v)+o$2+s.slice(v)+n$3+w):s+n$3+(-2===v?(e.push(void 0),i):w);}return [P(t,r+(t[s]||"<?>")+(2===i?"</svg>":"")),e]};class N{constructor({strings:t,_$litType$:i},e){let h;this.parts=[];let r=0,d=0;const c=t.length-1,v=this.parts,[a,f]=V(t,i);if(this.el=N.createElement(a,e),C.currentNode=this.el.content,2===i){const t=this.el.content,i=t.firstChild;i.remove(),t.append(...i.childNodes);}for(;null!==(h=C.nextNode())&&v.length<c;){if(1===h.nodeType){if(h.hasAttributes()){const t=[];for(const i of h.getAttributeNames())if(i.endsWith(o$2)||i.startsWith(n$3)){const s=f[d++];if(t.push(i),void 0!==s){const t=h.getAttribute(s.toLowerCase()+o$2).split(n$3),i=/([.?@])?(.*)/.exec(s);v.push({type:1,index:r,name:i[2],strings:t,ctor:"."===i[1]?H:"?"===i[1]?L$1:"@"===i[1]?z:k});}else v.push({type:6,index:r});}for(const i of t)h.removeAttribute(i);}if(y.test(h.tagName)){const t=h.textContent.split(n$3),i=t.length-1;if(i>0){h.textContent=s$1?s$1.emptyScript:"";for(let s=0;s<i;s++)h.append(t[s],u()),C.nextNode(),v.push({type:2,index:++r});h.append(t[i],u());}}}else if(8===h.nodeType)if(h.data===l$2)v.push({type:2,index:r});else {let t=-1;for(;-1!==(t=h.data.indexOf(n$3,t+1));)v.push({type:7,index:r}),t+=n$3.length-1;}r++;}}static createElement(t,i){const s=r.createElement("template");return s.innerHTML=t,s}}function S$1(t,i,s=t,e){var o,n,l,h;if(i===T$1)return i;let r=void 0!==e?null===(o=s._$Co)||void 0===o?void 0:o[e]:s._$Cl;const u=d(i)?void 0:i._$litDirective$;return (null==r?void 0:r.constructor)!==u&&(null===(n=null==r?void 0:r._$AO)||void 0===n||n.call(r,!1),void 0===u?r=void 0:(r=new u(t),r._$AT(t,s,e)),void 0!==e?(null!==(l=(h=s)._$Co)&&void 0!==l?l:h._$Co=[])[e]=r:s._$Cl=r),void 0!==r&&(i=S$1(t,r._$AS(t,i.values),r,e)),i}class M{constructor(t,i){this._$AV=[],this._$AN=void 0,this._$AD=t,this._$AM=i;}get parentNode(){return this._$AM.parentNode}get _$AU(){return this._$AM._$AU}u(t){var i;const{el:{content:s},parts:e}=this._$AD,o=(null!==(i=null==t?void 0:t.creationScope)&&void 0!==i?i:r).importNode(s,!0);C.currentNode=o;let n=C.nextNode(),l=0,h=0,u=e[0];for(;void 0!==u;){if(l===u.index){let i;2===u.type?i=new R(n,n.nextSibling,this,t):1===u.type?i=new u.ctor(n,u.name,u.strings,this,t):6===u.type&&(i=new Z$1(n,this,t)),this._$AV.push(i),u=e[++h];}l!==(null==u?void 0:u.index)&&(n=C.nextNode(),l++);}return C.currentNode=r,o}v(t){let i=0;for(const s of this._$AV)void 0!==s&&(void 0!==s.strings?(s._$AI(t,s,i),i+=s.strings.length-2):s._$AI(t[i])),i++;}}class R{constructor(t,i,s,e){var o;this.type=2,this._$AH=A$1,this._$AN=void 0,this._$AA=t,this._$AB=i,this._$AM=s,this.options=e,this._$Cp=null===(o=null==e?void 0:e.isConnected)||void 0===o||o;}get _$AU(){var t,i;return null!==(i=null===(t=this._$AM)||void 0===t?void 0:t._$AU)&&void 0!==i?i:this._$Cp}get parentNode(){let t=this._$AA.parentNode;const i=this._$AM;return void 0!==i&&11===(null==t?void 0:t.nodeType)&&(t=i.parentNode),t}get startNode(){return this._$AA}get endNode(){return this._$AB}_$AI(t,i=this){t=S$1(this,t,i),d(t)?t===A$1||null==t||""===t?(this._$AH!==A$1&&this._$AR(),this._$AH=A$1):t!==this._$AH&&t!==T$1&&this._(t):void 0!==t._$litType$?this.g(t):void 0!==t.nodeType?this.$(t):v$1(t)?this.T(t):this._(t);}k(t){return this._$AA.parentNode.insertBefore(t,this._$AB)}$(t){this._$AH!==t&&(this._$AR(),this._$AH=this.k(t));}_(t){this._$AH!==A$1&&d(this._$AH)?this._$AA.nextSibling.data=t:this.$(r.createTextNode(t)),this._$AH=t;}g(t){var i;const{values:s,_$litType$:e}=t,o="number"==typeof e?this._$AC(t):(void 0===e.el&&(e.el=N.createElement(P(e.h,e.h[0]),this.options)),e);if((null===(i=this._$AH)||void 0===i?void 0:i._$AD)===o)this._$AH.v(s);else {const t=new M(o,this),i=t.u(this.options);t.v(s),this.$(i),this._$AH=t;}}_$AC(t){let i=E.get(t.strings);return void 0===i&&E.set(t.strings,i=new N(t)),i}T(t){c$1(this._$AH)||(this._$AH=[],this._$AR());const i=this._$AH;let s,e=0;for(const o of t)e===i.length?i.push(s=new R(this.k(u()),this.k(u()),this,this.options)):s=i[e],s._$AI(o),e++;e<i.length&&(this._$AR(s&&s._$AB.nextSibling,e),i.length=e);}_$AR(t=this._$AA.nextSibling,i){var s;for(null===(s=this._$AP)||void 0===s||s.call(this,!1,!0,i);t&&t!==this._$AB;){const i=t.nextSibling;t.remove(),t=i;}}setConnected(t){var i;void 0===this._$AM&&(this._$Cp=t,null===(i=this._$AP)||void 0===i||i.call(this,t));}}class k{constructor(t,i,s,e,o){this.type=1,this._$AH=A$1,this._$AN=void 0,this.element=t,this.name=i,this._$AM=e,this.options=o,s.length>2||""!==s[0]||""!==s[1]?(this._$AH=Array(s.length-1).fill(new String),this.strings=s):this._$AH=A$1;}get tagName(){return this.element.tagName}get _$AU(){return this._$AM._$AU}_$AI(t,i=this,s,e){const o=this.strings;let n=!1;if(void 0===o)t=S$1(this,t,i,0),n=!d(t)||t!==this._$AH&&t!==T$1,n&&(this._$AH=t);else {const e=t;let l,h;for(t=o[0],l=0;l<o.length-1;l++)h=S$1(this,e[s+l],i,l),h===T$1&&(h=this._$AH[l]),n||(n=!d(h)||h!==this._$AH[l]),h===A$1?t=A$1:t!==A$1&&(t+=(null!=h?h:"")+o[l+1]),this._$AH[l]=h;}n&&!e&&this.j(t);}j(t){t===A$1?this.element.removeAttribute(this.name):this.element.setAttribute(this.name,null!=t?t:"");}}class H extends k{constructor(){super(...arguments),this.type=3;}j(t){this.element[this.name]=t===A$1?void 0:t;}}const I=s$1?s$1.emptyScript:"";let L$1 = class L extends k{constructor(){super(...arguments),this.type=4;}j(t){t&&t!==A$1?this.element.setAttribute(this.name,I):this.element.removeAttribute(this.name);}};class z extends k{constructor(t,i,s,e,o){super(t,i,s,e,o),this.type=5;}_$AI(t,i=this){var s;if((t=null!==(s=S$1(this,t,i,0))&&void 0!==s?s:A$1)===T$1)return;const e=this._$AH,o=t===A$1&&e!==A$1||t.capture!==e.capture||t.once!==e.once||t.passive!==e.passive,n=t!==A$1&&(e===A$1||o);o&&this.element.removeEventListener(this.name,this,e),n&&this.element.addEventListener(this.name,this,t),this._$AH=t;}handleEvent(t){var i,s;"function"==typeof this._$AH?this._$AH.call(null!==(s=null===(i=this.options)||void 0===i?void 0:i.host)&&void 0!==s?s:this.element,t):this._$AH.handleEvent(t);}}let Z$1 = class Z{constructor(t,i,s){this.element=t,this.type=6,this._$AN=void 0,this._$AM=i,this.options=s;}get _$AU(){return this._$AM._$AU}_$AI(t){S$1(this,t);}};const B$1=i$2.litHtmlPolyfillSupport;null==B$1||B$1(N,R),(null!==(t$2=i$2.litHtmlVersions)&&void 0!==t$2?t$2:i$2.litHtmlVersions=[]).push("2.8.0");const D$1=(t,i,s)=>{var e,o;const n=null!==(e=null==s?void 0:s.renderBefore)&&void 0!==e?e:i;let l=n._$litPart$;if(void 0===l){const t=null!==(o=null==s?void 0:s.renderBefore)&&void 0!==o?o:null;n._$litPart$=l=new R(i.insertBefore(u(),t),t,void 0,null!=s?s:{});}return l._$AI(t),l};

    /**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */var l$1,o$1;class s extends u$1{constructor(){super(...arguments),this.renderOptions={host:this},this._$Do=void 0;}createRenderRoot(){var t,e;const i=super.createRenderRoot();return null!==(t=(e=this.renderOptions).renderBefore)&&void 0!==t||(e.renderBefore=i.firstChild),i}update(t){const i=this.render();this.hasUpdated||(this.renderOptions.isConnected=this.isConnected),super.update(t),this._$Do=D$1(i,this.renderRoot,this.renderOptions);}connectedCallback(){var t;super.connectedCallback(),null===(t=this._$Do)||void 0===t||t.setConnected(!0);}disconnectedCallback(){var t;super.disconnectedCallback(),null===(t=this._$Do)||void 0===t||t.setConnected(!1);}render(){return T$1}}s.finalized=!0,s._$litElement$=!0,null===(l$1=globalThis.litElementHydrateSupport)||void 0===l$1||l$1.call(globalThis,{LitElement:s});const n$2=globalThis.litElementPolyfillSupport;null==n$2||n$2({LitElement:s});(null!==(o$1=globalThis.litElementVersions)&&void 0!==o$1?o$1:globalThis.litElementVersions=[]).push("3.3.3");

    /**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */
    const e$2=e=>n=>"function"==typeof n?((e,n)=>(customElements.define(e,n),n))(e,n):((e,n)=>{const{kind:t,elements:s}=n;return {kind:t,elements:s,finisher(n){customElements.define(e,n);}}})(e,n);

    /**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */
    const i$1=(i,e)=>"method"===e.kind&&e.descriptor&&!("value"in e.descriptor)?{...e,finisher(n){n.createProperty(e.key,i);}}:{kind:"field",key:Symbol(),placement:"own",descriptor:{},originalKey:e.key,initializer(){"function"==typeof e.initializer&&(this[e.key]=e.initializer.call(this));},finisher(n){n.createProperty(e.key,i);}},e$1=(i,e,n)=>{e.constructor.createProperty(n,i);};function n$1(n){return (t,o)=>void 0!==o?e$1(n,t,o):i$1(n,t)}

    /**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */function t$1(t){return n$1({...t,state:!0})}

    /**
     * @license
     * Copyright 2021 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */var n;null!=(null===(n=window.HTMLSlotElement)||void 0===n?void 0:n.prototype.assignedElements)?(o,n)=>o.assignedElements(n):(o,n)=>o.assignedNodes(n).filter((o=>o.nodeType===Node.ELEMENT_NODE));

    /**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */
    const t={ATTRIBUTE:1,CHILD:2,PROPERTY:3,BOOLEAN_ATTRIBUTE:4,EVENT:5,ELEMENT:6},e=t=>(...e)=>({_$litDirective$:t,values:e});class i{constructor(t){}get _$AU(){return this._$AM._$AU}_$AT(t,e,i){this._$Ct=t,this._$AM=e,this._$Ci=i;}_$AS(t,e){return this.update(t,e)}update(t,e){return this.render(...e)}}

    /**
     * @license
     * Copyright 2018 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */const o=e(class extends i{constructor(t$1){var i;if(super(t$1),t$1.type!==t.ATTRIBUTE||"class"!==t$1.name||(null===(i=t$1.strings)||void 0===i?void 0:i.length)>2)throw Error("`classMap()` can only be used in the `class` attribute and must be the only part in the attribute.")}render(t){return " "+Object.keys(t).filter((i=>t[i])).join(" ")+" "}update(i,[s]){var r,o;if(void 0===this.it){this.it=new Set,void 0!==i.strings&&(this.nt=new Set(i.strings.join(" ").split(/\s/).filter((t=>""!==t))));for(const t in s)s[t]&&!(null===(r=this.nt)||void 0===r?void 0:r.has(t))&&this.it.add(t);return this.render(s)}const e=i.element.classList;this.it.forEach((t=>{t in s||(e.remove(t),this.it.delete(t));}));for(const t in s){const i=!!s[t];i===this.it.has(t)||(null===(o=this.nt)||void 0===o?void 0:o.has(t))||(i?(e.add(t),this.it.add(t)):(e.remove(t),this.it.delete(t)));}return T$1}});

    function addUniqueItem(array, item) {
        array.indexOf(item) === -1 && array.push(item);
    }

    const clamp = (min, max, v) => Math.min(Math.max(v, min), max);

    const defaults = {
        duration: 0.3,
        delay: 0,
        endDelay: 0,
        repeat: 0,
        easing: "ease",
    };

    const isNumber = (value) => typeof value === "number";

    const isEasingList = (easing) => Array.isArray(easing) && !isNumber(easing[0]);

    const wrap = (min, max, v) => {
        const rangeSize = max - min;
        return ((((v - min) % rangeSize) + rangeSize) % rangeSize) + min;
    };

    function getEasingForSegment(easing, i) {
        return isEasingList(easing)
            ? easing[wrap(0, easing.length, i)]
            : easing;
    }

    const mix = (min, max, progress) => -progress * min + progress * max + min;

    const noop = () => { };
    const noopReturn = (v) => v;

    const progress = (min, max, value) => max - min === 0 ? 1 : (value - min) / (max - min);

    function fillOffset(offset, remaining) {
        const min = offset[offset.length - 1];
        for (let i = 1; i <= remaining; i++) {
            const offsetProgress = progress(0, remaining, i);
            offset.push(mix(min, 1, offsetProgress));
        }
    }
    function defaultOffset(length) {
        const offset = [0];
        fillOffset(offset, length - 1);
        return offset;
    }

    function interpolate(output, input = defaultOffset(output.length), easing = noopReturn) {
        const length = output.length;
        /**
         * If the input length is lower than the output we
         * fill the input to match. This currently assumes the input
         * is an animation progress value so is a good candidate for
         * moving outside the function.
         */
        const remainder = length - input.length;
        remainder > 0 && fillOffset(input, remainder);
        return (t) => {
            let i = 0;
            for (; i < length - 2; i++) {
                if (t < input[i + 1])
                    break;
            }
            let progressInRange = clamp(0, 1, progress(input[i], input[i + 1], t));
            const segmentEasing = getEasingForSegment(easing, i);
            progressInRange = segmentEasing(progressInRange);
            return mix(output[i], output[i + 1], progressInRange);
        };
    }

    const isCubicBezier = (easing) => Array.isArray(easing) && isNumber(easing[0]);

    const isEasingGenerator = (easing) => typeof easing === "object" &&
        Boolean(easing.createAnimation);

    const isFunction = (value) => typeof value === "function";

    const isString = (value) => typeof value === "string";

    const time = {
        ms: (seconds) => seconds * 1000,
        s: (milliseconds) => milliseconds / 1000,
    };

    /*
      Bezier function generator

      This has been modified from Gaëtan Renaudeau's BezierEasing
      https://github.com/gre/bezier-easing/blob/master/src/index.js
      https://github.com/gre/bezier-easing/blob/master/LICENSE
      
      I've removed the newtonRaphsonIterate algo because in benchmarking it
      wasn't noticiably faster than binarySubdivision, indeed removing it
      usually improved times, depending on the curve.

      I also removed the lookup table, as for the added bundle size and loop we're
      only cutting ~4 or so subdivision iterations. I bumped the max iterations up
      to 12 to compensate and this still tended to be faster for no perceivable
      loss in accuracy.

      Usage
        const easeOut = cubicBezier(.17,.67,.83,.67);
        const x = easeOut(0.5); // returns 0.627...
    */
    // Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.
    const calcBezier = (t, a1, a2) => (((1.0 - 3.0 * a2 + 3.0 * a1) * t + (3.0 * a2 - 6.0 * a1)) * t + 3.0 * a1) * t;
    const subdivisionPrecision = 0.0000001;
    const subdivisionMaxIterations = 12;
    function binarySubdivide(x, lowerBound, upperBound, mX1, mX2) {
        let currentX;
        let currentT;
        let i = 0;
        do {
            currentT = lowerBound + (upperBound - lowerBound) / 2.0;
            currentX = calcBezier(currentT, mX1, mX2) - x;
            if (currentX > 0.0) {
                upperBound = currentT;
            }
            else {
                lowerBound = currentT;
            }
        } while (Math.abs(currentX) > subdivisionPrecision &&
            ++i < subdivisionMaxIterations);
        return currentT;
    }
    function cubicBezier(mX1, mY1, mX2, mY2) {
        // If this is a linear gradient, return linear easing
        if (mX1 === mY1 && mX2 === mY2)
            return noopReturn;
        const getTForX = (aX) => binarySubdivide(aX, 0, 1, mX1, mX2);
        // If animation is at start/end, return t without easing
        return (t) => t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2);
    }

    const steps = (steps, direction = "end") => (progress) => {
        progress =
            direction === "end"
                ? Math.min(progress, 0.999)
                : Math.max(progress, 0.001);
        const expanded = progress * steps;
        const rounded = direction === "end" ? Math.floor(expanded) : Math.ceil(expanded);
        return clamp(0, 1, rounded / steps);
    };

    const namedEasings = {
        ease: cubicBezier(0.25, 0.1, 0.25, 1.0),
        "ease-in": cubicBezier(0.42, 0.0, 1.0, 1.0),
        "ease-in-out": cubicBezier(0.42, 0.0, 0.58, 1.0),
        "ease-out": cubicBezier(0.0, 0.0, 0.58, 1.0),
    };
    const functionArgsRegex = /\((.*?)\)/;
    function getEasingFunction(definition) {
        // If already an easing function, return
        if (isFunction(definition))
            return definition;
        // If an easing curve definition, return bezier function
        if (isCubicBezier(definition))
            return cubicBezier(...definition);
        // If we have a predefined easing function, return
        if (namedEasings[definition])
            return namedEasings[definition];
        // If this is a steps function, attempt to create easing curve
        if (definition.startsWith("steps")) {
            const args = functionArgsRegex.exec(definition);
            if (args) {
                const argsArray = args[1].split(",");
                return steps(parseFloat(argsArray[0]), argsArray[1].trim());
            }
        }
        return noopReturn;
    }

    class Animation {
        constructor(output, keyframes = [0, 1], { easing, duration: initialDuration = defaults.duration, delay = defaults.delay, endDelay = defaults.endDelay, repeat = defaults.repeat, offset, direction = "normal", autoplay = true, } = {}) {
            this.startTime = null;
            this.rate = 1;
            this.t = 0;
            this.cancelTimestamp = null;
            this.easing = noopReturn;
            this.duration = 0;
            this.totalDuration = 0;
            this.repeat = 0;
            this.playState = "idle";
            this.finished = new Promise((resolve, reject) => {
                this.resolve = resolve;
                this.reject = reject;
            });
            easing = easing || defaults.easing;
            if (isEasingGenerator(easing)) {
                const custom = easing.createAnimation(keyframes);
                easing = custom.easing;
                keyframes = custom.keyframes || keyframes;
                initialDuration = custom.duration || initialDuration;
            }
            this.repeat = repeat;
            this.easing = isEasingList(easing) ? noopReturn : getEasingFunction(easing);
            this.updateDuration(initialDuration);
            const interpolate$1 = interpolate(keyframes, offset, isEasingList(easing) ? easing.map(getEasingFunction) : noopReturn);
            this.tick = (timestamp) => {
                var _a;
                // TODO: Temporary fix for OptionsResolver typing
                delay = delay;
                let t = 0;
                if (this.pauseTime !== undefined) {
                    t = this.pauseTime;
                }
                else {
                    t = (timestamp - this.startTime) * this.rate;
                }
                this.t = t;
                // Convert to seconds
                t /= 1000;
                // Rebase on delay
                t = Math.max(t - delay, 0);
                /**
                 * If this animation has finished, set the current time
                 * to the total duration.
                 */
                if (this.playState === "finished" && this.pauseTime === undefined) {
                    t = this.totalDuration;
                }
                /**
                 * Get the current progress (0-1) of the animation. If t is >
                 * than duration we'll get values like 2.5 (midway through the
                 * third iteration)
                 */
                const progress = t / this.duration;
                // TODO progress += iterationStart
                /**
                 * Get the current iteration (0 indexed). For instance the floor of
                 * 2.5 is 2.
                 */
                let currentIteration = Math.floor(progress);
                /**
                 * Get the current progress of the iteration by taking the remainder
                 * so 2.5 is 0.5 through iteration 2
                 */
                let iterationProgress = progress % 1.0;
                if (!iterationProgress && progress >= 1) {
                    iterationProgress = 1;
                }
                /**
                 * If iteration progress is 1 we count that as the end
                 * of the previous iteration.
                 */
                iterationProgress === 1 && currentIteration--;
                /**
                 * Reverse progress if we're not running in "normal" direction
                 */
                const iterationIsOdd = currentIteration % 2;
                if (direction === "reverse" ||
                    (direction === "alternate" && iterationIsOdd) ||
                    (direction === "alternate-reverse" && !iterationIsOdd)) {
                    iterationProgress = 1 - iterationProgress;
                }
                const p = t >= this.totalDuration ? 1 : Math.min(iterationProgress, 1);
                const latest = interpolate$1(this.easing(p));
                output(latest);
                const isAnimationFinished = this.pauseTime === undefined &&
                    (this.playState === "finished" || t >= this.totalDuration + endDelay);
                if (isAnimationFinished) {
                    this.playState = "finished";
                    (_a = this.resolve) === null || _a === void 0 ? void 0 : _a.call(this, latest);
                }
                else if (this.playState !== "idle") {
                    this.frameRequestId = requestAnimationFrame(this.tick);
                }
            };
            if (autoplay)
                this.play();
        }
        play() {
            const now = performance.now();
            this.playState = "running";
            if (this.pauseTime !== undefined) {
                this.startTime = now - this.pauseTime;
            }
            else if (!this.startTime) {
                this.startTime = now;
            }
            this.cancelTimestamp = this.startTime;
            this.pauseTime = undefined;
            this.frameRequestId = requestAnimationFrame(this.tick);
        }
        pause() {
            this.playState = "paused";
            this.pauseTime = this.t;
        }
        finish() {
            this.playState = "finished";
            this.tick(0);
        }
        stop() {
            var _a;
            this.playState = "idle";
            if (this.frameRequestId !== undefined) {
                cancelAnimationFrame(this.frameRequestId);
            }
            (_a = this.reject) === null || _a === void 0 ? void 0 : _a.call(this, false);
        }
        cancel() {
            this.stop();
            this.tick(this.cancelTimestamp);
        }
        reverse() {
            this.rate *= -1;
        }
        commitStyles() { }
        updateDuration(duration) {
            this.duration = duration;
            this.totalDuration = duration * (this.repeat + 1);
        }
        get currentTime() {
            return this.t;
        }
        set currentTime(t) {
            if (this.pauseTime !== undefined || this.rate === 0) {
                this.pauseTime = t;
            }
            else {
                this.startTime = performance.now() - t / this.rate;
            }
        }
        get playbackRate() {
            return this.rate;
        }
        set playbackRate(rate) {
            this.rate = rate;
        }
    }

    var invariant = function () { };
    if (browser$1$1.env.NODE_ENV !== 'production') {
        invariant = function (check, message) {
            if (!check) {
                throw new Error(message);
            }
        };
    }

    /**
     * The MotionValue tracks the state of a single animatable
     * value. Currently, updatedAt and current are unused. The
     * long term idea is to use this to minimise the number
     * of DOM reads, and to abstract the DOM interactions here.
     */
    class MotionValue {
        setAnimation(animation) {
            this.animation = animation;
            animation === null || animation === void 0 ? void 0 : animation.finished.then(() => this.clearAnimation()).catch(() => { });
        }
        clearAnimation() {
            this.animation = this.generator = undefined;
        }
    }

    const data = new WeakMap();
    function getAnimationData(element) {
        if (!data.has(element)) {
            data.set(element, {
                transforms: [],
                values: new Map(),
            });
        }
        return data.get(element);
    }
    function getMotionValue(motionValues, name) {
        if (!motionValues.has(name)) {
            motionValues.set(name, new MotionValue());
        }
        return motionValues.get(name);
    }

    /**
     * A list of all transformable axes. We'll use this list to generated a version
     * of each axes for each transform.
     */
    const axes = ["", "X", "Y", "Z"];
    /**
     * An ordered array of each transformable value. By default, transform values
     * will be sorted to this order.
     */
    const order = ["translate", "scale", "rotate", "skew"];
    const transformAlias = {
        x: "translateX",
        y: "translateY",
        z: "translateZ",
    };
    const rotation = {
        syntax: "<angle>",
        initialValue: "0deg",
        toDefaultUnit: (v) => v + "deg",
    };
    const baseTransformProperties = {
        translate: {
            syntax: "<length-percentage>",
            initialValue: "0px",
            toDefaultUnit: (v) => v + "px",
        },
        rotate: rotation,
        scale: {
            syntax: "<number>",
            initialValue: 1,
            toDefaultUnit: noopReturn,
        },
        skew: rotation,
    };
    const transformDefinitions = new Map();
    const asTransformCssVar = (name) => `--motion-${name}`;
    /**
     * Generate a list of every possible transform key
     */
    const transforms = ["x", "y", "z"];
    order.forEach((name) => {
        axes.forEach((axis) => {
            transforms.push(name + axis);
            transformDefinitions.set(asTransformCssVar(name + axis), baseTransformProperties[name]);
        });
    });
    /**
     * A function to use with Array.sort to sort transform keys by their default order.
     */
    const compareTransformOrder = (a, b) => transforms.indexOf(a) - transforms.indexOf(b);
    /**
     * Provide a quick way to check if a string is the name of a transform
     */
    const transformLookup = new Set(transforms);
    const isTransform = (name) => transformLookup.has(name);
    const addTransformToElement = (element, name) => {
        // Map x to translateX etc
        if (transformAlias[name])
            name = transformAlias[name];
        const { transforms } = getAnimationData(element);
        addUniqueItem(transforms, name);
        /**
         * TODO: An optimisation here could be to cache the transform in element data
         * and only update if this has changed.
         */
        element.style.transform = buildTransformTemplate(transforms);
    };
    const buildTransformTemplate = (transforms) => transforms
        .sort(compareTransformOrder)
        .reduce(transformListToString, "")
        .trim();
    const transformListToString = (template, name) => `${template} ${name}(var(${asTransformCssVar(name)}))`;

    const isCssVar = (name) => name.startsWith("--");
    const registeredProperties = new Set();
    function registerCssVariable(name) {
        if (registeredProperties.has(name))
            return;
        registeredProperties.add(name);
        try {
            const { syntax, initialValue } = transformDefinitions.has(name)
                ? transformDefinitions.get(name)
                : {};
            CSS.registerProperty({
                name,
                inherits: false,
                syntax,
                initialValue,
            });
        }
        catch (e) { }
    }

    const testAnimation = (keyframes, options) => document.createElement("div").animate(keyframes, options);
    const featureTests = {
        cssRegisterProperty: () => typeof CSS !== "undefined" &&
            Object.hasOwnProperty.call(CSS, "registerProperty"),
        waapi: () => Object.hasOwnProperty.call(Element.prototype, "animate"),
        partialKeyframes: () => {
            try {
                testAnimation({ opacity: [1] });
            }
            catch (e) {
                return false;
            }
            return true;
        },
        finished: () => Boolean(testAnimation({ opacity: [0, 1] }, { duration: 0.001 }).finished),
        linearEasing: () => {
            try {
                testAnimation({ opacity: 0 }, { easing: "linear(0, 1)" });
            }
            catch (e) {
                return false;
            }
            return true;
        },
    };
    const results = {};
    const supports = {};
    for (const key in featureTests) {
        supports[key] = () => {
            if (results[key] === undefined)
                results[key] = featureTests[key]();
            return results[key];
        };
    }

    // Create a linear easing point for every x second
    const resolution = 0.015;
    const generateLinearEasingPoints = (easing, duration) => {
        let points = "";
        const numPoints = Math.round(duration / resolution);
        for (let i = 0; i < numPoints; i++) {
            points += easing(progress(0, numPoints - 1, i)) + ", ";
        }
        return points.substring(0, points.length - 2);
    };
    const convertEasing = (easing, duration) => {
        if (isFunction(easing)) {
            return supports.linearEasing()
                ? `linear(${generateLinearEasingPoints(easing, duration)})`
                : defaults.easing;
        }
        else {
            return isCubicBezier(easing) ? cubicBezierAsString(easing) : easing;
        }
    };
    const cubicBezierAsString = ([a, b, c, d]) => `cubic-bezier(${a}, ${b}, ${c}, ${d})`;

    function hydrateKeyframes(keyframes, readInitialValue) {
        for (let i = 0; i < keyframes.length; i++) {
            if (keyframes[i] === null) {
                keyframes[i] = i ? keyframes[i - 1] : readInitialValue();
            }
        }
        return keyframes;
    }
    const keyframesList = (keyframes) => Array.isArray(keyframes) ? keyframes : [keyframes];

    function getStyleName(key) {
        if (transformAlias[key])
            key = transformAlias[key];
        return isTransform(key) ? asTransformCssVar(key) : key;
    }

    const style = {
        get: (element, name) => {
            name = getStyleName(name);
            let value = isCssVar(name)
                ? element.style.getPropertyValue(name)
                : getComputedStyle(element)[name];
            if (!value && value !== 0) {
                const definition = transformDefinitions.get(name);
                if (definition)
                    value = definition.initialValue;
            }
            return value;
        },
        set: (element, name, value) => {
            name = getStyleName(name);
            if (isCssVar(name)) {
                element.style.setProperty(name, value);
            }
            else {
                element.style[name] = value;
            }
        },
    };

    function stopAnimation(animation, needsCommit = true) {
        if (!animation || animation.playState === "finished")
            return;
        // Suppress error thrown by WAAPI
        try {
            if (animation.stop) {
                animation.stop();
            }
            else {
                needsCommit && animation.commitStyles();
                animation.cancel();
            }
        }
        catch (e) { }
    }

    function getUnitConverter(keyframes, definition) {
        var _a;
        let toUnit = (definition === null || definition === void 0 ? void 0 : definition.toDefaultUnit) || noopReturn;
        const finalKeyframe = keyframes[keyframes.length - 1];
        if (isString(finalKeyframe)) {
            const unit = ((_a = finalKeyframe.match(/(-?[\d.]+)([a-z%]*)/)) === null || _a === void 0 ? void 0 : _a[2]) || "";
            if (unit)
                toUnit = (value) => value + unit;
        }
        return toUnit;
    }

    function getDevToolsRecord() {
        return window.__MOTION_DEV_TOOLS_RECORD;
    }
    function animateStyle(element, key, keyframesDefinition, options = {}, AnimationPolyfill) {
        const record = getDevToolsRecord();
        const isRecording = options.record !== false && record;
        let animation;
        let { duration = defaults.duration, delay = defaults.delay, endDelay = defaults.endDelay, repeat = defaults.repeat, easing = defaults.easing, persist = false, direction, offset, allowWebkitAcceleration = false, autoplay = true, } = options;
        const data = getAnimationData(element);
        const valueIsTransform = isTransform(key);
        let canAnimateNatively = supports.waapi();
        /**
         * If this is an individual transform, we need to map its
         * key to a CSS variable and update the element's transform style
         */
        valueIsTransform && addTransformToElement(element, key);
        const name = getStyleName(key);
        const motionValue = getMotionValue(data.values, name);
        /**
         * Get definition of value, this will be used to convert numerical
         * keyframes into the default value type.
         */
        const definition = transformDefinitions.get(name);
        /**
         * Stop the current animation, if any. Because this will trigger
         * commitStyles (DOM writes) and we might later trigger DOM reads,
         * this is fired now and we return a factory function to create
         * the actual animation that can get called in batch,
         */
        stopAnimation(motionValue.animation, !(isEasingGenerator(easing) && motionValue.generator) &&
            options.record !== false);
        /**
         * Batchable factory function containing all DOM reads.
         */
        return () => {
            const readInitialValue = () => { var _a, _b; return (_b = (_a = style.get(element, name)) !== null && _a !== void 0 ? _a : definition === null || definition === void 0 ? void 0 : definition.initialValue) !== null && _b !== void 0 ? _b : 0; };
            /**
             * Replace null values with the previous keyframe value, or read
             * it from the DOM if it's the first keyframe.
             */
            let keyframes = hydrateKeyframes(keyframesList(keyframesDefinition), readInitialValue);
            /**
             * Detect unit type of keyframes.
             */
            const toUnit = getUnitConverter(keyframes, definition);
            if (isEasingGenerator(easing)) {
                const custom = easing.createAnimation(keyframes, key !== "opacity", readInitialValue, name, motionValue);
                easing = custom.easing;
                keyframes = custom.keyframes || keyframes;
                duration = custom.duration || duration;
            }
            /**
             * If this is a CSS variable we need to register it with the browser
             * before it can be animated natively. We also set it with setProperty
             * rather than directly onto the element.style object.
             */
            if (isCssVar(name)) {
                if (supports.cssRegisterProperty()) {
                    registerCssVariable(name);
                }
                else {
                    canAnimateNatively = false;
                }
            }
            /**
             * If we've been passed a custom easing function, and this browser
             * does **not** support linear() easing, and the value is a transform
             * (and thus a pure number) we can still support the custom easing
             * by falling back to the animation polyfill.
             */
            if (valueIsTransform &&
                !supports.linearEasing() &&
                (isFunction(easing) || (isEasingList(easing) && easing.some(isFunction)))) {
                canAnimateNatively = false;
            }
            /**
             * If we can animate this value with WAAPI, do so.
             */
            if (canAnimateNatively) {
                /**
                 * Convert numbers to default value types. Currently this only supports
                 * transforms but it could also support other value types.
                 */
                if (definition) {
                    keyframes = keyframes.map((value) => isNumber(value) ? definition.toDefaultUnit(value) : value);
                }
                /**
                 * If this browser doesn't support partial/implicit keyframes we need to
                 * explicitly provide one.
                 */
                if (keyframes.length === 1 &&
                    (!supports.partialKeyframes() || isRecording)) {
                    keyframes.unshift(readInitialValue());
                }
                const animationOptions = {
                    delay: time.ms(delay),
                    duration: time.ms(duration),
                    endDelay: time.ms(endDelay),
                    easing: !isEasingList(easing)
                        ? convertEasing(easing, duration)
                        : undefined,
                    direction,
                    iterations: repeat + 1,
                    fill: "both",
                };
                animation = element.animate({
                    [name]: keyframes,
                    offset,
                    easing: isEasingList(easing)
                        ? easing.map((thisEasing) => convertEasing(thisEasing, duration))
                        : undefined,
                }, animationOptions);
                /**
                 * Polyfill finished Promise in browsers that don't support it
                 */
                if (!animation.finished) {
                    animation.finished = new Promise((resolve, reject) => {
                        animation.onfinish = resolve;
                        animation.oncancel = reject;
                    });
                }
                const target = keyframes[keyframes.length - 1];
                animation.finished
                    .then(() => {
                    if (persist)
                        return;
                    // Apply styles to target
                    style.set(element, name, target);
                    // Ensure fill modes don't persist
                    animation.cancel();
                })
                    .catch(noop);
                /**
                 * This forces Webkit to run animations on the main thread by exploiting
                 * this condition:
                 * https://trac.webkit.org/browser/webkit/trunk/Source/WebCore/platform/graphics/ca/GraphicsLayerCA.cpp?rev=281238#L1099
                 *
                 * This fixes Webkit's timing bugs, like accelerated animations falling
                 * out of sync with main thread animations and massive delays in starting
                 * accelerated animations in WKWebView.
                 */
                if (!allowWebkitAcceleration)
                    animation.playbackRate = 1.000001;
                /**
                 * If we can't animate the value natively then we can fallback to the numbers-only
                 * polyfill for transforms.
                 */
            }
            else if (AnimationPolyfill && valueIsTransform) {
                /**
                 * If any keyframe is a string (because we measured it from the DOM), we need to convert
                 * it into a number before passing to the Animation polyfill.
                 */
                keyframes = keyframes.map((value) => typeof value === "string" ? parseFloat(value) : value);
                /**
                 * If we only have a single keyframe, we need to create an initial keyframe by reading
                 * the current value from the DOM.
                 */
                if (keyframes.length === 1) {
                    keyframes.unshift(parseFloat(readInitialValue()));
                }
                animation = new AnimationPolyfill((latest) => {
                    style.set(element, name, toUnit ? toUnit(latest) : latest);
                }, keyframes, Object.assign(Object.assign({}, options), { duration,
                    easing }));
            }
            else {
                const target = keyframes[keyframes.length - 1];
                style.set(element, name, definition && isNumber(target)
                    ? definition.toDefaultUnit(target)
                    : target);
            }
            if (isRecording) {
                record(element, key, keyframes, {
                    duration,
                    delay: delay,
                    easing,
                    repeat,
                    offset,
                }, "motion-one");
            }
            motionValue.setAnimation(animation);
            if (animation && !autoplay)
                animation.pause();
            return animation;
        };
    }

    const getOptions = (options, key) => 
    /**
     * TODO: Make test for this
     * Always return a new object otherwise delay is overwritten by results of stagger
     * and this results in no stagger
     */
    options[key] ? Object.assign(Object.assign({}, options), options[key]) : Object.assign({}, options);

    function resolveElements(elements, selectorCache) {
        var _a;
        if (typeof elements === "string") {
            if (selectorCache) {
                (_a = selectorCache[elements]) !== null && _a !== void 0 ? _a : (selectorCache[elements] = document.querySelectorAll(elements));
                elements = selectorCache[elements];
            }
            else {
                elements = document.querySelectorAll(elements);
            }
        }
        else if (elements instanceof Element) {
            elements = [elements];
        }
        /**
         * Return an empty array
         */
        return Array.from(elements || []);
    }

    const createAnimation = (factory) => factory();
    const withControls = (animationFactory, options, duration = defaults.duration) => {
        return new Proxy({
            animations: animationFactory.map(createAnimation).filter(Boolean),
            duration,
            options,
        }, controls);
    };
    /**
     * TODO:
     * Currently this returns the first animation, ideally it would return
     * the first active animation.
     */
    const getActiveAnimation = (state) => state.animations[0];
    const controls = {
        get: (target, key) => {
            const activeAnimation = getActiveAnimation(target);
            switch (key) {
                case "duration":
                    return target.duration;
                case "currentTime":
                    return time.s((activeAnimation === null || activeAnimation === void 0 ? void 0 : activeAnimation[key]) || 0);
                case "playbackRate":
                case "playState":
                    return activeAnimation === null || activeAnimation === void 0 ? void 0 : activeAnimation[key];
                case "finished":
                    if (!target.finished) {
                        target.finished = Promise.all(target.animations.map(selectFinished)).catch(noop);
                    }
                    return target.finished;
                case "stop":
                    return () => {
                        target.animations.forEach((animation) => stopAnimation(animation));
                    };
                case "forEachNative":
                    /**
                     * This is for internal use only, fire a callback for each
                     * underlying animation.
                     */
                    return (callback) => {
                        target.animations.forEach((animation) => callback(animation, target));
                    };
                default:
                    return typeof (activeAnimation === null || activeAnimation === void 0 ? void 0 : activeAnimation[key]) === "undefined"
                        ? undefined
                        : () => target.animations.forEach((animation) => animation[key]());
            }
        },
        set: (target, key, value) => {
            switch (key) {
                case "currentTime":
                    value = time.ms(value);
                // Fall-through
                case "playbackRate":
                    for (let i = 0; i < target.animations.length; i++) {
                        target.animations[i][key] = value;
                    }
                    return true;
            }
            return false;
        },
    };
    const selectFinished = (animation) => animation.finished;

    function resolveOption(option, i, total) {
        return isFunction(option) ? option(i, total) : option;
    }

    function createAnimate(AnimatePolyfill) {
        return function animate(elements, keyframes, options = {}) {
            elements = resolveElements(elements);
            const numElements = elements.length;
            invariant(Boolean(numElements), "No valid element provided.");
            invariant(Boolean(keyframes), "No keyframes defined.");
            /**
             * Create and start new animations
             */
            const animationFactories = [];
            for (let i = 0; i < numElements; i++) {
                const element = elements[i];
                for (const key in keyframes) {
                    const valueOptions = getOptions(options, key);
                    valueOptions.delay = resolveOption(valueOptions.delay, i, numElements);
                    const animation = animateStyle(element, key, keyframes[key], valueOptions, AnimatePolyfill);
                    animationFactories.push(animation);
                }
            }
            return withControls(animationFactories, options, 
            /**
             * TODO:
             * If easing is set to spring or glide, duration will be dynamically
             * generated. Ideally we would dynamically generate this from
             * animation.effect.getComputedTiming().duration but this isn't
             * supported in iOS13 or our number polyfill. Perhaps it's possible
             * to Proxy animations returned from animateStyle that has duration
             * as a getter.
             */
            options.duration);
        };
    }

    const animate$1 = createAnimate(Animation);

    function animateProgress(target, options = {}) {
        return withControls([
            () => {
                const animation = new Animation(target, [0, 1], options);
                animation.finished.catch(() => { });
                return animation;
            },
        ], options, options.duration);
    }
    function animate(target, keyframesOrOptions, options) {
        const factory = isFunction(target) ? animateProgress : animate$1;
        return factory(target, keyframesOrOptions, options);
    }

    /**
     * @license
     * Copyright 2018 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */const l=l=>null!=l?l:A$1;

    var et=Object.defineProperty,Be=Object.getOwnPropertySymbols,tt=Object.prototype.hasOwnProperty,ot=Object.prototype.propertyIsEnumerable,Ue=(e,o,r)=>o in e?et(e,o,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[o]=r,ve=(e,o)=>{for(var r in o||(o={}))tt.call(o,r)&&Ue(e,r,o[r]);if(Be)for(var r of Be(o))ot.call(o,r)&&Ue(e,r,o[r]);return e};function rt(){var e;const o=(e=ne$1.state.themeMode)!=null?e:"dark",r={light:{foreground:{1:"rgb(20,20,20)",2:"rgb(121,134,134)",3:"rgb(158,169,169)"},background:{1:"rgb(255,255,255)",2:"rgb(241,243,243)",3:"rgb(228,231,231)"},overlay:"rgba(0,0,0,0.1)"},dark:{foreground:{1:"rgb(228,231,231)",2:"rgb(148,158,158)",3:"rgb(110,119,119)"},background:{1:"rgb(20,20,20)",2:"rgb(39,42,42)",3:"rgb(59,64,64)"},overlay:"rgba(255,255,255,0.1)"}}[o];return {"--wcm-color-fg-1":r.foreground[1],"--wcm-color-fg-2":r.foreground[2],"--wcm-color-fg-3":r.foreground[3],"--wcm-color-bg-1":r.background[1],"--wcm-color-bg-2":r.background[2],"--wcm-color-bg-3":r.background[3],"--wcm-color-overlay":r.overlay}}function He(){return {"--wcm-accent-color":"#3396FF","--wcm-accent-fill-color":"#FFFFFF","--wcm-z-index":"89","--wcm-background-color":"#3396FF","--wcm-background-border-radius":"8px","--wcm-container-border-radius":"30px","--wcm-wallet-icon-border-radius":"15px","--wcm-wallet-icon-large-border-radius":"30px","--wcm-wallet-icon-small-border-radius":"7px","--wcm-input-border-radius":"28px","--wcm-button-border-radius":"10px","--wcm-notification-border-radius":"36px","--wcm-secondary-button-border-radius":"28px","--wcm-icon-button-border-radius":"50%","--wcm-button-hover-highlight-border-radius":"10px","--wcm-text-big-bold-size":"20px","--wcm-text-big-bold-weight":"600","--wcm-text-big-bold-line-height":"24px","--wcm-text-big-bold-letter-spacing":"-0.03em","--wcm-text-big-bold-text-transform":"none","--wcm-text-xsmall-bold-size":"10px","--wcm-text-xsmall-bold-weight":"700","--wcm-text-xsmall-bold-line-height":"12px","--wcm-text-xsmall-bold-letter-spacing":"0.02em","--wcm-text-xsmall-bold-text-transform":"uppercase","--wcm-text-xsmall-regular-size":"12px","--wcm-text-xsmall-regular-weight":"600","--wcm-text-xsmall-regular-line-height":"14px","--wcm-text-xsmall-regular-letter-spacing":"-0.03em","--wcm-text-xsmall-regular-text-transform":"none","--wcm-text-small-thin-size":"14px","--wcm-text-small-thin-weight":"500","--wcm-text-small-thin-line-height":"16px","--wcm-text-small-thin-letter-spacing":"-0.03em","--wcm-text-small-thin-text-transform":"none","--wcm-text-small-regular-size":"14px","--wcm-text-small-regular-weight":"600","--wcm-text-small-regular-line-height":"16px","--wcm-text-small-regular-letter-spacing":"-0.03em","--wcm-text-small-regular-text-transform":"none","--wcm-text-medium-regular-size":"16px","--wcm-text-medium-regular-weight":"600","--wcm-text-medium-regular-line-height":"20px","--wcm-text-medium-regular-letter-spacing":"-0.03em","--wcm-text-medium-regular-text-transform":"none","--wcm-font-family":"-apple-system, system-ui, BlinkMacSystemFont, 'Segoe UI', Roboto, Ubuntu, 'Helvetica Neue', sans-serif","--wcm-font-feature-settings":"'tnum' on, 'lnum' on, 'case' on","--wcm-success-color":"rgb(38,181,98)","--wcm-error-color":"rgb(242, 90, 103)","--wcm-overlay-background-color":"rgba(0, 0, 0, 0.3)","--wcm-overlay-backdrop-filter":"none"}}const h={getPreset(e){return He()[e]},setTheme(){const e=document.querySelector(":root"),{themeVariables:o}=ne$1.state;if(e){const r=ve(ve(ve({},rt()),He()),o);Object.entries(r).forEach(([a,t])=>e.style.setProperty(a,t));}},globalCss:i$3`*,::after,::before{margin:0;padding:0;box-sizing:border-box;font-style:normal;text-rendering:optimizeSpeed;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;-webkit-tap-highlight-color:transparent;backface-visibility:hidden}button{cursor:pointer;display:flex;justify-content:center;align-items:center;position:relative;border:none;background-color:transparent;transition:all .2s ease}@media (hover:hover) and (pointer:fine){button:active{transition:all .1s ease;transform:scale(.93)}}button::after{content:'';position:absolute;top:0;bottom:0;left:0;right:0;transition:background-color,.2s ease}button:disabled{cursor:not-allowed}button svg,button wcm-text{position:relative;z-index:1}input{border:none;outline:0;appearance:none}img{display:block}::selection{color:var(--wcm-accent-fill-color);background:var(--wcm-accent-color)}`},at=i$3`button{border-radius:var(--wcm-secondary-button-border-radius);height:28px;padding:0 10px;background-color:var(--wcm-accent-color)}button path{fill:var(--wcm-accent-fill-color)}button::after{border-radius:inherit;border:1px solid var(--wcm-color-overlay)}button:disabled::after{background-color:transparent}.wcm-icon-left svg{margin-right:5px}.wcm-icon-right svg{margin-left:5px}button:active::after{background-color:var(--wcm-color-overlay)}.wcm-ghost,.wcm-ghost:active::after,.wcm-outline{background-color:transparent}.wcm-ghost:active{opacity:.5}@media(hover:hover){button:hover::after{background-color:var(--wcm-color-overlay)}.wcm-ghost:hover::after{background-color:transparent}.wcm-ghost:hover{opacity:.5}}button:disabled{background-color:var(--wcm-color-bg-3);pointer-events:none}.wcm-ghost::after{border-color:transparent}.wcm-ghost path{fill:var(--wcm-color-fg-2)}.wcm-outline path{fill:var(--wcm-accent-color)}.wcm-outline:disabled{background-color:transparent;opacity:.5}`;var lt=Object.defineProperty,it=Object.getOwnPropertyDescriptor,F=(e,o,r,a)=>{for(var t=a>1?void 0:a?it(o,r):o,l=e.length-1,i;l>=0;l--)(i=e[l])&&(t=(a?i(o,r,t):i(t))||t);return a&&t&&lt(o,r,t),t};let T=class extends s{constructor(){super(...arguments),this.disabled=!1,this.iconLeft=void 0,this.iconRight=void 0,this.onClick=()=>null,this.variant="default";}render(){const e={"wcm-icon-left":this.iconLeft!==void 0,"wcm-icon-right":this.iconRight!==void 0,"wcm-ghost":this.variant==="ghost","wcm-outline":this.variant==="outline"};let o$1="inverse";return this.variant==="ghost"&&(o$1="secondary"),this.variant==="outline"&&(o$1="accent"),x`<button class="${o(e)}" ?disabled="${this.disabled}" @click="${this.onClick}">${this.iconLeft}<wcm-text variant="small-regular" color="${o$1}"><slot></slot></wcm-text>${this.iconRight}</button>`}};T.styles=[h.globalCss,at],F([n$1({type:Boolean})],T.prototype,"disabled",2),F([n$1()],T.prototype,"iconLeft",2),F([n$1()],T.prototype,"iconRight",2),F([n$1()],T.prototype,"onClick",2),F([n$1()],T.prototype,"variant",2),T=F([e$2("wcm-button")],T);const nt=i$3`:host{display:inline-block}button{padding:0 15px 1px;height:40px;border-radius:var(--wcm-button-border-radius);color:var(--wcm-accent-fill-color);background-color:var(--wcm-accent-color)}button::after{content:'';top:0;bottom:0;left:0;right:0;position:absolute;background-color:transparent;border-radius:inherit;transition:background-color .2s ease;border:1px solid var(--wcm-color-overlay)}button:active::after{background-color:var(--wcm-color-overlay)}button:disabled{padding-bottom:0;background-color:var(--wcm-color-bg-3);color:var(--wcm-color-fg-3)}.wcm-secondary{color:var(--wcm-accent-color);background-color:transparent}.wcm-secondary::after{display:none}@media(hover:hover){button:hover::after{background-color:var(--wcm-color-overlay)}}`;var ct=Object.defineProperty,st=Object.getOwnPropertyDescriptor,ue=(e,o,r,a)=>{for(var t=a>1?void 0:a?st(o,r):o,l=e.length-1,i;l>=0;l--)(i=e[l])&&(t=(a?i(o,r,t):i(t))||t);return a&&t&&ct(o,r,t),t};let ee=class extends s{constructor(){super(...arguments),this.disabled=!1,this.variant="primary";}render(){const e={"wcm-secondary":this.variant==="secondary"};return x`<button ?disabled="${this.disabled}" class="${o(e)}"><slot></slot></button>`}};ee.styles=[h.globalCss,nt],ue([n$1({type:Boolean})],ee.prototype,"disabled",2),ue([n$1()],ee.prototype,"variant",2),ee=ue([e$2("wcm-button-big")],ee);const dt=i$3`:host{background-color:var(--wcm-color-bg-2);border-top:1px solid var(--wcm-color-bg-3)}div{padding:10px 20px;display:inherit;flex-direction:inherit;align-items:inherit;width:inherit;justify-content:inherit}`;var mt=Object.defineProperty,ht=Object.getOwnPropertyDescriptor,wt=(e,o,r,a)=>{for(var t=a>1?void 0:a?ht(o,r):o,l=e.length-1,i;l>=0;l--)(i=e[l])&&(t=(a?i(o,r,t):i(t))||t);return a&&t&&mt(o,r,t),t};let be=class extends s{render(){return x`<div><slot></slot></div>`}};be.styles=[h.globalCss,dt],be=wt([e$2("wcm-info-footer")],be);const v={CROSS_ICON:b`<svg width="12" height="12" viewBox="0 0 12 12"><path d="M9.94 11A.75.75 0 1 0 11 9.94L7.414 6.353a.5.5 0 0 1 0-.708L11 2.061A.75.75 0 1 0 9.94 1L6.353 4.586a.5.5 0 0 1-.708 0L2.061 1A.75.75 0 0 0 1 2.06l3.586 3.586a.5.5 0 0 1 0 .708L1 9.939A.75.75 0 1 0 2.06 11l3.586-3.586a.5.5 0 0 1 .708 0L9.939 11Z" fill="#fff"/></svg>`,WALLET_CONNECT_LOGO:b`<svg width="178" height="29" viewBox="0 0 178 29" id="wcm-wc-logo"><path d="M10.683 7.926c5.284-5.17 13.85-5.17 19.134 0l.636.623a.652.652 0 0 1 0 .936l-2.176 2.129a.343.343 0 0 1-.478 0l-.875-.857c-3.686-3.607-9.662-3.607-13.348 0l-.937.918a.343.343 0 0 1-.479 0l-2.175-2.13a.652.652 0 0 1 0-.936l.698-.683Zm23.633 4.403 1.935 1.895a.652.652 0 0 1 0 .936l-8.73 8.543a.687.687 0 0 1-.956 0L20.37 17.64a.172.172 0 0 0-.239 0l-6.195 6.063a.687.687 0 0 1-.957 0l-8.73-8.543a.652.652 0 0 1 0-.936l1.936-1.895a.687.687 0 0 1 .957 0l6.196 6.064a.172.172 0 0 0 .239 0l6.195-6.064a.687.687 0 0 1 .957 0l6.196 6.064a.172.172 0 0 0 .24 0l6.195-6.064a.687.687 0 0 1 .956 0ZM48.093 20.948l2.338-9.355c.139-.515.258-1.07.416-1.942.12.872.258 1.427.357 1.942l2.022 9.355h4.181l3.528-13.874h-3.21l-1.943 8.523a24.825 24.825 0 0 0-.456 2.457c-.158-.931-.317-1.625-.495-2.438l-1.883-8.542h-4.201l-2.042 8.542a41.204 41.204 0 0 0-.475 2.438 41.208 41.208 0 0 0-.476-2.438l-1.903-8.542h-3.349l3.508 13.874h4.083ZM63.33 21.304c1.585 0 2.596-.654 3.11-1.605-.059.297-.078.595-.078.892v.357h2.655V15.22c0-2.735-1.248-4.32-4.3-4.32-2.636 0-4.36 1.466-4.52 3.487h2.914c.1-.891.734-1.426 1.705-1.426.911 0 1.407.515 1.407 1.11 0 .435-.258.693-1.03.792l-1.388.159c-2.061.257-3.825 1.01-3.825 3.19 0 1.982 1.645 3.092 3.35 3.092Zm.891-2.041c-.773 0-1.348-.436-1.348-1.19 0-.733.655-1.09 1.645-1.268l.674-.119c.575-.118.892-.218 1.09-.396v.912c0 1.228-.892 2.06-2.06 2.06ZM70.398 7.074v13.874h2.874V7.074h-2.874ZM74.934 7.074v13.874h2.874V7.074h-2.874ZM84.08 21.304c2.735 0 4.5-1.546 4.697-3.567h-2.893c-.139.892-.892 1.387-1.804 1.387-1.228 0-2.12-.99-2.14-2.358h6.897v-.555c0-3.21-1.764-5.312-4.816-5.312-2.933 0-4.994 2.062-4.994 5.173 0 3.37 2.12 5.232 5.053 5.232Zm-2.16-6.421c.119-1.11.932-1.922 2.081-1.922 1.11 0 1.883.772 1.903 1.922H81.92ZM94.92 21.146c.633 0 1.248-.1 1.525-.179v-2.18c-.218.04-.475.06-.693.06-1.05 0-1.427-.595-1.427-1.566v-3.805h2.338v-2.24h-2.338V7.788H91.47v3.448H89.37v2.24h2.1v4.201c0 2.3 1.15 3.469 3.45 3.469ZM104.62 21.304c3.924 0 6.302-2.299 6.599-5.608h-3.111c-.238 1.803-1.506 3.032-3.369 3.032-2.2 0-3.746-1.784-3.746-4.796 0-2.953 1.605-4.638 3.805-4.638 1.883 0 2.953 1.15 3.171 2.834h3.191c-.317-3.448-2.854-5.41-6.342-5.41-3.984 0-7.036 2.695-7.036 7.214 0 4.677 2.676 7.372 6.838 7.372ZM117.449 21.304c2.993 0 5.114-1.882 5.114-5.172 0-3.23-2.121-5.233-5.114-5.233-2.972 0-5.093 2.002-5.093 5.233 0 3.29 2.101 5.172 5.093 5.172Zm0-2.22c-1.327 0-2.18-1.09-2.18-2.952 0-1.903.892-2.973 2.18-2.973 1.308 0 2.2 1.07 2.2 2.973 0 1.862-.872 2.953-2.2 2.953ZM126.569 20.948v-5.689c0-1.208.753-2.1 1.823-2.1 1.011 0 1.606.773 1.606 2.06v5.729h2.873v-6.144c0-2.339-1.229-3.905-3.428-3.905-1.526 0-2.458.734-2.953 1.606a5.31 5.31 0 0 0 .079-.892v-.377h-2.874v9.712h2.874ZM137.464 20.948v-5.689c0-1.208.753-2.1 1.823-2.1 1.011 0 1.606.773 1.606 2.06v5.729h2.873v-6.144c0-2.339-1.228-3.905-3.428-3.905-1.526 0-2.458.734-2.953 1.606a5.31 5.31 0 0 0 .079-.892v-.377h-2.874v9.712h2.874ZM149.949 21.304c2.735 0 4.499-1.546 4.697-3.567h-2.893c-.139.892-.892 1.387-1.804 1.387-1.228 0-2.12-.99-2.14-2.358h6.897v-.555c0-3.21-1.764-5.312-4.816-5.312-2.933 0-4.994 2.062-4.994 5.173 0 3.37 2.12 5.232 5.053 5.232Zm-2.16-6.421c.119-1.11.932-1.922 2.081-1.922 1.11 0 1.883.772 1.903 1.922h-3.984ZM160.876 21.304c3.013 0 4.658-1.645 4.975-4.201h-2.874c-.099 1.07-.713 1.982-2.001 1.982-1.309 0-2.2-1.21-2.2-2.993 0-1.942 1.03-2.933 2.259-2.933 1.209 0 1.803.872 1.883 1.882h2.873c-.218-2.358-1.823-4.142-4.776-4.142-2.874 0-5.153 1.903-5.153 5.193 0 3.25 1.923 5.212 5.014 5.212ZM172.067 21.146c.634 0 1.248-.1 1.526-.179v-2.18c-.218.04-.476.06-.694.06-1.05 0-1.427-.595-1.427-1.566v-3.805h2.339v-2.24h-2.339V7.788h-2.854v3.448h-2.1v2.24h2.1v4.201c0 2.3 1.15 3.469 3.449 3.469Z" fill="#fff"/></svg>`,WALLET_CONNECT_ICON:b`<svg width="28" height="20" viewBox="0 0 28 20"><g clip-path="url(#a)"><path d="M7.386 6.482c3.653-3.576 9.575-3.576 13.228 0l.44.43a.451.451 0 0 1 0 .648L19.55 9.033a.237.237 0 0 1-.33 0l-.606-.592c-2.548-2.496-6.68-2.496-9.228 0l-.648.634a.237.237 0 0 1-.33 0L6.902 7.602a.451.451 0 0 1 0-.647l.483-.473Zm16.338 3.046 1.339 1.31a.451.451 0 0 1 0 .648l-6.035 5.909a.475.475 0 0 1-.662 0L14.083 13.2a.119.119 0 0 0-.166 0l-4.283 4.194a.475.475 0 0 1-.662 0l-6.035-5.91a.451.451 0 0 1 0-.647l1.338-1.31a.475.475 0 0 1 .662 0l4.283 4.194c.046.044.12.044.166 0l4.283-4.194a.475.475 0 0 1 .662 0l4.283 4.194c.046.044.12.044.166 0l4.283-4.194a.475.475 0 0 1 .662 0Z" fill="#000000"/></g><defs><clipPath id="a"><path fill="#ffffff" d="M0 0h28v20H0z"/></clipPath></defs></svg>`,WALLET_CONNECT_ICON_COLORED:b`<svg width="96" height="96" fill="none"><path fill="#fff" d="M25.322 33.597c12.525-12.263 32.83-12.263 45.355 0l1.507 1.476a1.547 1.547 0 0 1 0 2.22l-5.156 5.048a.814.814 0 0 1-1.134 0l-2.074-2.03c-8.737-8.555-22.903-8.555-31.64 0l-2.222 2.175a.814.814 0 0 1-1.134 0l-5.156-5.049a1.547 1.547 0 0 1 0-2.22l1.654-1.62Zm56.019 10.44 4.589 4.494a1.547 1.547 0 0 1 0 2.22l-20.693 20.26a1.628 1.628 0 0 1-2.267 0L48.283 56.632a.407.407 0 0 0-.567 0L33.03 71.012a1.628 1.628 0 0 1-2.268 0L10.07 50.75a1.547 1.547 0 0 1 0-2.22l4.59-4.494a1.628 1.628 0 0 1 2.267 0l14.687 14.38c.156.153.41.153.567 0l14.685-14.38a1.628 1.628 0 0 1 2.268 0l14.687 14.38c.156.153.41.153.567 0l14.686-14.38a1.628 1.628 0 0 1 2.268 0Z"/><path stroke="#000" d="M25.672 33.954c12.33-12.072 32.325-12.072 44.655 0l1.508 1.476a1.047 1.047 0 0 1 0 1.506l-5.157 5.048a.314.314 0 0 1-.434 0l-2.074-2.03c-8.932-8.746-23.409-8.746-32.34 0l-2.222 2.174a.314.314 0 0 1-.434 0l-5.157-5.048a1.047 1.047 0 0 1 0-1.506l1.655-1.62Zm55.319 10.44 4.59 4.494a1.047 1.047 0 0 1 0 1.506l-20.694 20.26a1.128 1.128 0 0 1-1.568 0l-14.686-14.38a.907.907 0 0 0-1.267 0L32.68 70.655a1.128 1.128 0 0 1-1.568 0L10.42 50.394a1.047 1.047 0 0 1 0-1.506l4.59-4.493a1.128 1.128 0 0 1 1.567 0l14.687 14.379a.907.907 0 0 0 1.266 0l-.35-.357.35.357 14.686-14.38a1.128 1.128 0 0 1 1.568 0l14.687 14.38a.907.907 0 0 0 1.267 0l14.686-14.38a1.128 1.128 0 0 1 1.568 0Z"/></svg>`,BACK_ICON:b`<svg width="10" height="18" viewBox="0 0 10 18"><path fill-rule="evenodd" clip-rule="evenodd" d="M8.735.179a.75.75 0 0 1 .087 1.057L2.92 8.192a1.25 1.25 0 0 0 0 1.617l5.902 6.956a.75.75 0 1 1-1.144.97L1.776 10.78a2.75 2.75 0 0 1 0-3.559L7.678.265A.75.75 0 0 1 8.735.18Z" fill="#fff"/></svg>`,COPY_ICON:b`<svg width="24" height="24" fill="none"><path fill="#fff" fill-rule="evenodd" d="M7.01 7.01c.03-1.545.138-2.5.535-3.28A5 5 0 0 1 9.73 1.545C10.8 1 12.2 1 15 1c2.8 0 4.2 0 5.27.545a5 5 0 0 1 2.185 2.185C23 4.8 23 6.2 23 9c0 2.8 0 4.2-.545 5.27a5 5 0 0 1-2.185 2.185c-.78.397-1.735.505-3.28.534l-.001.01c-.03 1.54-.138 2.493-.534 3.27a5 5 0 0 1-2.185 2.186C13.2 23 11.8 23 9 23c-2.8 0-4.2 0-5.27-.545a5 5 0 0 1-2.185-2.185C1 19.2 1 17.8 1 15c0-2.8 0-4.2.545-5.27A5 5 0 0 1 3.73 7.545C4.508 7.149 5.46 7.04 7 7.01h.01ZM15 15.5c-1.425 0-2.403-.001-3.162-.063-.74-.06-1.139-.172-1.427-.319a3.5 3.5 0 0 1-1.53-1.529c-.146-.288-.257-.686-.318-1.427C8.501 11.403 8.5 10.425 8.5 9c0-1.425.001-2.403.063-3.162.06-.74.172-1.139.318-1.427a3.5 3.5 0 0 1 1.53-1.53c.288-.146.686-.257 1.427-.318.759-.062 1.737-.063 3.162-.063 1.425 0 2.403.001 3.162.063.74.06 1.139.172 1.427.318a3.5 3.5 0 0 1 1.53 1.53c.146.288.257.686.318 1.427.062.759.063 1.737.063 3.162 0 1.425-.001 2.403-.063 3.162-.06.74-.172 1.139-.319 1.427a3.5 3.5 0 0 1-1.529 1.53c-.288.146-.686.257-1.427.318-.759.062-1.737.063-3.162.063ZM7 8.511c-.444.009-.825.025-1.162.052-.74.06-1.139.172-1.427.318a3.5 3.5 0 0 0-1.53 1.53c-.146.288-.257.686-.318 1.427-.062.759-.063 1.737-.063 3.162 0 1.425.001 2.403.063 3.162.06.74.172 1.139.318 1.427a3.5 3.5 0 0 0 1.53 1.53c.288.146.686.257 1.427.318.759.062 1.737.063 3.162.063 1.425 0 2.403-.001 3.162-.063.74-.06 1.139-.172 1.427-.319a3.5 3.5 0 0 0 1.53-1.53c.146-.287.257-.685.318-1.426.027-.337.043-.718.052-1.162H15c-2.8 0-4.2 0-5.27-.545a5 5 0 0 1-2.185-2.185C7 13.2 7 11.8 7 9v-.489Z" clip-rule="evenodd"/></svg>`,RETRY_ICON:b`<svg width="15" height="16" viewBox="0 0 15 16"><path d="M6.464 2.03A.75.75 0 0 0 5.403.97L2.08 4.293a1 1 0 0 0 0 1.414L5.403 9.03a.75.75 0 0 0 1.06-1.06L4.672 6.177a.25.25 0 0 1 .177-.427h2.085a4 4 0 1 1-3.93 4.746c-.077-.407-.405-.746-.82-.746-.414 0-.755.338-.7.748a5.501 5.501 0 1 0 5.45-6.248H4.848a.25.25 0 0 1-.177-.427L6.464 2.03Z" fill="#fff"/></svg>`,DESKTOP_ICON:b`<svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M0 5.98c0-1.85 0-2.775.394-3.466a3 3 0 0 1 1.12-1.12C2.204 1 3.13 1 4.98 1h6.04c1.85 0 2.775 0 3.466.394a3 3 0 0 1 1.12 1.12C16 3.204 16 4.13 16 5.98v1.04c0 1.85 0 2.775-.394 3.466a3 3 0 0 1-1.12 1.12C13.796 12 12.87 12 11.02 12H4.98c-1.85 0-2.775 0-3.466-.394a3 3 0 0 1-1.12-1.12C0 9.796 0 8.87 0 7.02V5.98ZM4.98 2.5h6.04c.953 0 1.568.001 2.034.043.446.04.608.108.69.154a1.5 1.5 0 0 1 .559.56c.046.08.114.243.154.69.042.465.043 1.08.043 2.033v1.04c0 .952-.001 1.568-.043 2.034-.04.446-.108.608-.154.69a1.499 1.499 0 0 1-.56.559c-.08.046-.243.114-.69.154-.466.042-1.08.043-2.033.043H4.98c-.952 0-1.568-.001-2.034-.043-.446-.04-.608-.108-.69-.154a1.5 1.5 0 0 1-.559-.56c-.046-.08-.114-.243-.154-.69-.042-.465-.043-1.08-.043-2.033V5.98c0-.952.001-1.568.043-2.034.04-.446.108-.608.154-.69a1.5 1.5 0 0 1 .56-.559c.08-.046.243-.114.69-.154.465-.042 1.08-.043 2.033-.043Z" fill="#fff"/><path d="M4 14.25a.75.75 0 0 1 .75-.75h6.5a.75.75 0 0 1 0 1.5h-6.5a.75.75 0 0 1-.75-.75Z" fill="#fff"/></svg>`,MOBILE_ICON:b`<svg width="16" height="16" viewBox="0 0 16 16"><path d="M6.75 5a1.25 1.25 0 1 0 0-2.5 1.25 1.25 0 0 0 0 2.5Z" fill="#fff"/><path fill-rule="evenodd" clip-rule="evenodd" d="M3 4.98c0-1.85 0-2.775.394-3.466a3 3 0 0 1 1.12-1.12C5.204 0 6.136 0 8 0s2.795 0 3.486.394a3 3 0 0 1 1.12 1.12C13 2.204 13 3.13 13 4.98v6.04c0 1.85 0 2.775-.394 3.466a3 3 0 0 1-1.12 1.12C10.796 16 9.864 16 8 16s-2.795 0-3.486-.394a3 3 0 0 1-1.12-1.12C3 13.796 3 12.87 3 11.02V4.98Zm8.5 0v6.04c0 .953-.001 1.568-.043 2.034-.04.446-.108.608-.154.69a1.499 1.499 0 0 1-.56.559c-.08.045-.242.113-.693.154-.47.042-1.091.043-2.05.043-.959 0-1.58-.001-2.05-.043-.45-.04-.613-.109-.693-.154a1.5 1.5 0 0 1-.56-.56c-.046-.08-.114-.243-.154-.69-.042-.466-.043-1.08-.043-2.033V4.98c0-.952.001-1.568.043-2.034.04-.446.108-.608.154-.69a1.5 1.5 0 0 1 .56-.559c.08-.045.243-.113.693-.154C6.42 1.501 7.041 1.5 8 1.5c.959 0 1.58.001 2.05.043.45.04.613.109.693.154a1.5 1.5 0 0 1 .56.56c.046.08.114.243.154.69.042.465.043 1.08.043 2.033Z" fill="#fff"/></svg>`,ARROW_DOWN_ICON:b`<svg width="14" height="14" viewBox="0 0 14 14"><path d="M2.28 7.47a.75.75 0 0 0-1.06 1.06l5.25 5.25a.75.75 0 0 0 1.06 0l5.25-5.25a.75.75 0 0 0-1.06-1.06l-3.544 3.543a.25.25 0 0 1-.426-.177V.75a.75.75 0 0 0-1.5 0v10.086a.25.25 0 0 1-.427.176L2.28 7.47Z" fill="#fff"/></svg>`,ARROW_UP_RIGHT_ICON:b`<svg width="15" height="14" fill="none"><path d="M4.5 1.75A.75.75 0 0 1 5.25 1H12a1.5 1.5 0 0 1 1.5 1.5v6.75a.75.75 0 0 1-1.5 0V4.164a.25.25 0 0 0-.427-.176L4.061 11.5A.75.75 0 0 1 3 10.44l7.513-7.513a.25.25 0 0 0-.177-.427H5.25a.75.75 0 0 1-.75-.75Z" fill="#fff"/></svg>`,ARROW_RIGHT_ICON:b`<svg width="6" height="14" viewBox="0 0 6 14"><path fill-rule="evenodd" clip-rule="evenodd" d="M2.181 1.099a.75.75 0 0 1 1.024.279l2.433 4.258a2.75 2.75 0 0 1 0 2.729l-2.433 4.257a.75.75 0 1 1-1.303-.744L4.335 7.62a1.25 1.25 0 0 0 0-1.24L1.902 2.122a.75.75 0 0 1 .28-1.023Z" fill="#fff"/></svg>`,QRCODE_ICON:b`<svg width="25" height="24" viewBox="0 0 25 24"><path d="M23.748 9a.748.748 0 0 0 .748-.752c-.018-2.596-.128-4.07-.784-5.22a6 6 0 0 0-2.24-2.24c-1.15-.656-2.624-.766-5.22-.784a.748.748 0 0 0-.752.748c0 .414.335.749.748.752 1.015.007 1.82.028 2.494.088.995.09 1.561.256 1.988.5.7.398 1.28.978 1.679 1.678.243.427.41.993.498 1.988.061.675.082 1.479.09 2.493a.753.753 0 0 0 .75.749ZM3.527.788C4.677.132 6.152.022 8.747.004A.748.748 0 0 1 9.5.752a.753.753 0 0 1-.749.752c-1.014.007-1.818.028-2.493.088-.995.09-1.561.256-1.988.5-.7.398-1.28.978-1.679 1.678-.243.427-.41.993-.499 1.988-.06.675-.081 1.479-.088 2.493A.753.753 0 0 1 1.252 9a.748.748 0 0 1-.748-.752c.018-2.596.128-4.07.784-5.22a6 6 0 0 1 2.24-2.24ZM1.252 15a.748.748 0 0 0-.748.752c.018 2.596.128 4.07.784 5.22a6 6 0 0 0 2.24 2.24c1.15.656 2.624.766 5.22.784a.748.748 0 0 0 .752-.748.753.753 0 0 0-.749-.752c-1.014-.007-1.818-.028-2.493-.089-.995-.089-1.561-.255-1.988-.498a4.5 4.5 0 0 1-1.679-1.68c-.243-.426-.41-.992-.499-1.987-.06-.675-.081-1.479-.088-2.493A.753.753 0 0 0 1.252 15ZM22.996 15.749a.753.753 0 0 1 .752-.749c.415 0 .751.338.748.752-.018 2.596-.128 4.07-.784 5.22a6 6 0 0 1-2.24 2.24c-1.15.656-2.624.766-5.22.784a.748.748 0 0 1-.752-.748c0-.414.335-.749.748-.752 1.015-.007 1.82-.028 2.494-.089.995-.089 1.561-.255 1.988-.498a4.5 4.5 0 0 0 1.679-1.68c.243-.426.41-.992.498-1.987.061-.675.082-1.479.09-2.493Z" fill="#fff"/><path fill-rule="evenodd" clip-rule="evenodd" d="M7 4a2.5 2.5 0 0 0-2.5 2.5v2A2.5 2.5 0 0 0 7 11h2a2.5 2.5 0 0 0 2.5-2.5v-2A2.5 2.5 0 0 0 9 4H7Zm2 1.5H7a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1v-2a1 1 0 0 0-1-1ZM13.5 6.5A2.5 2.5 0 0 1 16 4h2a2.5 2.5 0 0 1 2.5 2.5v2A2.5 2.5 0 0 1 18 11h-2a2.5 2.5 0 0 1-2.5-2.5v-2Zm2.5-1h2a1 1 0 0 1 1 1v2a1 1 0 0 1-1 1h-2a1 1 0 0 1-1-1v-2a1 1 0 0 1 1-1ZM7 13a2.5 2.5 0 0 0-2.5 2.5v2A2.5 2.5 0 0 0 7 20h2a2.5 2.5 0 0 0 2.5-2.5v-2A2.5 2.5 0 0 0 9 13H7Zm2 1.5H7a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1v-2a1 1 0 0 0-1-1Z" fill="#fff"/><path d="M13.5 15.5c0-.465 0-.697.038-.89a2 2 0 0 1 1.572-1.572C15.303 13 15.535 13 16 13v2.5h-2.5ZM18 13c.465 0 .697 0 .89.038a2 2 0 0 1 1.572 1.572c.038.193.038.425.038.89H18V13ZM18 17.5h2.5c0 .465 0 .697-.038.89a2 2 0 0 1-1.572 1.572C18.697 20 18.465 20 18 20v-2.5ZM13.5 17.5H16V20c-.465 0-.697 0-.89-.038a2 2 0 0 1-1.572-1.572c-.038-.193-.038-.425-.038-.89Z" fill="#fff"/></svg>`,SCAN_ICON:b`<svg width="16" height="16" fill="none"><path fill="#fff" d="M10 15.216c0 .422.347.763.768.74 1.202-.064 2.025-.222 2.71-.613a5.001 5.001 0 0 0 1.865-1.866c.39-.684.549-1.507.613-2.709a.735.735 0 0 0-.74-.768.768.768 0 0 0-.76.732c-.009.157-.02.306-.032.447-.073.812-.206 1.244-.384 1.555-.31.545-.761.996-1.306 1.306-.311.178-.743.311-1.555.384-.141.013-.29.023-.447.032a.768.768 0 0 0-.732.76ZM10 .784c0 .407.325.737.732.76.157.009.306.02.447.032.812.073 1.244.206 1.555.384a3.5 3.5 0 0 1 1.306 1.306c.178.311.311.743.384 1.555.013.142.023.29.032.447a.768.768 0 0 0 .76.732.734.734 0 0 0 .74-.768c-.064-1.202-.222-2.025-.613-2.71A5 5 0 0 0 13.477.658c-.684-.39-1.507-.549-2.709-.613a.735.735 0 0 0-.768.74ZM5.232.044A.735.735 0 0 1 6 .784a.768.768 0 0 1-.732.76c-.157.009-.305.02-.447.032-.812.073-1.244.206-1.555.384A3.5 3.5 0 0 0 1.96 3.266c-.178.311-.311.743-.384 1.555-.013.142-.023.29-.032.447A.768.768 0 0 1 .784 6a.735.735 0 0 1-.74-.768c.064-1.202.222-2.025.613-2.71A5 5 0 0 1 2.523.658C3.207.267 4.03.108 5.233.044ZM5.268 14.456a.768.768 0 0 1 .732.76.734.734 0 0 1-.768.74c-1.202-.064-2.025-.222-2.71-.613a5 5 0 0 1-1.865-1.866c-.39-.684-.549-1.507-.613-2.709A.735.735 0 0 1 .784 10c.407 0 .737.325.76.732.009.157.02.306.032.447.073.812.206 1.244.384 1.555a3.5 3.5 0 0 0 1.306 1.306c.311.178.743.311 1.555.384.142.013.29.023.447.032Z"/></svg>`,CHECKMARK_ICON:b`<svg width="13" height="12" viewBox="0 0 13 12"><path fill-rule="evenodd" clip-rule="evenodd" d="M12.155.132a.75.75 0 0 1 .232 1.035L5.821 11.535a1 1 0 0 1-1.626.09L.665 7.21a.75.75 0 1 1 1.17-.937L4.71 9.867a.25.25 0 0 0 .406-.023L11.12.364a.75.75 0 0 1 1.035-.232Z" fill="#fff"/></svg>`,SEARCH_ICON:b`<svg width="20" height="21"><path fill-rule="evenodd" clip-rule="evenodd" d="M12.432 13.992c-.354-.353-.91-.382-1.35-.146a5.5 5.5 0 1 1 2.265-2.265c-.237.441-.208.997.145 1.35l3.296 3.296a.75.75 0 1 1-1.06 1.061l-3.296-3.296Zm.06-5a4 4 0 1 1-8 0 4 4 0 0 1 8 0Z" fill="#949E9E"/></svg>`,WALLET_PLACEHOLDER:b`<svg width="60" height="60" fill="none" viewBox="0 0 60 60"><g clip-path="url(#q)"><path id="wallet-placeholder-fill" fill="#fff" d="M0 24.9c0-9.251 0-13.877 1.97-17.332a15 15 0 0 1 5.598-5.597C11.023 0 15.648 0 24.9 0h10.2c9.252 0 13.877 0 17.332 1.97a15 15 0 0 1 5.597 5.598C60 11.023 60 15.648 60 24.9v10.2c0 9.252 0 13.877-1.97 17.332a15.001 15.001 0 0 1-5.598 5.597C48.977 60 44.352 60 35.1 60H24.9c-9.251 0-13.877 0-17.332-1.97a15 15 0 0 1-5.597-5.598C0 48.977 0 44.352 0 35.1V24.9Z"/><path id="wallet-placeholder-dash" stroke="#000" stroke-dasharray="4 4" stroke-width="1.5" d="M.04 41.708a231.598 231.598 0 0 1-.039-4.403l.75-.001L.75 35.1v-2.55H0v-5.1h.75V24.9l.001-2.204h-.75c.003-1.617.011-3.077.039-4.404l.75.016c.034-1.65.099-3.08.218-4.343l-.746-.07c.158-1.678.412-3.083.82-4.316l.713.236c.224-.679.497-1.296.827-1.875a14.25 14.25 0 0 1 1.05-1.585L3.076 5.9A15 15 0 0 1 5.9 3.076l.455.596a14.25 14.25 0 0 1 1.585-1.05c.579-.33 1.196-.603 1.875-.827l-.236-.712C10.812.674 12.217.42 13.895.262l.07.746C15.23.89 16.66.824 18.308.79l-.016-.75C19.62.012 21.08.004 22.695.001l.001.75L24.9.75h2.55V0h5.1v.75h2.55l2.204.001v-.75c1.617.003 3.077.011 4.404.039l-.016.75c1.65.034 3.08.099 4.343.218l.07-.746c1.678.158 3.083.412 4.316.82l-.236.713c.679.224 1.296.497 1.875.827a14.24 14.24 0 0 1 1.585 1.05l.455-.596A14.999 14.999 0 0 1 56.924 5.9l-.596.455c.384.502.735 1.032 1.05 1.585.33.579.602 1.196.827 1.875l.712-.236c.409 1.233.663 2.638.822 4.316l-.747.07c.119 1.264.184 2.694.218 4.343l.75-.016c.028 1.327.036 2.787.039 4.403l-.75.001.001 2.204v2.55H60v5.1h-.75v2.55l-.001 2.204h.75a231.431 231.431 0 0 1-.039 4.404l-.75-.016c-.034 1.65-.099 3.08-.218 4.343l.747.07c-.159 1.678-.413 3.083-.822 4.316l-.712-.236a10.255 10.255 0 0 1-.827 1.875 14.242 14.242 0 0 1-1.05 1.585l.596.455a14.997 14.997 0 0 1-2.824 2.824l-.455-.596c-.502.384-1.032.735-1.585 1.05-.579.33-1.196.602-1.875.827l.236.712c-1.233.409-2.638.663-4.316.822l-.07-.747c-1.264.119-2.694.184-4.343.218l.016.75c-1.327.028-2.787.036-4.403.039l-.001-.75-2.204.001h-2.55V60h-5.1v-.75H24.9l-2.204-.001v.75a231.431 231.431 0 0 1-4.404-.039l.016-.75c-1.65-.034-3.08-.099-4.343-.218l-.07.747c-1.678-.159-3.083-.413-4.316-.822l.236-.712a10.258 10.258 0 0 1-1.875-.827 14.252 14.252 0 0 1-1.585-1.05l-.455.596A14.999 14.999 0 0 1 3.076 54.1l.596-.455a14.24 14.24 0 0 1-1.05-1.585 10.259 10.259 0 0 1-.827-1.875l-.712.236C.674 49.188.42 47.783.262 46.105l.746-.07C.89 44.77.824 43.34.79 41.692l-.75.016Z"/><path fill="#fff" fill-rule="evenodd" d="M35.643 32.145c-.297-.743-.445-1.114-.401-1.275a.42.42 0 0 1 .182-.27c.134-.1.463-.1 1.123-.1.742 0 1.499.046 2.236-.05a6 6 0 0 0 5.166-5.166c.051-.39.051-.855.051-1.784 0-.928 0-1.393-.051-1.783a6 6 0 0 0-5.166-5.165c-.39-.052-.854-.052-1.783-.052h-7.72c-4.934 0-7.401 0-9.244 1.051a8 8 0 0 0-2.985 2.986C16.057 22.28 16.003 24.58 16 29 15.998 31.075 16 33.15 16 35.224A7.778 7.778 0 0 0 23.778 43H28.5c1.394 0 2.09 0 2.67-.116a6 6 0 0 0 4.715-4.714c.115-.58.115-1.301.115-2.744 0-1.31 0-1.964-.114-2.49a4.998 4.998 0 0 0-.243-.792Z" clip-rule="evenodd"/><path fill="#9EA9A9" fill-rule="evenodd" d="M37 18h-7.72c-2.494 0-4.266.002-5.647.126-1.361.122-2.197.354-2.854.728a6.5 6.5 0 0 0-2.425 2.426c-.375.657-.607 1.492-.729 2.853-.11 1.233-.123 2.777-.125 4.867 0 .7 0 1.05.097 1.181.096.13.182.181.343.2.163.02.518-.18 1.229-.581a6.195 6.195 0 0 1 3.053-.8H37c.977 0 1.32-.003 1.587-.038a4.5 4.5 0 0 0 3.874-3.874c.036-.268.039-.611.039-1.588 0-.976-.003-1.319-.038-1.587a4.5 4.5 0 0 0-3.875-3.874C38.32 18.004 37.977 18 37 18Zm-7.364 12.5h-7.414a4.722 4.722 0 0 0-4.722 4.723 6.278 6.278 0 0 0 6.278 6.278H28.5c1.466 0 1.98-.008 2.378-.087a4.5 4.5 0 0 0 3.535-3.536c.08-.397.087-.933.087-2.451 0-1.391-.009-1.843-.08-2.17a3.5 3.5 0 0 0-2.676-2.676c-.328-.072-.762-.08-2.108-.08Z" clip-rule="evenodd"/></g><defs><clipPath id="q"><path fill="#fff" d="M0 0h60v60H0z"/></clipPath></defs></svg>`,GLOBE_ICON:b`<svg width="16" height="16" fill="none" viewBox="0 0 16 16"><path fill="#fff" fill-rule="evenodd" d="M15.5 8a7.5 7.5 0 1 1-15 0 7.5 7.5 0 0 1 15 0Zm-2.113.75c.301 0 .535.264.47.558a6.01 6.01 0 0 1-2.867 3.896c-.203.116-.42-.103-.334-.32.409-1.018.691-2.274.797-3.657a.512.512 0 0 1 .507-.477h1.427Zm.47-2.058c.065.294-.169.558-.47.558H11.96a.512.512 0 0 1-.507-.477c-.106-1.383-.389-2.638-.797-3.656-.087-.217.13-.437.333-.32a6.01 6.01 0 0 1 2.868 3.895Zm-4.402.558c.286 0 .515-.24.49-.525-.121-1.361-.429-2.534-.83-3.393-.279-.6-.549-.93-.753-1.112a.535.535 0 0 0-.724 0c-.204.182-.474.513-.754 1.112-.4.859-.708 2.032-.828 3.393a.486.486 0 0 0 .49.525h2.909Zm-5.415 0c.267 0 .486-.21.507-.477.106-1.383.389-2.638.797-3.656.087-.217-.13-.437-.333-.32a6.01 6.01 0 0 0-2.868 3.895c-.065.294.169.558.47.558H4.04ZM2.143 9.308c-.065-.294.169-.558.47-.558H4.04c.267 0 .486.21.507.477.106 1.383.389 2.639.797 3.657.087.217-.13.436-.333.32a6.01 6.01 0 0 1-2.868-3.896Zm3.913-.033a.486.486 0 0 1 .49-.525h2.909c.286 0 .515.24.49.525-.121 1.361-.428 2.535-.83 3.394-.279.6-.549.93-.753 1.112a.535.535 0 0 1-.724 0c-.204-.182-.474-.513-.754-1.112-.4-.859-.708-2.033-.828-3.394Z" clip-rule="evenodd"/></svg>`},pt=i$3`.wcm-toolbar-placeholder{top:0;bottom:0;left:0;right:0;width:100%;position:absolute;display:block;pointer-events:none;height:100px;border-radius:calc(var(--wcm-background-border-radius) * .9);background-color:var(--wcm-background-color);background-position:center;background-size:cover}.wcm-toolbar{height:38px;display:flex;position:relative;margin:5px 15px 5px 5px;justify-content:space-between;align-items:center}.wcm-toolbar img,.wcm-toolbar svg{height:28px;object-position:left center;object-fit:contain}#wcm-wc-logo path{fill:var(--wcm-accent-fill-color)}button{width:28px;height:28px;border-radius:var(--wcm-icon-button-border-radius);border:0;display:flex;justify-content:center;align-items:center;cursor:pointer;background-color:var(--wcm-color-bg-1);box-shadow:0 0 0 1px var(--wcm-color-overlay)}button:active{background-color:var(--wcm-color-bg-2)}button svg{display:block;object-position:center}button path{fill:var(--wcm-color-fg-1)}.wcm-toolbar div{display:flex}@media(hover:hover){button:hover{background-color:var(--wcm-color-bg-2)}}`;var gt=Object.defineProperty,vt=Object.getOwnPropertyDescriptor,ut=(e,o,r,a)=>{for(var t=a>1?void 0:a?vt(o,r):o,l=e.length-1,i;l>=0;l--)(i=e[l])&&(t=(a?i(o,r,t):i(t))||t);return a&&t&&gt(o,r,t),t};let fe=class extends s{render(){return x`<div class="wcm-toolbar-placeholder"></div><div class="wcm-toolbar">${v.WALLET_CONNECT_LOGO} <button @click="${se$1.close}">${v.CROSS_ICON}</button></div>`}};fe.styles=[h.globalCss,pt],fe=ut([e$2("wcm-modal-backcard")],fe);const bt=i$3`main{padding:20px;padding-top:0;width:100%}`;var ft=Object.defineProperty,xt=Object.getOwnPropertyDescriptor,yt=(e,o,r,a)=>{for(var t=a>1?void 0:a?xt(o,r):o,l=e.length-1,i;l>=0;l--)(i=e[l])&&(t=(a?i(o,r,t):i(t))||t);return a&&t&&ft(o,r,t),t};let xe=class extends s{render(){return x`<main><slot></slot></main>`}};xe.styles=[h.globalCss,bt],xe=yt([e$2("wcm-modal-content")],xe);const $t=i$3`footer{padding:10px;display:flex;flex-direction:column;align-items:inherit;justify-content:inherit;border-top:1px solid var(--wcm-color-bg-2)}`;var Ct=Object.defineProperty,kt=Object.getOwnPropertyDescriptor,Ot=(e,o,r,a)=>{for(var t=a>1?void 0:a?kt(o,r):o,l=e.length-1,i;l>=0;l--)(i=e[l])&&(t=(a?i(o,r,t):i(t))||t);return a&&t&&Ct(o,r,t),t};let ye=class extends s{render(){return x`<footer><slot></slot></footer>`}};ye.styles=[h.globalCss,$t],ye=Ot([e$2("wcm-modal-footer")],ye);const Wt=i$3`header{display:flex;justify-content:center;align-items:center;padding:20px;position:relative}.wcm-border{border-bottom:1px solid var(--wcm-color-bg-2);margin-bottom:20px}header button{padding:15px 20px}header button:active{opacity:.5}@media(hover:hover){header button:hover{opacity:.5}}.wcm-back-btn{position:absolute;left:0}.wcm-action-btn{position:absolute;right:0}path{fill:var(--wcm-accent-color)}`;var It=Object.defineProperty,Et=Object.getOwnPropertyDescriptor,te=(e,o,r,a)=>{for(var t=a>1?void 0:a?Et(o,r):o,l=e.length-1,i;l>=0;l--)(i=e[l])&&(t=(a?i(o,r,t):i(t))||t);return a&&t&&It(o,r,t),t};let S=class extends s{constructor(){super(...arguments),this.title="",this.onAction=void 0,this.actionIcon=void 0,this.border=!1;}backBtnTemplate(){return x`<button class="wcm-back-btn" @click="${T$3.goBack}">${v.BACK_ICON}</button>`}actionBtnTemplate(){return x`<button class="wcm-action-btn" @click="${this.onAction}">${this.actionIcon}</button>`}render(){const e={"wcm-border":this.border},o$1=T$3.state.history.length>1,r=this.title?x`<wcm-text variant="big-bold">${this.title}</wcm-text>`:x`<slot></slot>`;return x`<header class="${o(e)}">${o$1?this.backBtnTemplate():null} ${r} ${this.onAction?this.actionBtnTemplate():null}</header>`}};S.styles=[h.globalCss,Wt],te([n$1()],S.prototype,"title",2),te([n$1()],S.prototype,"onAction",2),te([n$1()],S.prototype,"actionIcon",2),te([n$1({type:Boolean})],S.prototype,"border",2),S=te([e$2("wcm-modal-header")],S);const c={MOBILE_BREAKPOINT:600,WCM_RECENT_WALLET_DATA:"WCM_RECENT_WALLET_DATA",EXPLORER_WALLET_URL:"https://explorer.walletconnect.com/?type=wallet",getShadowRootElement(e,o){const r=e.renderRoot.querySelector(o);if(!r)throw new Error(`${o} not found`);return r},getWalletIcon({id:e,image_id:o}){const{walletImages:r}=y$3.state;return r!=null&&r[e]?r[e]:o?te$1.getWalletImageUrl(o):""},getWalletName(e,o=!1){return o&&e.length>8?`${e.substring(0,8)}..`:e},isMobileAnimation(){return window.innerWidth<=c.MOBILE_BREAKPOINT},async preloadImage(e){const o=new Promise((r,a)=>{const t=new Image;t.onload=r,t.onerror=a,t.crossOrigin="anonymous",t.src=e;});return Promise.race([o,a$4.wait(3e3)])},getErrorMessage(e){return e instanceof Error?e.message:"Unknown Error"},debounce(e,o=500){let r;return (...a)=>{function t(){e(...a);}r&&clearTimeout(r),r=setTimeout(t,o);}},handleMobileLinking(e){const{walletConnectUri:o}=p$3.state,{mobile:r,name:a}=e,t=r?.native,l=r?.universal;c.setRecentWallet(e);function i(s){let $="";t?$=a$4.formatUniversalUrl(t,s,a):l&&($=a$4.formatNativeUrl(l,s,a)),a$4.openHref($,"_self");}o&&i(o);},handleAndroidLinking(){const{walletConnectUri:e}=p$3.state;e&&(a$4.setWalletConnectAndroidDeepLink(e),a$4.openHref(e,"_self"));},async handleUriCopy(){const{walletConnectUri:e}=p$3.state;if(e)try{await navigator.clipboard.writeText(e),oe$1.openToast("Link copied","success");}catch{oe$1.openToast("Failed to copy","error");}},getCustomImageUrls(){const{walletImages:e}=y$3.state,o=Object.values(e??{});return Object.values(o)},truncate(e,o=8){return e.length<=o?e:`${e.substring(0,4)}...${e.substring(e.length-4)}`},setRecentWallet(e){try{localStorage.setItem(c.WCM_RECENT_WALLET_DATA,JSON.stringify(e));}catch{console.info("Unable to set recent wallet");}},getRecentWallet(){try{const e=localStorage.getItem(c.WCM_RECENT_WALLET_DATA);return e?JSON.parse(e):void 0}catch{console.info("Unable to get recent wallet");}},caseSafeIncludes(e,o){return e.toUpperCase().includes(o.toUpperCase())},openWalletExplorerUrl(){a$4.openHref(c.EXPLORER_WALLET_URL,"_blank");},getCachedRouterWalletPlatforms(){const{desktop:e,mobile:o}=a$4.getWalletRouterData(),r=Boolean(e?.native),a=Boolean(e?.universal),t=Boolean(o?.native)||Boolean(o?.universal);return {isDesktop:r,isMobile:t,isWeb:a}},goToConnectingView(e){T$3.setData({Wallet:e});const o=a$4.isMobile(),{isDesktop:r,isWeb:a,isMobile:t}=c.getCachedRouterWalletPlatforms();o?t?T$3.push("MobileConnecting"):a?T$3.push("WebConnecting"):T$3.push("InstallWallet"):r?T$3.push("DesktopConnecting"):a?T$3.push("WebConnecting"):t?T$3.push("MobileQrcodeConnecting"):T$3.push("InstallWallet");}},Mt=i$3`.wcm-router{overflow:hidden;will-change:transform}.wcm-content{display:flex;flex-direction:column}`;var Lt=Object.defineProperty,Rt=Object.getOwnPropertyDescriptor,$e=(e,o,r,a)=>{for(var t=a>1?void 0:a?Rt(o,r):o,l=e.length-1,i;l>=0;l--)(i=e[l])&&(t=(a?i(o,r,t):i(t))||t);return a&&t&&Lt(o,r,t),t};let oe=class extends s{constructor(){super(),this.view=T$3.state.view,this.prevView=T$3.state.view,this.unsubscribe=void 0,this.oldHeight="0px",this.resizeObserver=void 0,this.unsubscribe=T$3.subscribe(e=>{this.view!==e.view&&this.onChangeRoute();});}firstUpdated(){this.resizeObserver=new ResizeObserver(([e])=>{const o=`${e.contentRect.height}px`;this.oldHeight!=="0px"&&animate(this.routerEl,{height:[this.oldHeight,o]},{duration:.2}),this.oldHeight=o;}),this.resizeObserver.observe(this.contentEl);}disconnectedCallback(){var e,o;(e=this.unsubscribe)==null||e.call(this),(o=this.resizeObserver)==null||o.disconnect();}get routerEl(){return c.getShadowRootElement(this,".wcm-router")}get contentEl(){return c.getShadowRootElement(this,".wcm-content")}viewTemplate(){switch(this.view){case"ConnectWallet":return x`<wcm-connect-wallet-view></wcm-connect-wallet-view>`;case"DesktopConnecting":return x`<wcm-desktop-connecting-view></wcm-desktop-connecting-view>`;case"MobileConnecting":return x`<wcm-mobile-connecting-view></wcm-mobile-connecting-view>`;case"WebConnecting":return x`<wcm-web-connecting-view></wcm-web-connecting-view>`;case"MobileQrcodeConnecting":return x`<wcm-mobile-qr-connecting-view></wcm-mobile-qr-connecting-view>`;case"WalletExplorer":return x`<wcm-wallet-explorer-view></wcm-wallet-explorer-view>`;case"Qrcode":return x`<wcm-qrcode-view></wcm-qrcode-view>`;case"InstallWallet":return x`<wcm-install-wallet-view></wcm-install-wallet-view>`;default:return x`<div>Not Found</div>`}}async onChangeRoute(){await animate(this.routerEl,{opacity:[1,0],scale:[1,1.02]},{duration:.15,delay:.1}).finished,this.view=T$3.state.view,animate(this.routerEl,{opacity:[0,1],scale:[.99,1]},{duration:.37,delay:.05});}render(){return x`<div class="wcm-router"><div class="wcm-content">${this.viewTemplate()}</div></div>`}};oe.styles=[h.globalCss,Mt],$e([t$1()],oe.prototype,"view",2),$e([t$1()],oe.prototype,"prevView",2),oe=$e([e$2("wcm-modal-router")],oe);const At=i$3`div{height:36px;width:max-content;display:flex;justify-content:center;align-items:center;padding:9px 15px 11px;position:absolute;top:12px;box-shadow:0 6px 14px -6px rgba(10,16,31,.3),0 10px 32px -4px rgba(10,16,31,.15);z-index:2;left:50%;transform:translateX(-50%);pointer-events:none;backdrop-filter:blur(20px) saturate(1.8);-webkit-backdrop-filter:blur(20px) saturate(1.8);border-radius:var(--wcm-notification-border-radius);border:1px solid var(--wcm-color-overlay);background-color:var(--wcm-color-overlay)}svg{margin-right:5px}@-moz-document url-prefix(){div{background-color:var(--wcm-color-bg-3)}}.wcm-success path{fill:var(--wcm-accent-color)}.wcm-error path{fill:var(--wcm-error-color)}`;var Pt=Object.defineProperty,Tt=Object.getOwnPropertyDescriptor,ze=(e,o,r,a)=>{for(var t=a>1?void 0:a?Tt(o,r):o,l=e.length-1,i;l>=0;l--)(i=e[l])&&(t=(a?i(o,r,t):i(t))||t);return a&&t&&Pt(o,r,t),t};let ne=class extends s{constructor(){super(),this.open=!1,this.unsubscribe=void 0,this.timeout=void 0,this.unsubscribe=oe$1.subscribe(e=>{e.open?(this.open=!0,this.timeout=setTimeout(()=>oe$1.closeToast(),2200)):(this.open=!1,clearTimeout(this.timeout));});}disconnectedCallback(){var e;(e=this.unsubscribe)==null||e.call(this),clearTimeout(this.timeout),oe$1.closeToast();}render(){const{message:e,variant:o$1}=oe$1.state,r={"wcm-success":o$1==="success","wcm-error":o$1==="error"};return this.open?x`<div class="${o(r)}">${o$1==="success"?v.CHECKMARK_ICON:null} ${o$1==="error"?v.CROSS_ICON:null}<wcm-text variant="small-regular">${e}</wcm-text></div>`:null}};ne.styles=[h.globalCss,At],ze([t$1()],ne.prototype,"open",2),ne=ze([e$2("wcm-modal-toast")],ne);const jt=.1,Ve=2.5,A=7;function Ce(e,o,r){return e===o?!1:(e-o<0?o-e:e-o)<=r+jt}function _t(e,o){const r=Array.prototype.slice.call(browser$2.create(e,{errorCorrectionLevel:o}).modules.data,0),a=Math.sqrt(r.length);return r.reduce((t,l,i)=>(i%a===0?t.push([l]):t[t.length-1].push(l))&&t,[])}const Dt={generate(e,o,r){const a="#141414",t="#ffffff",l=[],i=_t(e,"Q"),s=o/i.length,$=[{x:0,y:0},{x:1,y:0},{x:0,y:1}];$.forEach(({x:y,y:u})=>{const O=(i.length-A)*s*y,b$1=(i.length-A)*s*u,E=.45;for(let M=0;M<$.length;M+=1){const V=s*(A-M*2);l.push(b`<rect fill="${M%2===0?a:t}" height="${V}" rx="${V*E}" ry="${V*E}" width="${V}" x="${O+s*M}" y="${b$1+s*M}">`);}});const f=Math.floor((r+25)/s),Ne=i.length/2-f/2,Ze=i.length/2+f/2-1,Se=[];i.forEach((y,u)=>{y.forEach((O,b)=>{if(i[u][b]&&!(u<A&&b<A||u>i.length-(A+1)&&b<A||u<A&&b>i.length-(A+1))&&!(u>Ne&&u<Ze&&b>Ne&&b<Ze)){const E=u*s+s/2,M=b*s+s/2;Se.push([E,M]);}});});const J={};return Se.forEach(([y,u])=>{J[y]?J[y].push(u):J[y]=[u];}),Object.entries(J).map(([y,u])=>{const O=u.filter(b=>u.every(E=>!Ce(b,E,s)));return [Number(y),O]}).forEach(([y,u])=>{u.forEach(O=>{l.push(b`<circle cx="${y}" cy="${O}" fill="${a}" r="${s/Ve}">`);});}),Object.entries(J).filter(([y,u])=>u.length>1).map(([y,u])=>{const O=u.filter(b=>u.some(E=>Ce(b,E,s)));return [Number(y),O]}).map(([y,u])=>{u.sort((b,E)=>b<E?-1:1);const O=[];for(const b of u){const E=O.find(M=>M.some(V=>Ce(b,V,s)));E?E.push(b):O.push([b]);}return [y,O.map(b=>[b[0],b[b.length-1]])]}).forEach(([y,u])=>{u.forEach(([O,b$1])=>{l.push(b`<line x1="${y}" x2="${y}" y1="${O}" y2="${b$1}" stroke="${a}" stroke-width="${s/(Ve/2)}" stroke-linecap="round">`);});}),l}},Nt=i$3`@keyframes fadeIn{0%{opacity:0}100%{opacity:1}}div{position:relative;user-select:none;display:block;overflow:hidden;aspect-ratio:1/1;animation:fadeIn ease .2s}.wcm-dark{background-color:#fff;border-radius:var(--wcm-container-border-radius);padding:18px;box-shadow:0 2px 5px #000}svg:first-child,wcm-wallet-image{position:absolute;top:50%;left:50%;transform:translateY(-50%) translateX(-50%)}wcm-wallet-image{transform:translateY(-50%) translateX(-50%)}wcm-wallet-image{width:25%;height:25%;border-radius:var(--wcm-wallet-icon-border-radius)}svg:first-child{transform:translateY(-50%) translateX(-50%) scale(.9)}svg:first-child path:first-child{fill:var(--wcm-accent-color)}svg:first-child path:last-child{stroke:var(--wcm-color-overlay)}`;var Zt=Object.defineProperty,St=Object.getOwnPropertyDescriptor,q=(e,o,r,a)=>{for(var t=a>1?void 0:a?St(o,r):o,l=e.length-1,i;l>=0;l--)(i=e[l])&&(t=(a?i(o,r,t):i(t))||t);return a&&t&&Zt(o,r,t),t};let j=class extends s{constructor(){super(...arguments),this.uri="",this.size=0,this.imageId=void 0,this.walletId=void 0,this.imageUrl=void 0;}svgTemplate(){const e=ne$1.state.themeMode==="light"?this.size:this.size-36;return b`<svg height="${e}" width="${e}">${Dt.generate(this.uri,e,e/4)}</svg>`}render(){const e={"wcm-dark":ne$1.state.themeMode==="dark"};return x`<div style="${`width: ${this.size}px`}" class="${o(e)}">${this.walletId||this.imageUrl?x`<wcm-wallet-image walletId="${l(this.walletId)}" imageId="${l(this.imageId)}" imageUrl="${l(this.imageUrl)}"></wcm-wallet-image>`:v.WALLET_CONNECT_ICON_COLORED} ${this.svgTemplate()}</div>`}};j.styles=[h.globalCss,Nt],q([n$1()],j.prototype,"uri",2),q([n$1({type:Number})],j.prototype,"size",2),q([n$1()],j.prototype,"imageId",2),q([n$1()],j.prototype,"walletId",2),q([n$1()],j.prototype,"imageUrl",2),j=q([e$2("wcm-qrcode")],j);const Bt=i$3`:host{position:relative;height:28px;width:80%}input{width:100%;height:100%;line-height:28px!important;border-radius:var(--wcm-input-border-radius);font-style:normal;font-family:-apple-system,system-ui,BlinkMacSystemFont,'Segoe UI',Roboto,Ubuntu,'Helvetica Neue',sans-serif;font-feature-settings:'case' on;font-weight:500;font-size:16px;letter-spacing:-.03em;padding:0 10px 0 34px;transition:.2s all ease;color:var(--wcm-color-fg-1);background-color:var(--wcm-color-bg-3);box-shadow:inset 0 0 0 1px var(--wcm-color-overlay);caret-color:var(--wcm-accent-color)}input::placeholder{color:var(--wcm-color-fg-2)}svg{left:10px;top:4px;pointer-events:none;position:absolute;width:20px;height:20px}input:focus-within{box-shadow:inset 0 0 0 1px var(--wcm-accent-color)}path{fill:var(--wcm-color-fg-2)}`;var Ut=Object.defineProperty,Ht=Object.getOwnPropertyDescriptor,Fe=(e,o,r,a)=>{for(var t=a>1?void 0:a?Ht(o,r):o,l=e.length-1,i;l>=0;l--)(i=e[l])&&(t=(a?i(o,r,t):i(t))||t);return a&&t&&Ut(o,r,t),t};let ce=class extends s{constructor(){super(...arguments),this.onChange=()=>null;}render(){return x`<input type="text" @input="${this.onChange}" placeholder="Search wallets"> ${v.SEARCH_ICON}`}};ce.styles=[h.globalCss,Bt],Fe([n$1()],ce.prototype,"onChange",2),ce=Fe([e$2("wcm-search-input")],ce);const zt=i$3`@keyframes rotate{100%{transform:rotate(360deg)}}@keyframes dash{0%{stroke-dasharray:1,150;stroke-dashoffset:0}50%{stroke-dasharray:90,150;stroke-dashoffset:-35}100%{stroke-dasharray:90,150;stroke-dashoffset:-124}}svg{animation:rotate 2s linear infinite;display:flex;justify-content:center;align-items:center}svg circle{stroke-linecap:round;animation:dash 1.5s ease infinite;stroke:var(--wcm-accent-color)}`;var Vt=Object.defineProperty,Ft=Object.getOwnPropertyDescriptor,qt=(e,o,r,a)=>{for(var t=a>1?void 0:a?Ft(o,r):o,l=e.length-1,i;l>=0;l--)(i=e[l])&&(t=(a?i(o,r,t):i(t))||t);return a&&t&&Vt(o,r,t),t};let ke=class extends s{render(){return x`<svg viewBox="0 0 50 50" width="24" height="24"><circle cx="25" cy="25" r="20" fill="none" stroke-width="4" stroke="#fff"/></svg>`}};ke.styles=[h.globalCss,zt],ke=qt([e$2("wcm-spinner")],ke);const Qt=i$3`span{font-style:normal;font-family:var(--wcm-font-family);font-feature-settings:var(--wcm-font-feature-settings)}.wcm-xsmall-bold{font-family:var(--wcm-text-xsmall-bold-font-family);font-weight:var(--wcm-text-xsmall-bold-weight);font-size:var(--wcm-text-xsmall-bold-size);line-height:var(--wcm-text-xsmall-bold-line-height);letter-spacing:var(--wcm-text-xsmall-bold-letter-spacing);text-transform:var(--wcm-text-xsmall-bold-text-transform)}.wcm-xsmall-regular{font-family:var(--wcm-text-xsmall-regular-font-family);font-weight:var(--wcm-text-xsmall-regular-weight);font-size:var(--wcm-text-xsmall-regular-size);line-height:var(--wcm-text-xsmall-regular-line-height);letter-spacing:var(--wcm-text-xsmall-regular-letter-spacing);text-transform:var(--wcm-text-xsmall-regular-text-transform)}.wcm-small-thin{font-family:var(--wcm-text-small-thin-font-family);font-weight:var(--wcm-text-small-thin-weight);font-size:var(--wcm-text-small-thin-size);line-height:var(--wcm-text-small-thin-line-height);letter-spacing:var(--wcm-text-small-thin-letter-spacing);text-transform:var(--wcm-text-small-thin-text-transform)}.wcm-small-regular{font-family:var(--wcm-text-small-regular-font-family);font-weight:var(--wcm-text-small-regular-weight);font-size:var(--wcm-text-small-regular-size);line-height:var(--wcm-text-small-regular-line-height);letter-spacing:var(--wcm-text-small-regular-letter-spacing);text-transform:var(--wcm-text-small-regular-text-transform)}.wcm-medium-regular{font-family:var(--wcm-text-medium-regular-font-family);font-weight:var(--wcm-text-medium-regular-weight);font-size:var(--wcm-text-medium-regular-size);line-height:var(--wcm-text-medium-regular-line-height);letter-spacing:var(--wcm-text-medium-regular-letter-spacing);text-transform:var(--wcm-text-medium-regular-text-transform)}.wcm-big-bold{font-family:var(--wcm-text-big-bold-font-family);font-weight:var(--wcm-text-big-bold-weight);font-size:var(--wcm-text-big-bold-size);line-height:var(--wcm-text-big-bold-line-height);letter-spacing:var(--wcm-text-big-bold-letter-spacing);text-transform:var(--wcm-text-big-bold-text-transform)}:host(*){color:var(--wcm-color-fg-1)}.wcm-color-primary{color:var(--wcm-color-fg-1)}.wcm-color-secondary{color:var(--wcm-color-fg-2)}.wcm-color-tertiary{color:var(--wcm-color-fg-3)}.wcm-color-inverse{color:var(--wcm-accent-fill-color)}.wcm-color-accnt{color:var(--wcm-accent-color)}.wcm-color-error{color:var(--wcm-error-color)}`;var Kt=Object.defineProperty,Yt=Object.getOwnPropertyDescriptor,Oe=(e,o,r,a)=>{for(var t=a>1?void 0:a?Yt(o,r):o,l=e.length-1,i;l>=0;l--)(i=e[l])&&(t=(a?i(o,r,t):i(t))||t);return a&&t&&Kt(o,r,t),t};let re=class extends s{constructor(){super(...arguments),this.variant="medium-regular",this.color="primary";}render(){const e={"wcm-big-bold":this.variant==="big-bold","wcm-medium-regular":this.variant==="medium-regular","wcm-small-regular":this.variant==="small-regular","wcm-small-thin":this.variant==="small-thin","wcm-xsmall-regular":this.variant==="xsmall-regular","wcm-xsmall-bold":this.variant==="xsmall-bold","wcm-color-primary":this.color==="primary","wcm-color-secondary":this.color==="secondary","wcm-color-tertiary":this.color==="tertiary","wcm-color-inverse":this.color==="inverse","wcm-color-accnt":this.color==="accent","wcm-color-error":this.color==="error"};return x`<span><slot class="${o(e)}"></slot></span>`}};re.styles=[h.globalCss,Qt],Oe([n$1()],re.prototype,"variant",2),Oe([n$1()],re.prototype,"color",2),re=Oe([e$2("wcm-text")],re);const Gt=i$3`button{width:100%;height:100%;border-radius:var(--wcm-button-hover-highlight-border-radius);display:flex;align-items:flex-start}button:active{background-color:var(--wcm-color-overlay)}@media(hover:hover){button:hover{background-color:var(--wcm-color-overlay)}}button>div{width:80px;padding:5px 0;display:flex;flex-direction:column;align-items:center}wcm-text{width:100%;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;text-align:center}wcm-wallet-image{height:60px;width:60px;transition:all .2s ease;border-radius:var(--wcm-wallet-icon-border-radius);margin-bottom:5px}.wcm-sublabel{margin-top:2px}`;var Xt=Object.defineProperty,Jt=Object.getOwnPropertyDescriptor,_=(e,o,r,a)=>{for(var t=a>1?void 0:a?Jt(o,r):o,l=e.length-1,i;l>=0;l--)(i=e[l])&&(t=(a?i(o,r,t):i(t))||t);return a&&t&&Xt(o,r,t),t};let L=class extends s{constructor(){super(...arguments),this.onClick=()=>null,this.name="",this.walletId="",this.label=void 0,this.imageId=void 0,this.installed=!1,this.recent=!1;}sublabelTemplate(){return this.recent?x`<wcm-text class="wcm-sublabel" variant="xsmall-bold" color="tertiary">RECENT</wcm-text>`:this.installed?x`<wcm-text class="wcm-sublabel" variant="xsmall-bold" color="tertiary">INSTALLED</wcm-text>`:null}handleClick(){R$2.click({name:"WALLET_BUTTON",walletId:this.walletId}),this.onClick();}render(){var e;return x`<button @click="${this.handleClick.bind(this)}"><div><wcm-wallet-image walletId="${this.walletId}" imageId="${l(this.imageId)}"></wcm-wallet-image><wcm-text variant="xsmall-regular">${(e=this.label)!=null?e:c.getWalletName(this.name,!0)}</wcm-text>${this.sublabelTemplate()}</div></button>`}};L.styles=[h.globalCss,Gt],_([n$1()],L.prototype,"onClick",2),_([n$1()],L.prototype,"name",2),_([n$1()],L.prototype,"walletId",2),_([n$1()],L.prototype,"label",2),_([n$1()],L.prototype,"imageId",2),_([n$1({type:Boolean})],L.prototype,"installed",2),_([n$1({type:Boolean})],L.prototype,"recent",2),L=_([e$2("wcm-wallet-button")],L);const eo=i$3`:host{display:block}div{overflow:hidden;position:relative;border-radius:inherit;width:100%;height:100%;background-color:var(--wcm-color-overlay)}svg{position:relative;width:100%;height:100%}div::after{content:'';position:absolute;top:0;bottom:0;left:0;right:0;border-radius:inherit;border:1px solid var(--wcm-color-overlay)}div img{width:100%;height:100%;object-fit:cover;object-position:center}#wallet-placeholder-fill{fill:var(--wcm-color-bg-3)}#wallet-placeholder-dash{stroke:var(--wcm-color-overlay)}`;var to=Object.defineProperty,oo=Object.getOwnPropertyDescriptor,se=(e,o,r,a)=>{for(var t=a>1?void 0:a?oo(o,r):o,l=e.length-1,i;l>=0;l--)(i=e[l])&&(t=(a?i(o,r,t):i(t))||t);return a&&t&&to(o,r,t),t};let Q=class extends s{constructor(){super(...arguments),this.walletId="",this.imageId=void 0,this.imageUrl=void 0;}render(){var e;const o=(e=this.imageUrl)!=null&&e.length?this.imageUrl:c.getWalletIcon({id:this.walletId,image_id:this.imageId});return x`${o.length?x`<div><img crossorigin="anonymous" src="${o}" alt="${this.id}"></div>`:v.WALLET_PLACEHOLDER}`}};Q.styles=[h.globalCss,eo],se([n$1()],Q.prototype,"walletId",2),se([n$1()],Q.prototype,"imageId",2),se([n$1()],Q.prototype,"imageUrl",2),Q=se([e$2("wcm-wallet-image")],Q);var ro=Object.defineProperty,ao=Object.getOwnPropertyDescriptor,qe=(e,o,r,a)=>{for(var t=a>1?void 0:a?ao(o,r):o,l=e.length-1,i;l>=0;l--)(i=e[l])&&(t=(a?i(o,r,t):i(t))||t);return a&&t&&ro(o,r,t),t};let We=class extends s{constructor(){super(),this.preload=!0,this.preloadData();}async loadImages(e){try{e!=null&&e.length&&await Promise.all(e.map(async o=>c.preloadImage(o)));}catch{console.info("Unsuccessful attempt at preloading some images",e);}}async preloadListings(){if(y$3.state.enableExplorer){await te$1.getRecomendedWallets(),p$3.setIsDataLoaded(!0);const{recomendedWallets:e}=te$1.state,o=e.map(r=>c.getWalletIcon(r));await this.loadImages(o);}else p$3.setIsDataLoaded(!0);}async preloadCustomImages(){const e=c.getCustomImageUrls();await this.loadImages(e);}async preloadData(){try{this.preload&&(this.preload=!1,await Promise.all([this.preloadListings(),this.preloadCustomImages()]));}catch(e){console.error(e),oe$1.openToast("Failed preloading","error");}}};qe([t$1()],We.prototype,"preload",2),We=qe([e$2("wcm-explorer-context")],We);var lo=Object.defineProperty,io=Object.getOwnPropertyDescriptor,no=(e,o,r,a)=>{for(var t=a>1?void 0:a?io(o,r):o,l=e.length-1,i;l>=0;l--)(i=e[l])&&(t=(a?i(o,r,t):i(t))||t);return a&&t&&lo(o,r,t),t};let Qe=class extends s{constructor(){super(),this.unsubscribeTheme=void 0,h.setTheme(),this.unsubscribeTheme=ne$1.subscribe(h.setTheme);}disconnectedCallback(){var e;(e=this.unsubscribeTheme)==null||e.call(this);}};Qe=no([e$2("wcm-theme-context")],Qe);const co=i$3`@keyframes scroll{0%{transform:translate3d(0,0,0)}100%{transform:translate3d(calc(-70px * 9),0,0)}}.wcm-slider{position:relative;overflow-x:hidden;padding:10px 0;margin:0 -20px;width:calc(100% + 40px)}.wcm-track{display:flex;width:calc(70px * 18);animation:scroll 20s linear infinite;opacity:.7}.wcm-track svg{margin:0 5px}wcm-wallet-image{width:60px;height:60px;margin:0 5px;border-radius:var(--wcm-wallet-icon-border-radius)}.wcm-grid{display:grid;grid-template-columns:repeat(4,80px);justify-content:space-between}.wcm-title{display:flex;align-items:center;margin-bottom:10px}.wcm-title svg{margin-right:6px}.wcm-title path{fill:var(--wcm-accent-color)}wcm-modal-footer .wcm-title{padding:0 10px}wcm-button-big{position:absolute;top:50%;left:50%;transform:translateY(-50%) translateX(-50%);filter:drop-shadow(0 0 17px var(--wcm-color-bg-1))}wcm-info-footer{flex-direction:column;align-items:center;display:flex;width:100%;padding:5px 0}wcm-info-footer wcm-text{text-align:center;margin-bottom:15px}#wallet-placeholder-fill{fill:var(--wcm-color-bg-3)}#wallet-placeholder-dash{stroke:var(--wcm-color-overlay)}`;var so=Object.defineProperty,mo=Object.getOwnPropertyDescriptor,ho=(e,o,r,a)=>{for(var t=a>1?void 0:a?mo(o,r):o,l=e.length-1,i;l>=0;l--)(i=e[l])&&(t=(a?i(o,r,t):i(t))||t);return a&&t&&so(o,r,t),t};let Ie=class extends s{onGoToQrcode(){T$3.push("Qrcode");}render(){const{recomendedWallets:e}=te$1.state,o=[...e,...e],r=a$4.RECOMMENDED_WALLET_AMOUNT*2;return x`<wcm-modal-header title="Connect your wallet" .onAction="${this.onGoToQrcode}" .actionIcon="${v.QRCODE_ICON}"></wcm-modal-header><wcm-modal-content><div class="wcm-title">${v.MOBILE_ICON}<wcm-text variant="small-regular" color="accent">WalletConnect</wcm-text></div><div class="wcm-slider"><div class="wcm-track">${[...Array(r)].map((a,t)=>{const l=o[t%o.length];return l?x`<wcm-wallet-image walletId="${l.id}" imageId="${l.image_id}"></wcm-wallet-image>`:v.WALLET_PLACEHOLDER})}</div><wcm-button-big @click="${c.handleAndroidLinking}"><wcm-text variant="medium-regular" color="inverse">Select Wallet</wcm-text></wcm-button-big></div></wcm-modal-content><wcm-info-footer><wcm-text color="secondary" variant="small-thin">Choose WalletConnect to see supported apps on your device</wcm-text></wcm-info-footer>`}};Ie.styles=[h.globalCss,co],Ie=ho([e$2("wcm-android-wallet-selection")],Ie);const wo=i$3`@keyframes loading{to{stroke-dashoffset:0}}@keyframes shake{10%,90%{transform:translate3d(-1px,0,0)}20%,80%{transform:translate3d(1px,0,0)}30%,50%,70%{transform:translate3d(-2px,0,0)}40%,60%{transform:translate3d(2px,0,0)}}:host{display:flex;flex-direction:column;align-items:center}div{position:relative;width:110px;height:110px;display:flex;justify-content:center;align-items:center;margin:40px 0 20px 0;transform:translate3d(0,0,0)}svg{position:absolute;width:110px;height:110px;fill:none;stroke:transparent;stroke-linecap:round;stroke-width:2px;top:0;left:0}use{stroke:var(--wcm-accent-color);animation:loading 1s linear infinite}wcm-wallet-image{border-radius:var(--wcm-wallet-icon-large-border-radius);width:90px;height:90px}wcm-text{margin-bottom:40px}.wcm-error svg{stroke:var(--wcm-error-color)}.wcm-error use{display:none}.wcm-error{animation:shake .4s cubic-bezier(.36,.07,.19,.97) both}.wcm-stale svg,.wcm-stale use{display:none}`;var po=Object.defineProperty,go=Object.getOwnPropertyDescriptor,K=(e,o,r,a)=>{for(var t=a>1?void 0:a?go(o,r):o,l=e.length-1,i;l>=0;l--)(i=e[l])&&(t=(a?i(o,r,t):i(t))||t);return a&&t&&po(o,r,t),t};let D=class extends s{constructor(){super(...arguments),this.walletId=void 0,this.imageId=void 0,this.isError=!1,this.isStale=!1,this.label="";}svgLoaderTemplate(){var e,o;const r=(o=(e=ne$1.state.themeVariables)==null?void 0:e["--wcm-wallet-icon-large-border-radius"])!=null?o:h.getPreset("--wcm-wallet-icon-large-border-radius");let a=0;r.includes("%")?a=88/100*parseInt(r,10):a=parseInt(r,10),a*=1.17;const t=317-a*1.57,l=425-a*1.8;return x`<svg viewBox="0 0 110 110" width="110" height="110"><rect id="wcm-loader" x="2" y="2" width="106" height="106" rx="${a}"/><use xlink:href="#wcm-loader" stroke-dasharray="106 ${t}" stroke-dashoffset="${l}"></use></svg>`}render(){const e={"wcm-error":this.isError,"wcm-stale":this.isStale};return x`<div class="${o(e)}">${this.svgLoaderTemplate()}<wcm-wallet-image walletId="${l(this.walletId)}" imageId="${l(this.imageId)}"></wcm-wallet-image></div><wcm-text variant="medium-regular" color="${this.isError?"error":"primary"}">${this.isError?"Connection declined":this.label}</wcm-text>`}};D.styles=[h.globalCss,wo],K([n$1()],D.prototype,"walletId",2),K([n$1()],D.prototype,"imageId",2),K([n$1({type:Boolean})],D.prototype,"isError",2),K([n$1({type:Boolean})],D.prototype,"isStale",2),K([n$1()],D.prototype,"label",2),D=K([e$2("wcm-connector-waiting")],D);const G={manualWallets(){var e,o;const{mobileWallets:r,desktopWallets:a}=y$3.state,t=(e=G.recentWallet())==null?void 0:e.id,l=a$4.isMobile()?r:a,i=l?.filter(s=>t!==s.id);return (o=a$4.isMobile()?i?.map(({id:s,name:$,links:f})=>({id:s,name:$,mobile:f,links:f})):i?.map(({id:s,name:$,links:f})=>({id:s,name:$,desktop:f,links:f})))!=null?o:[]},recentWallet(){return c.getRecentWallet()},recomendedWallets(e=!1){var o;const r=e||(o=G.recentWallet())==null?void 0:o.id,{recomendedWallets:a}=te$1.state;return a.filter(t=>r!==t.id)}},Z={onConnecting(e){c.goToConnectingView(e);},manualWalletsTemplate(){return G.manualWallets().map(e=>x`<wcm-wallet-button walletId="${e.id}" name="${e.name}" .onClick="${()=>this.onConnecting(e)}"></wcm-wallet-button>`)},recomendedWalletsTemplate(e=!1){return G.recomendedWallets(e).map(o=>x`<wcm-wallet-button name="${o.name}" walletId="${o.id}" imageId="${o.image_id}" .onClick="${()=>this.onConnecting(o)}"></wcm-wallet-button>`)},recentWalletTemplate(){const e=G.recentWallet();if(e)return x`<wcm-wallet-button name="${e.name}" walletId="${e.id}" imageId="${l(e.image_id)}" .recent="${!0}" .onClick="${()=>this.onConnecting(e)}"></wcm-wallet-button>`}},vo=i$3`.wcm-grid{display:grid;grid-template-columns:repeat(4,80px);justify-content:space-between}.wcm-desktop-title,.wcm-mobile-title{display:flex;align-items:center}.wcm-mobile-title{justify-content:space-between;margin-bottom:20px;margin-top:-10px}.wcm-desktop-title{margin-bottom:10px;padding:0 10px}.wcm-subtitle{display:flex;align-items:center}.wcm-subtitle:last-child path{fill:var(--wcm-color-fg-3)}.wcm-desktop-title svg,.wcm-mobile-title svg{margin-right:6px}.wcm-desktop-title path,.wcm-mobile-title path{fill:var(--wcm-accent-color)}`;var uo=Object.defineProperty,bo=Object.getOwnPropertyDescriptor,fo=(e,o,r,a)=>{for(var t=a>1?void 0:a?bo(o,r):o,l=e.length-1,i;l>=0;l--)(i=e[l])&&(t=(a?i(o,r,t):i(t))||t);return a&&t&&uo(o,r,t),t};let Ee=class extends s{render(){const{explorerExcludedWalletIds:e,enableExplorer:o}=y$3.state,r=e!=="ALL"&&o,a=Z.manualWalletsTemplate(),t=Z.recomendedWalletsTemplate();let l=[Z.recentWalletTemplate(),...a,...t];l=l.filter(Boolean);const i=l.length>4||r;let s=[];i?s=l.slice(0,3):s=l;const $=Boolean(s.length);return x`<wcm-modal-header .border="${!0}" title="Connect your wallet" .onAction="${c.handleUriCopy}" .actionIcon="${v.COPY_ICON}"></wcm-modal-header><wcm-modal-content><div class="wcm-mobile-title"><div class="wcm-subtitle">${v.MOBILE_ICON}<wcm-text variant="small-regular" color="accent">Mobile</wcm-text></div><div class="wcm-subtitle">${v.SCAN_ICON}<wcm-text variant="small-regular" color="secondary">Scan with your wallet</wcm-text></div></div><wcm-walletconnect-qr></wcm-walletconnect-qr></wcm-modal-content>${$?x`<wcm-modal-footer><div class="wcm-desktop-title">${v.DESKTOP_ICON}<wcm-text variant="small-regular" color="accent">Desktop</wcm-text></div><div class="wcm-grid">${s} ${i?x`<wcm-view-all-wallets-button></wcm-view-all-wallets-button>`:null}</div></wcm-modal-footer>`:null}`}};Ee.styles=[h.globalCss,vo],Ee=fo([e$2("wcm-desktop-wallet-selection")],Ee);const xo=i$3`div{background-color:var(--wcm-color-bg-2);padding:10px 20px 15px 20px;border-top:1px solid var(--wcm-color-bg-3);text-align:center}a{color:var(--wcm-accent-color);text-decoration:none;transition:opacity .2s ease-in-out;display:inline}a:active{opacity:.8}@media(hover:hover){a:hover{opacity:.8}}`;var yo=Object.defineProperty,$o=Object.getOwnPropertyDescriptor,Co=(e,o,r,a)=>{for(var t=a>1?void 0:a?$o(o,r):o,l=e.length-1,i;l>=0;l--)(i=e[l])&&(t=(a?i(o,r,t):i(t))||t);return a&&t&&yo(o,r,t),t};let Me=class extends s{render(){const{termsOfServiceUrl:e,privacyPolicyUrl:o}=y$3.state;return e??o?x`<div><wcm-text variant="small-regular" color="secondary">By connecting your wallet to this app, you agree to the app's ${e?x`<a href="${e}" target="_blank" rel="noopener noreferrer">Terms of Service</a>`:null} ${e&&o?"and":null} ${o?x`<a href="${o}" target="_blank" rel="noopener noreferrer">Privacy Policy</a>`:null}</wcm-text></div>`:null}};Me.styles=[h.globalCss,xo],Me=Co([e$2("wcm-legal-notice")],Me);const ko=i$3`div{display:grid;grid-template-columns:repeat(4,80px);margin:0 -10px;justify-content:space-between;row-gap:10px}`;var Oo=Object.defineProperty,Wo=Object.getOwnPropertyDescriptor,Io=(e,o,r,a)=>{for(var t=a>1?void 0:a?Wo(o,r):o,l=e.length-1,i;l>=0;l--)(i=e[l])&&(t=(a?i(o,r,t):i(t))||t);return a&&t&&Oo(o,r,t),t};let Le=class extends s{onQrcode(){T$3.push("Qrcode");}render(){const{explorerExcludedWalletIds:e,enableExplorer:o}=y$3.state,r=e!=="ALL"&&o,a=Z.manualWalletsTemplate(),t=Z.recomendedWalletsTemplate();let l=[Z.recentWalletTemplate(),...a,...t];l=l.filter(Boolean);const i=l.length>8||r;let s=[];i?s=l.slice(0,7):s=l;const $=Boolean(s.length);return x`<wcm-modal-header title="Connect your wallet" .onAction="${this.onQrcode}" .actionIcon="${v.QRCODE_ICON}"></wcm-modal-header>${$?x`<wcm-modal-content><div>${s} ${i?x`<wcm-view-all-wallets-button></wcm-view-all-wallets-button>`:null}</div></wcm-modal-content>`:null}`}};Le.styles=[h.globalCss,ko],Le=Io([e$2("wcm-mobile-wallet-selection")],Le);const Eo=i$3`:host{all:initial}.wcm-overlay{top:0;bottom:0;left:0;right:0;position:fixed;z-index:var(--wcm-z-index);overflow:hidden;display:flex;justify-content:center;align-items:center;opacity:0;pointer-events:none;background-color:var(--wcm-overlay-background-color);backdrop-filter:var(--wcm-overlay-backdrop-filter)}@media(max-height:720px) and (orientation:landscape){.wcm-overlay{overflow:scroll;align-items:flex-start;padding:20px 0}}.wcm-active{pointer-events:auto}.wcm-container{position:relative;max-width:360px;width:100%;outline:0;border-radius:var(--wcm-background-border-radius) var(--wcm-background-border-radius) var(--wcm-container-border-radius) var(--wcm-container-border-radius);border:1px solid var(--wcm-color-overlay);overflow:hidden}.wcm-card{width:100%;position:relative;border-radius:var(--wcm-container-border-radius);overflow:hidden;box-shadow:0 6px 14px -6px rgba(10,16,31,.12),0 10px 32px -4px rgba(10,16,31,.1),0 0 0 1px var(--wcm-color-overlay);background-color:var(--wcm-color-bg-1);color:var(--wcm-color-fg-1)}@media(max-width:600px){.wcm-container{max-width:440px;border-radius:var(--wcm-background-border-radius) var(--wcm-background-border-radius) 0 0}.wcm-card{border-radius:var(--wcm-container-border-radius) var(--wcm-container-border-radius) 0 0}.wcm-overlay{align-items:flex-end}}@media(max-width:440px){.wcm-container{border:0}}`;var Mo=Object.defineProperty,Lo=Object.getOwnPropertyDescriptor,Re=(e,o,r,a)=>{for(var t=a>1?void 0:a?Lo(o,r):o,l=e.length-1,i;l>=0;l--)(i=e[l])&&(t=(a?i(o,r,t):i(t))||t);return a&&t&&Mo(o,r,t),t};let ae=class extends s{constructor(){super(),this.open=!1,this.active=!1,this.unsubscribeModal=void 0,this.abortController=void 0,this.unsubscribeModal=se$1.subscribe(e=>{e.open?this.onOpenModalEvent():this.onCloseModalEvent();});}disconnectedCallback(){var e;(e=this.unsubscribeModal)==null||e.call(this);}get overlayEl(){return c.getShadowRootElement(this,".wcm-overlay")}get containerEl(){return c.getShadowRootElement(this,".wcm-container")}toggleBodyScroll(e){if(document.querySelector("body"))if(e){const o=document.getElementById("wcm-styles");o?.remove();}else document.head.insertAdjacentHTML("beforeend",'<style id="wcm-styles">html,body{touch-action:none;overflow:hidden;overscroll-behavior:contain;}</style>');}onCloseModal(e){e.target===e.currentTarget&&se$1.close();}onOpenModalEvent(){this.toggleBodyScroll(!1),this.addKeyboardEvents(),this.open=!0,setTimeout(async()=>{const e=c.isMobileAnimation()?{y:["50vh","0vh"]}:{scale:[.98,1]},o=.1,r=.2;await Promise.all([animate(this.overlayEl,{opacity:[0,1]},{delay:o,duration:r}).finished,animate(this.containerEl,e,{delay:o,duration:r}).finished]),this.active=!0;},0);}async onCloseModalEvent(){this.toggleBodyScroll(!0),this.removeKeyboardEvents();const e=c.isMobileAnimation()?{y:["0vh","50vh"]}:{scale:[1,.98]},o=.2;await Promise.all([animate(this.overlayEl,{opacity:[1,0]},{duration:o}).finished,animate(this.containerEl,e,{duration:o}).finished]),this.containerEl.removeAttribute("style"),this.active=!1,this.open=!1;}addKeyboardEvents(){this.abortController=new AbortController,window.addEventListener("keydown",e=>{var o;e.key==="Escape"?se$1.close():e.key==="Tab"&&((o=e.target)!=null&&o.tagName.includes("wcm-")||this.containerEl.focus());},this.abortController),this.containerEl.focus();}removeKeyboardEvents(){var e;(e=this.abortController)==null||e.abort(),this.abortController=void 0;}render(){const e={"wcm-overlay":!0,"wcm-active":this.active};return x`<wcm-explorer-context></wcm-explorer-context><wcm-theme-context></wcm-theme-context><div id="wcm-modal" class="${o(e)}" @click="${this.onCloseModal}" role="alertdialog" aria-modal="true"><div class="wcm-container" tabindex="0">${this.open?x`<wcm-modal-backcard></wcm-modal-backcard><div class="wcm-card"><wcm-modal-router></wcm-modal-router><wcm-modal-toast></wcm-modal-toast></div>`:null}</div></div>`}};ae.styles=[h.globalCss,Eo],Re([t$1()],ae.prototype,"open",2),Re([t$1()],ae.prototype,"active",2),ae=Re([e$2("wcm-modal")],ae);const Ro=i$3`div{display:flex;margin-top:15px}slot{display:inline-block;margin:0 5px}wcm-button{margin:0 5px}`;var Ao=Object.defineProperty,Po=Object.getOwnPropertyDescriptor,le=(e,o,r,a)=>{for(var t=a>1?void 0:a?Po(o,r):o,l=e.length-1,i;l>=0;l--)(i=e[l])&&(t=(a?i(o,r,t):i(t))||t);return a&&t&&Ao(o,r,t),t};let B=class extends s{constructor(){super(...arguments),this.isMobile=!1,this.isDesktop=!1,this.isWeb=!1,this.isRetry=!1;}onMobile(){a$4.isMobile()?T$3.replace("MobileConnecting"):T$3.replace("MobileQrcodeConnecting");}onDesktop(){T$3.replace("DesktopConnecting");}onWeb(){T$3.replace("WebConnecting");}render(){return x`<div>${this.isRetry?x`<slot></slot>`:null} ${this.isMobile?x`<wcm-button .onClick="${this.onMobile}" .iconLeft="${v.MOBILE_ICON}" variant="outline">Mobile</wcm-button>`:null} ${this.isDesktop?x`<wcm-button .onClick="${this.onDesktop}" .iconLeft="${v.DESKTOP_ICON}" variant="outline">Desktop</wcm-button>`:null} ${this.isWeb?x`<wcm-button .onClick="${this.onWeb}" .iconLeft="${v.GLOBE_ICON}" variant="outline">Web</wcm-button>`:null}</div>`}};B.styles=[h.globalCss,Ro],le([n$1({type:Boolean})],B.prototype,"isMobile",2),le([n$1({type:Boolean})],B.prototype,"isDesktop",2),le([n$1({type:Boolean})],B.prototype,"isWeb",2),le([n$1({type:Boolean})],B.prototype,"isRetry",2),B=le([e$2("wcm-platform-selection")],B);const To=i$3`button{display:flex;flex-direction:column;padding:5px 10px;border-radius:var(--wcm-button-hover-highlight-border-radius);height:100%;justify-content:flex-start}.wcm-icons{width:60px;height:60px;display:flex;flex-wrap:wrap;padding:7px;border-radius:var(--wcm-wallet-icon-border-radius);justify-content:space-between;align-items:center;margin-bottom:5px;background-color:var(--wcm-color-bg-2);box-shadow:inset 0 0 0 1px var(--wcm-color-overlay)}button:active{background-color:var(--wcm-color-overlay)}@media(hover:hover){button:hover{background-color:var(--wcm-color-overlay)}}.wcm-icons img{width:21px;height:21px;object-fit:cover;object-position:center;border-radius:calc(var(--wcm-wallet-icon-border-radius)/ 2);border:1px solid var(--wcm-color-overlay)}.wcm-icons svg{width:21px;height:21px}.wcm-icons img:nth-child(1),.wcm-icons img:nth-child(2),.wcm-icons svg:nth-child(1),.wcm-icons svg:nth-child(2){margin-bottom:4px}wcm-text{width:100%;text-align:center}#wallet-placeholder-fill{fill:var(--wcm-color-bg-3)}#wallet-placeholder-dash{stroke:var(--wcm-color-overlay)}`;var jo=Object.defineProperty,_o=Object.getOwnPropertyDescriptor,Do=(e,o,r,a)=>{for(var t=a>1?void 0:a?_o(o,r):o,l=e.length-1,i;l>=0;l--)(i=e[l])&&(t=(a?i(o,r,t):i(t))||t);return a&&t&&jo(o,r,t),t};let Ae=class extends s{onClick(){T$3.push("WalletExplorer");}render(){const{recomendedWallets:e}=te$1.state,o=G.manualWallets(),r=[...e,...o].reverse().slice(0,4);return x`<button @click="${this.onClick}"><div class="wcm-icons">${r.map(a=>{const t=c.getWalletIcon(a);if(t)return x`<img crossorigin="anonymous" src="${t}">`;const l=c.getWalletIcon({id:a.id});return l?x`<img crossorigin="anonymous" src="${l}">`:v.WALLET_PLACEHOLDER})} ${[...Array(4-r.length)].map(()=>v.WALLET_PLACEHOLDER)}</div><wcm-text variant="xsmall-regular">View All</wcm-text></button>`}};Ae.styles=[h.globalCss,To],Ae=Do([e$2("wcm-view-all-wallets-button")],Ae);const No=i$3`.wcm-qr-container{width:100%;display:flex;justify-content:center;align-items:center;aspect-ratio:1/1}`;var Zo=Object.defineProperty,So=Object.getOwnPropertyDescriptor,de=(e,o,r,a)=>{for(var t=a>1?void 0:a?So(o,r):o,l=e.length-1,i;l>=0;l--)(i=e[l])&&(t=(a?i(o,r,t):i(t))||t);return a&&t&&Zo(o,r,t),t};let Y=class extends s{constructor(){super(),this.walletId="",this.imageId="",this.uri="",setTimeout(()=>{const{walletConnectUri:e}=p$3.state;this.uri=e;},0);}get overlayEl(){return c.getShadowRootElement(this,".wcm-qr-container")}render(){return x`<div class="wcm-qr-container">${this.uri?x`<wcm-qrcode size="${this.overlayEl.offsetWidth}" uri="${this.uri}" walletId="${l(this.walletId)}" imageId="${l(this.imageId)}"></wcm-qrcode>`:x`<wcm-spinner></wcm-spinner>`}</div>`}};Y.styles=[h.globalCss,No],de([n$1()],Y.prototype,"walletId",2),de([n$1()],Y.prototype,"imageId",2),de([t$1()],Y.prototype,"uri",2),Y=de([e$2("wcm-walletconnect-qr")],Y);var Bo=Object.defineProperty,Uo=Object.getOwnPropertyDescriptor,Ho=(e,o,r,a)=>{for(var t=a>1?void 0:a?Uo(o,r):o,l=e.length-1,i;l>=0;l--)(i=e[l])&&(t=(a?i(o,r,t):i(t))||t);return a&&t&&Bo(o,r,t),t};let Pe=class extends s{viewTemplate(){return a$4.isAndroid()?x`<wcm-android-wallet-selection></wcm-android-wallet-selection>`:a$4.isMobile()?x`<wcm-mobile-wallet-selection></wcm-mobile-wallet-selection>`:x`<wcm-desktop-wallet-selection></wcm-desktop-wallet-selection>`}render(){return x`${this.viewTemplate()}<wcm-legal-notice></wcm-legal-notice>`}};Pe.styles=[h.globalCss],Pe=Ho([e$2("wcm-connect-wallet-view")],Pe);const zo=i$3`wcm-info-footer{flex-direction:column;align-items:center;display:flex;width:100%;padding:5px 0}wcm-text{text-align:center}`;var Vo=Object.defineProperty,Fo=Object.getOwnPropertyDescriptor,Ke=(e,o,r,a)=>{for(var t=a>1?void 0:a?Fo(o,r):o,l=e.length-1,i;l>=0;l--)(i=e[l])&&(t=(a?i(o,r,t):i(t))||t);return a&&t&&Vo(o,r,t),t};let me=class extends s{constructor(){super(),this.isError=!1,this.openDesktopApp();}onFormatAndRedirect(e){const{desktop:o,name:r}=a$4.getWalletRouterData(),a=o?.native;if(a){const t=a$4.formatNativeUrl(a,e,r);a$4.openHref(t,"_self");}}openDesktopApp(){const{walletConnectUri:e}=p$3.state,o=a$4.getWalletRouterData();c.setRecentWallet(o),e&&this.onFormatAndRedirect(e);}render(){const{name:e,id:o,image_id:r}=a$4.getWalletRouterData(),{isMobile:a,isWeb:t}=c.getCachedRouterWalletPlatforms();return x`<wcm-modal-header title="${e}" .onAction="${c.handleUriCopy}" .actionIcon="${v.COPY_ICON}"></wcm-modal-header><wcm-modal-content><wcm-connector-waiting walletId="${o}" imageId="${l(r)}" label="${`Continue in ${e}...`}" .isError="${this.isError}"></wcm-connector-waiting></wcm-modal-content><wcm-info-footer><wcm-text color="secondary" variant="small-thin">${`Connection can continue loading if ${e} is not installed on your device`}</wcm-text><wcm-platform-selection .isMobile="${a}" .isWeb="${t}" .isRetry="${!0}"><wcm-button .onClick="${this.openDesktopApp.bind(this)}" .iconRight="${v.RETRY_ICON}">Retry</wcm-button></wcm-platform-selection></wcm-info-footer>`}};me.styles=[h.globalCss,zo],Ke([t$1()],me.prototype,"isError",2),me=Ke([e$2("wcm-desktop-connecting-view")],me);const qo=i$3`wcm-info-footer{flex-direction:column;align-items:center;display:flex;width:100%;padding:5px 0}wcm-text{text-align:center}wcm-button{margin-top:15px}`;var Qo=Object.defineProperty,Ko=Object.getOwnPropertyDescriptor,Yo=(e,o,r,a)=>{for(var t=a>1?void 0:a?Ko(o,r):o,l=e.length-1,i;l>=0;l--)(i=e[l])&&(t=(a?i(o,r,t):i(t))||t);return a&&t&&Qo(o,r,t),t};let Te=class extends s{onInstall(e){e&&a$4.openHref(e,"_blank");}render(){const{name:e,id:o,image_id:r,homepage:a}=a$4.getWalletRouterData();return x`<wcm-modal-header title="${e}"></wcm-modal-header><wcm-modal-content><wcm-connector-waiting walletId="${o}" imageId="${l(r)}" label="Not Detected" .isStale="${!0}"></wcm-connector-waiting></wcm-modal-content><wcm-info-footer><wcm-text color="secondary" variant="small-thin">${`Download ${e} to continue. If multiple browser extensions are installed, disable non ${e} ones and try again`}</wcm-text><wcm-button .onClick="${()=>this.onInstall(a)}" .iconLeft="${v.ARROW_DOWN_ICON}">Download</wcm-button></wcm-info-footer>`}};Te.styles=[h.globalCss,qo],Te=Yo([e$2("wcm-install-wallet-view")],Te);const Go=i$3`wcm-wallet-image{border-radius:var(--wcm-wallet-icon-large-border-radius);width:96px;height:96px;margin-bottom:20px}wcm-info-footer{display:flex;width:100%}.wcm-app-store{justify-content:space-between}.wcm-app-store wcm-wallet-image{margin-right:10px;margin-bottom:0;width:28px;height:28px;border-radius:var(--wcm-wallet-icon-small-border-radius)}.wcm-app-store div{display:flex;align-items:center}.wcm-app-store wcm-button{margin-right:-10px}.wcm-note{flex-direction:column;align-items:center;padding:5px 0}.wcm-note wcm-text{text-align:center}wcm-platform-selection{margin-top:-15px}.wcm-note wcm-text{margin-top:15px}.wcm-note wcm-text span{color:var(--wcm-accent-color)}`;var Xo=Object.defineProperty,Jo=Object.getOwnPropertyDescriptor,Ye=(e,o,r,a)=>{for(var t=a>1?void 0:a?Jo(o,r):o,l=e.length-1,i;l>=0;l--)(i=e[l])&&(t=(a?i(o,r,t):i(t))||t);return a&&t&&Xo(o,r,t),t};let he=class extends s{constructor(){super(),this.isError=!1,this.openMobileApp();}onFormatAndRedirect(e,o=!1){const{mobile:r,name:a}=a$4.getWalletRouterData(),t=r?.native,l=r?.universal;if(t&&!o){const i=a$4.formatNativeUrl(t,e,a);a$4.openHref(i,"_self");}else if(l){const i=a$4.formatUniversalUrl(l,e,a);a$4.openHref(i,"_self");}}openMobileApp(e=!1){const{walletConnectUri:o}=p$3.state,r=a$4.getWalletRouterData();c.setRecentWallet(r),o&&this.onFormatAndRedirect(o,e);}onGoToAppStore(e){e&&a$4.openHref(e,"_blank");}render(){const{name:e,id:o,image_id:r,app:a,mobile:t}=a$4.getWalletRouterData(),{isWeb:l$1}=c.getCachedRouterWalletPlatforms(),i=a?.ios,s=t?.universal;return x`<wcm-modal-header title="${e}"></wcm-modal-header><wcm-modal-content><wcm-connector-waiting walletId="${o}" imageId="${l(r)}" label="Tap 'Open' to continue…" .isError="${this.isError}"></wcm-connector-waiting></wcm-modal-content><wcm-info-footer class="wcm-note"><wcm-platform-selection .isWeb="${l$1}" .isRetry="${!0}"><wcm-button .onClick="${()=>this.openMobileApp(!1)}" .iconRight="${v.RETRY_ICON}">Retry</wcm-button></wcm-platform-selection>${s?x`<wcm-text color="secondary" variant="small-thin">Still doesn't work? <span tabindex="0" @click="${()=>this.openMobileApp(!0)}">Try this alternate link</span></wcm-text>`:null}</wcm-info-footer><wcm-info-footer class="wcm-app-store"><div><wcm-wallet-image walletId="${o}" imageId="${l(r)}"></wcm-wallet-image><wcm-text>${`Get ${e}`}</wcm-text></div><wcm-button .iconRight="${v.ARROW_RIGHT_ICON}" .onClick="${()=>this.onGoToAppStore(i)}" variant="ghost">App Store</wcm-button></wcm-info-footer>`}};he.styles=[h.globalCss,Go],Ye([t$1()],he.prototype,"isError",2),he=Ye([e$2("wcm-mobile-connecting-view")],he);const er=i$3`wcm-info-footer{flex-direction:column;align-items:center;display:flex;width:100%;padding:5px 0}wcm-text{text-align:center}`;var tr=Object.defineProperty,or=Object.getOwnPropertyDescriptor,rr=(e,o,r,a)=>{for(var t=a>1?void 0:a?or(o,r):o,l=e.length-1,i;l>=0;l--)(i=e[l])&&(t=(a?i(o,r,t):i(t))||t);return a&&t&&tr(o,r,t),t};let je=class extends s{render(){const{name:e,id:o,image_id:r}=a$4.getWalletRouterData(),{isDesktop:a,isWeb:t}=c.getCachedRouterWalletPlatforms();return x`<wcm-modal-header title="${e}" .onAction="${c.handleUriCopy}" .actionIcon="${v.COPY_ICON}"></wcm-modal-header><wcm-modal-content><wcm-walletconnect-qr walletId="${o}" imageId="${l(r)}"></wcm-walletconnect-qr></wcm-modal-content><wcm-info-footer><wcm-text color="secondary" variant="small-thin">${`Scan this QR Code with your phone's camera or inside ${e} app`}</wcm-text><wcm-platform-selection .isDesktop="${a}" .isWeb="${t}"></wcm-platform-selection></wcm-info-footer>`}};je.styles=[h.globalCss,er],je=rr([e$2("wcm-mobile-qr-connecting-view")],je);var ar=Object.defineProperty,lr=Object.getOwnPropertyDescriptor,ir=(e,o,r,a)=>{for(var t=a>1?void 0:a?lr(o,r):o,l=e.length-1,i;l>=0;l--)(i=e[l])&&(t=(a?i(o,r,t):i(t))||t);return a&&t&&ar(o,r,t),t};let _e=class extends s{render(){return x`<wcm-modal-header title="Scan the code" .onAction="${c.handleUriCopy}" .actionIcon="${v.COPY_ICON}"></wcm-modal-header><wcm-modal-content><wcm-walletconnect-qr></wcm-walletconnect-qr></wcm-modal-content>`}};_e.styles=[h.globalCss],_e=ir([e$2("wcm-qrcode-view")],_e);const nr=i$3`wcm-modal-content{height:clamp(200px,60vh,600px);display:block;overflow:scroll;scrollbar-width:none;position:relative;margin-top:1px}.wcm-grid{display:grid;grid-template-columns:repeat(4,80px);justify-content:space-between;margin:-15px -10px;padding-top:20px}wcm-modal-content::after,wcm-modal-content::before{content:'';position:fixed;pointer-events:none;z-index:1;width:100%;height:20px;opacity:1}wcm-modal-content::before{box-shadow:0 -1px 0 0 var(--wcm-color-bg-1);background:linear-gradient(var(--wcm-color-bg-1),rgba(255,255,255,0))}wcm-modal-content::after{box-shadow:0 1px 0 0 var(--wcm-color-bg-1);background:linear-gradient(rgba(255,255,255,0),var(--wcm-color-bg-1));top:calc(100% - 20px)}wcm-modal-content::-webkit-scrollbar{display:none}.wcm-placeholder-block{display:flex;justify-content:center;align-items:center;height:100px;overflow:hidden}.wcm-empty,.wcm-loading{display:flex}.wcm-loading .wcm-placeholder-block{height:100%}.wcm-end-reached .wcm-placeholder-block{height:0;opacity:0}.wcm-empty .wcm-placeholder-block{opacity:1;height:100%}wcm-wallet-button{margin:calc((100% - 60px)/ 3) 0}`;var cr=Object.defineProperty,sr=Object.getOwnPropertyDescriptor,ie=(e,o,r,a)=>{for(var t=a>1?void 0:a?sr(o,r):o,l=e.length-1,i;l>=0;l--)(i=e[l])&&(t=(a?i(o,r,t):i(t))||t);return a&&t&&cr(o,r,t),t};const De=40;let U=class extends s{constructor(){super(...arguments),this.loading=!te$1.state.wallets.listings.length,this.firstFetch=!te$1.state.wallets.listings.length,this.search="",this.endReached=!1,this.intersectionObserver=void 0,this.searchDebounce=c.debounce(e=>{e.length>=1?(this.firstFetch=!0,this.endReached=!1,this.search=e,te$1.resetSearch(),this.fetchWallets()):this.search&&(this.search="",this.endReached=this.isLastPage(),te$1.resetSearch());});}firstUpdated(){this.createPaginationObserver();}disconnectedCallback(){var e;(e=this.intersectionObserver)==null||e.disconnect();}get placeholderEl(){return c.getShadowRootElement(this,".wcm-placeholder-block")}createPaginationObserver(){this.intersectionObserver=new IntersectionObserver(([e])=>{e.isIntersecting&&!(this.search&&this.firstFetch)&&this.fetchWallets();}),this.intersectionObserver.observe(this.placeholderEl);}isLastPage(){const{wallets:e,search:o}=te$1.state,{listings:r,total:a}=this.search?o:e;return a<=De||r.length>=a}async fetchWallets(){var e;const{wallets:o,search:r}=te$1.state,{listings:a,total:t,page:l}=this.search?r:o;if(!this.endReached&&(this.firstFetch||t>De&&a.length<t))try{this.loading=!0;const i=(e=p$3.state.chains)==null?void 0:e.join(","),{listings:s}=await te$1.getWallets({page:this.firstFetch?1:l+1,entries:De,search:this.search,version:2,chains:i}),$=s.map(f=>c.getWalletIcon(f));await Promise.all([...$.map(async f=>c.preloadImage(f)),a$4.wait(300)]),this.endReached=this.isLastPage();}catch(i){console.error(i),oe$1.openToast(c.getErrorMessage(i),"error");}finally{this.loading=!1,this.firstFetch=!1;}}onConnect(e){a$4.isAndroid()?c.handleMobileLinking(e):c.goToConnectingView(e);}onSearchChange(e){const{value:o}=e.target;this.searchDebounce(o);}render(){const{wallets:e,search:o$1}=te$1.state,{listings:r}=this.search?o$1:e,a=this.loading&&!r.length,t=this.search.length>=3;let l=Z.manualWalletsTemplate(),i=Z.recomendedWalletsTemplate(!0);t&&(l=l.filter(({values:f})=>c.caseSafeIncludes(f[0],this.search)),i=i.filter(({values:f})=>c.caseSafeIncludes(f[0],this.search)));const s=!this.loading&&!r.length&&!i.length,$={"wcm-loading":a,"wcm-end-reached":this.endReached||!this.loading,"wcm-empty":s};return x`<wcm-modal-header><wcm-search-input .onChange="${this.onSearchChange.bind(this)}"></wcm-search-input></wcm-modal-header><wcm-modal-content class="${o($)}"><div class="wcm-grid">${a?null:l} ${a?null:i} ${a?null:r.map(f=>x`${f?x`<wcm-wallet-button imageId="${f.image_id}" name="${f.name}" walletId="${f.id}" .onClick="${()=>this.onConnect(f)}"></wcm-wallet-button>`:null}`)}</div><div class="wcm-placeholder-block">${s?x`<wcm-text variant="big-bold" color="secondary">No results found</wcm-text>`:null} ${!s&&this.loading?x`<wcm-spinner></wcm-spinner>`:null}</div></wcm-modal-content>`}};U.styles=[h.globalCss,nr],ie([t$1()],U.prototype,"loading",2),ie([t$1()],U.prototype,"firstFetch",2),ie([t$1()],U.prototype,"search",2),ie([t$1()],U.prototype,"endReached",2),U=ie([e$2("wcm-wallet-explorer-view")],U);const dr=i$3`wcm-info-footer{flex-direction:column;align-items:center;display:flex;width:100%;padding:5px 0}wcm-text{text-align:center}`;var mr=Object.defineProperty,hr=Object.getOwnPropertyDescriptor,Ge=(e,o,r,a)=>{for(var t=a>1?void 0:a?hr(o,r):o,l=e.length-1,i;l>=0;l--)(i=e[l])&&(t=(a?i(o,r,t):i(t))||t);return a&&t&&mr(o,r,t),t};let we=class extends s{constructor(){super(),this.isError=!1,this.openWebWallet();}onFormatAndRedirect(e){const{desktop:o,name:r}=a$4.getWalletRouterData(),a=o?.universal;if(a){const t=a$4.formatUniversalUrl(a,e,r);a$4.openHref(t,"_blank");}}openWebWallet(){const{walletConnectUri:e}=p$3.state,o=a$4.getWalletRouterData();c.setRecentWallet(o),e&&this.onFormatAndRedirect(e);}render(){const{name:e,id:o,image_id:r}=a$4.getWalletRouterData(),{isMobile:a,isDesktop:t}=c.getCachedRouterWalletPlatforms(),l$1=a$4.isMobile();return x`<wcm-modal-header title="${e}" .onAction="${c.handleUriCopy}" .actionIcon="${v.COPY_ICON}"></wcm-modal-header><wcm-modal-content><wcm-connector-waiting walletId="${o}" imageId="${l(r)}" label="${`Continue in ${e}...`}" .isError="${this.isError}"></wcm-connector-waiting></wcm-modal-content><wcm-info-footer><wcm-text color="secondary" variant="small-thin">${`${e} web app has opened in a new tab. Go there, accept the connection, and come back`}</wcm-text><wcm-platform-selection .isMobile="${a}" .isDesktop="${l$1?!1:t}" .isRetry="${!0}"><wcm-button .onClick="${this.openWebWallet.bind(this)}" .iconRight="${v.RETRY_ICON}">Retry</wcm-button></wcm-platform-selection></wcm-info-footer>`}};we.styles=[h.globalCss,dr],Ge([t$1()],we.prototype,"isError",2),we=Ge([e$2("wcm-web-connecting-view")],we);

    var index = /*#__PURE__*/Object.freeze({
        __proto__: null,
        get WcmModal () { return ae; },
        get WcmQrCode () { return j; }
    });

})();
